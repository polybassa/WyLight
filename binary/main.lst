CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 1

ADDR   CODE       LINE  SOURCE

                  00001 
                  00002 ; CC8E Version 1.3F, Copyright (c) B Knudsen Data
                  00003 ; C compiler for the PIC18 microcontrollers
                  00004 ; ************  16. Mar 2013   0:32  *************
                  00005 
                  00006 	processor  PIC18F26K22
                  00007 	radix  DEC
                  00008 
       0FF6       00009 TBLPTR      EQU   0xFF6
       0FF5       00010 TABLAT      EQU   0xFF5
       0FEF       00011 INDF0       EQU   0xFEF
       0FEE       00012 POSTINC0    EQU   0xFEE
       0FED       00013 POSTDEC0    EQU   0xFED
       0FEA       00014 FSR0H       EQU   0xFEA
       0FE9       00015 FSR0L       EQU   0xFE9
       0FE9       00016 FSR0        EQU   0xFE9
       0FE0       00017 BSR         EQU   0xFE0
       0FD8       00018 STATUS      EQU   0xFD8
       0000       00019 Carry       EQU   0
       0002       00020 Zero_       EQU   2
       0FD3       00021 OSCCON      EQU   0xFD3
       0FCD       00022 T1CON       EQU   0xFCD
       0FC9       00023 SSP1BUF     EQU   0xFC9
       0FC6       00024 SSP1CON1    EQU   0xFC6
       0FBB       00025 PR2         EQU   0xFBB
       0FBA       00026 T2CON       EQU   0xFBA
       0FB3       00027 TMR3H       EQU   0xFB3
       0FB2       00028 TMR3L       EQU   0xFB2
       0FB1       00029 T3CON       EQU   0xFB1
       0FB0       00030 SPBRGH1     EQU   0xFB0
       0FAF       00031 SPBRG1      EQU   0xFAF
       0FAE       00032 RCREG1      EQU   0xFAE
       0FAD       00033 TXREG1      EQU   0xFAD
       0FAA       00034 EEADRH      EQU   0xFAA
       0FA9       00035 EEADR       EQU   0xFA9
       0FA8       00036 EEDATA      EQU   0xFA8
       0FA7       00037 EECON2      EQU   0xFA7
       0F94       00038 TRISC       EQU   0xF94
       0F8A       00039 LATB        EQU   0xF8A
       0F81       00040 PORTB       EQU   0xF81
       0F6F       00041 SSP2BUF     EQU   0xF6F
       0F6E       00042 SSP2ADD     EQU   0xF6E
       0F6D       00043 SSP2STAT    EQU   0xF6D
       0F6C       00044 SSP2CON1    EQU   0xF6C
       0F52       00045 PR4         EQU   0xF52
       0F51       00046 T4CON       EQU   0xF51
       0F50       00047 TMR5H       EQU   0xF50
       0F4F       00048 TMR5L       EQU   0xF4F
       0F4E       00049 T5CON       EQU   0xF4E
       0F3A       00050 ANSELC      EQU   0xF3A
       0F39       00051 ANSELB      EQU   0xF39
       0006       00052 PEIE        EQU   6
       0006       00053 GIEL        EQU   6
       0007       00054 GIE         EQU   7
       0007       00055 GIEH        EQU   7
       0007       00056 IPEN        EQU   7
       0000       00057 TMR1ON      EQU   0
       0006       00058 CKE         EQU   6
       0007       00059 SMP         EQU   7
       0004       00060 CKP         EQU   4
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 2

ADDR   CODE       LINE  SOURCE

       0005       00061 SSPEN       EQU   5
       0002       00062 TMR2ON      EQU   2
       0003       00063 BRG16       EQU   3
       0000       00064 TMR3ON      EQU   0
       0002       00065 BRGH1       EQU   2
       0004       00066 SYNC1       EQU   4
       0005       00067 TXEN1       EQU   5
       0006       00068 TX9_1       EQU   6
       0003       00069 ADDEN1      EQU   3
       0004       00070 CREN1       EQU   4
       0006       00071 RX9_1       EQU   6
       0007       00072 SPEN1       EQU   7
       0000       00073 RD          EQU   0
       0001       00074 WR          EQU   1
       0002       00075 WREN        EQU   2
       0006       00076 CFGS        EQU   6
       0007       00077 EEPGD       EQU   7
       0007       00078 SSP2IF      EQU   7
       0001       00079 TMR3IP      EQU   1
       0000       00080 TMR1IP      EQU   0
       0001       00081 TMR2IP      EQU   1
       0005       00082 RC1IP       EQU   5
       0000       00083 TMR1IF      EQU   0
       0003       00084 SSP1IF      EQU   3
       0004       00085 TX1IF       EQU   4
       0005       00086 RC1IF       EQU   5
       0000       00087 TMR1IE      EQU   0
       0001       00088 TMR2IE      EQU   1
       0005       00089 RC1IE       EQU   5
       0006       00090 PLLEN       EQU   6
       0000       00091 TMR4IP      EQU   0
       0001       00092 TMR5IP      EQU   1
       0001       00093 TMR5IF      EQU   1
       0000       00094 TMR4IE      EQU   0
       0001       00095 TMR5IE      EQU   1
       0005       00096 SSPEN2      EQU   5
       0000       00097 SEN2        EQU   0
       0001       00098 RSEN2       EQU   1
       0002       00099 PEN2        EQU   2
       0003       00100 RCEN2       EQU   3
       0004       00101 ACKEN2      EQU   4
       0023       00102 g_RtcTime   EQU   0x23
       002B       00103 g_ErrorBits EQU   0x2B
       0200       00104 g_CmdBuf    EQU   0x200
       0330       00105 gLedBuf     EQU   0x330
       002C       00106 gScriptBuf  EQU   0x2C
       0038       00107 g_UpdateLed EQU   0x38
       0039       00108 g_UpdateLedStrip EQU   0x39
       0007       00109 svrSTATUS   EQU   0x07
       0008       00110 svrBSR      EQU   0x08
       0009       00111 svrWREG     EQU   0x09
       0000       00112 sv_FSR0     EQU   0x00
       0002       00113 temp        EQU   0x02
       0016       00114 p_crcH      EQU   0x16
       0018       00115 p_crcL      EQU   0x18
       001A       00116 index       EQU   0x1A
       001B       00117 crcH        EQU   0x1B
       001C       00118 crcL        EQU   0x1C
       0F7F       00119 pCrc        EQU   0xF7F
       0F7F       00120 data        EQU   0xF7F
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 3

ADDR   CODE       LINE  SOURCE

       0F7F       00121 crcH_out    EQU   0xF7F
       0F7F       00122 crcL_out    EQU   0xF7F
       0F7F       00123 crcH_2      EQU   0xF7F
       0F7F       00124 crcL_2      EQU   0xF7F
       0F7F       00125 i           EQU   0xF7F
       0F7F       00126 byte_3      EQU   0xF7F
       0015       00127 p_crcH_2    EQU   0x15
       0017       00128 p_crcL_2    EQU   0x17
       0000       00129 GIE_status  EQU   0
       0014       00130 data_3      EQU   0x14
       0013       00131 array       EQU   0x13
       0015       00132 adress_3    EQU   0x15
       0018       00133 i_2         EQU   0x18
       0019       00134 pByte       EQU   0x19
       000C       00135 array_2     EQU   0x0C
       000D       00136 adress_4    EQU   0x0D
       0010       00137 i_3         EQU   0x10
       0011       00138 temp_2      EQU   0x11
       000A       00139 i_4         EQU   0x0A
       0018       00140 arg1        EQU   0x18
       0019       00141 arg2        EQU   0x19
       001A       00142 rval        EQU   0x1A
       001C       00143 counter     EQU   0x1C
       001D       00144 arg1_5      EQU   0x1D
       001F       00145 arg2_5      EQU   0x1F
       0020       00146 rm          EQU   0x20
       0021       00147 counter_5   EQU   0x21
       0022       00148 tmp         EQU   0x22
       0F7F       00149 counter_13  EQU   0xF7F
       0F7F       00150 i_5         EQU   0xF7F
       000A       00151 ledColor    EQU   0x0A
       000B       00152 i_6         EQU   0x0B
       000C       00153 led         EQU   0x0C
       000A       00154 i_7         EQU   0x0A
       000C       00155 pValues     EQU   0x0C
       000D       00156 k           EQU   0x0D
       000E       00157 temp_3      EQU   0x0E
       000A       00158 k_2         EQU   0x0A
       000B       00159 stepmask    EQU   0x0B
       000C       00160 stepSize    EQU   0x0C
       000D       00161 stepaddress EQU   0x0D
       000F       00162 periodeLength EQU   0x0F
       000C       00163 pCmd        EQU   0x0C
       000F       00164 stepAddress EQU   0x0F
       0011       00165 stepMask    EQU   0x11
       0012       00166 temp16      EQU   0x12
       0014       00167 red         EQU   0x14
       0015       00168 green       EQU   0x15
       0016       00169 blue        EQU   0x16
       0017       00170 delta       EQU   0x17
       0018       00171 stepSize_2  EQU   0x18
       0019       00172 temp8       EQU   0x19
       001A       00173 address     EQU   0x1A
       001B       00174 k_3         EQU   0x1B
       001C       00175 mask        EQU   0x1C
       000D       00176 array_3     EQU   0x0D
       000F       00177 end         EQU   0x0F
       000B       00178 tempTime    EQU   0x0B
       000B       00179 tempTime_2  EQU   0x0B
       000D       00180 temp16_2    EQU   0x0D
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 4

ADDR   CODE       LINE  SOURCE

       0011       00181 pArray      EQU   0x11
       0015       00182 i_8         EQU   0x15
       0017       00183 temp16_3    EQU   0x17
       000B       00184 pBuf        EQU   0x0B
       0018       00185 pBuf_2      EQU   0x18
       001A       00186 read        EQU   0x1A
       001B       00187 result      EQU   0x1B
       0002       00188 pBuf_3      EQU   0x02
       0005       00189 writeNext   EQU   0x05
       0006       00190 write       EQU   0x06
       0002       00191 pBuf_4      EQU   0x02
       0018       00192 pBuf_5      EQU   0x18
       001A       00193 write_2     EQU   0x1A
       001B       00194 read_2      EQU   0x1B
       000B       00195 byte_4      EQU   0x0B
       000A       00196 new_byte    EQU   0x0A
       000C       00197 mFrame      EQU   0x0C
       000E       00198 crcH_3      EQU   0x0E
       000F       00199 crcL_3      EQU   0x0F
       0010       00200 tempByte    EQU   0x10
       0011       00201 pData       EQU   0x11
       0013       00202 frameLength EQU   0x13
       000C       00203 mFrame_2    EQU   0x0C
       000E       00204 cmd         EQU   0x0E
       000F       00205 tempErrorState EQU   0x0F
       0010       00206 bytesPrint  EQU   0x10
       0010       00207 bytesPrint_2 EQU   0x10
       0010       00208 temp8_2     EQU   0x10
       0044       00209 lastSwitchState EQU   0x44
       0019       00210 hostShort   EQU   0x19
       001B       00211 retval      EQU   0x1B
       001A       00212 networkShort EQU   0x1A
       001C       00213 retval_2    EQU   0x1C
       0015       00214 retValue    EQU   0x15
       0015       00215 onesValue   EQU   0x15
       0016       00216 tensValue   EQU   0x16
       0017       00217 tempValue   EQU   0x17
       0010       00218 req         EQU   0x10
       0011       00219 pRtcTime    EQU   0x11
       0013       00220 temp_4      EQU   0x13
       0016       00221 _slaveaddr  EQU   0x16
       0017       00222 _data       EQU   0x17
       0045       00223 nextCmd     EQU   0x45
       000B       00224 pCmd_2      EQU   0x0B
       000C       00225 loopStart   EQU   0x0C
       000D       00226 numLoops    EQU   0x0D
       000A       00227 tempAddress EQU   0x0A
       000C       00228 tempAddress_2 EQU   0x0C
       000E       00229 pCmd_3      EQU   0x0E
       0010       00230 writeNext_2 EQU   0x10
       0011       00231 tempAddress_3 EQU   0x11
       000E       00232 string      EQU   0x0E
       0010       00233 ps          EQU   0x10
       0F7F       00234 temp_5      EQU   0xF7F
       0F7F       00235 h           EQU   0xF7F
       0F7F       00236 z           EQU   0xF7F
       0F7F       00237 e           EQU   0xF7F
       000F       00238 temp4       EQU   0x0F
       0011       00239 pArray_2    EQU   0x11
       0015       00240 i_9         EQU   0x15
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 5

ADDR   CODE       LINE  SOURCE

       0017       00241 tempByte_2  EQU   0x17
       001C       00242 ci_2        EQU   0x1C
       0011       00243 ci_3        EQU   0x11
       0011       00244 ci_4        EQU   0x11
                  00245 
000000 EF48 F000  00246 	GOTO main
                  00247 
                  00248   ; FILE main.c
                  00249 			;/**
                  00250 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  00251 			; 
                  00252 			; This file is part of Wifly_Light.
                  00253 			; 
                  00254 			; Wifly_Light is free software: you can redistribute it and/or modify
                  00255 			; it under the terms of the GNU General Public License as published by
                  00256 			; the Free Software Foundation, either version 3 of the License, or
                  00257 			; (at your option) any later version.
                  00258 			; 
                  00259 			; Wifly_Light is distributed in the hope that it will be useful,
                  00260 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  00261 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  00262 			; GNU General Public License for more details.
                  00263 			; 
                  00264 			; You should have received a copy of the GNU General Public License
                  00265 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  00266 			;
                  00267 			;#ifdef __CC8E__
                  00268 			;#define DEBUG
                  00269 			;#pragma optimize 1
                  00270 
                  00271   ; FILE main.c
                  00272 			;#pragma sharedAllocation
                  00273 			;#endif
                  00274 			;
                  00275 			;//*********************** INCLUDEDATEIEN *********************************************
                  00276 			;#include "platform.h"
                  00277 			;#include "RingBuf.h"		
                  00278 			;#include "usart.h"			
                  00279 			;#include "CommandIO.h"
                  00280 			;#include "ledstrip.h"		
                  00281 			;#include "timer.h"	
                  00282 			;#include "rtc.h"
                  00283 			;#include "ScriptCtrl.h"
                  00284 			;#include "trace.h"
                  00285 			;#include "error.h"
                  00286 			;#ifdef __CC8E__
                  00287 			;#include "int18XXX.h"
                  00288 			;#endif /* #ifdef __CC8E__ */
                  00289 			;//#include "MATH16.h"
                  00290 			;
                  00291 			;#ifndef __CC8E__
                  00292 			;#include <unistd.h>
                  00293 			;jmp_buf g_ResetEnvironment;
                  00294 			;#endif /* #ifndef CC8E */
                  00295 			;
                  00296 			;//*********************** GLOBAL VARIABLES *******************************************
                  00297 			;uns8 g_UpdateLed;
                  00298 			;uns8 g_UpdateLedStrip;
                  00299 			;const struct cmd_get_fw_version g_Version = {0, 1};
                  00300 			;
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 6

ADDR   CODE       LINE  SOURCE

                  00301 			;//*********************** MACROS *****************************************************
                  00302 			;#ifdef DEBUG
                  00303 			;#define do_and_measure(METHOD) {\
                  00304 			;	Timer_StartStopwatch(e ## METHOD); \
                  00305 			;	METHOD(); \
                  00306 			;	Timer_StopStopwatch(e ## METHOD);}
                  00307 			;#else
                  00308 			;#define do_and_measure(METHOD) METHOD();
                  00309 			;#endif /*#ifdef DEBUG */
                  00310 			;
                  00311 			;	
                  00312 			;//*********************** FUNKTIONSPROTOTYPEN ****************************************
                  00313 			;void InitAll();
                  00314 			;void HighPriorityInterruptFunction(void);
                  00315 			;#ifdef X86
                  00316 			;void init_x86(void);
                  00317 			;#endif /* #ifdef X86 */
                  00318 			;
                  00319 			;#ifndef X86
                  00320 			;//*********************** INTERRUPTSERVICEROUTINE ************************************
                  00321 			;#pragma origin 0x8					
       0000       00322 	ORG 0x0008
                  00323 			;//Adresse des High Priority Interrupts	
                  00324 			;interrupt HighPriorityInterrupt(void)
                  00325 			;{
                  00326 HighPriorityInterrupt
                  00327 			;	HighPriorityInterruptFunction();
000008 D827       00328 	RCALL HighPriorityInterruptFunction
                  00329 			;	#pragma fastMode
                  00330 			;}
00000A 0011       00331 	RETFIE 1
                  00332 			;
                  00333 			;#pragma origin 0x18
       0000       00334 	ORG 0x0018
                  00335 			;interrupt LowPriorityInterrupt(void)
                  00336 			;{
                  00337 LowPriorityInterrupt
                  00338 			;	int_save_registers
000018 CFD8 F007  00339 	MOVFF STATUS,svrSTATUS
00001C CFE0 F008  00340 	MOVFF BSR,svrBSR
000020 6E09       00341 	MOVWF svrWREG,0
                  00342 			;#if 0
                  00343 			;	uns16 sv_FSR0 = FSR0;
                  00344 			;	uns16 sv_FSR1 = FSR1;
                  00345 			;	uns16 sv_FSR2 = FSR2;
                  00346 			;	uns8 sv_PCLATH = PCLATH;
                  00347 			;	uns8 sv_PCLATU = PCLATU;
                  00348 			;	uns8 sv_PRODL = PRODL;
                  00349 			;	uns8 sv_PRODH = PRODH;
                  00350 			;	uns24 sv_TBLPTR = TBLPTR;
                  00351 			;	uns8 sv_TABLAT = TABLAT;
                  00352 			;#endif
                  00353 			;
                  00354 			;	if(TMR5IF)
000022 A27E       00355 	BTFSS 0xF7E,TMR5IF,0
000024 D00E       00356 	BRA   m002
                  00357 			;	{
                  00358 			;	      g_UpdateLed = g_UpdateLed + 1;
000026 2A38       00359 	INCF  g_UpdateLed,1,0
                  00360 			;	      if(gScriptBuf.waitValue > 0)
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 7

ADDR   CODE       LINE  SOURCE

000028 502C       00361 	MOVF  gScriptBuf,W,0
00002A 102D       00362 	IORWF gScriptBuf+1,W,0
00002C B4D8       00363 	BTFSC 0xFD8,Zero_,0
00002E D003       00364 	BRA   m001
                  00365 			;	      {
                  00366 			;		    gScriptBuf.waitValue = gScriptBuf.waitValue - 1;
000030 062C       00367 	DECF  gScriptBuf,1,0
000032 0E00       00368 	MOVLW 0
000034 5A2D       00369 	SUBWFB gScriptBuf+1,1,0
                  00370 			;	      }
                  00371 			;	      Timer5Interrupt();
000036 927E       00372 m001	BCF   0xF7E,TMR5IF,0
000038 0E63       00373 	MOVLW 99
00003A 010F       00374 	MOVLB 15
00003C 6F50       00375 	MOVWF TMR5H,1
00003E 0EC0       00376 	MOVLW 192
000040 6F4F       00377 	MOVWF TMR5L,1
                  00378 			;	} 
                  00379 			;		
                  00380 			;	if(TMR1IF)
000042 A09E       00381 m002	BTFSS 0xF9E,TMR1IF,0
000044 D003       00382 	BRA   m003
                  00383 			;	{
                  00384 			;	      g_UpdateLedStrip = g_UpdateLedStrip + 1;
000046 2A39       00385 	INCF  g_UpdateLedStrip,1,0
                  00386 			;	      Timer1Disable();
000048 90CD       00387 	BCF   0xFCD,TMR1ON,0
                  00388 			;	      Timer1Interrupt();
00004A 909E       00389 	BCF   0xF9E,TMR1IF,0
                  00390 			;	}
                  00391 			;#if 0	
                  00392 			;	FSR0 = sv_FSR0;
                  00393 			;	FSR1 = sv_FSR1;
                  00394 			;	FSR2 = sv_FSR2;
                  00395 			;	PCLATH = sv_PCLATH;
                  00396 			;	PCLATU = sv_PCLATU;
                  00397 			;	PRODL = sv_PRODL;
                  00398 			;	PRODH = sv_PRODH;
                  00399 			;	TBLPTR = sv_TBLPTR;
                  00400 			;	TABLAT = sv_TABLAT;
                  00401 			;#endif
                  00402 			;	int_restore_registers
00004C 5009       00403 m003	MOVF  svrWREG,W,0
00004E C008 FFE0  00404 	MOVFF svrBSR,BSR
000052 C007 FFD8  00405 	MOVFF svrSTATUS,STATUS
                  00406 			;}
000056 0010       00407 	RETFIE
                  00408 			;
                  00409 			;void HighPriorityInterruptFunction(void)
                  00410 			;{
                  00411 HighPriorityInterruptFunction
                  00412 			;	uns16 sv_FSR0 = FSR0;
000058 CFE9 F000  00413 	MOVFF FSR0,sv_FSR0
00005C CFEA F001  00414 	MOVFF FSR0+1,sv_FSR0+1
                  00415 			;	if(RC1IF)
000060 AA9E       00416 	BTFSS 0xF9E,RC1IF,0
000062 D011       00417 	BRA   m005
                  00418 			;	{
                  00419 			;		if(!RingBuf_HasError(&g_RingBuf)) 
000064 6A02       00420 	CLRF  pBuf_4,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 8

ADDR   CODE       LINE  SOURCE

000066 0E07       00421 	MOVLW 7
000068 6E03       00422 	MOVWF pBuf_4+1,0
00006A EC78 F006  00423 	CALL  RingBuf_HasError
00006E B0D8       00424 	BTFSC 0xFD8,Carry,0
000070 D008       00425 	BRA   m004
                  00426 			;		{
                  00427 			;			RingBuf_Put(&g_RingBuf, RCREG1);
000072 6A02       00428 	CLRF  pBuf_3,0
000074 0E07       00429 	MOVLW 7
000076 6E03       00430 	MOVWF pBuf_3+1,0
000078 CFAE F004  00431 	MOVFF RCREG1,value
00007C EC4A F006  00432 	CALL  RingBuf_Put
                  00433 			;		}
                  00434 			;		else 
000080 D002       00435 	BRA   m005
                  00436 			;		{
                  00437 			;			//Register lesen um Schnittstellen Fehler zu vermeiden
                  00438 			;			uns8 temp = RCREG1;
000082 CFAE F002  00439 m004	MOVFF RCREG1,temp
                  00440 			;		}
                  00441 			;	}
                  00442 			;	FSR0 = sv_FSR0;
000086 C000 FFE9  00443 m005	MOVFF sv_FSR0,FSR0
00008A C001 FFEA  00444 	MOVFF sv_FSR0+1,FSR0+1
                  00445 			;}
00008E 0012       00446 	RETURN
                  00447 			;#endif /* #ifndef X86 */
                  00448 			;
                  00449 			;
                  00450 			;//*********************** HAUPTPROGRAMM **********************************************
                  00451 			;#ifdef __CC8E__
                  00452 			;void main(void)
                  00453 			;#else
                  00454 			;int main(void)
                  00455 			;#endif
                  00456 			;{
                  00457 main
                  00458 			;	/* softReset() on x86 will jump here! */
                  00459 			;	softResetJumpDestination();
                  00460 			;
                  00461 			;	InitAll();
000090 D84B       00462 	RCALL InitAll
                  00463 			;
                  00464 			;	while(1)
                  00465 			;	{
                  00466 			;		Timer_StartStopwatch(eMAIN);
000092 6A0A       00467 m006	CLRF  destMethode,0
000094 EC8C F005  00468 	CALL  Timer_StartStopwatch
                  00469 			;#ifndef __CC8E__
                  00470 			;		// give opengl thread a chance to run
                  00471 			;		usleep(10);
                  00472 			;#endif /* #ifndef __CC8E__ */
                  00473 			;		
                  00474 			;		
                  00475 			;		
                  00476 			;		do_and_measure(Platform_CheckInputs);
000098 0E09       00477 	MOVLW 9
00009A 6E0A       00478 	MOVWF destMethode,0
00009C EC8C F005  00479 	CALL  Timer_StartStopwatch
0000A0 EC73 F008  00480 	CALL  Platform_CheckInputs
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 9

ADDR   CODE       LINE  SOURCE

0000A4 0E09       00481 	MOVLW 9
0000A6 6E0A       00482 	MOVWF destMethode_2,0
0000A8 EC9A F005  00483 	CALL  Timer_StopStopwatch
                  00484 			;
                  00485 			;		do_and_measure(Error_Throw);
0000AC 0E0A       00486 	MOVLW 10
0000AE 6E0A       00487 	MOVWF destMethode,0
0000B0 EC8C F005  00488 	CALL  Timer_StartStopwatch
0000B4 D947       00489 	RCALL Error_Throw
0000B6 0E0A       00490 	MOVLW 10
0000B8 6E0A       00491 	MOVWF destMethode_2,0
0000BA EC9A F005  00492 	CALL  Timer_StopStopwatch
                  00493 			;	
                  00494 			;		do_and_measure(CommandIO_GetCommands);
0000BE 0E07       00495 	MOVLW 7
0000C0 6E0A       00496 	MOVWF destMethode,0
0000C2 EC8C F005  00497 	CALL  Timer_StartStopwatch
0000C6 ECE7 F006  00498 	CALL  CommandIO_GetCommands
0000CA 0E07       00499 	MOVLW 7
0000CC 6E0A       00500 	MOVWF destMethode_2,0
0000CE EC9A F005  00501 	CALL  Timer_StopStopwatch
                  00502 			;				
                  00503 			;		do_and_measure(ScriptCtrl_Run);
0000D2 0E08       00504 	MOVLW 8
0000D4 6E0A       00505 	MOVWF destMethode,0
0000D6 EC8C F005  00506 	CALL  Timer_StartStopwatch
0000DA EC3A F00B  00507 	CALL  ScriptCtrl_Run
0000DE 0E08       00508 	MOVLW 8
0000E0 6E0A       00509 	MOVWF destMethode_2,0
0000E2 EC9A F005  00510 	CALL  Timer_StopStopwatch
                  00511 			;
                  00512 			;		if(g_UpdateLed > 0)
0000E6 5238       00513 	MOVF  g_UpdateLed,1,0
0000E8 B4D8       00514 	BTFSC 0xFD8,Zero_,0
0000EA D00C       00515 	BRA   m007
                  00516 			;		{		  
                  00517 			;			do_and_measure(Ledstrip_DoFade);
0000EC 0E01       00518 	MOVLW 1
0000EE 6E0A       00519 	MOVWF destMethode,0
0000F0 EC8C F005  00520 	CALL  Timer_StartStopwatch
0000F4 DA67       00521 	RCALL Ledstrip_DoFade
0000F6 0E01       00522 	MOVLW 1
0000F8 6E0A       00523 	MOVWF destMethode_2,0
0000FA EC9A F005  00524 	CALL  Timer_StopStopwatch
                  00525 			;			
                  00526 			;			Timer5InterruptLock();
0000FE 927D       00527 	BCF   0xF7D,TMR5IE,0
                  00528 			;			g_UpdateLed = 0;
000100 6A38       00529 	CLRF  g_UpdateLed,0
                  00530 			;			Timer5InterruptUnlock();
000102 827D       00531 	BSF   0xF7D,TMR5IE,0
                  00532 			;			
                  00533 			;		}
                  00534 			;		if(g_UpdateLedStrip > 0)
000104 5239       00535 m007	MOVF  g_UpdateLedStrip,1,0
000106 B4D8       00536 	BTFSC 0xFD8,Zero_,0
000108 D00B       00537 	BRA   m008
                  00538 			;		{
                  00539 			;			do_and_measure(Ledstrip_UpdateLed);
00010A 0E06       00540 	MOVLW 6
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 10

ADDR   CODE       LINE  SOURCE

00010C 6E0A       00541 	MOVWF destMethode,0
00010E EC8C F005  00542 	CALL  Timer_StartStopwatch
000112 DB08       00543 	RCALL Ledstrip_UpdateLed
000114 0E06       00544 	MOVLW 6
000116 6E0A       00545 	MOVWF destMethode_2,0
000118 EC9A F005  00546 	CALL  Timer_StopStopwatch
                  00547 			;			Timer1Enable();
00011C 80CD       00548 	BSF   0xFCD,TMR1ON,0
                  00549 			;			g_UpdateLedStrip = 0;
00011E 6A39       00550 	CLRF  g_UpdateLedStrip,0
                  00551 			;		}
                  00552 			;		Timer_StopStopwatch(eMAIN);
000120 6A0A       00553 m008	CLRF  destMethode_2,0
000122 EC9A F005  00554 	CALL  Timer_StopStopwatch
                  00555 			;	}
000126 D7B5       00556 	BRA   m006
                  00557 			;}
                  00558 			;//*********************** UNTERPROGRAMME **********************************************
                  00559 			;
                  00560 			;void InitAll()
                  00561 			;{
                  00562 InitAll
                  00563 			;	clearRAM();
000128 EE0F F037  00564 	LFSR  0,3895 
00012C 6AED       00565 m009	CLRF  POSTDEC0,0
00012E 50EA       00566 	MOVF  FSR0H,W,0
000130 E1FD       00567 	BNZ   m009
000132 50E9       00568 	MOVF  FSR0,W,0
000134 E1FB       00569 	BNZ   m009
000136 6AEF       00570 	CLRF  INDF0,0
                  00571 			;	Platform_OsciInit();
000138 0E72       00572 	MOVLW 114
00013A 6ED3       00573 	MOVWF OSCCON,0
00013C 8C9B       00574 	BSF   0xF9B,PLLEN,0
                  00575 			;	Platform_IOInit();
00013E 6A81       00576 	CLRF  PORTB,0
000140 6A8A       00577 	CLRF  LATB,0
000142 010F       00578 	MOVLB 15
000144 6B39       00579 	CLRF  ANSELB,1
                  00580 			;	RingBuf_Init(&g_RingBuf);
000146 6A0B       00581 	CLRF  pBuf,0
000148 0E07       00582 	MOVLW 7
00014A 6E0C       00583 	MOVWF pBuf+1,0
00014C EC1A F006  00584 	CALL  RingBuf_Init
                  00585 			;	UART_Init();
000150 EC97 F006  00586 	CALL  UART_Init
                  00587 			;	Timer_Init();
000154 EC72 F005  00588 	CALL  Timer_Init
                  00589 			;	Ledstrip_Init();
000158 D9B0       00590 	RCALL Ledstrip_Init
                  00591 			;	Error_Init();
00015A 902B       00592 	BCF   g_ErrorBits,0,0
00015C 922B       00593 	BCF   g_ErrorBits,1,0
                  00594 			;	CommandIO_Init();
00015E ECE4 F006  00595 	CALL  CommandIO_Init
                  00596 			;	Rtc_Init();
000162 ECDB F008  00597 	CALL  Rtc_Init
                  00598 			;	ScriptCtrl_Init();
000166 EC22 F00B  00599 	CALL  ScriptCtrl_Init
                  00600 			;
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 11

ADDR   CODE       LINE  SOURCE

                  00601 			;#ifndef __CC8E__
                  00602 			;	init_x86();
                  00603 			;#endif /* #ifndef CC8E */
                  00604 			;	
                  00605 			;	Platform_AllowInterrupts();
00016A EC81 F008  00606 	CALL  Platform_AllowInterrupts
                  00607 			;	Platform_DisableBootloaderAutostart();
00016E EC93 F008  00608 	CALL  Platform_DisableBootloaderAutostart
                  00609 			;	
                  00610 			;	Trace_String("Wait");
000172 6A0E       00611 	CLRF  string,0
000174 6A0F       00612 	CLRF  string+1,0
000176 EC51 F00C  00613 	CALL  Trace_String
                  00614 			;	
                  00615 			;	/* Startup Wait-Time 2s
                  00616 			;	 * to protect Wifly-Modul from errors*/
                  00617 			;	gScriptBuf.waitValue = 500;
00017A 0EF4       00618 	MOVLW 244
00017C 6E2C       00619 	MOVWF gScriptBuf,0
00017E 0E01       00620 	MOVLW 1
000180 6E2D       00621 	MOVWF gScriptBuf+1,0
                  00622 			;	CommandIO_CreateResponse(&g_ResponseBuf, FW_STARTED);
000182 0E60       00623 	MOVLW 96
000184 6E0C       00624 	MOVWF mFrame_2,0
000186 6A0D       00625 	CLRF  mFrame_2+1,0
000188 0EEC       00626 	MOVLW 236
00018A ECF0 F007  00627 	CALL  CommandIO_CreateResponse
                  00628 			;	CommandIO_SendResponse(&g_ResponseBuf);
00018E 0E60       00629 	MOVLW 96
000190 6E0C       00630 	MOVWF mFrame,0
000192 6A0D       00631 	CLRF  mFrame+1,0
000194 EF88 F007  00632 	GOTO  CommandIO_SendResponse
                  00633 			;}
                  00634 
                  00635   ; FILE crc.c
                  00636 			;/**
                  00637 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  00638 			; 
                  00639 			; This file is part of Wifly_Light.
                  00640 			; 
                  00641 			; Wifly_Light is free software: you can redistribute it and/or modify
                  00642 			; it under the terms of the GNU General Public License as published by
                  00643 			; the Free Software Foundation, either version 3 of the License, or
                  00644 			; (at your option) any later version.
                  00645 			; 
                  00646 			; Wifly_Light is distributed in the hope that it will be useful,
                  00647 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  00648 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  00649 			; GNU General Public License for more details.
                  00650 			; 
                  00651 			; You should have received a copy of the GNU General Public License
                  00652 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  00653 			;
                  00654 			;#include "crc.h"
                  00655 			;
                  00656 			;// 16-bit CCIT CRC
                  00657 			;void Crc_AddCrc(const uns8 byte,uns8* p_crcH,uns8* p_crcL)
                  00658 			;{
                  00659 Crc_AddCrc
                  00660 			;	uns8 index, crcH, crcL;
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 12

ADDR   CODE       LINE  SOURCE

                  00661 			;	crcH = *p_crcH;
000198 C016 FFE9  00662 	MOVFF p_crcH,FSR0
00019C C017 FFEA  00663 	MOVFF p_crcH+1,FSR0+1
0001A0 CFEF F01B  00664 	MOVFF INDF0,crcH
                  00665 			;	crcL = *p_crcL;
0001A4 C018 FFE9  00666 	MOVFF p_crcL,FSR0
0001A8 C019 FFEA  00667 	MOVFF p_crcL+1,FSR0+1
0001AC CFEF F01C  00668 	MOVFF INDF0,crcL
                  00669 			;#ifdef __CC8E__
                  00670 			;	MOVF(byte,0);
0001B0 5015       00671 	MOVF  byte,W,0
                  00672 			;	
                  00673 			;	XORWF(crcH,0);
0001B2 181B       00674 	XORWF crcH,W,0
                  00675 			;	MOVWF(index);
0001B4 6E1A       00676 	MOVWF index,0
                  00677 			;	ANDLW(0xf0);
0001B6 0BF0       00678 	ANDLW 240
                  00679 			;	SWAPF(index,1);
0001B8 3A1A       00680 	SWAPF index,1,0
                  00681 			;	XORWF(index,1);
0001BA 1A1A       00682 	XORWF index,1,0
                  00683 			;	
                  00684 			;	MOVF(index,0);
0001BC 501A       00685 	MOVF  index,W,0
                  00686 			;	ANDLW(0xf0);
0001BE 0BF0       00687 	ANDLW 240
                  00688 			;	XORWF(crcL,0);
0001C0 181C       00689 	XORWF crcL,W,0
                  00690 			;	MOVWF(crcH);
0001C2 6E1B       00691 	MOVWF crcH,0
                  00692 			;	
                  00693 			;	RLF(index,0);
0001C4 341A       00694 	RLCF  index,W,0
                  00695 			;	RLF(index,0);
0001C6 341A       00696 	RLCF  index,W,0
                  00697 			;	XORWF(crcH,1);
0001C8 1A1B       00698 	XORWF crcH,1,0
                  00699 			;	ANDLW(0xe0);
0001CA 0BE0       00700 	ANDLW 224
                  00701 			;	XORWF(crcH,1);
0001CC 1A1B       00702 	XORWF crcH,1,0
                  00703 			;		
                  00704 			;	SWAPF(index,1);
0001CE 3A1A       00705 	SWAPF index,1,0
                  00706 			;	XORWF(index,0);
0001D0 181A       00707 	XORWF index,W,0
                  00708 			;	MOVWF(crcL);
0001D2 6E1C       00709 	MOVWF crcL,0
                  00710 			;#else
                  00711 			;	uns8 work, temp;
                  00712 			;	
                  00713 			;	work = byte;			//MOVF(byte,0);
                  00714 			;	
                  00715 			;	work = work ^ crcH;		//XORWF(crcH,0);
                  00716 			;	index = work;			//MOVWF(index);
                  00717 			;	work = 0xf0 & work;		//ANDLW(0xf0);
                  00718 			;	index = ((index << 4)&0xf0) | (( index >> 4) & 0x0f); //SWAPF(index,1);
                  00719 			;	index = work ^ index;		//XORWF(index,1);
                  00720 			;	
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 13

ADDR   CODE       LINE  SOURCE

                  00721 			;	work = index;			//MOVF(index,0);
                  00722 			;	work = work & 0xf0;		//ANDLW(0xf0);
                  00723 			;	work = work ^ crcL;		//XORWF(crcL,0);
                  00724 			;	crcH = work;			//MOVWF(crcH);
                  00725 			;	
                  00726 			;	temp = 0x80 & index; 		//RLF(index,0);
                  00727 			;	work = index << 1;
                  00728 			;	temp = temp >> 7;
                  00729 			;	work = work & 0xfe;
                  00730 			;	work = work | temp;
                  00731 			;	
                  00732 			;	crcH = work ^ crcH;		//XORWF(crcH,1);
                  00733 			;	work = work & 0xe0;		//ANDLW(0xe0);
                  00734 			;	crcH = work ^ crcH;		//XORWF(crcH,1);
                  00735 			;	
                  00736 			;	index = ((index << 4)&0xf0) | (( index >> 4) & 0x0f);	//SWAPF(index,1);
                  00737 			;	work = work ^ index;		//XORWF(index,0);
                  00738 			;	crcL = work;			//MOVWF(crcL);
                  00739 			;#endif /* #ifdef __CC8E__ */
                  00740 			;	*p_crcH = crcH;
0001D4 C016 FFE9  00741 	MOVFF p_crcH,FSR0
0001D8 C017 FFEA  00742 	MOVFF p_crcH+1,FSR0+1
0001DC C01B FFEF  00743 	MOVFF crcH,INDF0
                  00744 			;	*p_crcL = crcL;
0001E0 C018 FFE9  00745 	MOVFF p_crcL,FSR0
0001E4 C019 FFEA  00746 	MOVFF p_crcL+1,FSR0+1
0001E8 C01C FFEF  00747 	MOVFF crcL,INDF0
                  00748 			;}
0001EC 0012       00749 	RETURN
                  00750 			;
                  00751 			;/**
                  00752 			; * Wrapper for the Crc_AddCrc function with seperate parameter for high and low
                  00753 			; * crc value. In a next refactoring step we should replace that other functions
                  00754 			; * with this one.
                  00755 			; */
                  00756 			;#ifdef __cplusplus
                  00757 			;	extern "C" {
                  00758 			;#endif
                  00759 			;	void Crc_AddCrc16(const uns8 byte, uns16* pCrc)
                  00760 			;	{
                  00761 Crc_AddCrc16
                  00762 			;		Crc_AddCrc(byte, ((uns8*)pCrc) + 1, (uns8*)pCrc);
0001EE CF7F F015  00763 	MOVFF byte_2,byte
0001F2 6A17       00764 	CLRF  p_crcH+1,0
0001F4 287F       00765 	INCF  pCrc,W,0
0001F6 6E16       00766 	MOVWF p_crcH,0
0001F8 CF7F F018  00767 	MOVFF pCrc,p_crcL
0001FC 6A19       00768 	CLRF  p_crcL+1,0
0001FE D7CC       00769 	BRA   Crc_AddCrc
                  00770 			;	}
                  00771 			;#ifdef __cplusplus
                  00772 			;	}
                  00773 			;#endif
                  00774 			;
                  00775 			;void Crc_BuildCrc(const uns8 *data, const uns8 length, uns8* crcH_out, uns8* crcL_out)
                  00776 			;{
                  00777 Crc_BuildCrc
                  00778 			;	if(!crcH_out) return;
000200 507F       00779 	MOVF  crcH_out,W,0
000202 B4D8       00780 	BTFSC 0xFD8,Zero_,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 14

ADDR   CODE       LINE  SOURCE

000204 0012       00781 	RETURN
                  00782 			;	if(!crcL_out) return;
000206 507F       00783 	MOVF  crcL_out,W,0
000208 B4D8       00784 	BTFSC 0xFD8,Zero_,0
00020A 0012       00785 	RETURN
                  00786 			;	if(!data) return;
00020C 507F       00787 	MOVF  data,W,0
00020E B4D8       00788 	BTFSC 0xFD8,Zero_,0
000210 0012       00789 	RETURN
                  00790 			;	uns8 crcH,crcL,i,byte;
                  00791 			;	crcH=0xff;
000212 687F       00792 	SETF  crcH_2,0
                  00793 			;	crcL=0xff;
000214 687F       00794 	SETF  crcL_2,0
                  00795 			;
                  00796 			;	for(i=0;i<length;i++)
000216 6A7F       00797 	CLRF  i,0
000218 507F       00798 m010	MOVF  length,W,0
00021A 607F       00799 	CPFSLT i,0
00021C D012       00800 	BRA   m011
                  00801 			;	{
                  00802 			;		byte = data[i];
00021E 507F       00803 	MOVF  i,W,0
000220 247F       00804 	ADDWF data,W,0
000222 EC15 F00D  00805 	CALL  _const1
000226 6E7F       00806 	MOVWF byte_3,0
                  00807 			;		Crc_AddCrc(byte,&crcH,&crcL);
000228 CF7F F015  00808 	MOVFF byte_3,byte
00022C 0E7F       00809 	MOVLW 127
00022E 6E16       00810 	MOVWF p_crcH,0
000230 0E0F       00811 	MOVLW 15
000232 6E17       00812 	MOVWF p_crcH+1,0
000234 0E7F       00813 	MOVLW 127
000236 6E18       00814 	MOVWF p_crcL,0
000238 0E0F       00815 	MOVLW 15
00023A 6E19       00816 	MOVWF p_crcL+1,0
00023C DFAD       00817 	RCALL Crc_AddCrc
                  00818 			;	}
00023E 2A7F       00819 	INCF  i,1,0
000240 D7EB       00820 	BRA   m010
                  00821 			;	
                  00822 			;	*crcH_out = crcH;
000242 CF7F FFE9  00823 m011	MOVFF crcH_out,FSR0
000246 6AEA       00824 	CLRF  FSR0+1,0
000248 CF7F FFEF  00825 	MOVFF crcH_2,INDF0
                  00826 			;	*crcL_out = crcL;
00024C CF7F FFE9  00827 	MOVFF crcL_out,FSR0
000250 6AEA       00828 	CLRF  FSR0+1,0
000252 CF7F FFEF  00829 	MOVFF crcL_2,INDF0
                  00830 			;}
000256 0012       00831 	RETURN
                  00832 			;
                  00833 			;void Crc_NewCrc(uns8* p_crcH, uns8* p_crcL)
                  00834 			;{
                  00835 Crc_NewCrc
                  00836 			;    if(!p_crcH) return;
000258 5015       00837 	MOVF  p_crcH_2,W,0
00025A 1016       00838 	IORWF p_crcH_2+1,W,0
00025C B4D8       00839 	BTFSC 0xFD8,Zero_,0
00025E 0012       00840 	RETURN
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 15

ADDR   CODE       LINE  SOURCE

                  00841 			;    if(!p_crcL) return;
000260 5017       00842 	MOVF  p_crcL_2,W,0
000262 1018       00843 	IORWF p_crcL_2+1,W,0
000264 B4D8       00844 	BTFSC 0xFD8,Zero_,0
000266 0012       00845 	RETURN
                  00846 			;		// bootloader is using 0x0000 as initial crc not 0xFFFF
                  00847 			;    *p_crcH = 0x00;
000268 C015 FFE9  00848 	MOVFF p_crcH_2,FSR0
00026C C016 FFEA  00849 	MOVFF p_crcH_2+1,FSR0+1
000270 6AEF       00850 	CLRF  INDF0,0
                  00851 			;    *p_crcL = 0x00;
000272 C017 FFE9  00852 	MOVFF p_crcL_2,FSR0
000276 C018 FFEA  00853 	MOVFF p_crcL_2+1,FSR0+1
00027A 6AEF       00854 	CLRF  INDF0,0
                  00855 			;}
00027C 0012       00856 	RETURN
                  00857 
                  00858   ; FILE eeprom.c
                  00859 			;/**
                  00860 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  00861 			; 
                  00862 			; This file is part of Wifly_Light.
                  00863 			; 
                  00864 			; Wifly_Light is free software: you can redistribute it and/or modify
                  00865 			; it under the terms of the GNU General Public License as published by
                  00866 			; the Free Software Foundation, either version 3 of the License, or
                  00867 			; (at your option) any later version.
                  00868 			; 
                  00869 			; Wifly_Light is distributed in the hope that it will be useful,
                  00870 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  00871 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  00872 			; GNU General Public License for more details.
                  00873 			; 
                  00874 			; You should have received a copy of the GNU General Public License
                  00875 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  00876 			;
                  00877 			;#include "eeprom.h"
                  00878 			;
                  00879 			;#ifdef __CC8E__
                  00880 			;//*********************** EEPROM BYTE SCHREIBEN  **********************************************
                  00881 			;void Eeprom_Write(const uns16 adress, const uns8 data)
                  00882 			;{
                  00883 Eeprom_Write
                  00884 			;	bit GIE_status; 
                  00885 			;	GIE_status = GIE;	
00027E 901E       00886 	BCF   0x1E,GIE_status,0
000280 BEF2       00887 	BTFSC 0xFF2,GIE,0
000282 801E       00888 	BSF   0x1E,GIE_status,0
                  00889 			;	
                  00890 			;	EEADRH = adress.high8;
000284 C01C FFAA  00891 	MOVFF adress+1,EEADRH
                  00892 			;	EEADR = adress.low8;        	// Adresse in Adressregister übertragen
000288 C01B FFA9  00893 	MOVFF adress,EEADR
                  00894 			;	EEDATA = data;          		// Daten in Datenregister übertragen
00028C C01D FFA8  00895 	MOVFF data_2,EEDATA
                  00896 			;	
                  00897 			;	CFGS = 0;
000290 9CA6       00898 	BCF   0xFA6,CFGS,0
                  00899 			;	EEPGD = 0;                		// Auswahl: Programmspeicher lesen oder EEPROM
000292 9EA6       00900 	BCF   0xFA6,EEPGD,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 16

ADDR   CODE       LINE  SOURCE

                  00901 			;	WREN = 1;                 		// Schreiben ins EEPROM erlauben
000294 84A6       00902 	BSF   0xFA6,WREN,0
                  00903 			;	GIE=0;                  		// Interrups verbieten
000296 9EF2       00904 	BCF   0xFF2,GIE,0
                  00905 			;	
                  00906 			;	EECON2 = 0x55;
000298 0E55       00907 	MOVLW 85
00029A 6EA7       00908 	MOVWF EECON2,0
                  00909 			;	EECON2 = 0xAA;
00029C 0EAA       00910 	MOVLW 170
00029E 6EA7       00911 	MOVWF EECON2,0
                  00912 			;	WR = 1; 						// Starten des Schreibens
0002A0 82A6       00913 	BSF   0xFA6,WR,0
                  00914 			;	GIE = GIE_status;               // Interrups erlauben
0002A2 A01E       00915 	BTFSS 0x1E,GIE_status,0
0002A4 9EF2       00916 	BCF   0xFF2,GIE,0
0002A6 B01E       00917 	BTFSC 0x1E,GIE_status,0
0002A8 8EF2       00918 	BSF   0xFF2,GIE,0
                  00919 			;	WREN = 0;
0002AA 94A6       00920 	BCF   0xFA6,WREN,0
                  00921 			;	while(WR);
0002AC B2A6       00922 m012	BTFSC 0xFA6,WR,0
0002AE D7FE       00923 	BRA   m012
                  00924 			;}
0002B0 0012       00925 	RETURN
                  00926 			;
                  00927 			;//*********************** EEPROM BYTE LESEN  **********************************************
                  00928 			;
                  00929 			;uns8 Eeprom_Read(const uns16 adress)
                  00930 			;{
                  00931 Eeprom_Read
                  00932 			;	uns8 data;
                  00933 			;	EEADRH = adress.high8;        // Adresse in Adressregister übertragen
0002B2 C013 FFAA  00934 	MOVFF adress_2+1,EEADRH
                  00935 			;	EEADR = adress.low8;
0002B6 C012 FFA9  00936 	MOVFF adress_2,EEADR
                  00937 			;	CFGS = 0;
0002BA 9CA6       00938 	BCF   0xFA6,CFGS,0
                  00939 			;	EEPGD = 0;                			// Auswahl: Programmspeicher lesen oder EEPROM
0002BC 9EA6       00940 	BCF   0xFA6,EEPGD,0
                  00941 			;	RD = 1;                   			// Starten des Lesesn
0002BE 80A6       00942 	BSF   0xFA6,RD,0
                  00943 			;	data = EEDATA;       				// Daten aus Datenregister auslesen
0002C0 CFA8 F014  00944 	MOVFF EEDATA,data_3
                  00945 			;	return data;
0002C4 5014       00946 	MOVF  data_3,W,0
0002C6 0012       00947 	RETURN
                  00948 			;}
                  00949 			;
                  00950 			;#else
                  00951 			;#include "ScriptCtrl.h"
                  00952 			;#include "wifly_cmd.h"
                  00953 			;#include <assert.h>
                  00954 			;static uns8 g_Eeprom[(1 + SCRIPTCTRL_NUM_CMD_MAX) * sizeof(struct led_cmd)];
                  00955 			;
                  00956 			;uns8 Eeprom_Read(const uns16 adress)
                  00957 			;{
                  00958 			;	return g_Eeprom[adress];
                  00959 			;}
                  00960 			;
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 17

ADDR   CODE       LINE  SOURCE

                  00961 			;void Eeprom_Write(const uns16 adress, const uns8 data)
                  00962 			;{
                  00963 			;	assert(adress < sizeof(g_Eeprom));
                  00964 			;	g_Eeprom[adress] = data;
                  00965 			;}
                  00966 			;#endif /* #ifdef X86 */
                  00967 			;
                  00968 			;//*********************** EEPROM BYTEARRAY SCHREIBEN  **************************************
                  00969 			;
                  00970 			;void Eeprom_WriteBlock(const uns8 *array, uns16 adress,const uns8 length)			//Zum Ausführen eines beliebigen Befehls durch den Programmcode
                  00971 			;{
                  00972 Eeprom_WriteBlock
                  00973 			;	if(!array) return;
0002C8 5013       00974 	MOVF  array,W,0
0002CA 1014       00975 	IORWF array+1,W,0
0002CC B4D8       00976 	BTFSC 0xFD8,Zero_,0
0002CE 0012       00977 	RETURN
                  00978 			;	uns8 i;
                  00979 			;	for(i=0;i<length;i++)
0002D0 6A18       00980 	CLRF  i_2,0
0002D2 5017       00981 m013	MOVF  length_2,W,0
0002D4 6018       00982 	CPFSLT i_2,0
0002D6 D017       00983 	BRA   m014
                  00984 			;	{
                  00985 			;		uns8* pByte = (uns8*)array;
0002D8 C013 F019  00986 	MOVFF array,pByte
0002DC C014 F01A  00987 	MOVFF array+1,pByte+1
                  00988 			;		Eeprom_Write(adress, *pByte);
0002E0 C015 F01B  00989 	MOVFF adress_3,adress
0002E4 C016 F01C  00990 	MOVFF adress_3+1,adress+1
0002E8 C019 FFE9  00991 	MOVFF pByte,FSR0
0002EC C01A FFEA  00992 	MOVFF pByte+1,FSR0+1
0002F0 CFEF F01D  00993 	MOVFF INDF0,data_2
0002F4 DFC4       00994 	RCALL Eeprom_Write
                  00995 			;		adress++;
0002F6 2A15       00996 	INCF  adress_3,1,0
0002F8 0E00       00997 	MOVLW 0
0002FA 2216       00998 	ADDWFC adress_3+1,1,0
                  00999 			;		array++;
0002FC 2A13       01000 	INCF  array,1,0
0002FE 0E00       01001 	MOVLW 0
000300 2214       01002 	ADDWFC array+1,1,0
                  01003 			;	}
000302 2A18       01004 	INCF  i_2,1,0
000304 D7E6       01005 	BRA   m013
                  01006 			;}
000306 0012       01007 m014	RETURN
                  01008 			;
                  01009 			;//*********************** EEPROM BYTEARRAY LESEN  **************************************
                  01010 			;
                  01011 			;void Eeprom_ReadBlock(uns8 *array, uns16 adress, const uns8 length)			//Zum Ausführen eines beliebigen Befehls durch den Programmcode
                  01012 			;{
                  01013 Eeprom_ReadBlock
                  01014 			;	if(!array) return;
000308 520C       01015 	MOVF  array_2,1,0
00030A B4D8       01016 	BTFSC 0xFD8,Zero_,0
00030C 0012       01017 	RETURN
                  01018 			;	uns8 i, temp;
                  01019 			;	for(i=0;i<length;i++)
00030E 6A10       01020 	CLRF  i_3,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 18

ADDR   CODE       LINE  SOURCE

000310 500F       01021 m015	MOVF  length_3,W,0
000312 6010       01022 	CPFSLT i_3,0
000314 D011       01023 	BRA   m016
                  01024 			;	{
                  01025 			;		temp = Eeprom_Read(adress);
000316 C00D F012  01026 	MOVFF adress_4,adress_2
00031A C00E F013  01027 	MOVFF adress_4+1,adress_2+1
00031E DFC9       01028 	RCALL Eeprom_Read
000320 6E11       01029 	MOVWF temp_2,0
                  01030 			;		array[i] = temp;
000322 6AEA       01031 	CLRF  FSR0+1,0
000324 5010       01032 	MOVF  i_3,W,0
000326 240C       01033 	ADDWF array_2,W,0
000328 6EE9       01034 	MOVWF FSR0,0
00032A C011 FFEF  01035 	MOVFF temp_2,INDF0
                  01036 			;		adress++;
00032E 2A0D       01037 	INCF  adress_4,1,0
000330 0E00       01038 	MOVLW 0
000332 220E       01039 	ADDWFC adress_4+1,1,0
                  01040 			;	}
000334 2A10       01041 	INCF  i_3,1,0
000336 D7EC       01042 	BRA   m015
                  01043 			;}
000338 0012       01044 m016	RETURN
                  01045 
                  01046   ; FILE error.c
                  01047 			;/**
                  01048 			; Copyright (C) 2012 Nils Weiss, Patrick BrÃ¼nn.
                  01049 			; 
                  01050 			; This file is part of Wifly_Light.
                  01051 			; 
                  01052 			; Wifly_Light is free software: you can redistribute it and/or modify
                  01053 			; it under the terms of the GNU General Public License as published by
                  01054 			; the Free Software Foundation, either version 3 of the License, or
                  01055 			; (at your option) any later version.
                  01056 			; 
                  01057 			; Wifly_Light is distributed in the hope that it will be useful,
                  01058 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  01059 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  01060 			; GNU General Public License for more details.
                  01061 			; 
                  01062 			; You should have received a copy of the GNU General Public License
                  01063 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  01064 			;
                  01065 			;#include "error.h"
                  01066 			;#include "CommandIO.h"
                  01067 			;#include "RingBuf.h"
                  01068 			;#include "trace.h"
                  01069 			;#include "ledstrip.h"
                  01070 			;
                  01071 			;struct ErrorBits g_ErrorBits;
                  01072 			;
                  01073 			;ErrorCode Error_GetState()
                  01074 			;{
                  01075 Error_GetState
                  01076 			;	if(g_ErrorBits.EepromFailure) return SCRIPTBUFFER_FULL;
00033A B22B       01077 	BTFSC g_ErrorBits,1,0
00033C 0C01       01078 	RETLW 1
                  01079 			;	else if(g_ErrorBits.CrcFailure) return CRC_CHECK_FAILED;
00033E B02B       01080 	BTFSC g_ErrorBits,0,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 19

ADDR   CODE       LINE  SOURCE

000340 0C02       01081 	RETLW 2
                  01082 			;	else return OK;
000342 0C00       01083 	RETLW 0
                  01084 			;}
                  01085 			;
                  01086 			;void Error_Throw()
                  01087 			;{
                  01088 Error_Throw
                  01089 			;#ifdef DEBUG
                  01090 			;	if(RingBuf_HasError(&g_TraceBuf)) 
000344 0E03       01091 	MOVLW 3
000346 6E02       01092 	MOVWF pBuf_4,0
000348 0E08       01093 	MOVLW 8
00034A 6E03       01094 	MOVWF pBuf_4+1,0
00034C EC78 F006  01095 	CALL  RingBuf_HasError
000350 A0D8       01096 	BTFSS 0xFD8,Carry,0
000352 D00B       01097 	BRA   m017
                  01098 			;	{
                  01099 			;		// *** Re-init the Ringbuffer
                  01100 			;		RingBuf_Init(&g_TraceBuf);
000354 0E03       01101 	MOVLW 3
000356 6E0B       01102 	MOVWF pBuf,0
000358 0E08       01103 	MOVLW 8
00035A 6E0C       01104 	MOVWF pBuf+1,0
00035C EC1A F006  01105 	CALL  RingBuf_Init
                  01106 			;		Trace_String("E:05; ERROR: Tracebuffer full");
000360 0E05       01107 	MOVLW 5
000362 6E0E       01108 	MOVWF string,0
000364 6A0F       01109 	CLRF  string+1,0
000366 EC51 F00C  01110 	CALL  Trace_String
                  01111 			;	}
                  01112 			;#endif
                  01113 			;	
                  01114 			;	if(g_ErrorBits.CmdBufOverflow)
00036A A42B       01115 m017	BTFSS g_ErrorBits,2,0
00036C D006       01116 	BRA   m018
                  01117 			;	{
                  01118 			;		Trace_String("E:04; ERROR: Commandbuffer full");
00036E 0E23       01119 	MOVLW 35
000370 6E0E       01120 	MOVWF string,0
000372 6A0F       01121 	CLRF  string+1,0
000374 EC51 F00C  01122 	CALL  Trace_String
                  01123 			;		Error_FatalError();
000378 D824       01124 	RCALL Error_FatalError
                  01125 			;	}
                  01126 			;	
                  01127 			;	if(RingBuf_HasError(&g_RingBuf)) 
00037A 6A02       01128 m018	CLRF  pBuf_4,0
00037C 0E07       01129 	MOVLW 7
00037E 6E03       01130 	MOVWF pBuf_4+1,0
000380 EC78 F006  01131 	CALL  RingBuf_HasError
000384 A0D8       01132 	BTFSS 0xFD8,Carry,0
000386 D00C       01133 	BRA   m019
                  01134 			;	{
                  01135 			;		Trace_String("E:03; ERROR: Receivebuffer full");
000388 0E43       01136 	MOVLW 67
00038A 6E0E       01137 	MOVWF string,0
00038C 6A0F       01138 	CLRF  string+1,0
00038E EC51 F00C  01139 	CALL  Trace_String
                  01140 			;		// *** Re-init the Ringbuffer to get a consistent commandstring and reset error
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 20

ADDR   CODE       LINE  SOURCE

                  01141 			;		RingBuf_Init(&g_RingBuf);
000392 6A0B       01142 	CLRF  pBuf,0
000394 0E07       01143 	MOVLW 7
000396 6E0C       01144 	MOVWF pBuf+1,0
000398 EC1A F006  01145 	CALL  RingBuf_Init
                  01146 			;		// *** if a RingBufError occure, I have to throw away the current command,
                  01147 			;		// *** because the last byte was not saved. Commandstring is inconsistent
                  01148 			;		CommandIO_Init();
00039C ECE4 F006  01149 	CALL  CommandIO_Init
                  01150 			;	}
                  01151 			;	if(g_ErrorBits.CrcFailure)
0003A0 A02B       01152 m019	BTFSS g_ErrorBits,0,0
0003A2 D006       01153 	BRA   m020
                  01154 			;	{
                  01155 			;		Trace_String("E:02; ERROR: Crc-Check failed");
0003A4 0E63       01156 	MOVLW 99
0003A6 6E0E       01157 	MOVWF string,0
0003A8 6A0F       01158 	CLRF  string+1,0
0003AA EC51 F00C  01159 	CALL  Trace_String
                  01160 			;		g_ErrorBits.CrcFailure = 0;
0003AE 902B       01161 	BCF   g_ErrorBits,0,0
                  01162 			;	}
                  01163 			;	if(g_ErrorBits.EepromFailure)
0003B0 A22B       01164 m020	BTFSS g_ErrorBits,1,0
0003B2 D006       01165 	BRA   m021
                  01166 			;	{
                  01167 			;		Trace_String("E:01; ERROR: EEPROM is full");
0003B4 0E81       01168 	MOVLW 129
0003B6 6E0E       01169 	MOVWF string,0
0003B8 6A0F       01170 	CLRF  string+1,0
0003BA EC51 F00C  01171 	CALL  Trace_String
                  01172 			;		g_ErrorBits.EepromFailure = 0;
0003BE 922B       01173 	BCF   g_ErrorBits,1,0
                  01174 			;	}
                  01175 			;}
0003C0 0012       01176 m021	RETURN
                  01177 			;
                  01178 			;void Error_FatalError()
                  01179 			;{
                  01180 Error_FatalError
                  01181 			;	uns8 i = 0;
0003C2 6A0A       01182 	CLRF  i_4,0
                  01183 			;	for(;i < NUM_OF_LED * 3; i++)
0003C4 0E60       01184 m022	MOVLW 96
0003C6 600A       01185 	CPFSLT i_4,0
0003C8 D019       01186 	BRA   m023
                  01187 			;	{
                  01188 			;		gLedBuf.led_array[i] = 0x00;
0003CA 0E30       01189 	MOVLW 48
0003CC 240A       01190 	ADDWF i_4,W,0
0003CE 6EE9       01191 	MOVWF FSR0,0
0003D0 0E03       01192 	MOVLW 3
0003D2 6AEA       01193 	CLRF  FSR0+1,0
0003D4 22EA       01194 	ADDWFC FSR0+1,1,0
0003D6 6AEF       01195 	CLRF  INDF0,0
                  01196 			;		i++;
0003D8 2A0A       01197 	INCF  i_4,1,0
                  01198 			;		gLedBuf.led_array[i] = 0x00;
0003DA 0E30       01199 	MOVLW 48
0003DC 240A       01200 	ADDWF i_4,W,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 21

ADDR   CODE       LINE  SOURCE

0003DE 6EE9       01201 	MOVWF FSR0,0
0003E0 0E03       01202 	MOVLW 3
0003E2 6AEA       01203 	CLRF  FSR0+1,0
0003E4 22EA       01204 	ADDWFC FSR0+1,1,0
0003E6 6AEF       01205 	CLRF  INDF0,0
                  01206 			;		i++;
0003E8 2A0A       01207 	INCF  i_4,1,0
                  01208 			;		gLedBuf.led_array[i] = 0xff;
0003EA 0E30       01209 	MOVLW 48
0003EC 240A       01210 	ADDWF i_4,W,0
0003EE 6EE9       01211 	MOVWF FSR0,0
0003F0 0E03       01212 	MOVLW 3
0003F2 6AEA       01213 	CLRF  FSR0+1,0
0003F4 22EA       01214 	ADDWFC FSR0+1,1,0
0003F6 68EF       01215 	SETF  INDF0,0
                  01216 			;	}
0003F8 2A0A       01217 	INCF  i_4,1,0
0003FA D7E4       01218 	BRA   m022
                  01219 			;	
                  01220 			;	Ledstrip_UpdateLed();
0003FC D993       01221 m023	RCALL Ledstrip_UpdateLed
                  01222 			;#ifdef __CC8E__
                  01223 			;	while(PORTB.5 != 0);
0003FE BA81       01224 m024	BTFSC PORTB,5,0
000400 D7FE       01225 	BRA   m024
                  01226 			;	while(PORTB.5 == 0);
000402 AA81       01227 m025	BTFSS PORTB,5,0
000404 D7FE       01228 	BRA   m025
                  01229 			;#endif
                  01230 			;	CommandIO_Init();
000406 ECE4 F006  01231 	CALL  CommandIO_Init
                  01232 			;	RingBuf_Init(&g_RingBuf);
00040A 6A0B       01233 	CLRF  pBuf,0
00040C 0E07       01234 	MOVLW 7
00040E 6E0C       01235 	MOVWF pBuf+1,0
000410 EF1A F006  01236 	GOTO  RingBuf_Init
                  01237 			;}
                  01238 
                  01239   ; FILE MATH16.H
                  01240 			;// SIZE
                  01241 			;#pragma codepage 1
                  01242 			;#pragma library 1
                  01243 			;/*
                  01244 			;uns16 operator* _mult8x8( uns8 arg1, uns8 arg2);
                  01245 			;int16 operator* _multS8x8( int8 arg1, int8 arg2);
                  01246 			;uns16 operator* _multU16x8( uns16 arg1, uns8 arg2);
                  01247 			;uns16 operator* _mult16x16( uns16 arg1, uns16 arg2);
                  01248 			;uns16 operator/ _divU16_8( uns16 arg1, uns8 arg2);
                  01249 			;uns16 operator/ _divU16_16( uns16 arg1, uns16 arg2);
                  01250 			;int16 operator/ _divS16_8( int16 arg1, int8 arg2);
                  01251 			;int16 operator/ _divS16_16( int16 arg1, int16 arg2);
                  01252 			;uns8 operator% _remU16_8( uns16 arg1, uns8 arg2);
                  01253 			;uns16 operator% _remU16_16( uns16 arg1, uns16 arg2);
                  01254 			;int8 operator% _remS16_8( int16 arg1, int8 arg2);
                  01255 			;int16 operator% _remS16_16( int16 arg1, int16 arg2);
                  01256 			;*/
                  01257 			;
                  01258 			;#if __CoreSet__ < 1410
                  01259 			; #define genAdd(r,a) W=a; btsc(Carry); W=incsz(a); r+=W
                  01260 			; #define genSub(r,a) W=a; btss(Carry); W=incsz(a); r-=W
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 22

ADDR   CODE       LINE  SOURCE

                  01261 			; #define genAddW(r,a) W=a; btsc(Carry); W=incsz(a); W=r+W
                  01262 			; #define genSubW(r,a) W=a; btss(Carry); W=incsz(a); W=r-W
                  01263 			;#else
                  01264 			; #define genAdd(r,a) W=a; r=addWFC(r)
                  01265 			; #define genSub(r,a) W=a; r=subWFB(r)
                  01266 			; #define genAddW(r,a) W=a; W=addWFC(r)
                  01267 			; #define genSubW(r,a) W=a; W=subWFB(r)
                  01268 			;#endif
                  01269 			;
                  01270 			;
                  01271 			;int8 operator*( int8 arg1, int8 arg2)  @
                  01272 			;
                  01273 			;uns16 operator* _mult8x8( uns8 arg1, uns8 arg2)
                  01274 			;{
                  01275 _mult8x8
000414 6E19       01276 	MOVWF arg2,0
                  01277 			;    uns16 rval;
                  01278 			;    char counter = sizeof(arg2)*8;
000416 0E08       01279 	MOVLW 8
000418 6E1C       01280 	MOVWF counter,0
                  01281 			;    rval.high8 = 0;
00041A 6A1B       01282 	CLRF  rval+1,0
                  01283 			;    W = arg1;
00041C 5018       01284 	MOVF  arg1,W,0
                  01285 			;    do  {
                  01286 			;        arg2 = rr( arg2);
00041E 3219       01287 m026	RRCF  arg2,1,0
                  01288 			;        if (Carry)
000420 B0D8       01289 	BTFSC 0xFD8,Carry,0
                  01290 			;            rval.high8 += W;
000422 261B       01291 	ADDWF rval+1,1,0
                  01292 			;        rval = rr( rval);
000424 321B       01293 	RRCF  rval+1,1,0
000426 321A       01294 	RRCF  rval,1,0
                  01295 			;        counter = decsz(counter);
000428 2E1C       01296 	DECFSZ counter,1,0
                  01297 			;    } while (1);
00042A D7F9       01298 	BRA   m026
                  01299 			;    return rval;
00042C 501A       01300 	MOVF  rval,W,0
00042E 0012       01301 	RETURN
                  01302 			;}
                  01303 			;
                  01304 			;
                  01305 			;int16 operator* _multS8x8( int8 arg1, int8 arg2)
                  01306 			;{
                  01307 _multS8x8
                  01308 			;    uns16 rval;
                  01309 			;    char counter = sizeof(arg2)*8;
                  01310 			;    int8 tmpArg2 = arg2;
                  01311 			;    rval.high8 = 0;
                  01312 			;    W = arg1;
                  01313 			;    do  {
                  01314 			;        tmpArg2 = rr( tmpArg2);
                  01315 			;        if (Carry)
                  01316 			;            rval.high8 += W;
                  01317 			;        rval = rr( rval);
                  01318 			;        counter = decsz(counter);
                  01319 			;    } while (1);
                  01320 			;    W = arg2;
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 23

ADDR   CODE       LINE  SOURCE

                  01321 			;    if (arg1 < 0)
                  01322 			;        rval.high8 -= W;
                  01323 			;    W = arg1;
                  01324 			;    if (arg2 < 0)
                  01325 			;        rval.high8 -= W;
                  01326 			;    return rval;
                  01327 			;}
                  01328 			;
                  01329 			;
                  01330 			;uns16 operator*( uns8 arg1, uns16 arg2) exchangeArgs @
                  01331 			;
                  01332 			;uns16 operator* _multU16x8( uns16 arg1, uns8 arg2)
                  01333 			;{
                  01334 _multU16x8
                  01335 			;    uns16 rval;
                  01336 			;    uns8 rvalH = 0;
                  01337 			;    char counter = sizeof(arg1)*8;
                  01338 			;    W = arg2;
                  01339 			;    do  {
                  01340 			;        arg1 = rr( arg1);
                  01341 			;        if (Carry)
                  01342 			;            rvalH += W;
                  01343 			;        rvalH = rr(rvalH);
                  01344 			;        rval = rr(rval);
                  01345 			;        counter = decsz(counter);
                  01346 			;    } while (1);
                  01347 			;    return rval;
                  01348 			;}
                  01349 			;
                  01350 			;
                  01351 			;int16 operator*( int16 arg1, int16 arg2) @
                  01352 			;
                  01353 			;uns16 operator* _mult16x16( uns16 arg1, uns16 arg2)
                  01354 			;{
                  01355 _mult16x16
                  01356 			;    uns16 rval;
                  01357 			;    char counter = sizeof(arg1)*8;
                  01358 			;    do  {
                  01359 			;        Carry = 0;
                  01360 			;        rval = rl( rval);
                  01361 			;        arg1 = rl( arg1);
                  01362 			;        if (Carry)
                  01363 			;            rval += arg2;
                  01364 			;        counter = decsz(counter);
                  01365 			;    } while (1);
                  01366 			;    return rval;
                  01367 			;}
                  01368 			;
                  01369 			;
                  01370 			;
                  01371 			;uns16 operator/ _divU16_8( uns16 arg1, uns8 arg2)
                  01372 			;{
                  01373 _divU16_8
000430 6E1F       01374 	MOVWF arg2_5,0
                  01375 			;    uns8 rm = 0;
000432 6A20       01376 	CLRF  rm,0
                  01377 			;    char counter = sizeof(arg1)*8+1;
000434 0E11       01378 	MOVLW 17
000436 6E21       01379 	MOVWF counter_5,0
                  01380 			;    goto ENTRY_ML;
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 24

ADDR   CODE       LINE  SOURCE

000438 D008       01381 	BRA   m028
                  01382 			;    do  {
                  01383 			;        rm = rl( rm);
00043A 3620       01384 m027	RLCF  rm,1,0
                  01385 			;        uns8 tmp = rl( tmp);
00043C 3622       01386 	RLCF  tmp,1,0
                  01387 			;        W = rm - arg2;
00043E 501F       01388 	MOVF  arg2_5,W,0
000440 5C20       01389 	SUBWF rm,W,0
                  01390 			;        if (tmp&1)
000442 B022       01391 	BTFSC tmp,0,0
                  01392 			;            Carry = 1;
000444 80D8       01393 	BSF   0xFD8,Carry,0
                  01394 			;        if (Carry)
000446 B0D8       01395 	BTFSC 0xFD8,Carry,0
                  01396 			;            rm = W;
000448 6E20       01397 	MOVWF rm,0
                  01398 			;       ENTRY_ML:
                  01399 			;        arg1 = rl( arg1);
00044A 361D       01400 m028	RLCF  arg1_5,1,0
00044C 361E       01401 	RLCF  arg1_5+1,1,0
                  01402 			;        counter = decsz(counter);
00044E 2E21       01403 	DECFSZ counter_5,1,0
                  01404 			;    } while (1);
000450 D7F4       01405 	BRA   m027
                  01406 			;    return arg1;
000452 501D       01407 	MOVF  arg1_5,W,0
000454 0012       01408 	RETURN
                  01409 			;}
                  01410 			;
                  01411 			;
                  01412 			;uns16 operator/ _divU16_16( uns16 arg1, uns16 arg2)
                  01413 			;{
                  01414 _divU16_16
                  01415 			;    uns16 rm = 0;
                  01416 			;    char counter = sizeof(arg1)*8+1;
                  01417 			;    goto ENTRY_ML;
                  01418 			;    do  {
                  01419 			;        rm = rl( rm);
                  01420 			;        W = rm.low8 - arg2.low8;
                  01421 			;        genSubW( rm.high8, arg2.high8);
                  01422 			;        if (!Carry)
                  01423 			;            goto ENTRY_ML;
                  01424 			;        rm.high8 = W;
                  01425 			;        rm.low8 -= arg2.low8;
                  01426 			;        Carry = 1;
                  01427 			;       ENTRY_ML:
                  01428 			;        arg1 = rl( arg1);
                  01429 			;        counter = decsz(counter);
                  01430 			;    } while (1);
                  01431 			;    return arg1;
                  01432 			;}
                  01433 			;
                  01434 			;
                  01435 			;int8  operator/ (int8 arg1, int8 arg2) @
                  01436 			;
                  01437 			;int16 operator/ _divS16_8( int16 arg1, int8 arg2)
                  01438 			;{
                  01439 _divS16_8
                  01440 			;    uns8 rm = 0;
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 25

ADDR   CODE       LINE  SOURCE

                  01441 			;    char counter = 16+1;
                  01442 			;    char sign = arg1.high8 ^ arg2.high8;
                  01443 			;    if (arg1 < 0)  {
                  01444 			;       INVERT_ML:
                  01445 			;        arg1 = -arg1;
                  01446 			;        if (!counter)
                  01447 			;            return arg1;
                  01448 			;    }
                  01449 			;    if (arg2 < 0)
                  01450 			;        arg2 = -arg2;
                  01451 			;    goto ENTRY_ML;
                  01452 			;    do  {
                  01453 			;        rm = rl( rm);
                  01454 			;        W = rm - arg2;
                  01455 			;        if (Carry)
                  01456 			;            rm = W;
                  01457 			;       ENTRY_ML:
                  01458 			;        arg1 = rl( arg1);
                  01459 			;        counter = decsz(counter);
                  01460 			;    } while (1);
                  01461 			;    if (sign & 0x80)
                  01462 			;        goto INVERT_ML;
                  01463 			;    return arg1;
                  01464 			;}
                  01465 			;
                  01466 			;
                  01467 			;int16 operator/ _divS16_16( int16 arg1, int16 arg2)
                  01468 			;{
                  01469 _divS16_16
                  01470 			;    uns16 rm = 0;
                  01471 			;    char counter = sizeof(arg1)*8+1;
                  01472 			;    char sign = arg1.high8 ^ arg2.high8;
                  01473 			;    if (arg1 < 0)  {
                  01474 			;       INVERT_ML:
                  01475 			;        arg1 = -arg1;
                  01476 			;        if (!counter)
                  01477 			;            return arg1;
                  01478 			;    }
                  01479 			;    if (arg2 < 0)
                  01480 			;        arg2 = -arg2;
                  01481 			;    goto ENTRY_ML;
                  01482 			;    do  {
                  01483 			;        rm = rl( rm);
                  01484 			;        W = rm.low8 - arg2.low8;
                  01485 			;        genSubW( rm.high8, arg2.high8);
                  01486 			;        if (!Carry)
                  01487 			;            goto ENTRY_ML;
                  01488 			;        rm.high8 = W;
                  01489 			;        rm.low8 -= arg2.low8;
                  01490 			;        Carry = 1;
                  01491 			;       ENTRY_ML:
                  01492 			;        arg1 = rl( arg1);
                  01493 			;        counter = decsz(counter);
                  01494 			;    } while (1);
                  01495 			;    if (sign & 0x80)
                  01496 			;        goto INVERT_ML;
                  01497 			;    return arg1;
                  01498 			;}
                  01499 			;
                  01500 			;
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 26

ADDR   CODE       LINE  SOURCE

                  01501 			;uns8 operator% _remU16_8( uns16 arg1, uns8 arg2)
                  01502 			;{
                  01503 _remU16_8
                  01504 			;    uns8 rm = 0;
                  01505 			;    char counter = sizeof(arg1)*8;
                  01506 			;    do  {
                  01507 			;        arg1 = rl( arg1);
                  01508 			;        rm = rl( rm);
                  01509 			;        uns8 tmp = rl( tmp);
                  01510 			;        W = rm - arg2;
                  01511 			;        if (tmp&1)
                  01512 			;            Carry = 1;
                  01513 			;        if (Carry)
                  01514 			;            rm = W;
                  01515 			;        counter = decsz(counter);
                  01516 			;    } while (1);
                  01517 			;    return rm;
                  01518 			;}
                  01519 			;
                  01520 			;
                  01521 			;uns16 operator% _remU16_16( uns16 arg1, uns16 arg2)
                  01522 			;{
                  01523 _remU16_16
                  01524 			;    uns16 rm = 0;
                  01525 			;    char counter = sizeof(arg1)*8;
                  01526 			;    do  {
                  01527 			;        arg1 = rl( arg1);
                  01528 			;        rm = rl( rm);
                  01529 			;        W = rm.low8 - arg2.low8;
                  01530 			;        genSubW( rm.high8, arg2.high8);
                  01531 			;        if (!Carry)
                  01532 			;            goto NOSUB;
                  01533 			;        rm.high8 = W;
                  01534 			;        rm.low8 -= arg2.low8;
                  01535 			;      NOSUB:
                  01536 			;        counter = decsz(counter);
                  01537 			;    } while (1);
                  01538 			;    return rm;
                  01539 			;}
                  01540 			;
                  01541 			;
                  01542 			;int8 operator% (int8 arg1, int8 arg2) @
                  01543 			;
                  01544 			;int8 operator% _remS16_8( int16 arg1, int8 arg2)
                  01545 			;{
                  01546 _remS16_8
                  01547 			;    int8 rm = 0;
                  01548 			;    char counter = 16;
                  01549 			;    char sign = arg1.high8;
                  01550 			;    if (arg1 < 0)
                  01551 			;        arg1 = -arg1;
                  01552 			;    if (arg2 < 0)
                  01553 			;        arg2 = -arg2;
                  01554 			;    do  {
                  01555 			;        arg1 = rl( arg1);
                  01556 			;        rm = rl( rm);
                  01557 			;        W = rm - arg2;
                  01558 			;        if (Carry)
                  01559 			;            rm = W;
                  01560 			;        counter = decsz(counter);
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 27

ADDR   CODE       LINE  SOURCE

                  01561 			;    } while (1);
                  01562 			;    if (sign & 0x80)
                  01563 			;        rm = -rm;
                  01564 			;    return rm;
                  01565 			;}
                  01566 			;
                  01567 			;
                  01568 			;int16 operator% _remS16_16( int16 arg1, int16 arg2)
                  01569 			;{
                  01570 _remS16_16
                  01571 			;    int16 rm = 0;
                  01572 			;    char counter = sizeof(arg1)*8;
                  01573 			;    char sign = arg1.high8;
                  01574 			;    if (arg1 < 0)
                  01575 			;        arg1 = -arg1;
                  01576 			;    if (arg2 < 0)
                  01577 			;        arg2 = -arg2;
                  01578 			;    do  {
                  01579 			;        arg1 = rl( arg1);
                  01580 			;        rm = rl( rm);
                  01581 			;        W = rm.low8 - arg2.low8;
                  01582 			;        genSubW( rm.high8, arg2.high8);
                  01583 			;        if (!Carry)
                  01584 			;            goto NOSUB;
                  01585 			;        rm.high8 = W;
                  01586 			;        rm.low8 -= arg2.low8;
                  01587 			;      NOSUB:
                  01588 			;        counter = decsz(counter);
                  01589 			;    } while (1);
                  01590 			;    if (sign & 0x80)
                  01591 			;        rm = -rm;
                  01592 			;    return rm;
                  01593 
                  01594   ; FILE ledstrip.c
                  01595 			;/**
                  01596 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  01597 			; 
                  01598 			; This file is part of Wifly_Light.
                  01599 			; 
                  01600 			; Wifly_Light is free software: you can redistribute it and/or modify
                  01601 			; it under the terms of the GNU General Public License as published by
                  01602 			; the Free Software Foundation, either version 3 of the License, or
                  01603 			; (at your option) any later version.
                  01604 			; 
                  01605 			; Wifly_Light is distributed in the hope that it will be useful,
                  01606 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  01607 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  01608 			; GNU General Public License for more details.
                  01609 			; 
                  01610 			; You should have received a copy of the GNU General Public License
                  01611 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  01612 			;
                  01613 			;#include "ledstrip.h"
                  01614 			;#include "spi.h"
                  01615 			;#include "wifly_cmd.h"
                  01616 			;#ifdef __CC8E__
                  01617 			;#include "MATH16.H"
                  01618 			;#endif /* #ifdef __CC8E__ */
                  01619 			;
                  01620 			;struct LedBuffer gLedBuf;
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 28

ADDR   CODE       LINE  SOURCE

                  01621 			;struct cmd_set_fade mFade;
                  01622 			;
                  01623 			;
                  01624 			;/**
                  01625 			; * Since we often work with a rotating bitmask which is greater
                  01626 			; * than 1 byte we use this macro to keep the mask and the bitfield
                  01627 			; * in sync.
                  01628 			; */
                  01629 			;#define INC_BIT_COUNTER(PTR, MASK) { \
                  01630 			;	MASK <<= 1; \
                  01631 			;	if(0 == MASK) { \
                  01632 			;		PTR++; \
                  01633 			;		MASK = 0x01; \
                  01634 			;	} \
                  01635 			;}
                  01636 			;
                  01637 			;/**
                  01638 			; * This macro is used to iterate over each led and each color.
                  01639 			; * <BLOCK> is executed if the led color was selected in <pCmd->addr>
                  01640 			; * <ELSE> is executed if not
                  01641 			; */
                  01642 			;#define FOR_EACH_MASKED_LED_DO(BLOCK, ELSE) { \
                  01643 			;	uns8 *address = pCmd->addr; \
                  01644 			;	uns8 k,mask; \
                  01645 			;	mask = 0x01; \
                  01646 			;	for(k = 0; k < (NUM_OF_LED * 3); k++) {	\
                  01647 			;		if(0 != (*address & mask)) { \
                  01648 			;			BLOCK \
                  01649 			;		} else { \
                  01650 			;			ELSE \
                  01651 			;		} \
                  01652 			;		INC_BIT_COUNTER(address, mask); \
                  01653 			;	} \
                  01654 			;}
                  01655 			;
                  01656 			;/**
                  01657 			; * This is a sub-macro of <FOR_EACH_MASKED_LED_DO> used in fade precalculations
                  01658 			; * to calculate the fading parameters(<periodeLength>, <stepSize> and <delta>) for <newColor>
                  01659 			;**/
                  01660 			;#define CALC_COLOR(newColor)  \
                  01661 			;		{\
                  01662 			;		delta = gLedBuf.led_array[k]; \
                  01663 			;		if(delta > newColor)  \
                  01664 			;		{ \
                  01665 			;			delta = delta - newColor;  \
                  01666 			;			*(stepAddress) |= (stepMask);  \
                  01667 			;		} \
                  01668 			;		else  \
                  01669 			;		{  \
                  01670 			;			delta = newColor - delta;  \
                  01671 			;			*(stepAddress) &= ~(stepMask); \
                  01672 			;		}  \
                  01673 			;		INC_BIT_COUNTER(stepAddress, stepMask); \
                  01674 			;		stepSize = 0x01; \
                  01675 			;		temp16 = 0; \
                  01676 			;		if((0 != delta))  \
                  01677 			;		{ \
                  01678 			;			do{ \
                  01679 			;			temp8 = delta / stepSize; \
                  01680 			;			temp16 = fadeTmms / temp8;  \
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 29

ADDR   CODE       LINE  SOURCE

                  01681 			;			if(temp16 < 1) { \
                  01682 			;			      stepSize += 1; } \
                  01683 			;			} while(temp16 < 1); \
                  01684 			;		} \
                  01685 			;		gLedBuf.stepSize[k] = stepSize; \
                  01686 			;		gLedBuf.delta[k] = delta; \
                  01687 			;		gLedBuf.periodeLength[k] = temp16;  \
                  01688 			;		gLedBuf.cyclesLeft[k] = temp16;  \
                  01689 			;};
                  01690 			;
                  01691 			;uns8 Ledstrip_NumOfFades(void)
                  01692 			;{
                  01693 Ledstrip_NumOfFades
                  01694 			;	uns8 counter = 0;
000456 6A7F       01695 	CLRF  counter_13,0
                  01696 			;	uns8 i;
                  01697 			;	
                  01698 			;	for(i = 0; i < NUM_OF_LED * 3; i++)
000458 6A7F       01699 	CLRF  i_5,0
00045A 0E60       01700 m029	MOVLW 96
00045C 607F       01701 	CPFSLT i_5,0
00045E D00B       01702 	BRA   m030
                  01703 			;	{
                  01704 			;		if(gLedBuf.delta[i] > 0)
000460 0E90       01705 	MOVLW 144
000462 247F       01706 	ADDWF i_5,W,0
000464 6EE9       01707 	MOVWF FSR0,0
000466 0E03       01708 	MOVLW 3
000468 6AEA       01709 	CLRF  FSR0+1,0
00046A 22EA       01710 	ADDWFC FSR0+1,1,0
00046C 50EF       01711 	MOVF  INDF0,W,0
00046E A4D8       01712 	BTFSS 0xFD8,Zero_,0
                  01713 			;		{
                  01714 			;			counter += 1;
000470 2A7F       01715 	INCF  counter_13,1,0
                  01716 			;		}
                  01717 			;	}
000472 2A7F       01718 	INCF  i_5,1,0
000474 D7F2       01719 	BRA   m029
                  01720 			;	return counter;
000476 507F       01721 m030	MOVF  counter_13,W,0
000478 0012       01722 	RETURN
                  01723 			;}
                  01724 			;
                  01725 			;void Ledstrip_ToggleLeds(void)
                  01726 			;{
                  01727 Ledstrip_ToggleLeds
                  01728 			;#if 1
                  01729 			;	//TODO is this implementation equivalent to yours?
                  01730 			;
                  01731 			;	// if all leds are of we switch all on to white else switch all off
                  01732 			;	uns8 ledColor = 0xff;
00047A 680A       01733 	SETF  ledColor,0
                  01734 			;	uns8 i = 0;
00047C 6A0B       01735 	CLRF  i_6,0
                  01736 			;	while(i < NUM_OF_LED * 3)
00047E 0E60       01737 m031	MOVLW 96
000480 600B       01738 	CPFSLT i_6,0
000482 D00D       01739 	BRA   m033
                  01740 			;	{
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 30

ADDR   CODE       LINE  SOURCE

                  01741 			;		if(gLedBuf.led_array[i] > 0)
000484 0E30       01742 	MOVLW 48
000486 240B       01743 	ADDWF i_6,W,0
000488 6EE9       01744 	MOVWF FSR0,0
00048A 0E03       01745 	MOVLW 3
00048C 6AEA       01746 	CLRF  FSR0+1,0
00048E 22EA       01747 	ADDWFC FSR0+1,1,0
000490 50EF       01748 	MOVF  INDF0,W,0
000492 B4D8       01749 	BTFSC 0xFD8,Zero_,0
000494 D002       01750 	BRA   m032
                  01751 			;		{
                  01752 			;			ledColor = 0;
000496 6A0A       01753 	CLRF  ledColor,0
                  01754 			;			break;
000498 D002       01755 	BRA   m033
                  01756 			;		}
                  01757 			;		i++;
00049A 2A0B       01758 m032	INCF  i_6,1,0
                  01759 			;	}
00049C D7F0       01760 	BRA   m031
                  01761 			;
                  01762 			;	// we found out the state of the leds. Now, we switch on or off
                  01763 			;	uns8 led;
                  01764 			;	for(led = 0; led < NUM_OF_LED * 3; led++)
00049E 6A0C       01765 m033	CLRF  led,0
0004A0 0E60       01766 m034	MOVLW 96
0004A2 600C       01767 	CPFSLT led,0
0004A4 D13F       01768 	BRA   Ledstrip_UpdateLed
                  01769 			;	{
                  01770 			;		gLedBuf.led_array[led] = ledColor;
0004A6 0E30       01771 	MOVLW 48
0004A8 240C       01772 	ADDWF led,W,0
0004AA 6EE9       01773 	MOVWF FSR0,0
0004AC 0E03       01774 	MOVLW 3
0004AE 6AEA       01775 	CLRF  FSR0+1,0
0004B0 22EA       01776 	ADDWFC FSR0+1,1,0
0004B2 C00A FFEF  01777 	MOVFF ledColor,INDF0
                  01778 			;	}
0004B6 2A0C       01779 	INCF  led,1,0
0004B8 D7F3       01780 	BRA   m034
                  01781 			;	Ledstrip_UpdateLed();
                  01782 			;#else
                  01783 			;	//check current status of led
                  01784 			;	uns8 counter = 0;
                  01785 			;	uns8 i;
                  01786 			;	
                  01787 			;	for(i = 0; i < NUM_OF_LED * 3; i++)
                  01788 			;	{
                  01789 			;		if(gLedBuf.led_array[i] > 0)
                  01790 			;		{
                  01791 			;			counter += 1;
                  01792 			;		}
                  01793 			;	}
                  01794 			;	//struct cmd_set_fade mFade;
                  01795 			;	
                  01796 			;	mFade.addr[0] = 0xff;
                  01797 			;	mFade.addr[1] = 0xff;
                  01798 			;	mFade.addr[2] = 0xff;
                  01799 			;	mFade.addr[3] = 0xff;
                  01800 			;	mFade.fadeTmms = htons(200);
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 31

ADDR   CODE       LINE  SOURCE

                  01801 			;
                  01802 			;	if(counter > 0)		//switch off
                  01803 			;	{
                  01804 			;		mFade.red = 0x00;
                  01805 			;		mFade.green = 0x00;
                  01806 			;		mFade.blue = 0x00;
                  01807 			;	}
                  01808 			;	else {
                  01809 			;		mFade.red = 0xff;
                  01810 			;		mFade.green = 0xff;
                  01811 			;		mFade.blue = 0xff;
                  01812 			;	}
                  01813 			;	Ledstrip_SetFade(&mFade);
                  01814 			;#endif
                  01815 			;}
                  01816 			;
                  01817 			;void Ledstrip_Init(void)
                  01818 			;{
                  01819 Ledstrip_Init
                  01820 			;	// initialize interface to ledstrip
                  01821 			;	SPI_Init();
0004BA DAEA       01822 	RCALL SPI_Init
                  01823 			;	
                  01824 			;	// initialize variables
                  01825 			;	uns8 i = sizeof(gLedBuf.led_array);
0004BC 0E60       01826 	MOVLW 96
0004BE 6E0A       01827 	MOVWF i_7,0
                  01828 			;	do {
                  01829 			;		i--;
0004C0 060A       01830 m035	DECF  i_7,1,0
                  01831 			;		gLedBuf.led_array[i] = 0;
0004C2 0E30       01832 	MOVLW 48
0004C4 240A       01833 	ADDWF i_7,W,0
0004C6 6EE9       01834 	MOVWF FSR0,0
0004C8 0E03       01835 	MOVLW 3
0004CA 6AEA       01836 	CLRF  FSR0+1,0
0004CC 22EA       01837 	ADDWFC FSR0+1,1,0
0004CE 6AEF       01838 	CLRF  INDF0,0
                  01839 			;	} while(0 != i);
0004D0 520A       01840 	MOVF  i_7,1,0
0004D2 A4D8       01841 	BTFSS 0xFD8,Zero_,0
0004D4 D7F5       01842 	BRA   m035
                  01843 			;	/*-------------------------------------*/
                  01844 			;	i = sizeof(gLedBuf.delta);
0004D6 0E60       01845 	MOVLW 96
0004D8 6E0A       01846 	MOVWF i_7,0
                  01847 			;	do {
                  01848 			;		i--;
0004DA 060A       01849 m036	DECF  i_7,1,0
                  01850 			;		gLedBuf.delta[i] = 0;
0004DC 0E90       01851 	MOVLW 144
0004DE 240A       01852 	ADDWF i_7,W,0
0004E0 6EE9       01853 	MOVWF FSR0,0
0004E2 0E03       01854 	MOVLW 3
0004E4 6AEA       01855 	CLRF  FSR0+1,0
0004E6 22EA       01856 	ADDWFC FSR0+1,1,0
0004E8 6AEF       01857 	CLRF  INDF0,0
                  01858 			;	} while(0 != i);
0004EA 520A       01859 	MOVF  i_7,1,0
0004EC A4D8       01860 	BTFSS 0xFD8,Zero_,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 32

ADDR   CODE       LINE  SOURCE

0004EE D7F5       01861 	BRA   m036
                  01862 			;	/*-------------------------------------*/
                  01863 			;	i = sizeof(gLedBuf.cyclesLeft);
0004F0 0EC0       01864 	MOVLW 192
0004F2 6E0A       01865 	MOVWF i_7,0
                  01866 			;	do {
                  01867 			;		i--;
0004F4 060A       01868 m037	DECF  i_7,1,0
                  01869 			;		gLedBuf.cyclesLeft[i] = 0;
0004F6 90D8       01870 	BCF   0xFD8,Carry,0
0004F8 340A       01871 	RLCF  i_7,W,0
0004FA 6EE9       01872 	MOVWF FSR0,0
0004FC 6AEA       01873 	CLRF  FSR0+1,0
0004FE 36EA       01874 	RLCF  FSR0+1,1,0
000500 0EF0       01875 	MOVLW 240
000502 26E9       01876 	ADDWF FSR0,1,0
000504 0E03       01877 	MOVLW 3
000506 22EA       01878 	ADDWFC FSR0+1,1,0
000508 6AEE       01879 	CLRF  POSTINC0,0
00050A 6AEF       01880 	CLRF  INDF0,0
                  01881 			;	} while(0 != i);
00050C 520A       01882 	MOVF  i_7,1,0
00050E A4D8       01883 	BTFSS 0xFD8,Zero_,0
000510 D7F1       01884 	BRA   m037
                  01885 			;	/*-------------------------------------*/
                  01886 			;	i = sizeof(gLedBuf.periodeLength);
000512 0EC0       01887 	MOVLW 192
000514 6E0A       01888 	MOVWF i_7,0
                  01889 			;	do {
                  01890 			;		i--;
000516 060A       01891 m038	DECF  i_7,1,0
                  01892 			;		gLedBuf.periodeLength[i] = 0;
000518 90D8       01893 	BCF   0xFD8,Carry,0
00051A 340A       01894 	RLCF  i_7,W,0
00051C 6EE9       01895 	MOVWF FSR0,0
00051E 6AEA       01896 	CLRF  FSR0+1,0
000520 36EA       01897 	RLCF  FSR0+1,1,0
000522 0EB0       01898 	MOVLW 176
000524 26E9       01899 	ADDWF FSR0,1,0
000526 0E04       01900 	MOVLW 4
000528 22EA       01901 	ADDWFC FSR0+1,1,0
00052A 6AEE       01902 	CLRF  POSTINC0,0
00052C 6AEF       01903 	CLRF  INDF0,0
                  01904 			;	} while(0 != i);
00052E 520A       01905 	MOVF  i_7,1,0
000530 A4D8       01906 	BTFSS 0xFD8,Zero_,0
000532 D7F1       01907 	BRA   m038
                  01908 			;	/*-------------------------------------*/
                  01909 			;	i = sizeof(gLedBuf.step);
000534 0E0C       01910 	MOVLW 12
000536 6E0A       01911 	MOVWF i_7,0
                  01912 			;	do {
                  01913 			;		i--;
000538 060A       01914 m039	DECF  i_7,1,0
                  01915 			;		gLedBuf.step[i] = 0;
00053A 0E70       01916 	MOVLW 112
00053C 240A       01917 	ADDWF i_7,W,0
00053E 6EE9       01918 	MOVWF FSR0,0
000540 0E05       01919 	MOVLW 5
000542 6AEA       01920 	CLRF  FSR0+1,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 33

ADDR   CODE       LINE  SOURCE

000544 22EA       01921 	ADDWFC FSR0+1,1,0
000546 6AEF       01922 	CLRF  INDF0,0
                  01923 			;	} while(0 != i);
000548 520A       01924 	MOVF  i_7,1,0
00054A A4D8       01925 	BTFSS 0xFD8,Zero_,0
00054C D7F5       01926 	BRA   m039
                  01927 			;	/*-------------------------------------*/
                  01928 			;	i = sizeof(gLedBuf.stepSize);
00054E 0E60       01929 	MOVLW 96
000550 6E0A       01930 	MOVWF i_7,0
                  01931 			;	do {
                  01932 			;		i--;
000552 060A       01933 m040	DECF  i_7,1,0
                  01934 			;		gLedBuf.stepSize[i] = 0;
000554 0E7C       01935 	MOVLW 124
000556 240A       01936 	ADDWF i_7,W,0
000558 6EE9       01937 	MOVWF FSR0,0
00055A 0E05       01938 	MOVLW 5
00055C 6AEA       01939 	CLRF  FSR0+1,0
00055E 22EA       01940 	ADDWFC FSR0+1,1,0
000560 6AEF       01941 	CLRF  INDF0,0
                  01942 			;	} while(0 != i);
000562 520A       01943 	MOVF  i_7,1,0
000564 A4D8       01944 	BTFSS 0xFD8,Zero_,0
000566 D7F5       01945 	BRA   m040
                  01946 			;	
                  01947 			;	gLedBuf.fadeTmms = 0;
000568 0105       01948 	MOVLB 5
00056A 6BDC       01949 	CLRF  gLedBuf+684,1
00056C 6BDD       01950 	CLRF  gLedBuf+685,1
                  01951 			;	gLedBuf.flags.run_aktiv = 0;
00056E 91DE       01952 	BCF   gLedBuf+686,0,1
                  01953 			;	gLedBuf.flags.run_direction = 0;
000570 93DE       01954 	BCF   gLedBuf+686,1,1
                  01955 			;}
000572 0012       01956 	RETURN
                  01957 			;
                  01958 			;void Ledstrip_SetColorDirect(uns8 *pValues)
                  01959 			;{
                  01960 Ledstrip_SetColorDirect
                  01961 			;	uns8 k, temp;
                  01962 			;	for(k = 0; k < (NUM_OF_LED * 3); k++)
000574 6A0D       01963 	CLRF  k,0
000576 0E60       01964 m041	MOVLW 96
000578 600D       01965 	CPFSLT k,0
00057A D023       01966 	BRA   m042
                  01967 			;	{
                  01968 			;		temp = *pValues;
00057C 0E02       01969 	MOVLW 2
00057E 6EEA       01970 	MOVWF FSR0+1,0
000580 C00C FFE9  01971 	MOVFF pValues,FSR0
000584 CFEF F00E  01972 	MOVFF INDF0,temp_3
                  01973 			;		gLedBuf.led_array[k] = temp;
000588 0E30       01974 	MOVLW 48
00058A 240D       01975 	ADDWF k,W,0
00058C 6EE9       01976 	MOVWF FSR0,0
00058E 0E03       01977 	MOVLW 3
000590 6AEA       01978 	CLRF  FSR0+1,0
000592 22EA       01979 	ADDWFC FSR0+1,1,0
000594 C00E FFEF  01980 	MOVFF temp_3,INDF0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 34

ADDR   CODE       LINE  SOURCE

                  01981 			;		pValues += 1;
000598 2A0C       01982 	INCF  pValues,1,0
                  01983 			;		gLedBuf.cyclesLeft[k] = 0;
00059A 90D8       01984 	BCF   0xFD8,Carry,0
00059C 340D       01985 	RLCF  k,W,0
00059E 6EE9       01986 	MOVWF FSR0,0
0005A0 6AEA       01987 	CLRF  FSR0+1,0
0005A2 36EA       01988 	RLCF  FSR0+1,1,0
0005A4 0EF0       01989 	MOVLW 240
0005A6 26E9       01990 	ADDWF FSR0,1,0
0005A8 0E03       01991 	MOVLW 3
0005AA 22EA       01992 	ADDWFC FSR0+1,1,0
0005AC 6AEE       01993 	CLRF  POSTINC0,0
0005AE 6AEF       01994 	CLRF  INDF0,0
                  01995 			;		gLedBuf.delta[k] = 0;
0005B0 0E90       01996 	MOVLW 144
0005B2 240D       01997 	ADDWF k,W,0
0005B4 6EE9       01998 	MOVWF FSR0,0
0005B6 0E03       01999 	MOVLW 3
0005B8 6AEA       02000 	CLRF  FSR0+1,0
0005BA 22EA       02001 	ADDWFC FSR0+1,1,0
0005BC 6AEF       02002 	CLRF  INDF0,0
                  02003 			;	}
0005BE 2A0D       02004 	INCF  k,1,0
0005C0 D7DA       02005 	BRA   m041
                  02006 			;}
0005C2 0012       02007 m042	RETURN
                  02008 			;
                  02009 			;void Ledstrip_DoFade(void)
                  02010 			;{
                  02011 Ledstrip_DoFade
                  02012 			;	uns8 k, stepmask, stepSize;
                  02013 			;	uns8* stepaddress = gLedBuf.step;
0005C4 0E70       02014 	MOVLW 112
0005C6 6E0D       02015 	MOVWF stepaddress,0
0005C8 0E05       02016 	MOVLW 5
0005CA 6E0E       02017 	MOVWF stepaddress+1,0
                  02018 			;	stepmask = 0x01;
0005CC 0E01       02019 	MOVLW 1
0005CE 6E0B       02020 	MOVWF stepmask,0
                  02021 			;	uns16 periodeLength;
                  02022 			;	
                  02023 			;	/* Update cyclesLeft Value for all LED's */
                  02024 			;	
                  02025 			;	for(k = 0; k < NUM_OF_LED * 3; k++)
0005D0 6A0A       02026 	CLRF  k_2,0
0005D2 0E60       02027 m043	MOVLW 96
0005D4 600A       02028 	CPFSLT k_2,0
0005D6 D024       02029 	BRA   m045
                  02030 			;	{
                  02031 			;		if((gLedBuf.delta[k] > 0) && (gLedBuf.cyclesLeft[k] > 0))
0005D8 0E90       02032 	MOVLW 144
0005DA 240A       02033 	ADDWF k_2,W,0
0005DC 6EE9       02034 	MOVWF FSR0,0
0005DE 0E03       02035 	MOVLW 3
0005E0 6AEA       02036 	CLRF  FSR0+1,0
0005E2 22EA       02037 	ADDWFC FSR0+1,1,0
0005E4 50EF       02038 	MOVF  INDF0,W,0
0005E6 B4D8       02039 	BTFSC 0xFD8,Zero_,0
0005E8 D019       02040 	BRA   m044
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 35

ADDR   CODE       LINE  SOURCE

0005EA 90D8       02041 	BCF   0xFD8,Carry,0
0005EC 340A       02042 	RLCF  k_2,W,0
0005EE 6EE9       02043 	MOVWF FSR0,0
0005F0 6AEA       02044 	CLRF  FSR0+1,0
0005F2 36EA       02045 	RLCF  FSR0+1,1,0
0005F4 0EF0       02046 	MOVLW 240
0005F6 26E9       02047 	ADDWF FSR0,1,0
0005F8 0E03       02048 	MOVLW 3
0005FA 22EA       02049 	ADDWFC FSR0+1,1,0
0005FC 50EE       02050 	MOVF  POSTINC0,W,0
0005FE 10EF       02051 	IORWF INDF0,W,0
000600 B4D8       02052 	BTFSC 0xFD8,Zero_,0
000602 D00C       02053 	BRA   m044
                  02054 			;		{
                  02055 			;			gLedBuf.cyclesLeft[k]--;	
000604 90D8       02056 	BCF   0xFD8,Carry,0
000606 340A       02057 	RLCF  k_2,W,0
000608 6EE9       02058 	MOVWF FSR0,0
00060A 6AEA       02059 	CLRF  FSR0+1,0
00060C 36EA       02060 	RLCF  FSR0+1,1,0
00060E 0EF0       02061 	MOVLW 240
000610 26E9       02062 	ADDWF FSR0,1,0
000612 0E03       02063 	MOVLW 3
000614 22EA       02064 	ADDWFC FSR0+1,1,0
000616 06EE       02065 	DECF  POSTINC0,1,0
000618 0E00       02066 	MOVLW 0
00061A 5AEF       02067 	SUBWFB INDF0,1,0
                  02068 			;		}
                  02069 			;	}
00061C 2A0A       02070 m044	INCF  k_2,1,0
00061E D7D9       02071 	BRA   m043
                  02072 			;	
                  02073 			;	for(k = 0; k < (NUM_OF_LED * 3); k++)
000620 6A0A       02074 m045	CLRF  k_2,0
000622 0E60       02075 m046	MOVLW 96
000624 600A       02076 	CPFSLT k_2,0
000626 D07D       02077 	BRA   m052
                  02078 			;	{
                  02079 			;		// fade active on this led and current periode is over?
                  02080 			;		if((gLedBuf.delta[k] > 0) && (gLedBuf.cyclesLeft[k] == 0))
000628 0E90       02081 	MOVLW 144
00062A 240A       02082 	ADDWF k_2,W,0
00062C 6EE9       02083 	MOVWF FSR0,0
00062E 0E03       02084 	MOVLW 3
000630 6AEA       02085 	CLRF  FSR0+1,0
000632 22EA       02086 	ADDWFC FSR0+1,1,0
000634 50EF       02087 	MOVF  INDF0,W,0
000636 B4D8       02088 	BTFSC 0xFD8,Zero_,0
000638 D069       02089 	BRA   m050
00063A 90D8       02090 	BCF   0xFD8,Carry,0
00063C 340A       02091 	RLCF  k_2,W,0
00063E 6EE9       02092 	MOVWF FSR0,0
000640 6AEA       02093 	CLRF  FSR0+1,0
000642 36EA       02094 	RLCF  FSR0+1,1,0
000644 0EF0       02095 	MOVLW 240
000646 26E9       02096 	ADDWF FSR0,1,0
000648 0E03       02097 	MOVLW 3
00064A 22EA       02098 	ADDWFC FSR0+1,1,0
00064C 50EE       02099 	MOVF  POSTINC0,W,0
00064E 10EF       02100 	IORWF INDF0,W,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 36

ADDR   CODE       LINE  SOURCE

000650 A4D8       02101 	BTFSS 0xFD8,Zero_,0
000652 D05C       02102 	BRA   m050
                  02103 			;		{
                  02104 			;			stepSize = gLedBuf.stepSize[k];
000654 0E7C       02105 	MOVLW 124
000656 240A       02106 	ADDWF k_2,W,0
000658 6EE9       02107 	MOVWF FSR0,0
00065A 0E05       02108 	MOVLW 5
00065C 6AEA       02109 	CLRF  FSR0+1,0
00065E 22EA       02110 	ADDWFC FSR0+1,1,0
000660 CFEF F00C  02111 	MOVFF INDF0,stepSize
                  02112 			;			// reset cycle counters
                  02113 			;			if(gLedBuf.delta[k] < stepSize)
000664 0E90       02114 	MOVLW 144
000666 240A       02115 	ADDWF k_2,W,0
000668 6EE9       02116 	MOVWF FSR0,0
00066A 0E03       02117 	MOVLW 3
00066C 6AEA       02118 	CLRF  FSR0+1,0
00066E 22EA       02119 	ADDWFC FSR0+1,1,0
000670 500C       02120 	MOVF  stepSize,W,0
000672 60EF       02121 	CPFSLT INDF0,0
000674 D010       02122 	BRA   m047
                  02123 			;			{
                  02124 			;			  stepSize = gLedBuf.delta[k];
000676 0E90       02125 	MOVLW 144
000678 240A       02126 	ADDWF k_2,W,0
00067A 6EE9       02127 	MOVWF FSR0,0
00067C 0E03       02128 	MOVLW 3
00067E 6AEA       02129 	CLRF  FSR0+1,0
000680 22EA       02130 	ADDWFC FSR0+1,1,0
000682 CFEF F00C  02131 	MOVFF INDF0,stepSize
                  02132 			;			  gLedBuf.delta[k] = 0;
000686 0E90       02133 	MOVLW 144
000688 240A       02134 	ADDWF k_2,W,0
00068A 6EE9       02135 	MOVWF FSR0,0
00068C 0E03       02136 	MOVLW 3
00068E 6AEA       02137 	CLRF  FSR0+1,0
000690 22EA       02138 	ADDWFC FSR0+1,1,0
000692 6AEF       02139 	CLRF  INDF0,0
                  02140 			;			}
                  02141 			;			else
000694 D008       02142 	BRA   m048
                  02143 			;			{
                  02144 			;			  gLedBuf.delta[k] -= stepSize;
000696 0E90       02145 m047	MOVLW 144
000698 240A       02146 	ADDWF k_2,W,0
00069A 6EE9       02147 	MOVWF FSR0,0
00069C 0E03       02148 	MOVLW 3
00069E 6AEA       02149 	CLRF  FSR0+1,0
0006A0 22EA       02150 	ADDWFC FSR0+1,1,0
0006A2 500C       02151 	MOVF  stepSize,W,0
0006A4 5EEF       02152 	SUBWF INDF0,1,0
                  02153 			;			}
                  02154 			;			periodeLength = gLedBuf.periodeLength[k];
0006A6 90D8       02155 m048	BCF   0xFD8,Carry,0
0006A8 340A       02156 	RLCF  k_2,W,0
0006AA 6EE9       02157 	MOVWF FSR0,0
0006AC 6AEA       02158 	CLRF  FSR0+1,0
0006AE 36EA       02159 	RLCF  FSR0+1,1,0
0006B0 0EB0       02160 	MOVLW 176
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 37

ADDR   CODE       LINE  SOURCE

0006B2 26E9       02161 	ADDWF FSR0,1,0
0006B4 0E04       02162 	MOVLW 4
0006B6 22EA       02163 	ADDWFC FSR0+1,1,0
0006B8 CFEE F00F  02164 	MOVFF POSTINC0,periodeLength
0006BC CFEE F010  02165 	MOVFF POSTINC0,periodeLength+1
                  02166 			;			gLedBuf.cyclesLeft[k] = periodeLength;
0006C0 90D8       02167 	BCF   0xFD8,Carry,0
0006C2 340A       02168 	RLCF  k_2,W,0
0006C4 6EE9       02169 	MOVWF FSR0,0
0006C6 6AEA       02170 	CLRF  FSR0+1,0
0006C8 36EA       02171 	RLCF  FSR0+1,1,0
0006CA 0EF0       02172 	MOVLW 240
0006CC 26E9       02173 	ADDWF FSR0,1,0
0006CE 0E03       02174 	MOVLW 3
0006D0 22EA       02175 	ADDWFC FSR0+1,1,0
0006D2 C00F FFEE  02176 	MOVFF periodeLength,POSTINC0
0006D6 C010 FFEE  02177 	MOVFF periodeLength+1,POSTINC0
                  02178 			;
                  02179 			;			// update rgb value by one step
                  02180 			;			if(0 != ((*stepaddress) & stepmask)) 
0006DA C00D FFE9  02181 	MOVFF stepaddress,FSR0
0006DE C00E FFEA  02182 	MOVFF stepaddress+1,FSR0+1
0006E2 500B       02183 	MOVF  stepmask,W,0
0006E4 14EF       02184 	ANDWF INDF0,W,0
0006E6 B4D8       02185 	BTFSC 0xFD8,Zero_,0
0006E8 D009       02186 	BRA   m049
                  02187 			;			{
                  02188 			;				gLedBuf.led_array[k] -= stepSize;
0006EA 0E30       02189 	MOVLW 48
0006EC 240A       02190 	ADDWF k_2,W,0
0006EE 6EE9       02191 	MOVWF FSR0,0
0006F0 0E03       02192 	MOVLW 3
0006F2 6AEA       02193 	CLRF  FSR0+1,0
0006F4 22EA       02194 	ADDWFC FSR0+1,1,0
0006F6 500C       02195 	MOVF  stepSize,W,0
0006F8 5EEF       02196 	SUBWF INDF0,1,0
                  02197 			;			} else 
0006FA D008       02198 	BRA   m050
                  02199 			;			{
                  02200 			;				gLedBuf.led_array[k] += stepSize;
0006FC 0E30       02201 m049	MOVLW 48
0006FE 240A       02202 	ADDWF k_2,W,0
000700 6EE9       02203 	MOVWF FSR0,0
000702 0E03       02204 	MOVLW 3
000704 6AEA       02205 	CLRF  FSR0+1,0
000706 22EA       02206 	ADDWFC FSR0+1,1,0
000708 500C       02207 	MOVF  stepSize,W,0
00070A 26EF       02208 	ADDWF INDF0,1,0
                  02209 			;			}
                  02210 			;		}
                  02211 			;		INC_BIT_COUNTER(stepaddress, stepmask);
00070C 90D8       02212 m050	BCF   0xFD8,Carry,0
00070E 360B       02213 	RLCF  stepmask,1,0
000710 A4D8       02214 	BTFSS 0xFD8,Zero_,0
000712 D005       02215 	BRA   m051
000714 2A0D       02216 	INCF  stepaddress,1,0
000716 0E00       02217 	MOVLW 0
000718 220E       02218 	ADDWFC stepaddress+1,1,0
00071A 0E01       02219 	MOVLW 1
00071C 6E0B       02220 	MOVWF stepmask,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 38

ADDR   CODE       LINE  SOURCE

                  02221 			;	}
00071E 2A0A       02222 m051	INCF  k_2,1,0
000720 D780       02223 	BRA   m046
                  02224 			;	
                  02225 			;}
000722 0012       02226 m052	RETURN
                  02227 			;
                  02228 			;void Ledstrip_UpdateLed(void)
                  02229 			;{
                  02230 Ledstrip_UpdateLed
                  02231 			;	SPI_SendLedBuffer(gLedBuf.led_array);
000724 0E30       02232 	MOVLW 48
000726 6E0D       02233 	MOVWF array_3,0
000728 0E03       02234 	MOVLW 3
00072A 6E0E       02235 	MOVWF array_3+1,0
00072C D1C3       02236 	BRA   SPI_SendLedBuffer
                  02237 			;}
                  02238 			;
                  02239 			;void Ledstrip_SetFade(struct cmd_set_fade *pCmd)
                  02240 			;{
                  02241 Ledstrip_SetFade
                  02242 			;	// constant for this fade used in CALC_COLOR
                  02243 			;	const uns16 fadeTmms = ntohs(pCmd->fadeTmms);
00072E 6AEA       02244 	CLRF  FSR0+1,0
000730 0E08       02245 	MOVLW 8
000732 240C       02246 	ADDWF pCmd,W,0
000734 6EE9       02247 	MOVWF FSR0,0
000736 CFEE F01A  02248 	MOVFF POSTINC0,networkShort
00073A CFEE F01B  02249 	MOVFF POSTINC0,networkShort+1
00073E ECA6 F008  02250 	CALL  ntohs
000742 C01C F00D  02251 	MOVFF retval_2,fadeTmms
000746 C01D F00E  02252 	MOVFF retval_2+1,fadeTmms+1
                  02253 			;
                  02254 			;	uns8* stepAddress = gLedBuf.step;
00074A 0E70       02255 	MOVLW 112
00074C 6E0F       02256 	MOVWF stepAddress,0
00074E 0E05       02257 	MOVLW 5
000750 6E10       02258 	MOVWF stepAddress+1,0
                  02259 			;	uns8 stepMask = 0x01;
000752 0E01       02260 	MOVLW 1
000754 6E11       02261 	MOVWF stepMask,0
                  02262 			;	uns16 temp16;
                  02263 			;	uns8 red,green,blue,delta,stepSize,temp8;
                  02264 			;	
                  02265 			;	red = pCmd->red;
000756 6AEA       02266 	CLRF  FSR0+1,0
000758 0E04       02267 	MOVLW 4
00075A 240C       02268 	ADDWF pCmd,W,0
00075C 6EE9       02269 	MOVWF FSR0,0
00075E CFEF F014  02270 	MOVFF INDF0,red
                  02271 			;	green = pCmd->green;
000762 6AEA       02272 	CLRF  FSR0+1,0
000764 0E05       02273 	MOVLW 5
000766 240C       02274 	ADDWF pCmd,W,0
000768 6EE9       02275 	MOVWF FSR0,0
00076A CFEF F015  02276 	MOVFF INDF0,green
                  02277 			;	blue = pCmd->blue;
00076E 6AEA       02278 	CLRF  FSR0+1,0
000770 0E06       02279 	MOVLW 6
000772 240C       02280 	ADDWF pCmd,W,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 39

ADDR   CODE       LINE  SOURCE

000774 6EE9       02281 	MOVWF FSR0,0
000776 CFEF F016  02282 	MOVFF INDF0,blue
                  02283 			;	// calc fade parameters for each led
                  02284 			;	FOR_EACH_MASKED_LED_DO(
                  02285 			;		{
                  02286 			;			CALC_COLOR(blue);
                  02287 			;			k++;
                  02288 			;			CALC_COLOR(green);
                  02289 			;			k++;
                  02290 			;			CALC_COLOR(red);
                  02291 			;		},
                  02292 			;		{
                  02293 			;			// if led is not fade, we have to increment our pointers and rotate the mask
                  02294 			;			k++;k++;
                  02295 			;			INC_BIT_COUNTER(stepAddress, stepMask);
                  02296 			;			INC_BIT_COUNTER(stepAddress, stepMask);
                  02297 			;			INC_BIT_COUNTER(stepAddress, stepMask);
                  02298 			;		}
                  02299 			;	);
00077A C00C F01A  02300 	MOVFF pCmd,address
00077E 0E01       02301 	MOVLW 1
000780 6E1C       02302 	MOVWF mask,0
000782 6A1B       02303 	CLRF  k_3,0
000784 0E60       02304 m053	MOVLW 96
000786 601B       02305 	CPFSLT k_3,0
000788 D180       02306 	BRA   m074
00078A C01A FFE9  02307 	MOVFF address,FSR0
00078E 6AEA       02308 	CLRF  FSR0+1,0
000790 501C       02309 	MOVF  mask,W,0
000792 14EF       02310 	ANDWF INDF0,W,0
000794 B4D8       02311 	BTFSC 0xFD8,Zero_,0
000796 D153       02312 	BRA   m069
000798 0E30       02313 	MOVLW 48
00079A 241B       02314 	ADDWF k_3,W,0
00079C 6EE9       02315 	MOVWF FSR0,0
00079E 0E03       02316 	MOVLW 3
0007A0 6AEA       02317 	CLRF  FSR0+1,0
0007A2 22EA       02318 	ADDWFC FSR0+1,1,0
0007A4 CFEF F017  02319 	MOVFF INDF0,delta
0007A8 5017       02320 	MOVF  delta,W,0
0007AA 6016       02321 	CPFSLT blue,0
0007AC D009       02322 	BRA   m054
0007AE 5016       02323 	MOVF  blue,W,0
0007B0 5E17       02324 	SUBWF delta,1,0
0007B2 C00F FFE9  02325 	MOVFF stepAddress,FSR0
0007B6 C010 FFEA  02326 	MOVFF stepAddress+1,FSR0+1
0007BA 5011       02327 	MOVF  stepMask,W,0
0007BC 12EF       02328 	IORWF INDF0,1,0
0007BE D009       02329 	BRA   m055
0007C0 5017       02330 m054	MOVF  delta,W,0
0007C2 5C16       02331 	SUBWF blue,W,0
0007C4 6E17       02332 	MOVWF delta,0
0007C6 C00F FFE9  02333 	MOVFF stepAddress,FSR0
0007CA C010 FFEA  02334 	MOVFF stepAddress+1,FSR0+1
0007CE 1C11       02335 	COMF  stepMask,W,0
0007D0 16EF       02336 	ANDWF INDF0,1,0
0007D2 90D8       02337 m055	BCF   0xFD8,Carry,0
0007D4 3611       02338 	RLCF  stepMask,1,0
0007D6 A4D8       02339 	BTFSS 0xFD8,Zero_,0
0007D8 D005       02340 	BRA   m056
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 40

ADDR   CODE       LINE  SOURCE

0007DA 2A0F       02341 	INCF  stepAddress,1,0
0007DC 0E00       02342 	MOVLW 0
0007DE 2210       02343 	ADDWFC stepAddress+1,1,0
0007E0 0E01       02344 	MOVLW 1
0007E2 6E11       02345 	MOVWF stepMask,0
0007E4 0E01       02346 m056	MOVLW 1
0007E6 6E18       02347 	MOVWF stepSize_2,0
0007E8 6A12       02348 	CLRF  temp16,0
0007EA 6A13       02349 	CLRF  temp16+1,0
0007EC 5217       02350 	MOVF  delta,1,0
0007EE B4D8       02351 	BTFSC 0xFD8,Zero_,0
0007F0 D019       02352 	BRA   m058
0007F2 C017 F01D  02353 m057	MOVFF delta,arg1_5
0007F6 6A1E       02354 	CLRF  arg1_5+1,0
0007F8 5018       02355 	MOVF  stepSize_2,W,0
0007FA DE1A       02356 	RCALL _divU16_8
0007FC C01D F019  02357 	MOVFF arg1_5,temp8
000800 C00D F01D  02358 	MOVFF fadeTmms,arg1_5
000804 C00E F01E  02359 	MOVFF fadeTmms+1,arg1_5+1
000808 5019       02360 	MOVF  temp8,W,0
00080A DE12       02361 	RCALL _divU16_8
00080C C01D F012  02362 	MOVFF arg1_5,temp16
000810 C01E F013  02363 	MOVFF arg1_5+1,temp16+1
000814 5012       02364 	MOVF  temp16,W,0
000816 1013       02365 	IORWF temp16+1,W,0
000818 B4D8       02366 	BTFSC 0xFD8,Zero_,0
00081A 2A18       02367 	INCF  stepSize_2,1,0
00081C 5012       02368 	MOVF  temp16,W,0
00081E 1013       02369 	IORWF temp16+1,W,0
000820 B4D8       02370 	BTFSC 0xFD8,Zero_,0
000822 D7E7       02371 	BRA   m057
000824 0E7C       02372 m058	MOVLW 124
000826 241B       02373 	ADDWF k_3,W,0
000828 6EE9       02374 	MOVWF FSR0,0
00082A 0E05       02375 	MOVLW 5
00082C 6AEA       02376 	CLRF  FSR0+1,0
00082E 22EA       02377 	ADDWFC FSR0+1,1,0
000830 C018 FFEF  02378 	MOVFF stepSize_2,INDF0
000834 0E90       02379 	MOVLW 144
000836 241B       02380 	ADDWF k_3,W,0
000838 6EE9       02381 	MOVWF FSR0,0
00083A 0E03       02382 	MOVLW 3
00083C 6AEA       02383 	CLRF  FSR0+1,0
00083E 22EA       02384 	ADDWFC FSR0+1,1,0
000840 C017 FFEF  02385 	MOVFF delta,INDF0
000844 90D8       02386 	BCF   0xFD8,Carry,0
000846 341B       02387 	RLCF  k_3,W,0
000848 6EE9       02388 	MOVWF FSR0,0
00084A 6AEA       02389 	CLRF  FSR0+1,0
00084C 36EA       02390 	RLCF  FSR0+1,1,0
00084E 0EB0       02391 	MOVLW 176
000850 26E9       02392 	ADDWF FSR0,1,0
000852 0E04       02393 	MOVLW 4
000854 22EA       02394 	ADDWFC FSR0+1,1,0
000856 C012 FFEE  02395 	MOVFF temp16,POSTINC0
00085A C013 FFEE  02396 	MOVFF temp16+1,POSTINC0
00085E 90D8       02397 	BCF   0xFD8,Carry,0
000860 341B       02398 	RLCF  k_3,W,0
000862 6EE9       02399 	MOVWF FSR0,0
000864 6AEA       02400 	CLRF  FSR0+1,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 41

ADDR   CODE       LINE  SOURCE

000866 36EA       02401 	RLCF  FSR0+1,1,0
000868 0EF0       02402 	MOVLW 240
00086A 26E9       02403 	ADDWF FSR0,1,0
00086C 0E03       02404 	MOVLW 3
00086E 22EA       02405 	ADDWFC FSR0+1,1,0
000870 C012 FFEE  02406 	MOVFF temp16,POSTINC0
000874 C013 FFEE  02407 	MOVFF temp16+1,POSTINC0
000878 2A1B       02408 	INCF  k_3,1,0
00087A 0E30       02409 	MOVLW 48
00087C 241B       02410 	ADDWF k_3,W,0
00087E 6EE9       02411 	MOVWF FSR0,0
000880 0E03       02412 	MOVLW 3
000882 6AEA       02413 	CLRF  FSR0+1,0
000884 22EA       02414 	ADDWFC FSR0+1,1,0
000886 CFEF F017  02415 	MOVFF INDF0,delta
00088A 5017       02416 	MOVF  delta,W,0
00088C 6015       02417 	CPFSLT green,0
00088E D009       02418 	BRA   m059
000890 5015       02419 	MOVF  green,W,0
000892 5E17       02420 	SUBWF delta,1,0
000894 C00F FFE9  02421 	MOVFF stepAddress,FSR0
000898 C010 FFEA  02422 	MOVFF stepAddress+1,FSR0+1
00089C 5011       02423 	MOVF  stepMask,W,0
00089E 12EF       02424 	IORWF INDF0,1,0
0008A0 D009       02425 	BRA   m060
0008A2 5017       02426 m059	MOVF  delta,W,0
0008A4 5C15       02427 	SUBWF green,W,0
0008A6 6E17       02428 	MOVWF delta,0
0008A8 C00F FFE9  02429 	MOVFF stepAddress,FSR0
0008AC C010 FFEA  02430 	MOVFF stepAddress+1,FSR0+1
0008B0 1C11       02431 	COMF  stepMask,W,0
0008B2 16EF       02432 	ANDWF INDF0,1,0
0008B4 90D8       02433 m060	BCF   0xFD8,Carry,0
0008B6 3611       02434 	RLCF  stepMask,1,0
0008B8 A4D8       02435 	BTFSS 0xFD8,Zero_,0
0008BA D005       02436 	BRA   m061
0008BC 2A0F       02437 	INCF  stepAddress,1,0
0008BE 0E00       02438 	MOVLW 0
0008C0 2210       02439 	ADDWFC stepAddress+1,1,0
0008C2 0E01       02440 	MOVLW 1
0008C4 6E11       02441 	MOVWF stepMask,0
0008C6 0E01       02442 m061	MOVLW 1
0008C8 6E18       02443 	MOVWF stepSize_2,0
0008CA 6A12       02444 	CLRF  temp16,0
0008CC 6A13       02445 	CLRF  temp16+1,0
0008CE 5217       02446 	MOVF  delta,1,0
0008D0 B4D8       02447 	BTFSC 0xFD8,Zero_,0
0008D2 D019       02448 	BRA   m063
0008D4 C017 F01D  02449 m062	MOVFF delta,arg1_5
0008D8 6A1E       02450 	CLRF  arg1_5+1,0
0008DA 5018       02451 	MOVF  stepSize_2,W,0
0008DC DDA9       02452 	RCALL _divU16_8
0008DE C01D F019  02453 	MOVFF arg1_5,temp8
0008E2 C00D F01D  02454 	MOVFF fadeTmms,arg1_5
0008E6 C00E F01E  02455 	MOVFF fadeTmms+1,arg1_5+1
0008EA 5019       02456 	MOVF  temp8,W,0
0008EC DDA1       02457 	RCALL _divU16_8
0008EE C01D F012  02458 	MOVFF arg1_5,temp16
0008F2 C01E F013  02459 	MOVFF arg1_5+1,temp16+1
0008F6 5012       02460 	MOVF  temp16,W,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 42

ADDR   CODE       LINE  SOURCE

0008F8 1013       02461 	IORWF temp16+1,W,0
0008FA B4D8       02462 	BTFSC 0xFD8,Zero_,0
0008FC 2A18       02463 	INCF  stepSize_2,1,0
0008FE 5012       02464 	MOVF  temp16,W,0
000900 1013       02465 	IORWF temp16+1,W,0
000902 B4D8       02466 	BTFSC 0xFD8,Zero_,0
000904 D7E7       02467 	BRA   m062
000906 0E7C       02468 m063	MOVLW 124
000908 241B       02469 	ADDWF k_3,W,0
00090A 6EE9       02470 	MOVWF FSR0,0
00090C 0E05       02471 	MOVLW 5
00090E 6AEA       02472 	CLRF  FSR0+1,0
000910 22EA       02473 	ADDWFC FSR0+1,1,0
000912 C018 FFEF  02474 	MOVFF stepSize_2,INDF0
000916 0E90       02475 	MOVLW 144
000918 241B       02476 	ADDWF k_3,W,0
00091A 6EE9       02477 	MOVWF FSR0,0
00091C 0E03       02478 	MOVLW 3
00091E 6AEA       02479 	CLRF  FSR0+1,0
000920 22EA       02480 	ADDWFC FSR0+1,1,0
000922 C017 FFEF  02481 	MOVFF delta,INDF0
000926 90D8       02482 	BCF   0xFD8,Carry,0
000928 341B       02483 	RLCF  k_3,W,0
00092A 6EE9       02484 	MOVWF FSR0,0
00092C 6AEA       02485 	CLRF  FSR0+1,0
00092E 36EA       02486 	RLCF  FSR0+1,1,0
000930 0EB0       02487 	MOVLW 176
000932 26E9       02488 	ADDWF FSR0,1,0
000934 0E04       02489 	MOVLW 4
000936 22EA       02490 	ADDWFC FSR0+1,1,0
000938 C012 FFEE  02491 	MOVFF temp16,POSTINC0
00093C C013 FFEE  02492 	MOVFF temp16+1,POSTINC0
000940 90D8       02493 	BCF   0xFD8,Carry,0
000942 341B       02494 	RLCF  k_3,W,0
000944 6EE9       02495 	MOVWF FSR0,0
000946 6AEA       02496 	CLRF  FSR0+1,0
000948 36EA       02497 	RLCF  FSR0+1,1,0
00094A 0EF0       02498 	MOVLW 240
00094C 26E9       02499 	ADDWF FSR0,1,0
00094E 0E03       02500 	MOVLW 3
000950 22EA       02501 	ADDWFC FSR0+1,1,0
000952 C012 FFEE  02502 	MOVFF temp16,POSTINC0
000956 C013 FFEE  02503 	MOVFF temp16+1,POSTINC0
00095A 2A1B       02504 	INCF  k_3,1,0
00095C 0E30       02505 	MOVLW 48
00095E 241B       02506 	ADDWF k_3,W,0
000960 6EE9       02507 	MOVWF FSR0,0
000962 0E03       02508 	MOVLW 3
000964 6AEA       02509 	CLRF  FSR0+1,0
000966 22EA       02510 	ADDWFC FSR0+1,1,0
000968 CFEF F017  02511 	MOVFF INDF0,delta
00096C 5017       02512 	MOVF  delta,W,0
00096E 6014       02513 	CPFSLT red,0
000970 D009       02514 	BRA   m064
000972 5014       02515 	MOVF  red,W,0
000974 5E17       02516 	SUBWF delta,1,0
000976 C00F FFE9  02517 	MOVFF stepAddress,FSR0
00097A C010 FFEA  02518 	MOVFF stepAddress+1,FSR0+1
00097E 5011       02519 	MOVF  stepMask,W,0
000980 12EF       02520 	IORWF INDF0,1,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 43

ADDR   CODE       LINE  SOURCE

000982 D009       02521 	BRA   m065
000984 5017       02522 m064	MOVF  delta,W,0
000986 5C14       02523 	SUBWF red,W,0
000988 6E17       02524 	MOVWF delta,0
00098A C00F FFE9  02525 	MOVFF stepAddress,FSR0
00098E C010 FFEA  02526 	MOVFF stepAddress+1,FSR0+1
000992 1C11       02527 	COMF  stepMask,W,0
000994 16EF       02528 	ANDWF INDF0,1,0
000996 90D8       02529 m065	BCF   0xFD8,Carry,0
000998 3611       02530 	RLCF  stepMask,1,0
00099A A4D8       02531 	BTFSS 0xFD8,Zero_,0
00099C D005       02532 	BRA   m066
00099E 2A0F       02533 	INCF  stepAddress,1,0
0009A0 0E00       02534 	MOVLW 0
0009A2 2210       02535 	ADDWFC stepAddress+1,1,0
0009A4 0E01       02536 	MOVLW 1
0009A6 6E11       02537 	MOVWF stepMask,0
0009A8 0E01       02538 m066	MOVLW 1
0009AA 6E18       02539 	MOVWF stepSize_2,0
0009AC 6A12       02540 	CLRF  temp16,0
0009AE 6A13       02541 	CLRF  temp16+1,0
0009B0 5217       02542 	MOVF  delta,1,0
0009B2 B4D8       02543 	BTFSC 0xFD8,Zero_,0
0009B4 D019       02544 	BRA   m068
0009B6 C017 F01D  02545 m067	MOVFF delta,arg1_5
0009BA 6A1E       02546 	CLRF  arg1_5+1,0
0009BC 5018       02547 	MOVF  stepSize_2,W,0
0009BE DD38       02548 	RCALL _divU16_8
0009C0 C01D F019  02549 	MOVFF arg1_5,temp8
0009C4 C00D F01D  02550 	MOVFF fadeTmms,arg1_5
0009C8 C00E F01E  02551 	MOVFF fadeTmms+1,arg1_5+1
0009CC 5019       02552 	MOVF  temp8,W,0
0009CE DD30       02553 	RCALL _divU16_8
0009D0 C01D F012  02554 	MOVFF arg1_5,temp16
0009D4 C01E F013  02555 	MOVFF arg1_5+1,temp16+1
0009D8 5012       02556 	MOVF  temp16,W,0
0009DA 1013       02557 	IORWF temp16+1,W,0
0009DC B4D8       02558 	BTFSC 0xFD8,Zero_,0
0009DE 2A18       02559 	INCF  stepSize_2,1,0
0009E0 5012       02560 	MOVF  temp16,W,0
0009E2 1013       02561 	IORWF temp16+1,W,0
0009E4 B4D8       02562 	BTFSC 0xFD8,Zero_,0
0009E6 D7E7       02563 	BRA   m067
0009E8 0E7C       02564 m068	MOVLW 124
0009EA 241B       02565 	ADDWF k_3,W,0
0009EC 6EE9       02566 	MOVWF FSR0,0
0009EE 0E05       02567 	MOVLW 5
0009F0 6AEA       02568 	CLRF  FSR0+1,0
0009F2 22EA       02569 	ADDWFC FSR0+1,1,0
0009F4 C018 FFEF  02570 	MOVFF stepSize_2,INDF0
0009F8 0E90       02571 	MOVLW 144
0009FA 241B       02572 	ADDWF k_3,W,0
0009FC 6EE9       02573 	MOVWF FSR0,0
0009FE 0E03       02574 	MOVLW 3
000A00 6AEA       02575 	CLRF  FSR0+1,0
000A02 22EA       02576 	ADDWFC FSR0+1,1,0
000A04 C017 FFEF  02577 	MOVFF delta,INDF0
000A08 90D8       02578 	BCF   0xFD8,Carry,0
000A0A 341B       02579 	RLCF  k_3,W,0
000A0C 6EE9       02580 	MOVWF FSR0,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 44

ADDR   CODE       LINE  SOURCE

000A0E 6AEA       02581 	CLRF  FSR0+1,0
000A10 36EA       02582 	RLCF  FSR0+1,1,0
000A12 0EB0       02583 	MOVLW 176
000A14 26E9       02584 	ADDWF FSR0,1,0
000A16 0E04       02585 	MOVLW 4
000A18 22EA       02586 	ADDWFC FSR0+1,1,0
000A1A C012 FFEE  02587 	MOVFF temp16,POSTINC0
000A1E C013 FFEE  02588 	MOVFF temp16+1,POSTINC0
000A22 90D8       02589 	BCF   0xFD8,Carry,0
000A24 341B       02590 	RLCF  k_3,W,0
000A26 6EE9       02591 	MOVWF FSR0,0
000A28 6AEA       02592 	CLRF  FSR0+1,0
000A2A 36EA       02593 	RLCF  FSR0+1,1,0
000A2C 0EF0       02594 	MOVLW 240
000A2E 26E9       02595 	ADDWF FSR0,1,0
000A30 0E03       02596 	MOVLW 3
000A32 22EA       02597 	ADDWFC FSR0+1,1,0
000A34 C012 FFEE  02598 	MOVFF temp16,POSTINC0
000A38 C013 FFEE  02599 	MOVFF temp16+1,POSTINC0
000A3C D01D       02600 	BRA   m072
000A3E 2A1B       02601 m069	INCF  k_3,1,0
000A40 2A1B       02602 	INCF  k_3,1,0
000A42 90D8       02603 	BCF   0xFD8,Carry,0
000A44 3611       02604 	RLCF  stepMask,1,0
000A46 A4D8       02605 	BTFSS 0xFD8,Zero_,0
000A48 D005       02606 	BRA   m070
000A4A 2A0F       02607 	INCF  stepAddress,1,0
000A4C 0E00       02608 	MOVLW 0
000A4E 2210       02609 	ADDWFC stepAddress+1,1,0
000A50 0E01       02610 	MOVLW 1
000A52 6E11       02611 	MOVWF stepMask,0
000A54 90D8       02612 m070	BCF   0xFD8,Carry,0
000A56 3611       02613 	RLCF  stepMask,1,0
000A58 A4D8       02614 	BTFSS 0xFD8,Zero_,0
000A5A D005       02615 	BRA   m071
000A5C 2A0F       02616 	INCF  stepAddress,1,0
000A5E 0E00       02617 	MOVLW 0
000A60 2210       02618 	ADDWFC stepAddress+1,1,0
000A62 0E01       02619 	MOVLW 1
000A64 6E11       02620 	MOVWF stepMask,0
000A66 90D8       02621 m071	BCF   0xFD8,Carry,0
000A68 3611       02622 	RLCF  stepMask,1,0
000A6A A4D8       02623 	BTFSS 0xFD8,Zero_,0
000A6C D005       02624 	BRA   m072
000A6E 2A0F       02625 	INCF  stepAddress,1,0
000A70 0E00       02626 	MOVLW 0
000A72 2210       02627 	ADDWFC stepAddress+1,1,0
000A74 0E01       02628 	MOVLW 1
000A76 6E11       02629 	MOVWF stepMask,0
000A78 90D8       02630 m072	BCF   0xFD8,Carry,0
000A7A 361C       02631 	RLCF  mask,1,0
000A7C A4D8       02632 	BTFSS 0xFD8,Zero_,0
000A7E D003       02633 	BRA   m073
000A80 2A1A       02634 	INCF  address,1,0
000A82 0E01       02635 	MOVLW 1
000A84 6E1C       02636 	MOVWF mask,0
000A86 2A1B       02637 m073	INCF  k_3,1,0
000A88 D67D       02638 	BRA   m053
                  02639 			;	gLedBuf.flags.run_aktiv = 0;
000A8A 0105       02640 m074	MOVLB 5
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 45

ADDR   CODE       LINE  SOURCE

000A8C 91DE       02641 	BCF   gLedBuf+686,0,1
                  02642 			;	
                  02643 			;}
000A8E 0012       02644 	RETURN
                  02645 
                  02646   ; FILE spi.c
                  02647 			;/**
                  02648 			; Copyright (C) 2012 Nils Weiss, Patrick Brnn.
                  02649 			; 
                  02650 			; This file is part of Wifly_Light.
                  02651 			; 
                  02652 			; Wifly_Light is free software: you can redistribute it and/or modify
                  02653 			; it under the terms of the GNU General Public License as published by
                  02654 			; the Free Software Foundation, either version 3 of the License, or
                  02655 			; (at your option) any later version.
                  02656 			; 
                  02657 			; Wifly_Light is distributed in the hope that it will be useful,
                  02658 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  02659 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  02660 			; GNU General Public License for more details.
                  02661 			; 
                  02662 			; You should have received a copy of the GNU General Public License
                  02663 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  02664 			;
                  02665 			;#include "spi.h"
                  02666 			;
                  02667 			;#ifdef __CC8E__
                  02668 			;void SPI_Init()
                  02669 			;{
                  02670 SPI_Init
                  02671 			;	ANSELC = FALSE;		/* Set PORTC to digital IO */
000A90 010F       02672 	MOVLB 15
000A92 6B3A       02673 	CLRF  ANSELC,1
                  02674 			;	TRISC.3 = FALSE;       /* Make port RC3 an output(SPI Clock) */
000A94 9694       02675 	BCF   TRISC,3,0
                  02676 			;	TRISC.4 = TRUE;        	/* Make port RC4 an input(SPI Data In) */
000A96 8894       02677 	BSF   TRISC,4,0
                  02678 			;	TRISC.5 = FALSE;       /* Make port RC5 an output(SPI Data Out) */
000A98 9A94       02679 	BCF   TRISC,5,0
                  02680 			;
                  02681 			;	SMP = TRUE;		/* Input data sampeld at end of data output time */
000A9A 8EC7       02682 	BSF   0xFC7,SMP,0
                  02683 			;	CKP = FALSE;		/* Idle state for clock is low level */
000A9C 98C6       02684 	BCF   0xFC6,CKP,0
                  02685 			;	CKE = TRUE;		/* Transmit occures on transition from active to Idle clock state */
000A9E 8CC7       02686 	BSF   0xFC7,CKE,0
                  02687 			;	SSP1CON1.0 = TRUE;	/* SPI MASTER mode, clock = Fosc/16 */
000AA0 80C6       02688 	BSF   SSP1CON1,0,0
                  02689 			;	SSPEN = TRUE;		/* Enables the serial port and configures SCK, SDO, SDI */
000AA2 8AC6       02690 	BSF   0xFC6,SSPEN,0
                  02691 			;}
000AA4 0012       02692 	RETURN
                  02693 			;
                  02694 			;uns8 SPI_Send(const uns8 data)
                  02695 			;{
                  02696 SPI_Send
                  02697 			;	SSP1IF = FALSE;		/* Reset interruptflag, that end of transmisson can be detected */
000AA6 969E       02698 	BCF   0xF9E,SSP1IF,0
                  02699 			;	SSP1BUF = data;	
000AA8 C011 FFC9  02700 	MOVFF data_4,SSP1BUF
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 46

ADDR   CODE       LINE  SOURCE

                  02701 			;	while(SSP1IF == 0);	/* Wait for end of transmission */
000AAC A69E       02702 m075	BTFSS 0xF9E,SSP1IF,0
000AAE D7FE       02703 	BRA   m075
                  02704 			;	
                  02705 			;	return SSP1BUF;
000AB0 50C9       02706 	MOVF  SSP1BUF,W,0
000AB2 0012       02707 	RETURN
                  02708 			;}
                  02709 			;
                  02710 			;void SPI_SendLedBuffer(uns8 *array)
                  02711 			;{
                  02712 SPI_SendLedBuffer
                  02713 			;	const uns8* end = (uns8*) (array + (NUM_OF_LED * 3));				/* array must be the address of the first byte*/
000AB4 0E60       02714 	MOVLW 96
000AB6 240D       02715 	ADDWF array_3,W,0
000AB8 6E0F       02716 	MOVWF end,0
000ABA 0E00       02717 	MOVLW 0
000ABC 200E       02718 	ADDWFC array_3+1,W,0
000ABE 6E10       02719 	MOVWF end+1,0
                  02720 			;																		/* calculate whe
                           re the end is */
                  02721 			;	for(; array < end; array++)		/* send all data */
000AC0 500F       02722 m076	MOVF  end,W,0
000AC2 5C0D       02723 	SUBWF array_3,W,0
000AC4 5010       02724 	MOVF  end+1,W,0
000AC6 580E       02725 	SUBWFB array_3+1,W,0
000AC8 B0D8       02726 	BTFSC 0xFD8,Carry,0
000ACA D00B       02727 	BRA   m077
                  02728 			;	{
                  02729 			;		SPI_Send(*array);
000ACC C00D FFE9  02730 	MOVFF array_3,FSR0
000AD0 C00E FFEA  02731 	MOVFF array_3+1,FSR0+1
000AD4 CFEF F011  02732 	MOVFF INDF0,data_4
000AD8 DFE6       02733 	RCALL SPI_Send
                  02734 			;	}
000ADA 2A0D       02735 	INCF  array_3,1,0
000ADC 0E00       02736 	MOVLW 0
000ADE 220E       02737 	ADDWFC array_3+1,1,0
000AE0 D7EF       02738 	BRA   m076
                  02739 			;	
                  02740 			;/* If we really have to garantee a sleep after data was written to the LEDs, it should be added here.
                  02741 			; * Other locations would be more attractive to avoid a waiting core, but here it is much clearer and easier
                  02742 			; * to find for later optimization. In my opinion we should spend this 1ms waste here, before we make the main
                  02743 			; * loop more complex. */
                  02744 			;}
000AE2 0012       02745 m077	RETURN
                  02746 
                  02747   ; FILE timer.c
                  02748 			;/**
                  02749 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  02750 			; 
                  02751 			; This file is part of Wifly_Light.
                  02752 			; 
                  02753 			; Wifly_Light is free software: you can redistribute it and/or modify
                  02754 			; it under the terms of the GNU General Public License as published by
                  02755 			; the Free Software Foundation, either version 3 of the License, or
                  02756 			; (at your option) any later version.
                  02757 			; 
                  02758 			; Wifly_Light is distributed in the hope that it will be useful,
                  02759 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 47

ADDR   CODE       LINE  SOURCE

                  02760 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  02761 			; GNU General Public License for more details.
                  02762 			; 
                  02763 			; You should have received a copy of the GNU General Public License
                  02764 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  02765 			;
                  02766 			;#include "timer.h"
                  02767 			;#include "trace.h"
                  02768 			;
                  02769 			;bank3 struct CycleTimeBuffer g_CycleTimeBuffer;
                  02770 			;enum CYCLETIME_METHODE enumMethode;
                  02771 			;
                  02772 			;void Timer_Init()
                  02773 			;{	
                  02774 Timer_Init
                  02775 			;#ifdef __CC8E__
                  02776 			;	/*
                  02777 			;	 * T1 Interrupt every 10 Millisecounds if clock is 64MHz
                  02778 			;	 * Calculation
                  02779 			;	 * 64000000 Hz / 4 / 8 / 65536
                  02780 			;	 * T1 Interrupt occures with a frequency of 30 Hz.
                  02781 			;	 * This is used to update the ledstrip with the current colorvalue
                  02782 			;	 */
                  02783 			;	T1CON = 0b00100111;
000AE4 0E27       02784 	MOVLW 39
000AE6 6ECD       02785 	MOVWF T1CON,0
                  02786 			;	TMR1IE = TRUE;
000AE8 809D       02787 	BSF   0xF9D,TMR1IE,0
                  02788 			;	
                  02789 			;	/*
                  02790 			;	 * T5 Interrupt every 5 Millisecounds if clock is 64MHz
                  02791 			;	 * Calculation
                  02792 			;	 * 64000000 Hz / 8 / 40000
                  02793 			;	 */
                  02794 			;	T5CON = 0b01110111;
000AEA 0E77       02795 	MOVLW 119
000AEC 010F       02796 	MOVLB 15
000AEE 6F4E       02797 	MOVWF T5CON,1
                  02798 			;	TMR5IE = TRUE;
000AF0 827D       02799 	BSF   0xF7D,TMR5IE,0
                  02800 			;	TMR5H = 0x63;
000AF2 0E63       02801 	MOVLW 99
000AF4 6F50       02802 	MOVWF TMR5H,1
                  02803 			;	TMR5L = 0xC0;
000AF6 0EC0       02804 	MOVLW 192
000AF8 6F4F       02805 	MOVWF TMR5L,1
                  02806 			;	/* 
                  02807 			;	** T4 Interrupt every 4 Millisecound if clock is 64MHz
                  02808 			;	** Calculation
                  02809 			;	** 64000000 Hz / 4 / 16 / 250 / 16
                  02810 			;	*/
                  02811 			;	T4CON = 0b01111111;
000AFA 0E7F       02812 	MOVLW 127
000AFC 6F51       02813 	MOVWF T4CON,1
                  02814 			;	TMR4IE = FALSE;
000AFE 907D       02815 	BCF   0xF7D,TMR4IE,0
                  02816 			;	PR4 = 250;
000B00 0EFA       02817 	MOVLW 250
000B02 6F52       02818 	MOVWF PR4,1
                  02819 			;	
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 48

ADDR   CODE       LINE  SOURCE

                  02820 			;	/* 
                  02821 			;	** T2 Interrupt every 0.5 Millisecound if clock is 64MHz
                  02822 			;	** Calculation
                  02823 			;	** 64000000 Hz / 4 / 16 / 75 / 10
                  02824 			;	*/
                  02825 			;	T2CON = 0b01001111;
000B04 0E4F       02826 	MOVLW 79
000B06 6EBA       02827 	MOVWF T2CON,0
                  02828 			;	TMR2ON = 0;
000B08 94BA       02829 	BCF   0xFBA,TMR2ON,0
                  02830 			;	TMR2IE = 0;
000B0A 929D       02831 	BCF   0xF9D,TMR2IE,0
                  02832 			;	PR2 = 75;
000B0C 0E4B       02833 	MOVLW 75
000B0E 6EBB       02834 	MOVWF PR2,0
                  02835 			;	
                  02836 			;	/*
                  02837 			;	** T3 Modul count with a frequency of 2MHz
                  02838 			;	** T3 is used as PerformanceCounter
                  02839 			;	** Calculation:
                  02840 			;	** 64MHz / 4 / 8
                  02841 			;	*/
                  02842 			;	T3CON = 0b00110110;
000B10 0E36       02843 	MOVLW 54
000B12 6EB1       02844 	MOVWF T3CON,0
                  02845 			;	TMR3ON = 1;
000B14 80B1       02846 	BSF   0xFB1,TMR3ON,0
                  02847 			;#endif /* #ifdef __CC8E__ */
                  02848 			;}
000B16 0012       02849 	RETURN
                  02850 			;
                  02851 			;#ifdef DEBUG
                  02852 			;void Timer_StartStopwatch(const enum CYCLETIME_METHODE destMethode)
                  02853 			;{
                  02854 Timer_StartStopwatch
                  02855 			;	uns16 tempTime;
                  02856 			;
                  02857 			;	Platform_ReadPerformanceCounter(tempTime);
000B18 CFB2 F00B  02858 	MOVFF TMR3L,tempTime
000B1C CFB3 F00C  02859 	MOVFF TMR3H,tempTime+1
                  02860 			;	
                  02861 			;	g_CycleTimeBuffer.tempCycleTime[destMethode] = tempTime;
000B20 EE03 F018  02862 	LFSR  0,792 
000B24 90D8       02863 	BCF   0xFD8,Carry,0
000B26 340A       02864 	RLCF  destMethode,W,0
000B28 26E9       02865 	ADDWF FSR0,1,0
000B2A C00B FFEE  02866 	MOVFF tempTime,POSTINC0
000B2E C00C FFEE  02867 	MOVFF tempTime+1,POSTINC0
                  02868 			;}
000B32 0012       02869 	RETURN
                  02870 			;
                  02871 			;void Timer_StopStopwatch(const enum CYCLETIME_METHODE destMethode)
                  02872 			;{
                  02873 Timer_StopStopwatch
                  02874 			;	uns16 tempTime,temp16;
                  02875 			;	
                  02876 			;	Platform_ReadPerformanceCounter(tempTime);
000B34 CFB2 F00B  02877 	MOVFF TMR3L,tempTime_2
000B38 CFB3 F00C  02878 	MOVFF TMR3H,tempTime_2+1
                  02879 			;	
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 49

ADDR   CODE       LINE  SOURCE

                  02880 			;	if(g_CycleTimeBuffer.tempCycleTime[destMethode] < tempTime)
000B3C EE03 F018  02881 	LFSR  0,792 
000B40 90D8       02882 	BCF   0xFD8,Carry,0
000B42 340A       02883 	RLCF  destMethode_2,W,0
000B44 26E9       02884 	ADDWF FSR0,1,0
000B46 500B       02885 	MOVF  tempTime_2,W,0
000B48 5CEE       02886 	SUBWF POSTINC0,W,0
000B4A 500C       02887 	MOVF  tempTime_2+1,W,0
000B4C 58EF       02888 	SUBWFB INDF0,W,0
000B4E B0D8       02889 	BTFSC 0xFD8,Carry,0
000B50 D00A       02890 	BRA   m078
                  02891 			;	{
                  02892 			;		tempTime = tempTime - g_CycleTimeBuffer.tempCycleTime[destMethode];
000B52 EE03 F018  02893 	LFSR  0,792 
000B56 90D8       02894 	BCF   0xFD8,Carry,0
000B58 340A       02895 	RLCF  destMethode_2,W,0
000B5A 26E9       02896 	ADDWF FSR0,1,0
000B5C 50EE       02897 	MOVF  POSTINC0,W,0
000B5E 5E0B       02898 	SUBWF tempTime_2,1,0
000B60 50EF       02899 	MOVF  INDF0,W,0
000B62 5A0C       02900 	SUBWFB tempTime_2+1,1,0
                  02901 			;	}
                  02902 			;	else
000B64 D00D       02903 	BRA   m079
                  02904 			;	{
                  02905 			;		temp16 = 0xffff - g_CycleTimeBuffer.tempCycleTime[destMethode];
000B66 EE03 F018  02906 m078	LFSR  0,792 
000B6A 90D8       02907 	BCF   0xFD8,Carry,0
000B6C 340A       02908 	RLCF  destMethode_2,W,0
000B6E 26E9       02909 	ADDWF FSR0,1,0
000B70 1CEE       02910 	COMF  POSTINC0,W,0
000B72 6E0D       02911 	MOVWF temp16_2,0
000B74 1CEF       02912 	COMF  INDF0,W,0
000B76 6E0E       02913 	MOVWF temp16_2+1,0
                  02914 			;		tempTime += temp16;
000B78 500D       02915 	MOVF  temp16_2,W,0
000B7A 260B       02916 	ADDWF tempTime_2,1,0
000B7C 500E       02917 	MOVF  temp16_2+1,W,0
000B7E 220C       02918 	ADDWFC tempTime_2+1,1,0
                  02919 			;	}
                  02920 			;	
                  02921 			;	if(tempTime > g_CycleTimeBuffer.maxCycleTime[destMethode])
000B80 EE03 F000  02922 m079	LFSR  0,768 
000B84 90D8       02923 	BCF   0xFD8,Carry,0
000B86 340A       02924 	RLCF  destMethode_2,W,0
000B88 26E9       02925 	ADDWF FSR0,1,0
000B8A 500B       02926 	MOVF  tempTime_2,W,0
000B8C 5CEE       02927 	SUBWF POSTINC0,W,0
000B8E 500C       02928 	MOVF  tempTime_2+1,W,0
000B90 58EF       02929 	SUBWFB INDF0,W,0
000B92 B0D8       02930 	BTFSC 0xFD8,Carry,0
000B94 D009       02931 	BRA   m080
                  02932 			;	{
                  02933 			;		g_CycleTimeBuffer.maxCycleTime[destMethode] = tempTime;
000B96 EE03 F000  02934 	LFSR  0,768 
000B9A 90D8       02935 	BCF   0xFD8,Carry,0
000B9C 340A       02936 	RLCF  destMethode_2,W,0
000B9E 26E9       02937 	ADDWF FSR0,1,0
000BA0 C00B FFEE  02938 	MOVFF tempTime_2,POSTINC0
000BA4 C00C FFEE  02939 	MOVFF tempTime_2+1,POSTINC0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 50

ADDR   CODE       LINE  SOURCE

                  02940 			;	}
                  02941 			;	g_CycleTimeBuffer.tempCycleTime[destMethode] = 0;
000BA8 EE03 F018  02942 m080	LFSR  0,792 
000BAC 90D8       02943 	BCF   0xFD8,Carry,0
000BAE 340A       02944 	RLCF  destMethode_2,W,0
000BB0 26E9       02945 	ADDWF FSR0,1,0
000BB2 6AEE       02946 	CLRF  POSTINC0,0
000BB4 6AEF       02947 	CLRF  INDF0,0
                  02948 			;}
000BB6 0012       02949 	RETURN
                  02950 			;
                  02951 			;uns8 Timer_PrintCycletime(uns16 *pArray, const uns16 arraySize)
                  02952 			;{
                  02953 Timer_PrintCycletime
                  02954 			;	uns16 i, temp16;
                  02955 			;	for(i = 0; i < CYCLETIME_METHODE_ENUM_SIZE && i < arraySize; i++)
000BB8 6A15       02956 	CLRF  i_8,0
000BBA 6A16       02957 	CLRF  i_8+1,0
000BBC 5016       02958 m081	MOVF  i_8+1,W,0
000BBE A4D8       02959 	BTFSS 0xFD8,Zero_,0
000BC0 D036       02960 	BRA   m082
000BC2 0E0C       02961 	MOVLW 12
000BC4 6015       02962 	CPFSLT i_8,0
000BC6 D033       02963 	BRA   m082
000BC8 5013       02964 	MOVF  arraySize,W,0
000BCA 5C15       02965 	SUBWF i_8,W,0
000BCC 5014       02966 	MOVF  arraySize+1,W,0
000BCE 5816       02967 	SUBWFB i_8+1,W,0
000BD0 B0D8       02968 	BTFSC 0xFD8,Carry,0
000BD2 D02D       02969 	BRA   m082
                  02970 			;	{
                  02971 			;		temp16 = g_CycleTimeBuffer.maxCycleTime[i];
000BD4 90D8       02972 	BCF   0xFD8,Carry,0
000BD6 3415       02973 	RLCF  i_8,W,0
000BD8 6EE9       02974 	MOVWF FSR0,0
000BDA 3416       02975 	RLCF  i_8+1,W,0
000BDC 6EEA       02976 	MOVWF FSR0+1,0
000BDE 0E03       02977 	MOVLW 3
000BE0 26EA       02978 	ADDWF FSR0+1,1,0
000BE2 CFEE F017  02979 	MOVFF POSTINC0,temp16_3
000BE6 CFEE F018  02980 	MOVFF POSTINC0,temp16_3+1
                  02981 			;		temp16 = htons(temp16);
000BEA C017 F019  02982 	MOVFF temp16_3,hostShort
000BEE C018 F01A  02983 	MOVFF temp16_3+1,hostShort+1
000BF2 DAA6       02984 	RCALL htons
000BF4 C01B F017  02985 	MOVFF retval,temp16_3
000BF8 C01C F018  02986 	MOVFF retval+1,temp16_3+1
                  02987 			;		*pArray = temp16;
000BFC C011 FFE9  02988 	MOVFF pArray,FSR0
000C00 C012 FFEA  02989 	MOVFF pArray+1,FSR0+1
000C04 C017 FFEE  02990 	MOVFF temp16_3,POSTINC0
000C08 C018 FFEE  02991 	MOVFF temp16_3+1,POSTINC0
                  02992 			;		pArray++;
000C0C 0E02       02993 	MOVLW 2
000C0E 2611       02994 	ADDWF pArray,1,0
000C10 0E00       02995 	MOVLW 0
000C12 2212       02996 	ADDWFC pArray+1,1,0
                  02997 			;		g_CycleTimeBuffer.maxCycleTime[i] = 0;
000C14 90D8       02998 	BCF   0xFD8,Carry,0
000C16 3415       02999 	RLCF  i_8,W,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 51

ADDR   CODE       LINE  SOURCE

000C18 6EE9       03000 	MOVWF FSR0,0
000C1A 3416       03001 	RLCF  i_8+1,W,0
000C1C 6EEA       03002 	MOVWF FSR0+1,0
000C1E 0E03       03003 	MOVLW 3
000C20 26EA       03004 	ADDWF FSR0+1,1,0
000C22 6AEE       03005 	CLRF  POSTINC0,0
000C24 6AEF       03006 	CLRF  INDF0,0
                  03007 			;	}
000C26 2A15       03008 	INCF  i_8,1,0
000C28 0E00       03009 	MOVLW 0
000C2A 2216       03010 	ADDWFC i_8+1,1,0
000C2C D7C7       03011 	BRA   m081
                  03012 			;	return i + i;
000C2E 5015       03013 m082	MOVF  i_8,W,0
000C30 2415       03014 	ADDWF i_8,W,0
000C32 0012       03015 	RETURN
                  03016 
                  03017   ; FILE RingBuf.c
                  03018 			;/**
                  03019 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  03020 			; 
                  03021 			; This file is part of Wifly_Light.
                  03022 			; 
                  03023 			; Wifly_Light is free software: you can redistribute it and/or modify
                  03024 			; it under the terms of the GNU General Public License as published by
                  03025 			; the Free Software Foundation, either version 3 of the License, or
                  03026 			; (at your option) any later version.
                  03027 			; 
                  03028 			; Wifly_Light is distributed in the hope that it will be useful,
                  03029 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  03030 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  03031 			; GNU General Public License for more details.
                  03032 			; 
                  03033 			; You should have received a copy of the GNU General Public License
                  03034 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  03035 			;
                  03036 			;#include "RingBuf.h"
                  03037 			;
                  03038 			;bank7 struct RingBuffer g_RingBuf;
                  03039 			;
                  03040 			;void RingBuf_Init(struct RingBuffer *pBuf)
                  03041 			;{
                  03042 RingBuf_Init
                  03043 			;	pBuf->read = 0;
000C34 500B       03044 	MOVF  pBuf,W,0
000C36 6EE9       03045 	MOVWF FSR0,0
000C38 280C       03046 	INCF  pBuf+1,W,0
000C3A 6EEA       03047 	MOVWF FSR0+1,0
000C3C 6AEF       03048 	CLRF  INDF0,0
                  03049 			;	pBuf->write = 0;
000C3E 280B       03050 	INCF  pBuf,W,0
000C40 6EE9       03051 	MOVWF FSR0,0
000C42 0E01       03052 	MOVLW 1
000C44 200C       03053 	ADDWFC pBuf+1,W,0
000C46 6EEA       03054 	MOVWF FSR0+1,0
000C48 6AEF       03055 	CLRF  INDF0,0
                  03056 			;	pBuf->error_full = 0;
000C4A 0E02       03057 	MOVLW 2
000C4C 240B       03058 	ADDWF pBuf,W,0
000C4E 6EE9       03059 	MOVWF FSR0,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 52

ADDR   CODE       LINE  SOURCE

000C50 0E01       03060 	MOVLW 1
000C52 200C       03061 	ADDWFC pBuf+1,W,0
000C54 6EEA       03062 	MOVWF FSR0+1,0
000C56 90EF       03063 	BCF   INDF0,0,0
                  03064 			;}
000C58 0012       03065 	RETURN
                  03066 			;
                  03067 			;uns8 RingBuf_Get(struct RingBuffer *pBuf)
                  03068 			;{
                  03069 RingBuf_Get
                  03070 			;	//Platform_DisableAllInterrupts();
                  03071 			;	uns8 read = pBuf->read;
000C5A 5018       03072 	MOVF  pBuf_2,W,0
000C5C 6EE9       03073 	MOVWF FSR0,0
000C5E 2819       03074 	INCF  pBuf_2+1,W,0
000C60 6EEA       03075 	MOVWF FSR0+1,0
000C62 CFEF F01A  03076 	MOVFF INDF0,read
                  03077 			;	uns8 result = pBuf->data[read];
000C66 501A       03078 	MOVF  read,W,0
000C68 2418       03079 	ADDWF pBuf_2,W,0
000C6A 6EE9       03080 	MOVWF FSR0,0
000C6C 0E00       03081 	MOVLW 0
000C6E 2019       03082 	ADDWFC pBuf_2+1,W,0
000C70 6EEA       03083 	MOVWF FSR0+1,0
000C72 CFEF F01B  03084 	MOVFF INDF0,result
                  03085 			;	pBuf->read = RingBufInc(read);
000C76 5018       03086 	MOVF  pBuf_2,W,0
000C78 6EE9       03087 	MOVWF FSR0,0
000C7A 2819       03088 	INCF  pBuf_2+1,W,0
000C7C 6EEA       03089 	MOVWF FSR0+1,0
000C7E 281A       03090 	INCF  read,W,0
000C80 6EEF       03091 	MOVWF INDF0,0
                  03092 			;	
                  03093 			;	//TODO make this thread safe or remove flag!
                  03094 			;	pBuf->error_full = FALSE;
000C82 0E02       03095 	MOVLW 2
000C84 2418       03096 	ADDWF pBuf_2,W,0
000C86 6EE9       03097 	MOVWF FSR0,0
000C88 0E01       03098 	MOVLW 1
000C8A 2019       03099 	ADDWFC pBuf_2+1,W,0
000C8C 6EEA       03100 	MOVWF FSR0+1,0
000C8E 90EF       03101 	BCF   INDF0,0,0
                  03102 			;	//Platform_EnableAllInterrupts();
                  03103 			;	return result;
000C90 501B       03104 	MOVF  result,W,0
000C92 0012       03105 	RETURN
                  03106 			;}
                  03107 			;
                  03108 			;void RingBuf_Put(struct RingBuffer *pBuf,const uns8 value)
                  03109 			;{
                  03110 RingBuf_Put
                  03111 			;	//Platform_DisableAllInterrupts();
                  03112 			;	uns8 writeNext = RingBufInc(pBuf->write);
000C94 2802       03113 	INCF  pBuf_3,W,0
000C96 6EE9       03114 	MOVWF FSR0,0
000C98 0E01       03115 	MOVLW 1
000C9A 2003       03116 	ADDWFC pBuf_3+1,W,0
000C9C 6EEA       03117 	MOVWF FSR0+1,0
000C9E 28EF       03118 	INCF  INDF0,W,0
000CA0 6E05       03119 	MOVWF writeNext,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 53

ADDR   CODE       LINE  SOURCE

                  03120 			;	if(writeNext != pBuf->read)
000CA2 5002       03121 	MOVF  pBuf_3,W,0
000CA4 6EE9       03122 	MOVWF FSR0,0
000CA6 2803       03123 	INCF  pBuf_3+1,W,0
000CA8 6EEA       03124 	MOVWF FSR0+1,0
000CAA 5005       03125 	MOVF  writeNext,W,0
000CAC 18EF       03126 	XORWF INDF0,W,0
000CAE B4D8       03127 	BTFSC 0xFD8,Zero_,0
000CB0 D017       03128 	BRA   m083
                  03129 			;	{
                  03130 			;		uns8 write = pBuf->write;
000CB2 2802       03131 	INCF  pBuf_3,W,0
000CB4 6EE9       03132 	MOVWF FSR0,0
000CB6 0E01       03133 	MOVLW 1
000CB8 2003       03134 	ADDWFC pBuf_3+1,W,0
000CBA 6EEA       03135 	MOVWF FSR0+1,0
000CBC CFEF F006  03136 	MOVFF INDF0,write
                  03137 			;		pBuf->data[write] = value;
000CC0 5006       03138 	MOVF  write,W,0
000CC2 2402       03139 	ADDWF pBuf_3,W,0
000CC4 6EE9       03140 	MOVWF FSR0,0
000CC6 0E00       03141 	MOVLW 0
000CC8 2003       03142 	ADDWFC pBuf_3+1,W,0
000CCA 6EEA       03143 	MOVWF FSR0+1,0
000CCC C004 FFEF  03144 	MOVFF value,INDF0
                  03145 			;		pBuf->write = writeNext;
000CD0 2802       03146 	INCF  pBuf_3,W,0
000CD2 6EE9       03147 	MOVWF FSR0,0
000CD4 0E01       03148 	MOVLW 1
000CD6 2003       03149 	ADDWFC pBuf_3+1,W,0
000CD8 6EEA       03150 	MOVWF FSR0+1,0
000CDA C005 FFEF  03151 	MOVFF writeNext,INDF0
                  03152 			;	}
                  03153 			;	else pBuf->error_full = 1;
000CDE D007       03154 	BRA   m084
000CE0 0E02       03155 m083	MOVLW 2
000CE2 2402       03156 	ADDWF pBuf_3,W,0
000CE4 6EE9       03157 	MOVWF FSR0,0
000CE6 0E01       03158 	MOVLW 1
000CE8 2003       03159 	ADDWFC pBuf_3+1,W,0
000CEA 6EEA       03160 	MOVWF FSR0+1,0
000CEC 80EF       03161 	BSF   INDF0,0,0
                  03162 			;	//Platform_EnableAllInterrupts();
                  03163 			;}
000CEE 0012       03164 m084	RETURN
                  03165 			;
                  03166 			;bit RingBuf_HasError(struct RingBuffer *pBuf)
                  03167 			;{
                  03168 RingBuf_HasError
                  03169 			;	return pBuf->error_full;
000CF0 0E02       03170 	MOVLW 2
000CF2 2402       03171 	ADDWF pBuf_4,W,0
000CF4 6EE9       03172 	MOVWF FSR0,0
000CF6 0E01       03173 	MOVLW 1
000CF8 2003       03174 	ADDWFC pBuf_4+1,W,0
000CFA 6EEA       03175 	MOVWF FSR0+1,0
000CFC 90D8       03176 	BCF   0xFD8,Carry,0
000CFE B0EF       03177 	BTFSC INDF0,0,0
000D00 80D8       03178 	BSF   0xFD8,Carry,0
000D02 0012       03179 	RETURN
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 54

ADDR   CODE       LINE  SOURCE

                  03180 			;}
                  03181 			;
                  03182 			;bit RingBuf_IsEmpty(const struct RingBuffer *pBuf)
                  03183 			;{
                  03184 RingBuf_IsEmpty
                  03185 			;	//Platform_DisableAllInterrupts();
                  03186 			;	uns8 write = pBuf->write;
000D04 2818       03187 	INCF  pBuf_5,W,0
000D06 6E1C       03188 	MOVWF ci_2,0
000D08 0E01       03189 	MOVLW 1
000D0A 2019       03190 	ADDWFC pBuf_5+1,W,0
000D0C 6E1D       03191 	MOVWF ci_2+1,0
000D0E EC16 F00D  03192 	CALL  _const2
000D12 6E1A       03193 	MOVWF write_2,0
                  03194 			;	uns8 read = pBuf->read;
000D14 5018       03195 	MOVF  pBuf_5,W,0
000D16 6E1C       03196 	MOVWF ci_2,0
000D18 2819       03197 	INCF  pBuf_5+1,W,0
000D1A 6E1D       03198 	MOVWF ci_2+1,0
000D1C EC16 F00D  03199 	CALL  _const2
000D20 6E1B       03200 	MOVWF read_2,0
                  03201 			;	//Platform_EnableAllInterrupts();
                  03202 			;	return write == read;
000D22 90D8       03203 	BCF   0xFD8,Carry,0
000D24 501A       03204 	MOVF  write_2,W,0
000D26 621B       03205 	CPFSEQ read_2,0
000D28 D001       03206 	BRA   m085
000D2A 80D8       03207 	BSF   0xFD8,Carry,0
000D2C 0012       03208 m085	RETURN
                  03209 
                  03210   ; FILE usart.c
                  03211 			;/**
                  03212 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  03213 			; 
                  03214 			; This file is part of Wifly_Light.
                  03215 			; 
                  03216 			; Wifly_Light is free software: you can redistribute it and/or modify
                  03217 			; it under the terms of the GNU General Public License as published by
                  03218 			; the Free Software Foundation, either version 3 of the License, or
                  03219 			; (at your option) any later version.
                  03220 			; 
                  03221 			; Wifly_Light is distributed in the hope that it will be useful,
                  03222 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  03223 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  03224 			; GNU General Public License for more details.
                  03225 			; 
                  03226 			; You should have received a copy of the GNU General Public License
                  03227 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  03228 			;
                  03229 			;#include "usart.h"
                  03230 			;
                  03231 			;#ifdef __CC8E__
                  03232 			;//*******  Initialisierungs-Funktion  *************************************************
                  03233 			;void UART_Init()
                  03234 			;{
                  03235 UART_Init
                  03236 			;	//USART TX Pin als Ausgang
                  03237 			;	TRISC.6 = 0;
000D2E 9C94       03238 	BCF   TRISC,6,0
                  03239 			;	BRGH1=1;					// High Baudrate activated
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 55

ADDR   CODE       LINE  SOURCE

000D30 84AC       03240 	BSF   0xFAC,BRGH1,0
                  03241 			;	BRG16=1;
000D32 86B8       03242 	BSF   0xFB8,BRG16,0
                  03243 			;	SPBRG1=34;				// 115200 Bps @ 64 MHz Clock
000D34 0E22       03244 	MOVLW 34
000D36 6EAF       03245 	MOVWF SPBRG1,0
                  03246 			;	SPBRGH1=0;
000D38 6AB0       03247 	CLRF  SPBRGH1,0
                  03248 			;	SPEN1 = 1;               // Set_Serial_Pins;
000D3A 8EAB       03249 	BSF   0xFAB,SPEN1,0
                  03250 			;	SYNC1 = 0;               // Set_Async_Mode;
000D3C 98AC       03251 	BCF   0xFAC,SYNC1,0
                  03252 			;	TX9_1 = 0;                // Set_8bit_Tx;
000D3E 9CAC       03253 	BCF   0xFAC,TX9_1,0
                  03254 			;	RX9_1 = 0;                // Set_8bit_Rx;
000D40 9CAB       03255 	BCF   0xFAB,RX9_1,0
                  03256 			;	CREN1 = 1;               // Enable_Rx;
000D42 88AB       03257 	BSF   0xFAB,CREN1,0
                  03258 			;	TXEN1 = 1;               // Enable_Tx;
000D44 8AAC       03259 	BSF   0xFAC,TXEN1,0
                  03260 			;	RC1IE=1;                 // Rx Interrupt aus
000D46 8A9D       03261 	BSF   0xF9D,RC1IE,0
                  03262 			;	ADDEN1=0;				// Disable Adressdetection
000D48 96AB       03263 	BCF   0xFAB,ADDEN1,0
                  03264 			;}
000D4A 0012       03265 	RETURN
                  03266 			;
                  03267 			;//*******  Sende-char-Funktion  *************************************************
                  03268 			;void UART_Send(const uns8 ch)
                  03269 			;{
                  03270 UART_Send
                  03271 			;	while(!TX1IF);
000D4C A89E       03272 m086	BTFSS 0xF9E,TX1IF,0
000D4E D7FE       03273 	BRA   m086
                  03274 			;	TXREG1=ch;
000D50 C015 FFAD  03275 	MOVFF ch,TXREG1
                  03276 			;}
000D54 0012       03277 	RETURN
                  03278 
                  03279   ; FILE CommandIO.c
                  03280 			;/**
                  03281 			; Copyright (C) 2012 Nils Weiss, Patrick BrÃ¼nn.
                  03282 			; 
                  03283 			; This file is part of Wifly_Light.
                  03284 			; 
                  03285 			; Wifly_Light is free software: you can redistribute it and/or modify
                  03286 			; it under the terms of the GNU General Public License as published by
                  03287 			; the Free Software Foundation, either version 3 of the License, or
                  03288 			; (at your option) any later version.
                  03289 			; 
                  03290 			; Wifly_Light is distributed in the hope that it will be useful,
                  03291 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  03292 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  03293 			; GNU General Public License for more details.
                  03294 			; 
                  03295 			; You should have received a copy of the GNU General Public License
                  03296 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  03297 			;
                  03298 			;#include "CommandIO.h"
                  03299 			;#include "ScriptCtrl.h"
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 56

ADDR   CODE       LINE  SOURCE

                  03300 			;#include "trace.h"
                  03301 			;#include "usart.h"
                  03302 			;#include "RingBuf.h"
                  03303 			;#include "crc.h"
                  03304 			;#include "error.h"
                  03305 			;#include "wifly_cmd.h"
                  03306 			;#include "rtc.h"
                  03307 			;
                  03308 			;bank2 struct CommandBuffer g_CmdBuf;
                  03309 			;struct response_frame g_ResponseBuf;
                  03310 			;
                  03311 			;
                  03312 			;/** PRIVATE METHODE **/
                  03313 			;
                  03314 			;void writeByte(uns8 byte)
                  03315 			;{
                  03316 writeByte
000D56 6E0B       03317 	MOVWF byte_4,0
                  03318 			;    if(g_CmdBuf.counter < (uns16)CMDFRAMELENGTH)
000D58 0102       03319 	MOVLB 2
000D5A 51DB       03320 	MOVF  g_CmdBuf+219,W,1
000D5C A4D8       03321 	BTFSS 0xFD8,Zero_,0
000D5E D01A       03322 	BRA   m087
000D60 0EDA       03323 	MOVLW 218
000D62 61DA       03324 	CPFSLT g_CmdBuf+218,1
000D64 D017       03325 	BRA   m087
                  03326 			;    {
                  03327 			;	  g_CmdBuf.buffer[g_CmdBuf.counter] = byte;
000D66 51DA       03328 	MOVF  g_CmdBuf+218,W,1
000D68 6EE9       03329 	MOVWF FSR0,0
000D6A 0E02       03330 	MOVLW 2
000D6C 25DB       03331 	ADDWF g_CmdBuf+219,W,1
000D6E 6EEA       03332 	MOVWF FSR0+1,0
000D70 C00B FFEF  03333 	MOVFF byte_4,INDF0
                  03334 			;	  g_CmdBuf.counter++;
000D74 2BDA       03335 	INCF  g_CmdBuf+218,1,1
000D76 0E00       03336 	MOVLW 0
000D78 23DB       03337 	ADDWFC g_CmdBuf+219,1,1
                  03338 			;	  Crc_AddCrc(byte, &g_CmdBuf.CrcH, &g_CmdBuf.CrcL);		
000D7A C00B F015  03339 	MOVFF byte_4,byte
000D7E 0EDD       03340 	MOVLW 221
000D80 6E16       03341 	MOVWF p_crcH,0
000D82 0E02       03342 	MOVLW 2
000D84 6E17       03343 	MOVWF p_crcH+1,0
000D86 0EDE       03344 	MOVLW 222
000D88 6E18       03345 	MOVWF p_crcL,0
000D8A 0E02       03346 	MOVLW 2
000D8C 6E19       03347 	MOVWF p_crcL+1,0
000D8E ECCC F000  03348 	CALL  Crc_AddCrc
                  03349 			;    }
                  03350 			;    else
000D92 D00C       03351 	BRA   m088
                  03352 			;    {
                  03353 			;		g_ErrorBits.CmdBufOverflow = TRUE;
000D94 842B       03354 m087	BSF   g_ErrorBits,2,0
                  03355 			;		Trace_Hex16(g_CmdBuf.counter);
000D96 C2DA F00C  03356 	MOVFF g_CmdBuf+218,input_4
000D9A C2DB F00D  03357 	MOVFF g_CmdBuf+219,input_4+1
000D9E ECE9 F00C  03358 	CALL  Trace_Hex16
                  03359 			;		Trace_String(" cntr");
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 57

ADDR   CODE       LINE  SOURCE

000DA2 0E9D       03360 	MOVLW 157
000DA4 6E0E       03361 	MOVWF string,0
000DA6 6A0F       03362 	CLRF  string+1,0
000DA8 EF51 F00C  03363 	GOTO  Trace_String
                  03364 			;    }
                  03365 			;}
000DAC 0012       03366 m088	RETURN
                  03367 			;
                  03368 			;void DeleteBuffer()
                  03369 			;{
                  03370 DeleteBuffer
                  03371 			;    g_CmdBuf.counter = 0;
000DAE 0102       03372 	MOVLB 2
000DB0 6BDA       03373 	CLRF  g_CmdBuf+218,1
000DB2 6BDB       03374 	CLRF  g_CmdBuf+219,1
                  03375 			;    Crc_NewCrc(&g_CmdBuf.CrcH, &g_CmdBuf.CrcL);
000DB4 0EDD       03376 	MOVLW 221
000DB6 6E15       03377 	MOVWF p_crcH_2,0
000DB8 0E02       03378 	MOVLW 2
000DBA 6E16       03379 	MOVWF p_crcH_2+1,0
000DBC 0EDE       03380 	MOVLW 222
000DBE 6E17       03381 	MOVWF p_crcL_2,0
000DC0 0E02       03382 	MOVLW 2
000DC2 6E18       03383 	MOVWF p_crcL_2+1,0
000DC4 EF2C F001  03384 	GOTO  Crc_NewCrc
                  03385 			;}
                  03386 			;
                  03387 			;
                  03388 			;void CommandIO_Init()
                  03389 			;{ 
                  03390 CommandIO_Init
                  03391 			;    g_CmdBuf.state = CS_WaitForSTX;
000DC8 0102       03392 	MOVLB 2
000DCA 6BDC       03393 	CLRF  g_CmdBuf+220,1
                  03394 			;    DeleteBuffer();
000DCC D7F0       03395 	BRA   DeleteBuffer
                  03396 			;}
                  03397 			;
                  03398 			;
                  03399 			;
                  03400 			;/** STATEMACHINE FOR GetCommands:
                  03401 			; * All ASCII-Chars are seperatet in 4 Groups
                  03402 			; * 	Group1: STX
                  03403 			; * 	Group2: ETX
                  03404 			; * 	Group3: DLE
                  03405 			; * 	Group4: All Elements of ASCII-Table without STX,ETX,DLE. I will call it CHAR in further description
                  03406 			; * 
                  03407 			; * The Statemachine has 4 different states
                  03408 			; * 	state 0: Wait for STX 		--> representet from CS_WaitForSTX
                  03409 			; * 		read DLE or ETX or CHAR 	--> new state = state 0 (nothing happens)
                  03410 			; *		read STX			--> new state = state 1
                  03411 			; * 	
                  03412 			; * 	state 1: Delete commandbuffer 	--> representet from CS_DeleteBuffer
                  03413 			; * 		read STX			--> new state = state 1 (nothing happens)
                  03414 			; * 		read ETX			--> new state = state 0
                  03415 			; * 		read DLE			--> new state = state 2
                  03416 			; * 		read CHAR			--> new state = state 3, save CHAR to commandbuffer, increment counter
                  03417 			; * 
                  03418 			; * 	state 2: Read mask character	--> representet from CS_UnMaskChar
                  03419 			; * 		read STX or ETX or DLE or CHAR	--> new state = state 3, save byte to commandbuffer, increment counter
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 58

ADDR   CODE       LINE  SOURCE

                  03420 			; * 
                  03421 			; * 	state 3: Save Char 		--> representet from CS_SaveChar
                  03422 			; * 		read CHAR			--> new state = state 3, save CHAR to commandbuffer, increment counter
                  03423 			; * 		read DLE			--> new state = state 2
                  03424 			; * 		read STX			--> new state = state 1
                  03425 			; * 		read ETX			--> new state = state 0, do CRC-check, save dataframe 
                  03426 			; * 
                  03427 			; * **/
                  03428 			;
                  03429 			;void CommandIO_GetCommands()
                  03430 			;{	
                  03431 CommandIO_GetCommands
                  03432 			;	if(g_ErrorBits.CmdBufOverflow)
000DCE B42B       03433 	BTFSC g_ErrorBits,2,0
                  03434 			;	{
                  03435 			;		return;
000DD0 0012       03436 	RETURN
                  03437 			;	}
                  03438 			;  
                  03439 			;	if(RingBuf_HasError(&g_RingBuf))
000DD2 6A02       03440 	CLRF  pBuf_4,0
000DD4 0E07       03441 	MOVLW 7
000DD6 6E03       03442 	MOVWF pBuf_4+1,0
000DD8 DF8B       03443 	RCALL RingBuf_HasError
000DDA B0D8       03444 	BTFSC 0xFD8,Carry,0
                  03445 			;	{
                  03446 			;		// *** if a RingBufError occure, I have to throw away the current command,
                  03447 			;		// *** because the last byte was not saved. Commandstring is inconsistent
                  03448 			;		return;
000DDC 0012       03449 	RETURN
                  03450 			;	}
                  03451 			;	
                  03452 			;	if(RingBuf_IsEmpty(&g_RingBuf))
000DDE 6A18       03453 	CLRF  pBuf_5,0
000DE0 0E07       03454 	MOVLW 7
000DE2 6E19       03455 	MOVWF pBuf_5+1,0
000DE4 DF8F       03456 	RCALL RingBuf_IsEmpty
000DE6 B0D8       03457 	BTFSC 0xFD8,Carry,0
                  03458 			;	{
                  03459 			;		return;
000DE8 0012       03460 	RETURN
                  03461 			;	}
                  03462 			;	
                  03463 			;	// *** get new_byte from ringbuffer
                  03464 			;	uns8 new_byte = RingBuf_Get(&g_RingBuf);
000DEA 6A18       03465 	CLRF  pBuf_2,0
000DEC 0E07       03466 	MOVLW 7
000DEE 6E19       03467 	MOVWF pBuf_2+1,0
000DF0 DF34       03468 	RCALL RingBuf_Get
000DF2 6E0A       03469 	MOVWF new_byte,0
                  03470 			;	switch(g_CmdBuf.state)
000DF4 0102       03471 	MOVLB 2
000DF6 51DC       03472 	MOVF  g_CmdBuf+220,W,1
000DF8 B4D8       03473 	BTFSC 0xFD8,Zero_,0
000DFA D00A       03474 	BRA   m089
000DFC 0A01       03475 	XORLW 1
000DFE B4D8       03476 	BTFSC 0xFD8,Zero_,0
000E00 D00E       03477 	BRA   m090
000E02 0A03       03478 	XORLW 3
000E04 B4D8       03479 	BTFSC 0xFD8,Zero_,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 59

ADDR   CODE       LINE  SOURCE

000E06 D023       03480 	BRA   m094
000E08 0A01       03481 	XORLW 1
000E0A B4D8       03482 	BTFSC 0xFD8,Zero_,0
000E0C D026       03483 	BRA   m095
000E0E D07F       03484 	BRA   m101
                  03485 			;	{
                  03486 			;	  case CS_WaitForSTX:
                  03487 			;	  {
                  03488 			;	      if(new_byte == STX)
000E10 0E0F       03489 m089	MOVLW 15
000E12 620A       03490 	CPFSEQ new_byte,0
000E14 D07C       03491 	BRA   m101
                  03492 			;	      {
                  03493 			;					g_CmdBuf.state = CS_DeleteBuffer;
000E16 0E01       03494 	MOVLW 1
000E18 0102       03495 	MOVLB 2
000E1A 6FDC       03496 	MOVWF g_CmdBuf+220,1
                  03497 			;	      }
                  03498 			;	      break;
000E1C D078       03499 	BRA   m101
                  03500 			;	  }
                  03501 			;	  case CS_DeleteBuffer:
                  03502 			;	  {
                  03503 			;	      DeleteBuffer();
000E1E DFC7       03504 m090	RCALL DeleteBuffer
                  03505 			;	      
                  03506 			;	      if(new_byte == STX)
000E20 0E0F       03507 	MOVLW 15
000E22 620A       03508 	CPFSEQ new_byte,0
000E24 D001       03509 	BRA   m091
                  03510 			;	      {
                  03511 			;		  break;
000E26 D073       03512 	BRA   m101
                  03513 			;	      }
                  03514 			;	      
                  03515 			;	      if(new_byte == ETX)
000E28 0E04       03516 m091	MOVLW 4
000E2A 620A       03517 	CPFSEQ new_byte,0
000E2C D003       03518 	BRA   m092
                  03519 			;	      {
                  03520 			;		  g_CmdBuf.state = CS_WaitForSTX;
000E2E 0102       03521 	MOVLB 2
000E30 6BDC       03522 	CLRF  g_CmdBuf+220,1
                  03523 			;		  break;
000E32 D06D       03524 	BRA   m101
                  03525 			;	      }
                  03526 			;	      
                  03527 			;	      if(new_byte == DLE)
000E34 0E05       03528 m092	MOVLW 5
000E36 620A       03529 	CPFSEQ new_byte,0
000E38 D004       03530 	BRA   m093
                  03531 			;	      {
                  03532 			;		  g_CmdBuf.state = CS_UnMaskChar;
000E3A 0E02       03533 	MOVLW 2
000E3C 0102       03534 	MOVLB 2
000E3E 6FDC       03535 	MOVWF g_CmdBuf+220,1
                  03536 			;		  break;
000E40 D066       03537 	BRA   m101
                  03538 			;	      }
                  03539 			;	      
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 60

ADDR   CODE       LINE  SOURCE

                  03540 			;	      writeByte(new_byte);
000E42 500A       03541 m093	MOVF  new_byte,W,0
000E44 DF88       03542 	RCALL writeByte
                  03543 			;	      g_CmdBuf.state = CS_SaveChar;
000E46 0E03       03544 	MOVLW 3
000E48 0102       03545 	MOVLB 2
000E4A 6FDC       03546 	MOVWF g_CmdBuf+220,1
                  03547 			;	      break;
000E4C D060       03548 	BRA   m101
                  03549 			;	  }
                  03550 			;	  case CS_UnMaskChar:
                  03551 			;	  {
                  03552 			;	      writeByte(new_byte);
000E4E 500A       03553 m094	MOVF  new_byte,W,0
000E50 DF82       03554 	RCALL writeByte
                  03555 			;	      g_CmdBuf.state = CS_SaveChar;
000E52 0E03       03556 	MOVLW 3
000E54 0102       03557 	MOVLB 2
000E56 6FDC       03558 	MOVWF g_CmdBuf+220,1
                  03559 			;	      break;
000E58 D05A       03560 	BRA   m101
                  03561 			;	  }
                  03562 			;	  case CS_SaveChar:
                  03563 			;	  {
                  03564 			;	      if(new_byte == DLE)
000E5A 0E05       03565 m095	MOVLW 5
000E5C 620A       03566 	CPFSEQ new_byte,0
000E5E D004       03567 	BRA   m096
                  03568 			;	      {
                  03569 			;			  g_CmdBuf.state = CS_UnMaskChar;
000E60 0E02       03570 	MOVLW 2
000E62 0102       03571 	MOVLB 2
000E64 6FDC       03572 	MOVWF g_CmdBuf+220,1
                  03573 			;			  break;
000E66 D053       03574 	BRA   m101
                  03575 			;	      }
                  03576 			;	      if(new_byte == STX)
000E68 0E0F       03577 m096	MOVLW 15
000E6A 620A       03578 	CPFSEQ new_byte,0
000E6C D004       03579 	BRA   m097
                  03580 			;	      {
                  03581 			;			  g_CmdBuf.state = CS_DeleteBuffer;
000E6E 0E01       03582 	MOVLW 1
000E70 0102       03583 	MOVLB 2
000E72 6FDC       03584 	MOVWF g_CmdBuf+220,1
                  03585 			;			  break;
000E74 D04C       03586 	BRA   m101
                  03587 			;	      }
                  03588 			;	      if(new_byte == ETX)
000E76 0E04       03589 m097	MOVLW 4
000E78 620A       03590 	CPFSEQ new_byte,0
000E7A D047       03591 	BRA   m100
                  03592 			;		  {
                  03593 			;			g_CmdBuf.state = CS_WaitForSTX;
000E7C 0102       03594 	MOVLB 2
000E7E 6BDC       03595 	CLRF  g_CmdBuf+220,1
                  03596 			;
                  03597 			;			  if((0 == g_CmdBuf.CrcL) && (0 == g_CmdBuf.CrcH)) 	/* CRC Check */
000E80 53DE       03598 	MOVF  g_CmdBuf+222,1,1
000E82 A4D8       03599 	BTFSS 0xFD8,Zero_,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 61

ADDR   CODE       LINE  SOURCE

000E84 D00B       03600 	BRA   m098
000E86 53DD       03601 	MOVF  g_CmdBuf+221,1,1
000E88 A4D8       03602 	BTFSS 0xFD8,Zero_,0
000E8A D008       03603 	BRA   m098
                  03604 			;			  {
                  03605 			;				  // [0] contains cmd_frame->length so we send [1]
                  03606 			;#ifndef __CC8E__
                  03607 			;					if(!ScriptCtrl_Add((struct led_cmd*)&g_CmdBuf.buffer[1]))
                  03608 			;#else
                  03609 			;					if(!ScriptCtrl_Add(&g_CmdBuf.buffer[1]))
000E8C 0E01       03610 	MOVLW 1
000E8E 6E0B       03611 	MOVWF pCmd_2,0
000E90 DAE1       03612 	RCALL ScriptCtrl_Add
000E92 0A00       03613 	XORLW 0
000E94 A4D8       03614 	BTFSS 0xFD8,Zero_,0
000E96 D02D       03615 	BRA   m099
                  03616 			;#endif
                  03617 			;					{
                  03618 			;						g_ErrorBits.EepromFailure = 1;
000E98 822B       03619 	BSF   g_ErrorBits,1,0
                  03620 			;					}
                  03621 			;			  }
                  03622 			;			  else
000E9A D02B       03623 	BRA   m099
                  03624 			;			  {
                  03625 			;				  g_ErrorBits.CrcFailure = 1;
000E9C 802B       03626 m098	BSF   g_ErrorBits,0,0
                  03627 			;				  Trace_String("Crc error: ");
000E9E 0EA3       03628 	MOVLW 163
000EA0 6E0E       03629 	MOVWF string,0
000EA2 6A0F       03630 	CLRF  string+1,0
000EA4 EC51 F00C  03631 	CALL  Trace_String
                  03632 			;				  Trace_Hex(g_CmdBuf.CrcL);
000EA8 C2DE F00E  03633 	MOVFF g_CmdBuf+222,input_3
000EAC ECBB F00C  03634 	CALL  Trace_Hex
                  03635 			;				  Trace_Hex(g_CmdBuf.CrcH);
000EB0 C2DD F00E  03636 	MOVFF g_CmdBuf+221,input_3
000EB4 ECBB F00C  03637 	CALL  Trace_Hex
                  03638 			;				  Trace_Hex(g_CmdBuf.buffer[g_CmdBuf.counter - 2]);
000EB8 0E02       03639 	MOVLW 2
000EBA 0102       03640 	MOVLB 2
000EBC 5DDA       03641 	SUBWF g_CmdBuf+218,W,1
000EBE 6EE9       03642 	MOVWF FSR0,0
000EC0 0E00       03643 	MOVLW 0
000EC2 59DB       03644 	SUBWFB g_CmdBuf+219,W,1
000EC4 6EEA       03645 	MOVWF FSR0+1,0
000EC6 0E02       03646 	MOVLW 2
000EC8 26EA       03647 	ADDWF FSR0+1,1,0
000ECA CFEF F00E  03648 	MOVFF INDF0,input_3
000ECE ECBB F00C  03649 	CALL  Trace_Hex
                  03650 			;				  Trace_Hex(g_CmdBuf.buffer[g_CmdBuf.counter - 1]);
000ED2 05DA       03651 	DECF  g_CmdBuf+218,W,1
000ED4 6EE9       03652 	MOVWF FSR0,0
000ED6 0E00       03653 	MOVLW 0
000ED8 59DB       03654 	SUBWFB g_CmdBuf+219,W,1
000EDA 6EEA       03655 	MOVWF FSR0+1,0
000EDC 0E02       03656 	MOVLW 2
000EDE 26EA       03657 	ADDWF FSR0+1,1,0
000EE0 CFEF F00E  03658 	MOVFF INDF0,input_3
000EE4 ECBB F00C  03659 	CALL  Trace_Hex
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 62

ADDR   CODE       LINE  SOURCE

                  03660 			;				  Trace_String("\n");
000EE8 0EC5       03661 	MOVLW 197
000EEA 6E0E       03662 	MOVWF string,0
000EEC 6A0F       03663 	CLRF  string+1,0
000EEE EC51 F00C  03664 	CALL  Trace_String
                  03665 			;			  }
                  03666 			;			  DeleteBuffer();
000EF2 DF5D       03667 m099	RCALL DeleteBuffer
                  03668 			;			  CommandIO_CreateResponse(&g_ResponseBuf, g_CmdBuf.buffer[1]);
000EF4 0E60       03669 	MOVLW 96
000EF6 6E0C       03670 	MOVWF mFrame_2,0
000EF8 6A0D       03671 	CLRF  mFrame_2+1,0
000EFA 0102       03672 	MOVLB 2
000EFC 5101       03673 	MOVF  g_CmdBuf+1,W,1
000EFE D870       03674 	RCALL CommandIO_CreateResponse
                  03675 			;			  CommandIO_SendResponse(&g_ResponseBuf);
000F00 0E60       03676 	MOVLW 96
000F02 6E0C       03677 	MOVWF mFrame,0
000F04 6A0D       03678 	CLRF  mFrame+1,0
000F06 D804       03679 	RCALL CommandIO_SendResponse
                  03680 			;			  
                  03681 			;			  break;
000F08 D002       03682 	BRA   m101
                  03683 			;	      }
                  03684 			;	      writeByte(new_byte);
000F0A 500A       03685 m100	MOVF  new_byte,W,0
000F0C DF24       03686 	RCALL writeByte
                  03687 			;	      break;
                  03688 			;	  }
                  03689 			;	}
                  03690 			;}
000F0E 0012       03691 m101	RETURN
                  03692 			;
                  03693 			;
                  03694 			;void CommandIO_SendResponse(struct response_frame *mFrame)
                  03695 			;{
                  03696 CommandIO_SendResponse
                  03697 			;	uns8 crcH, crcL, tempByte, *pData;
                  03698 			;	uns16 frameLength;
                  03699 			;		
                  03700 			;	frameLength = mFrame->length;
000F10 C00C FFE9  03701 	MOVFF mFrame,FSR0
000F14 C00D FFEA  03702 	MOVFF mFrame+1,FSR0+1
000F18 CFEE F013  03703 	MOVFF POSTINC0,frameLength
000F1C CFEE F014  03704 	MOVFF POSTINC0,frameLength+1
                  03705 			;	
                  03706 			;	pData = (uns8*)mFrame;
000F20 C00C F011  03707 	MOVFF mFrame,pData
000F24 C00D F012  03708 	MOVFF mFrame+1,pData+1
                  03709 			;	 
                  03710 			;	Crc_NewCrc(&crcH, &crcL);
000F28 0E0E       03711 	MOVLW 14
000F2A 6E15       03712 	MOVWF p_crcH_2,0
000F2C 6A16       03713 	CLRF  p_crcH_2+1,0
000F2E 0E0F       03714 	MOVLW 15
000F30 6E17       03715 	MOVWF p_crcL_2,0
000F32 6A18       03716 	CLRF  p_crcL_2+1,0
000F34 EC2C F001  03717 	CALL  Crc_NewCrc
                  03718 			;	 
                  03719 			;	UART_Send(STX);
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 63

ADDR   CODE       LINE  SOURCE

000F38 0E0F       03720 	MOVLW 15
000F3A 6E15       03721 	MOVWF ch,0
000F3C DF07       03722 	RCALL UART_Send
                  03723 			;	
                  03724 			;	while(frameLength > 0)
000F3E 5013       03725 m102	MOVF  frameLength,W,0
000F40 1014       03726 	IORWF frameLength+1,W,0
000F42 B4D8       03727 	BTFSC 0xFD8,Zero_,0
000F44 D028       03728 	BRA   m105
                  03729 			;	{
                  03730 			;		frameLength--;
000F46 0613       03731 	DECF  frameLength,1,0
000F48 0E00       03732 	MOVLW 0
000F4A 5A14       03733 	SUBWFB frameLength+1,1,0
                  03734 			;		tempByte = *pData++;
000F4C C011 FFE9  03735 	MOVFF pData,FSR0
000F50 C012 FFEA  03736 	MOVFF pData+1,FSR0+1
000F54 CFEF F010  03737 	MOVFF INDF0,tempByte
000F58 2A11       03738 	INCF  pData,1,0
000F5A 0E00       03739 	MOVLW 0
000F5C 2212       03740 	ADDWFC pData+1,1,0
                  03741 			;		Crc_AddCrc(tempByte, &crcH, &crcL);
000F5E C010 F015  03742 	MOVFF tempByte,byte
000F62 0E0E       03743 	MOVLW 14
000F64 6E16       03744 	MOVWF p_crcH,0
000F66 6A17       03745 	CLRF  p_crcH+1,0
000F68 0E0F       03746 	MOVLW 15
000F6A 6E18       03747 	MOVWF p_crcL,0
000F6C 6A19       03748 	CLRF  p_crcL+1,0
000F6E ECCC F000  03749 	CALL  Crc_AddCrc
                  03750 			;		if(tempByte == STX || tempByte == DLE || tempByte == ETX)
000F72 5010       03751 	MOVF  tempByte,W,0
000F74 0A0F       03752 	XORLW 15
000F76 B4D8       03753 	BTFSC 0xFD8,Zero_,0
000F78 D007       03754 	BRA   m103
000F7A 5010       03755 	MOVF  tempByte,W,0
000F7C 0A05       03756 	XORLW 5
000F7E B4D8       03757 	BTFSC 0xFD8,Zero_,0
000F80 D003       03758 	BRA   m103
000F82 0E04       03759 	MOVLW 4
000F84 6210       03760 	CPFSEQ tempByte,0
000F86 D003       03761 	BRA   m104
                  03762 			;		{
                  03763 			;			UART_Send(DLE);
000F88 0E05       03764 m103	MOVLW 5
000F8A 6E15       03765 	MOVWF ch,0
000F8C DEDF       03766 	RCALL UART_Send
                  03767 			;		}
                  03768 			;		UART_Send(tempByte);
000F8E C010 F015  03769 m104	MOVFF tempByte,ch
000F92 DEDC       03770 	RCALL UART_Send
                  03771 			;	}
000F94 D7D4       03772 	BRA   m102
                  03773 			;	if(crcH == STX || crcH == DLE || crcH == ETX)
000F96 500E       03774 m105	MOVF  crcH_3,W,0
000F98 0A0F       03775 	XORLW 15
000F9A B4D8       03776 	BTFSC 0xFD8,Zero_,0
000F9C D007       03777 	BRA   m106
000F9E 500E       03778 	MOVF  crcH_3,W,0
000FA0 0A05       03779 	XORLW 5
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 64

ADDR   CODE       LINE  SOURCE

000FA2 B4D8       03780 	BTFSC 0xFD8,Zero_,0
000FA4 D003       03781 	BRA   m106
000FA6 0E04       03782 	MOVLW 4
000FA8 620E       03783 	CPFSEQ crcH_3,0
000FAA D003       03784 	BRA   m107
                  03785 			;	{
                  03786 			;		UART_Send(DLE);
000FAC 0E05       03787 m106	MOVLW 5
000FAE 6E15       03788 	MOVWF ch,0
000FB0 DECD       03789 	RCALL UART_Send
                  03790 			;	}
                  03791 			;	UART_Send(crcH);
000FB2 C00E F015  03792 m107	MOVFF crcH_3,ch
000FB6 DECA       03793 	RCALL UART_Send
                  03794 			;	if(crcL == STX || crcL == DLE || crcL == ETX)
000FB8 500F       03795 	MOVF  crcL_3,W,0
000FBA 0A0F       03796 	XORLW 15
000FBC B4D8       03797 	BTFSC 0xFD8,Zero_,0
000FBE D007       03798 	BRA   m108
000FC0 500F       03799 	MOVF  crcL_3,W,0
000FC2 0A05       03800 	XORLW 5
000FC4 B4D8       03801 	BTFSC 0xFD8,Zero_,0
000FC6 D003       03802 	BRA   m108
000FC8 0E04       03803 	MOVLW 4
000FCA 620F       03804 	CPFSEQ crcL_3,0
000FCC D003       03805 	BRA   m109
                  03806 			;	{
                  03807 			;		UART_Send(DLE);
000FCE 0E05       03808 m108	MOVLW 5
000FD0 6E15       03809 	MOVWF ch,0
000FD2 DEBC       03810 	RCALL UART_Send
                  03811 			;	}
                  03812 			;	UART_Send(crcL);
000FD4 C00F F015  03813 m109	MOVFF crcL_3,ch
000FD8 DEB9       03814 	RCALL UART_Send
                  03815 			;	UART_Send(ETX);
000FDA 0E04       03816 	MOVLW 4
000FDC 6E15       03817 	MOVWF ch,0
000FDE D6B6       03818 	BRA   UART_Send
                  03819 			;}
                  03820 			;
                  03821 			;void CommandIO_CreateResponse(struct response_frame *mFrame, uns8 cmd)
                  03822 			;{
                  03823 CommandIO_CreateResponse
000FE0 6E0E       03824 	MOVWF cmd,0
                  03825 			;	mFrame->cmd = cmd;
000FE2 0E02       03826 	MOVLW 2
000FE4 240C       03827 	ADDWF mFrame_2,W,0
000FE6 6EE9       03828 	MOVWF FSR0,0
000FE8 0E00       03829 	MOVLW 0
000FEA 200D       03830 	ADDWFC mFrame_2+1,W,0
000FEC 6EEA       03831 	MOVWF FSR0+1,0
000FEE C00E FFEF  03832 	MOVFF cmd,INDF0
                  03833 			;	uns8 tempErrorState = (uns8)Error_GetState();
000FF2 EC9D F001  03834 	CALL  Error_GetState
000FF6 6E0F       03835 	MOVWF tempErrorState,0
                  03836 			;	mFrame->state = tempErrorState;
000FF8 0E03       03837 	MOVLW 3
000FFA 240C       03838 	ADDWF mFrame_2,W,0
000FFC 6EE9       03839 	MOVWF FSR0,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 65

ADDR   CODE       LINE  SOURCE

000FFE 0E00       03840 	MOVLW 0
001000 200D       03841 	ADDWFC mFrame_2+1,W,0
001002 6EEA       03842 	MOVWF FSR0+1,0
001004 C00F FFEF  03843 	MOVFF tempErrorState,INDF0
                  03844 			;	mFrame->length = sizeof(uns8) + sizeof(ErrorCode) + sizeof(uns16);
001008 C00C FFE9  03845 	MOVFF mFrame_2,FSR0
00100C C00D FFEA  03846 	MOVFF mFrame_2+1,FSR0+1
001010 0E04       03847 	MOVLW 4
001012 6EEE       03848 	MOVWF POSTINC0,0
001014 6AEF       03849 	CLRF  INDF0,0
                  03850 			;	switch (cmd) {
001016 500E       03851 	MOVF  cmd,W,0
001018 0AF3       03852 	XORLW 243
00101A B4D8       03853 	BTFSC 0xFD8,Zero_,0
00101C D00A       03854 	BRA   m110
00101E 0A03       03855 	XORLW 3
001020 B4D8       03856 	BTFSC 0xFD8,Zero_,0
001022 D019       03857 	BRA   m111
001024 0A1E       03858 	XORLW 30
001026 B4D8       03859 	BTFSC 0xFD8,Zero_,0
001028 D029       03860 	BRA   m112
00102A 0A03       03861 	XORLW 3
00102C B4D8       03862 	BTFSC 0xFD8,Zero_,0
00102E D03A       03863 	BRA   m113
001030 D059       03864 	BRA   m114
                  03865 			;		case GET_RTC:
                  03866 			;		{
                  03867 			;			Rtc_Ctl(RTC_RD_TIME, &mFrame->data.get_rtc);
001032 0E01       03868 m110	MOVLW 1
001034 6E10       03869 	MOVWF req,0
001036 0E04       03870 	MOVLW 4
001038 240C       03871 	ADDWF mFrame_2,W,0
00103A 6E11       03872 	MOVWF pRtcTime,0
00103C 0E00       03873 	MOVLW 0
00103E 200D       03874 	ADDWFC mFrame_2+1,W,0
001040 6E12       03875 	MOVWF pRtcTime+1,0
001042 D8C5       03876 	RCALL Rtc_Ctl
                  03877 			;			mFrame->length += sizeof(struct rtc_time);
001044 C00C FFE9  03878 	MOVFF mFrame_2,FSR0
001048 C00D FFEA  03879 	MOVFF mFrame_2+1,FSR0+1
00104C 0E07       03880 	MOVLW 7
00104E 26EE       03881 	ADDWF POSTINC0,1,0
001050 0E00       03882 	MOVLW 0
001052 22EF       03883 	ADDWFC INDF0,1,0
                  03884 			;			break;
001054 D047       03885 	BRA   m114
                  03886 			;		};
                  03887 			;		case GET_CYCLETIME:
                  03888 			;		{
                  03889 			;			uns8 bytesPrint = Timer_PrintCycletime(&(mFrame->data.get_max_cycle_times[0]), sizeof(struct response_frame) - 4);
001056 0E04       03890 m111	MOVLW 4
001058 240C       03891 	ADDWF mFrame_2,W,0
00105A 6E11       03892 	MOVWF pArray,0
00105C 0E00       03893 	MOVLW 0
00105E 200D       03894 	ADDWFC mFrame_2+1,W,0
001060 6E12       03895 	MOVWF pArray+1,0
001062 6813       03896 	SETF  arraySize,0
001064 6A14       03897 	CLRF  arraySize+1,0
001066 DDA8       03898 	RCALL Timer_PrintCycletime
001068 6E10       03899 	MOVWF bytesPrint,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 66

ADDR   CODE       LINE  SOURCE

                  03900 			;			mFrame->length += bytesPrint;
00106A C00C FFE9  03901 	MOVFF mFrame_2,FSR0
00106E C00D FFEA  03902 	MOVFF mFrame_2+1,FSR0+1
001072 5010       03903 	MOVF  bytesPrint,W,0
001074 26EE       03904 	ADDWF POSTINC0,1,0
001076 0E00       03905 	MOVLW 0
001078 22EF       03906 	ADDWFC INDF0,1,0
                  03907 			;			break;
00107A D034       03908 	BRA   m114
                  03909 			;		};
                  03910 			;		case GET_TRACE:
                  03911 			;		{
                  03912 			;			uns8 bytesPrint = Trace_Print(&(mFrame->data.get_trace_string[0]), sizeof(struct response_frame) - 4);
00107C 0E04       03913 m112	MOVLW 4
00107E 240C       03914 	ADDWF mFrame_2,W,0
001080 6E11       03915 	MOVWF pArray_2,0
001082 0E00       03916 	MOVLW 0
001084 200D       03917 	ADDWFC mFrame_2+1,W,0
001086 6E12       03918 	MOVWF pArray_2+1,0
001088 6813       03919 	SETF  arraySize_2,0
00108A 6A14       03920 	CLRF  arraySize_2+1,0
00108C ECEF F00C  03921 	CALL  Trace_Print
001090 6E10       03922 	MOVWF bytesPrint_2,0
                  03923 			;			mFrame->length += bytesPrint;
001092 C00C FFE9  03924 	MOVFF mFrame_2,FSR0
001096 C00D FFEA  03925 	MOVFF mFrame_2+1,FSR0+1
00109A 5010       03926 	MOVF  bytesPrint_2,W,0
00109C 26EE       03927 	ADDWF POSTINC0,1,0
00109E 0E00       03928 	MOVLW 0
0010A0 22EF       03929 	ADDWFC INDF0,1,0
                  03930 			;			break;
0010A2 D020       03931 	BRA   m114
                  03932 			;		};
                  03933 			;		case GET_FW_VERSION:
                  03934 			;		{
                  03935 			;			uns8 temp8;
                  03936 			;			temp8 = g_Version.major;
0010A4 0E00       03937 m113	MOVLW 0
0010A6 EC1C F00D  03938 	CALL  _const3
0010AA 6E10       03939 	MOVWF temp8_2,0
                  03940 			;			mFrame->data.version.major = temp8;
0010AC 0E04       03941 	MOVLW 4
0010AE 240C       03942 	ADDWF mFrame_2,W,0
0010B0 6EE9       03943 	MOVWF FSR0,0
0010B2 0E00       03944 	MOVLW 0
0010B4 200D       03945 	ADDWFC mFrame_2+1,W,0
0010B6 6EEA       03946 	MOVWF FSR0+1,0
0010B8 C010 FFEF  03947 	MOVFF temp8_2,INDF0
                  03948 			;			temp8 = g_Version.minor;
0010BC 0E01       03949 	MOVLW 1
0010BE EC1C F00D  03950 	CALL  _const3
0010C2 6E10       03951 	MOVWF temp8_2,0
                  03952 			;			mFrame->data.version.minor = temp8;
0010C4 0E05       03953 	MOVLW 5
0010C6 240C       03954 	ADDWF mFrame_2,W,0
0010C8 6EE9       03955 	MOVWF FSR0,0
0010CA 0E00       03956 	MOVLW 0
0010CC 200D       03957 	ADDWFC mFrame_2+1,W,0
0010CE 6EEA       03958 	MOVWF FSR0+1,0
0010D0 C010 FFEF  03959 	MOVFF temp8_2,INDF0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 67

ADDR   CODE       LINE  SOURCE

                  03960 			;			mFrame->length += sizeof(struct cmd_get_fw_version);
0010D4 C00C FFE9  03961 	MOVFF mFrame_2,FSR0
0010D8 C00D FFEA  03962 	MOVFF mFrame_2+1,FSR0+1
0010DC 0E02       03963 	MOVLW 2
0010DE 26EE       03964 	ADDWF POSTINC0,1,0
0010E0 0E00       03965 	MOVLW 0
0010E2 22EF       03966 	ADDWFC INDF0,1,0
                  03967 			;			break;
                  03968 			;		}
                  03969 			;		default:
                  03970 			;			break;
                  03971 			;	}
                  03972 			;}
0010E4 0012       03973 m114	RETURN
                  03974 
                  03975   ; FILE platform.c
                  03976 			;/**
                  03977 			; Copyright (C) 2012 Nils Weiss, Patrick BrÃ¼nn.
                  03978 			; 
                  03979 			; This file is part of Wifly_Light.
                  03980 			; 
                  03981 			; Wifly_Light is free software: you can redistribute it and/or modify
                  03982 			; it under the terms of the GNU General Public License as published by
                  03983 			; the Free Software Foundation, either version 3 of the License, or
                  03984 			; (at your option) any later version.
                  03985 			; 
                  03986 			; Wifly_Light is distributed in the hope that it will be useful,
                  03987 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  03988 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  03989 			; GNU General Public License for more details.
                  03990 			; 
                  03991 			; You should have received a copy of the GNU General Public License
                  03992 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  03993 			;
                  03994 			;#include "platform.h"
                  03995 			;//#include "ScriptCtrl.h"
                  03996 			;#include "ledstrip.h"
                  03997 			;
                  03998 			;#ifdef __CC8E__
                  03999 			;void Platform_CheckInputs()
                  04000 			;{
                  04001 Platform_CheckInputs
                  04002 			;	static uns8 lastSwitchState;
                  04003 			;	if(PORTB.5 == 0)
0010E6 BA81       04004 	BTFSC PORTB,5,0
0010E8 D003       04005 	BRA   m115
                  04006 			;	{
                  04007 			;		lastSwitchState = 1;
0010EA 0E01       04008 	MOVLW 1
0010EC 6E44       04009 	MOVWF lastSwitchState,0
                  04010 			;		return;
0010EE 0012       04011 	RETURN
                  04012 			;	}
                  04013 			;	if(PORTB.5 == 1)
0010F0 AA81       04014 m115	BTFSS PORTB,5,0
0010F2 D006       04015 	BRA   m117
                  04016 			;	{
                  04017 			;		if(lastSwitchState == 1)
0010F4 2C44       04018 	DECFSZ lastSwitchState,W,0
0010F6 D003       04019 	BRA   m116
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 68

ADDR   CODE       LINE  SOURCE

                  04020 			;		{
                  04021 			;			ScriptCtrl_Clear();
0010F8 DA87       04022 	RCALL ScriptCtrl_Clear
                  04023 			;			Ledstrip_ToggleLeds();
0010FA EC3D F002  04024 	CALL  Ledstrip_ToggleLeds
                  04025 			;		}
                  04026 			;		lastSwitchState = 0;
0010FE 6A44       04027 m116	CLRF  lastSwitchState,0
                  04028 			;	}
                  04029 			;	/*
                  04030 			;	//Goto Bootloader if PORTB.0 is low
                  04031 			;	if(PORTB.5 == 0)
                  04032 			;	{
                  04033 			;		softReset();
                  04034 			;	}*/
                  04035 			;}
001100 0012       04036 m117	RETURN
                  04037 			;
                  04038 			;void Platform_AllowInterrupts()
                  04039 			;{
                  04040 Platform_AllowInterrupts
                  04041 			;	IPEN = 1;
001102 8ED0       04042 	BSF   0xFD0,IPEN,0
                  04043 			;	TMR1IP = 0;
001104 909F       04044 	BCF   0xF9F,TMR1IP,0
                  04045 			;	TMR2IP = 0;
001106 929F       04046 	BCF   0xF9F,TMR2IP,0
                  04047 			;	TMR3IP = 0;
001108 92A2       04048 	BCF   0xFA2,TMR3IP,0
                  04049 			;	TMR4IP = 0;
00110A 907F       04050 	BCF   0xF7F,TMR4IP,0
                  04051 			;	TMR5IP = 0;
00110C 927F       04052 	BCF   0xF7F,TMR5IP,0
                  04053 			;	RC1IP = 1;
00110E 8A9F       04054 	BSF   0xF9F,RC1IP,0
                  04055 			;	RC1IE = 1; 
001110 8A9D       04056 	BSF   0xF9D,RC1IE,0
                  04057 			;	PEIE = 1; 
001112 8CF2       04058 	BSF   0xFF2,PEIE,0
                  04059 			;	GIEL = 1; 
001114 8CF2       04060 	BSF   0xFF2,GIEL,0
                  04061 			;	GIEH = 1;
001116 8EF2       04062 	BSF   0xFF2,GIEH,0
                  04063 			;}
001118 0012       04064 	RETURN
                  04065 			;
                  04066 			;void Platform_EnableAllInterrupts()
                  04067 			;{
                  04068 Platform_EnableAllInterrupts
                  04069 			;	GIEL = 1; 
00111A 8CF2       04070 	BSF   0xFF2,GIEL,0
                  04071 			;	GIEH = 1;
00111C 8EF2       04072 	BSF   0xFF2,GIEH,0
                  04073 			;}
00111E 0012       04074 	RETURN
                  04075 			;
                  04076 			;void Platform_DisableAllInterrupts()
                  04077 			;{
                  04078 Platform_DisableAllInterrupts
                  04079 			;	GIEL = 0; 
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 69

ADDR   CODE       LINE  SOURCE

001120 9CF2       04080 	BCF   0xFF2,GIEL,0
                  04081 			;	GIEH = 0;
001122 9EF2       04082 	BCF   0xFF2,GIEH,0
                  04083 			;}
001124 0012       04084 	RETURN
                  04085 			;
                  04086 			;void Platform_DisableBootloaderAutostart()
                  04087 			;{
                  04088 Platform_DisableBootloaderAutostart
                  04089 			;	Eeprom_Write(0x3ff, 1);
001126 681B       04090 	SETF  adress,0
001128 0E03       04091 	MOVLW 3
00112A 6E1C       04092 	MOVWF adress+1,0
00112C 0E01       04093 	MOVLW 1
00112E 6E1D       04094 	MOVWF data_2,0
001130 EF3F F001  04095 	GOTO  Eeprom_Write
                  04096 			;}
                  04097 			;
                  04098 			;void Platform_EnableBootloaderAutostart()
                  04099 			;{
                  04100 Platform_EnableBootloaderAutostart
                  04101 			;	Eeprom_Write(0x3ff, 0xff);
001134 681B       04102 	SETF  adress,0
001136 0E03       04103 	MOVLW 3
001138 6E1C       04104 	MOVWF adress+1,0
00113A 681D       04105 	SETF  data_2,0
00113C EF3F F001  04106 	GOTO  Eeprom_Write
                  04107 			;}
                  04108 			;
                  04109 			;uns16 htons(uns16 hostShort)
                  04110 			;{
                  04111 htons
                  04112 			;	uns16 retval;
                  04113 			;	retval.low8 = hostShort.high8;
001140 C01A F01B  04114 	MOVFF hostShort+1,retval
                  04115 			;	retval.high8 = hostShort.low8;
001144 C019 F01C  04116 	MOVFF hostShort,retval+1
                  04117 			;	return retval;
001148 501B       04118 	MOVF  retval,W,0
00114A 0012       04119 	RETURN
                  04120 			;}
                  04121 			;
                  04122 			;uns16 ntohs(uns16 networkShort)
                  04123 			;{
                  04124 ntohs
                  04125 			;	uns16 retval;
                  04126 			;	retval.low8 = networkShort.high8;
00114C C01B F01C  04127 	MOVFF networkShort+1,retval_2
                  04128 			;	retval.high8 = networkShort.low8;
001150 C01A F01D  04129 	MOVFF networkShort,retval_2+1
                  04130 			;	return retval;
001154 501C       04131 	MOVF  retval_2,W,0
001156 0012       04132 	RETURN
                  04133 
                  04134   ; FILE rtc.c
                  04135 			;/**
                  04136 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  04137 			; 
                  04138 			; This file is part of Wifly_Light.
                  04139 			; 
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 70

ADDR   CODE       LINE  SOURCE

                  04140 			; Wifly_Light is free software: you can redistribute it and/or modify
                  04141 			; it under the terms of the GNU General Public License as published by
                  04142 			; the Free Software Foundation, either version 3 of the License, or
                  04143 			; (at your option) any later version.
                  04144 			; 
                  04145 			; Wifly_Light is distributed in the hope that it will be useful,
                  04146 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  04147 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  04148 			; GNU General Public License for more details.
                  04149 			; 
                  04150 			; You should have received a copy of the GNU General Public License
                  04151 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  04152 			;
                  04153 			;#include "rtc.h"
                  04154 			;#include "iic.h"
                  04155 			;#ifdef __CC8E__
                  04156 			;#include "INLINE.H"
                  04157 			;#endif
                  04158 			;
                  04159 			;//*********************** PRIVATE FUNCTIONS *********************************************
                  04160 			;
                  04161 			;uns8 BcdToBin(const uns8 BcdValue)
                  04162 			;{
                  04163 BcdToBin
                  04164 			;	uns8 retValue = 0x00;
001158 6A15       04165 	CLRF  retValue,0
                  04166 			;	
                  04167 			;	retValue = BcdValue & 0x0f;
00115A 0E0F       04168 	MOVLW 15
00115C 1414       04169 	ANDWF BcdValue,W,0
00115E 6E15       04170 	MOVWF retValue,0
                  04171 			;	BcdValue = BcdValue >> 4;
001160 3814       04172 	SWAPF BcdValue,W,0
001162 0B0F       04173 	ANDLW 15
001164 6E14       04174 	MOVWF BcdValue,0
                  04175 			;	BcdValue = BcdValue * 0x0a;
001166 C014 F018  04176 	MOVFF BcdValue,arg1
00116A 0E0A       04177 	MOVLW 10
00116C EC0A F002  04178 	CALL  _mult8x8
001170 C01A F014  04179 	MOVFF rval,BcdValue
                  04180 			;	
                  04181 			;	return retValue + BcdValue;
001174 5014       04182 	MOVF  BcdValue,W,0
001176 2415       04183 	ADDWF retValue,W,0
001178 0012       04184 	RETURN
                  04185 			;}
                  04186 			;
                  04187 			;uns8 BinToBcd(const uns8 BinValue)
                  04188 			;{
                  04189 BinToBcd
                  04190 			;	uns8 onesValue, tensValue, tempValue;
                  04191 			;	
                  04192 			;	onesValue = 0x00;
00117A 6A15       04193 	CLRF  onesValue,0
                  04194 			;	tensValue = 0x00;
00117C 6A16       04195 	CLRF  tensValue,0
                  04196 			;	
                  04197 			;	if(BinValue > 9 )
00117E 0E09       04198 	MOVLW 9
001180 6414       04199 	CPFSGT BinValue,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 71

ADDR   CODE       LINE  SOURCE

001182 D011       04200 	BRA   m118
                  04201 			;	{
                  04202 			;		tensValue = BinValue / 0x0a;
001184 C014 F01D  04203 	MOVFF BinValue,arg1_5
001188 6A1E       04204 	CLRF  arg1_5+1,0
00118A 0E0A       04205 	MOVLW 10
00118C EC18 F002  04206 	CALL  _divU16_8
001190 C01D F016  04207 	MOVFF arg1_5,tensValue
                  04208 			;		tempValue = tensValue * 10;
001194 C016 F018  04209 	MOVFF tensValue,arg1
001198 0E0A       04210 	MOVLW 10
00119A EC0A F002  04211 	CALL  _mult8x8
00119E C01A F017  04212 	MOVFF rval,tempValue
                  04213 			;		BinValue -= tempValue;
0011A2 5017       04214 	MOVF  tempValue,W,0
0011A4 5E14       04215 	SUBWF BinValue,1,0
                  04216 			;	}
                  04217 			;	onesValue = BinValue;
0011A6 C014 F015  04218 m118	MOVFF BinValue,onesValue
                  04219 			;	tensValue = tensValue << 4;
0011AA 3816       04220 	SWAPF tensValue,W,0
0011AC 0BF0       04221 	ANDLW 240
0011AE 6E16       04222 	MOVWF tensValue,0
                  04223 			;	
                  04224 			;	return tensValue + onesValue;
0011B0 5015       04225 	MOVF  onesValue,W,0
0011B2 2416       04226 	ADDWF tensValue,W,0
0011B4 0012       04227 	RETURN
                  04228 			;}
                  04229 			;
                  04230 			;//*********************** PUBLIC FUNCTIONS *********************************************
                  04231 			;
                  04232 			;
                  04233 			;struct rtc_time g_RtcTime;
                  04234 			;
                  04235 			;void Rtc_Init(void)
                  04236 			;{
                  04237 Rtc_Init
                  04238 			;	I2C_Init();
0011B6 D8FD       04239 	RCALL I2C_Init
                  04240 			;	I2C_Write(RTC,0x00,0x00);		//Make sure that the TEST-Bits in the RTC-Device are set to zero
0011B8 0EA2       04241 	MOVLW 162
0011BA 6E14       04242 	MOVWF slaveaddr,0
0011BC 6A15       04243 	CLRF  dataaddr,0
0011BE 6A16       04244 	CLRF  data_5,0
0011C0 D901       04245 	RCALL I2C_Write
                  04246 			;	I2C_Write(RTC,0x01,0x00);		//Disable Interrupts in the RTC-Device
0011C2 0EA2       04247 	MOVLW 162
0011C4 6E14       04248 	MOVWF slaveaddr,0
0011C6 0E01       04249 	MOVLW 1
0011C8 6E15       04250 	MOVWF dataaddr,0
0011CA 6A16       04251 	CLRF  data_5,0
0011CC D0FB       04252 	BRA   I2C_Write
                  04253 			;} 
                  04254 			;
                  04255 			;void Rtc_Ctl(enum RTC_request req,struct rtc_time *pRtcTime)
                  04256 			;{
                  04257 Rtc_Ctl
                  04258 			;	uns8 temp;
                  04259 			;	switch(req)
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 72

ADDR   CODE       LINE  SOURCE

0011CE 5010       04260 	MOVF  req,W,0
0011D0 0A01       04261 	XORLW 1
0011D2 B4D8       04262 	BTFSC 0xFD8,Zero_,0
0011D4 D004       04263 	BRA   m119
0011D6 0A01       04264 	XORLW 1
0011D8 B4D8       04265 	BTFSC 0xFD8,Zero_,0
0011DA D076       04266 	BRA   m120
0011DC D0E9       04267 	BRA   m121
                  04268 			;	{
                  04269 			;		case RTC_RD_TIME:
                  04270 			;		{
                  04271 			;			temp = BcdToBin( I2C_Read(RTC, 0x02) & 0b01111111);
0011DE 0EA2       04272 m119	MOVLW 162
0011E0 6E14       04273 	MOVWF slaveaddr_2,0
0011E2 0E02       04274 	MOVLW 2
0011E4 6E15       04275 	MOVWF readaddr,0
0011E6 D908       04276 	RCALL I2C_Read
0011E8 0B7F       04277 	ANDLW 127
0011EA 6E14       04278 	MOVWF BcdValue,0
0011EC DFB5       04279 	RCALL BcdToBin
0011EE 6E13       04280 	MOVWF temp_4,0
                  04281 			;			pRtcTime->tm_sec = temp;
0011F0 C011 FFE9  04282 	MOVFF pRtcTime,FSR0
0011F4 C012 FFEA  04283 	MOVFF pRtcTime+1,FSR0+1
0011F8 C013 FFEF  04284 	MOVFF temp_4,INDF0
                  04285 			;			temp = BcdToBin( I2C_Read(RTC, 0x03) & 0b01111111);
0011FC 0EA2       04286 	MOVLW 162
0011FE 6E14       04287 	MOVWF slaveaddr_2,0
001200 0E03       04288 	MOVLW 3
001202 6E15       04289 	MOVWF readaddr,0
001204 D8F9       04290 	RCALL I2C_Read
001206 0B7F       04291 	ANDLW 127
001208 6E14       04292 	MOVWF BcdValue,0
00120A DFA6       04293 	RCALL BcdToBin
00120C 6E13       04294 	MOVWF temp_4,0
                  04295 			;			pRtcTime->tm_min = temp;
00120E 2811       04296 	INCF  pRtcTime,W,0
001210 6EE9       04297 	MOVWF FSR0,0
001212 0E00       04298 	MOVLW 0
001214 2012       04299 	ADDWFC pRtcTime+1,W,0
001216 6EEA       04300 	MOVWF FSR0+1,0
001218 C013 FFEF  04301 	MOVFF temp_4,INDF0
                  04302 			;			temp = BcdToBin( I2C_Read(RTC, 0x04) & 0b00111111);
00121C 0EA2       04303 	MOVLW 162
00121E 6E14       04304 	MOVWF slaveaddr_2,0
001220 0E04       04305 	MOVLW 4
001222 6E15       04306 	MOVWF readaddr,0
001224 D8E9       04307 	RCALL I2C_Read
001226 0B3F       04308 	ANDLW 63
001228 6E14       04309 	MOVWF BcdValue,0
00122A DF96       04310 	RCALL BcdToBin
00122C 6E13       04311 	MOVWF temp_4,0
                  04312 			;			pRtcTime->tm_hour = temp;	
00122E 0E02       04313 	MOVLW 2
001230 2411       04314 	ADDWF pRtcTime,W,0
001232 6EE9       04315 	MOVWF FSR0,0
001234 0E00       04316 	MOVLW 0
001236 2012       04317 	ADDWFC pRtcTime+1,W,0
001238 6EEA       04318 	MOVWF FSR0+1,0
00123A C013 FFEF  04319 	MOVFF temp_4,INDF0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 73

ADDR   CODE       LINE  SOURCE

                  04320 			;			temp = BcdToBin( I2C_Read(RTC, 0x05) & 0b00111111);
00123E 0EA2       04321 	MOVLW 162
001240 6E14       04322 	MOVWF slaveaddr_2,0
001242 0E05       04323 	MOVLW 5
001244 6E15       04324 	MOVWF readaddr,0
001246 D8D8       04325 	RCALL I2C_Read
001248 0B3F       04326 	ANDLW 63
00124A 6E14       04327 	MOVWF BcdValue,0
00124C DF85       04328 	RCALL BcdToBin
00124E 6E13       04329 	MOVWF temp_4,0
                  04330 			;			pRtcTime->tm_mday = temp;
001250 0E03       04331 	MOVLW 3
001252 2411       04332 	ADDWF pRtcTime,W,0
001254 6EE9       04333 	MOVWF FSR0,0
001256 0E00       04334 	MOVLW 0
001258 2012       04335 	ADDWFC pRtcTime+1,W,0
00125A 6EEA       04336 	MOVWF FSR0+1,0
00125C C013 FFEF  04337 	MOVFF temp_4,INDF0
                  04338 			;			temp = BcdToBin( I2C_Read(RTC, 0x06) & 0b00000111);
001260 0EA2       04339 	MOVLW 162
001262 6E14       04340 	MOVWF slaveaddr_2,0
001264 0E06       04341 	MOVLW 6
001266 6E15       04342 	MOVWF readaddr,0
001268 D8C7       04343 	RCALL I2C_Read
00126A 0B07       04344 	ANDLW 7
00126C 6E14       04345 	MOVWF BcdValue,0
00126E DF74       04346 	RCALL BcdToBin
001270 6E13       04347 	MOVWF temp_4,0
                  04348 			;			pRtcTime->tm_wday = temp;
001272 0E06       04349 	MOVLW 6
001274 2411       04350 	ADDWF pRtcTime,W,0
001276 6EE9       04351 	MOVWF FSR0,0
001278 0E00       04352 	MOVLW 0
00127A 2012       04353 	ADDWFC pRtcTime+1,W,0
00127C 6EEA       04354 	MOVWF FSR0+1,0
00127E C013 FFEF  04355 	MOVFF temp_4,INDF0
                  04356 			;			temp = BcdToBin( I2C_Read(RTC, 0x07) & 0b00011111);
001282 0EA2       04357 	MOVLW 162
001284 6E14       04358 	MOVWF slaveaddr_2,0
001286 0E07       04359 	MOVLW 7
001288 6E15       04360 	MOVWF readaddr,0
00128A D8B6       04361 	RCALL I2C_Read
00128C 0B1F       04362 	ANDLW 31
00128E 6E14       04363 	MOVWF BcdValue,0
001290 DF63       04364 	RCALL BcdToBin
001292 6E13       04365 	MOVWF temp_4,0
                  04366 			;			temp -= 1;
001294 0613       04367 	DECF  temp_4,1,0
                  04368 			;			pRtcTime->tm_mon = temp;
001296 0E04       04369 	MOVLW 4
001298 2411       04370 	ADDWF pRtcTime,W,0
00129A 6EE9       04371 	MOVWF FSR0,0
00129C 0E00       04372 	MOVLW 0
00129E 2012       04373 	ADDWFC pRtcTime+1,W,0
0012A0 6EEA       04374 	MOVWF FSR0+1,0
0012A2 C013 FFEF  04375 	MOVFF temp_4,INDF0
                  04376 			;			temp = BcdToBin( I2C_Read(RTC, 0x08) & 0b11111111);
0012A6 0EA2       04377 	MOVLW 162
0012A8 6E14       04378 	MOVWF slaveaddr_2,0
0012AA 0E08       04379 	MOVLW 8
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 74

ADDR   CODE       LINE  SOURCE

0012AC 6E15       04380 	MOVWF readaddr,0
0012AE D8A4       04381 	RCALL I2C_Read
0012B0 6E14       04382 	MOVWF BcdValue,0
0012B2 DF52       04383 	RCALL BcdToBin
0012B4 6E13       04384 	MOVWF temp_4,0
                  04385 			;			pRtcTime->tm_year = temp;
0012B6 0E05       04386 	MOVLW 5
0012B8 2411       04387 	ADDWF pRtcTime,W,0
0012BA 6EE9       04388 	MOVWF FSR0,0
0012BC 0E00       04389 	MOVLW 0
0012BE 2012       04390 	ADDWFC pRtcTime+1,W,0
0012C0 6EEA       04391 	MOVWF FSR0+1,0
0012C2 C013 FFEF  04392 	MOVFF temp_4,INDF0
                  04393 			;		}break;
0012C6 D074       04394 	BRA   m121
                  04395 			;		case RTC_SET_TIME:
                  04396 			;		{
                  04397 			;			temp = BinToBcd(pRtcTime->tm_sec);
0012C8 C011 FFE9  04398 m120	MOVFF pRtcTime,FSR0
0012CC C012 FFEA  04399 	MOVFF pRtcTime+1,FSR0+1
0012D0 CFEF F014  04400 	MOVFF INDF0,BinValue
0012D4 DF52       04401 	RCALL BinToBcd
0012D6 6E13       04402 	MOVWF temp_4,0
                  04403 			;			I2C_Write(RTC,0x02,( temp ));
0012D8 0EA2       04404 	MOVLW 162
0012DA 6E14       04405 	MOVWF slaveaddr,0
0012DC 0E02       04406 	MOVLW 2
0012DE 6E15       04407 	MOVWF dataaddr,0
0012E0 C013 F016  04408 	MOVFF temp_4,data_5
0012E4 D86F       04409 	RCALL I2C_Write
                  04410 			;			temp = BinToBcd(pRtcTime->tm_min);
0012E6 2811       04411 	INCF  pRtcTime,W,0
0012E8 6EE9       04412 	MOVWF FSR0,0
0012EA 0E00       04413 	MOVLW 0
0012EC 2012       04414 	ADDWFC pRtcTime+1,W,0
0012EE 6EEA       04415 	MOVWF FSR0+1,0
0012F0 CFEF F014  04416 	MOVFF INDF0,BinValue
0012F4 DF42       04417 	RCALL BinToBcd
0012F6 6E13       04418 	MOVWF temp_4,0
                  04419 			;			I2C_Write(RTC,0x03,( temp ));
0012F8 0EA2       04420 	MOVLW 162
0012FA 6E14       04421 	MOVWF slaveaddr,0
0012FC 0E03       04422 	MOVLW 3
0012FE 6E15       04423 	MOVWF dataaddr,0
001300 C013 F016  04424 	MOVFF temp_4,data_5
001304 D85F       04425 	RCALL I2C_Write
                  04426 			;			temp = BinToBcd(pRtcTime->tm_hour);
001306 0E02       04427 	MOVLW 2
001308 2411       04428 	ADDWF pRtcTime,W,0
00130A 6EE9       04429 	MOVWF FSR0,0
00130C 0E00       04430 	MOVLW 0
00130E 2012       04431 	ADDWFC pRtcTime+1,W,0
001310 6EEA       04432 	MOVWF FSR0+1,0
001312 CFEF F014  04433 	MOVFF INDF0,BinValue
001316 DF31       04434 	RCALL BinToBcd
001318 6E13       04435 	MOVWF temp_4,0
                  04436 			;			I2C_Write(RTC,0x04,( temp ));
00131A 0EA2       04437 	MOVLW 162
00131C 6E14       04438 	MOVWF slaveaddr,0
00131E 0E04       04439 	MOVLW 4
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 75

ADDR   CODE       LINE  SOURCE

001320 6E15       04440 	MOVWF dataaddr,0
001322 C013 F016  04441 	MOVFF temp_4,data_5
001326 D84E       04442 	RCALL I2C_Write
                  04443 			;			temp = BinToBcd(pRtcTime->tm_mday);
001328 0E03       04444 	MOVLW 3
00132A 2411       04445 	ADDWF pRtcTime,W,0
00132C 6EE9       04446 	MOVWF FSR0,0
00132E 0E00       04447 	MOVLW 0
001330 2012       04448 	ADDWFC pRtcTime+1,W,0
001332 6EEA       04449 	MOVWF FSR0+1,0
001334 CFEF F014  04450 	MOVFF INDF0,BinValue
001338 DF20       04451 	RCALL BinToBcd
00133A 6E13       04452 	MOVWF temp_4,0
                  04453 			;			I2C_Write(RTC,0x05,( temp ));
00133C 0EA2       04454 	MOVLW 162
00133E 6E14       04455 	MOVWF slaveaddr,0
001340 0E05       04456 	MOVLW 5
001342 6E15       04457 	MOVWF dataaddr,0
001344 C013 F016  04458 	MOVFF temp_4,data_5
001348 D83D       04459 	RCALL I2C_Write
                  04460 			;			temp = BinToBcd(pRtcTime->tm_wday);
00134A 0E06       04461 	MOVLW 6
00134C 2411       04462 	ADDWF pRtcTime,W,0
00134E 6EE9       04463 	MOVWF FSR0,0
001350 0E00       04464 	MOVLW 0
001352 2012       04465 	ADDWFC pRtcTime+1,W,0
001354 6EEA       04466 	MOVWF FSR0+1,0
001356 CFEF F014  04467 	MOVFF INDF0,BinValue
00135A DF0F       04468 	RCALL BinToBcd
00135C 6E13       04469 	MOVWF temp_4,0
                  04470 			;			I2C_Write(RTC,0x06,( temp ));
00135E 0EA2       04471 	MOVLW 162
001360 6E14       04472 	MOVWF slaveaddr,0
001362 0E06       04473 	MOVLW 6
001364 6E15       04474 	MOVWF dataaddr,0
001366 C013 F016  04475 	MOVFF temp_4,data_5
00136A D82C       04476 	RCALL I2C_Write
                  04477 			;			temp = BinToBcd((pRtcTime->tm_mon + 1));
00136C 0E04       04478 	MOVLW 4
00136E 2411       04479 	ADDWF pRtcTime,W,0
001370 6EE9       04480 	MOVWF FSR0,0
001372 0E00       04481 	MOVLW 0
001374 2012       04482 	ADDWFC pRtcTime+1,W,0
001376 6EEA       04483 	MOVWF FSR0+1,0
001378 28EF       04484 	INCF  INDF0,W,0
00137A 6E14       04485 	MOVWF BinValue,0
00137C DEFE       04486 	RCALL BinToBcd
00137E 6E13       04487 	MOVWF temp_4,0
                  04488 			;			I2C_Write(RTC,0x07,( temp ));
001380 0EA2       04489 	MOVLW 162
001382 6E14       04490 	MOVWF slaveaddr,0
001384 0E07       04491 	MOVLW 7
001386 6E15       04492 	MOVWF dataaddr,0
001388 C013 F016  04493 	MOVFF temp_4,data_5
00138C D81B       04494 	RCALL I2C_Write
                  04495 			;			temp = BinToBcd(pRtcTime->tm_year);
00138E 0E05       04496 	MOVLW 5
001390 2411       04497 	ADDWF pRtcTime,W,0
001392 6EE9       04498 	MOVWF FSR0,0
001394 0E00       04499 	MOVLW 0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 76

ADDR   CODE       LINE  SOURCE

001396 2012       04500 	ADDWFC pRtcTime+1,W,0
001398 6EEA       04501 	MOVWF FSR0+1,0
00139A CFEF F014  04502 	MOVFF INDF0,BinValue
00139E DEED       04503 	RCALL BinToBcd
0013A0 6E13       04504 	MOVWF temp_4,0
                  04505 			;			I2C_Write(RTC,0x08,( temp ));
0013A2 0EA2       04506 	MOVLW 162
0013A4 6E14       04507 	MOVWF slaveaddr,0
0013A6 0E08       04508 	MOVLW 8
0013A8 6E15       04509 	MOVWF dataaddr,0
0013AA C013 F016  04510 	MOVFF temp_4,data_5
0013AE D80A       04511 	RCALL I2C_Write
                  04512 			;		}break;
                  04513 			;	}
                  04514 			;}
0013B0 0012       04515 m121	RETURN
                  04516 
                  04517   ; FILE iic.c
                  04518 			;/**
                  04519 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  04520 			; 
                  04521 			; This file is part of Wifly_Light.
                  04522 			; 
                  04523 			; Wifly_Light is free software: you can redistribute it and/or modify
                  04524 			; it under the terms of the GNU General Public License as published by
                  04525 			; the Free Software Foundation, either version 3 of the License, or
                  04526 			; (at your option) any later version.
                  04527 			; 
                  04528 			; Wifly_Light is distributed in the hope that it will be useful,
                  04529 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  04530 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  04531 			; GNU General Public License for more details.
                  04532 			; 
                  04533 			; You should have received a copy of the GNU General Public License
                  04534 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  04535 			; 
                  04536 			;//Befehle:
                  04537 			;//I2C_Init() zum initialisieren
                  04538 			;//IICwrite(Slave-Adresse,Register-Adresse,Datenbyte) zum Schreiben eines Byte in einen Slave
                  04539 			;//IICread(Slave-Adresse,Register-Adresse) ließt ein Byte von der angegebenen Adresse
                  04540 			;
                  04541 			;#include "iic.h"
                  04542 			;
                  04543 			;void I2C_Init()
                  04544 			;{	
                  04545 I2C_Init
                  04546 			;	ANSELB = 0;
0013B2 010F       04547 	MOVLB 15
0013B4 6B39       04548 	CLRF  ANSELB,1
                  04549 			;	SSP2ADD=39;				//Takt des IIC-Bus auf 400kHz einstellen
0013B6 0E27       04550 	MOVLW 39
0013B8 6E6E       04551 	MOVWF SSP2ADD,0
                  04552 			;	SSP2STAT=0x00;
0013BA 6A6D       04553 	CLRF  SSP2STAT,0
                  04554 			;	SSP2CON1=0x08;			//Betriebsart des MSSP-Modul festlegen
0013BC 0E08       04555 	MOVLW 8
0013BE 6E6C       04556 	MOVWF SSP2CON1,0
                  04557 			;	SSPEN2=1;				//MSSP-Modul einschalten
0013C0 8A6C       04558 	BSF   0xF6C,SSPEN2,0
                  04559 			;}
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 77

ADDR   CODE       LINE  SOURCE

0013C2 0012       04560 	RETURN
                  04561 			;
                  04562 			;void I2C_Write(const uns8 slaveaddr, const uns8 dataaddr, const uns8 data)
                  04563 			;{
                  04564 I2C_Write
                  04565 			;	//Writebit in Slaveadresse setzen
                  04566 			;	
                  04567 			;	slaveaddr = slaveaddr & 0b11111110;
0013C4 9014       04568 	BCF   slaveaddr,0,0
                  04569 			;
                  04570 			;	//Bus übernehmen
                  04571 			;	SSP2IF=0;
0013C6 9EA4       04572 	BCF   0xFA4,SSP2IF,0
                  04573 			;	SEN2=1;
0013C8 806B       04574 	BSF   0xF6B,SEN2,0
                  04575 			;	while(!SSP2IF);
0013CA AEA4       04576 m122	BTFSS 0xFA4,SSP2IF,0
0013CC D7FE       04577 	BRA   m122
                  04578 			;	SSP2IF=0;
0013CE 9EA4       04579 	BCF   0xFA4,SSP2IF,0
                  04580 			;
                  04581 			;	//Slave ansprechen
                  04582 			;	SSP2BUF=slaveaddr;
0013D0 C014 FF6F  04583 	MOVFF slaveaddr,SSP2BUF
                  04584 			;	while(!SSP2IF);
0013D4 AEA4       04585 m123	BTFSS 0xFA4,SSP2IF,0
0013D6 D7FE       04586 	BRA   m123
                  04587 			;	SSP2IF=0;
0013D8 9EA4       04588 	BCF   0xFA4,SSP2IF,0
                  04589 			;	
                  04590 			;	//Datenregisteradresse übertragen
                  04591 			;	SSP2BUF=dataaddr;
0013DA C015 FF6F  04592 	MOVFF dataaddr,SSP2BUF
                  04593 			;	while(!SSP2IF);
0013DE AEA4       04594 m124	BTFSS 0xFA4,SSP2IF,0
0013E0 D7FE       04595 	BRA   m124
                  04596 			;	SSP2IF=0;
0013E2 9EA4       04597 	BCF   0xFA4,SSP2IF,0
                  04598 			;	
                  04599 			;	//Daten schreiben
                  04600 			;	SSP2BUF=data;
0013E4 C016 FF6F  04601 	MOVFF data_5,SSP2BUF
                  04602 			;	while(!SSP2IF);
0013E8 AEA4       04603 m125	BTFSS 0xFA4,SSP2IF,0
0013EA D7FE       04604 	BRA   m125
                  04605 			;	SSP2IF=0;
0013EC 9EA4       04606 	BCF   0xFA4,SSP2IF,0
                  04607 			;
                  04608 			;	//Bus freigeben
                  04609 			;	PEN2=1;
0013EE 846B       04610 	BSF   0xF6B,PEN2,0
                  04611 			;	while(!SSP2IF);
0013F0 AEA4       04612 m126	BTFSS 0xFA4,SSP2IF,0
0013F2 D7FE       04613 	BRA   m126
                  04614 			;	SSP2IF=0;
0013F4 9EA4       04615 	BCF   0xFA4,SSP2IF,0
                  04616 			;}
0013F6 0012       04617 	RETURN
                  04618 			;
                  04619 			;uns8 I2C_Read(const uns8 slaveaddr, const uns8 readaddr)
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 78

ADDR   CODE       LINE  SOURCE

                  04620 			;{
                  04621 I2C_Read
                  04622 			;	//Writebit in Slaveadresse setzen
                  04623 			;	uns8 _slaveaddr;
                  04624 			;	uns8 _data;
                  04625 			;	_slaveaddr=slaveaddr&0b11111110;
0013F8 0EFE       04626 	MOVLW 254
0013FA 1414       04627 	ANDWF slaveaddr_2,W,0
0013FC 6E16       04628 	MOVWF _slaveaddr,0
                  04629 			;	
                  04630 			;	//Bus übernehmen
                  04631 			;	SSP2IF=0;
0013FE 9EA4       04632 	BCF   0xFA4,SSP2IF,0
                  04633 			;	SEN2=1;
001400 806B       04634 	BSF   0xF6B,SEN2,0
                  04635 			;	while(!SSP2IF);
001402 AEA4       04636 m127	BTFSS 0xFA4,SSP2IF,0
001404 D7FE       04637 	BRA   m127
                  04638 			;	SSP2IF=0;
001406 9EA4       04639 	BCF   0xFA4,SSP2IF,0
                  04640 			;
                  04641 			;	//Slave ansprechen
                  04642 			;	SSP2BUF=_slaveaddr;
001408 C016 FF6F  04643 	MOVFF _slaveaddr,SSP2BUF
                  04644 			;	while(!SSP2IF);
00140C AEA4       04645 m128	BTFSS 0xFA4,SSP2IF,0
00140E D7FE       04646 	BRA   m128
                  04647 			;	SSP2IF=0;
001410 9EA4       04648 	BCF   0xFA4,SSP2IF,0
                  04649 			;	
                  04650 			;	//Datenregisteradresse übertragen
                  04651 			;	SSP2BUF=readaddr;
001412 C015 FF6F  04652 	MOVFF readaddr,SSP2BUF
                  04653 			;	while(!SSP2IF);
001416 AEA4       04654 m129	BTFSS 0xFA4,SSP2IF,0
001418 D7FE       04655 	BRA   m129
                  04656 			;	SSP2IF=0;
00141A 9EA4       04657 	BCF   0xFA4,SSP2IF,0
                  04658 			;
                  04659 			;	//Bus freigeben
                  04660 			;	PEN2=1;
00141C 846B       04661 	BSF   0xF6B,PEN2,0
                  04662 			;	while(!SSP2IF);
00141E AEA4       04663 m130	BTFSS 0xFA4,SSP2IF,0
001420 D7FE       04664 	BRA   m130
                  04665 			;	SSP2IF=0;
001422 9EA4       04666 	BCF   0xFA4,SSP2IF,0
                  04667 			;
                  04668 			;	//Bus übernehmen
                  04669 			;	SSP2IF=0;
001424 9EA4       04670 	BCF   0xFA4,SSP2IF,0
                  04671 			;	RSEN2=1;
001426 826B       04672 	BSF   0xF6B,RSEN2,0
                  04673 			;	while(!SSP2IF);
001428 AEA4       04674 m131	BTFSS 0xFA4,SSP2IF,0
00142A D7FE       04675 	BRA   m131
                  04676 			;	SSP2IF=0;
00142C 9EA4       04677 	BCF   0xFA4,SSP2IF,0
                  04678 			;
                  04679 			;	//Readbit in Slaveadresse setzen
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 79

ADDR   CODE       LINE  SOURCE

                  04680 			;	_slaveaddr|=0b00000001;
00142E 8016       04681 	BSF   _slaveaddr,0,0
                  04682 			;	//Slave ansprechen
                  04683 			;	SSP2BUF=_slaveaddr;
001430 C016 FF6F  04684 	MOVFF _slaveaddr,SSP2BUF
                  04685 			;	while(!SSP2IF);
001434 AEA4       04686 m132	BTFSS 0xFA4,SSP2IF,0
001436 D7FE       04687 	BRA   m132
                  04688 			;	SSP2IF=0;
001438 9EA4       04689 	BCF   0xFA4,SSP2IF,0
                  04690 			;	
                  04691 			;	//Pic auf Lesen umschalten
                  04692 			;	RCEN2=1;
00143A 866B       04693 	BSF   0xF6B,RCEN2,0
                  04694 			;	while(!SSP2IF);
00143C AEA4       04695 m133	BTFSS 0xFA4,SSP2IF,0
00143E D7FE       04696 	BRA   m133
                  04697 			;	SSP2IF=0;
001440 9EA4       04698 	BCF   0xFA4,SSP2IF,0
                  04699 			;	ACKEN2=0;
001442 986B       04700 	BCF   0xF6B,ACKEN2,0
                  04701 			;	_data=SSP2BUF;
001444 CF6F F017  04702 	MOVFF SSP2BUF,_data
                  04703 			;	
                  04704 			;	
                  04705 			;	//Bus freigeben
                  04706 			;	PEN2=1;
001448 846B       04707 	BSF   0xF6B,PEN2,0
                  04708 			;	while(!SSP2IF);
00144A AEA4       04709 m134	BTFSS 0xFA4,SSP2IF,0
00144C D7FE       04710 	BRA   m134
                  04711 			;	SSP2IF=0;
00144E 9EA4       04712 	BCF   0xFA4,SSP2IF,0
                  04713 			;	return _data;	
001450 5017       04714 	MOVF  _data,W,0
001452 0012       04715 	RETURN
                  04716 
                  04717   ; FILE ScriptCtrl.c
                  04718 			;/**
                  04719 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  04720 			; 
                  04721 			; This file is part of Wifly_Light.
                  04722 			; 
                  04723 			; Wifly_Light is free software: you can redistribute it and/or modify
                  04724 			; it under the terms of the GNU General Public License as published by
                  04725 			; the Free Software Foundation, either version 3 of the License, or
                  04726 			; (at your option) any later version.
                  04727 			; 
                  04728 			; Wifly_Light is distributed in the hope that it will be useful,
                  04729 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  04730 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  04731 			; GNU General Public License for more details.
                  04732 			; 
                  04733 			; You should have received a copy of the GNU General Public License
                  04734 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  04735 			;
                  04736 			;#include "ScriptCtrl.h"
                  04737 			;#include "CommandIO.h"
                  04738 			;#include "ledstrip.h"
                  04739 			;#include "eeprom.h"
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 80

ADDR   CODE       LINE  SOURCE

                  04740 			;#include "trace.h"
                  04741 			;
                  04742 			;/**************** private functions/ macros *****************/
                  04743 			;/**
                  04744 			; * Helper to calculate an eeprom address from a command pointer
                  04745 			; */
                  04746 			;#define ScriptBufAddr(x) ((uns16)EEPROM_SCRIPTBUF_BASE + ((uns16)(x)*(uns16)sizeof(struct led_cmd)))
                  04747 			;
                  04748 			;/**
                  04749 			; * Helper to increment a ScriptBuf pointer
                  04750 			; */
                  04751 			;#define ScriptBufInc(x) ((x + 1) & SCRIPTCTRL_NUM_CMD_MAX)
                  04752 			;
                  04753 			;/**
                  04754 			; * Setter for ScriptBuf.inLoop
                  04755 			; */
                  04756 			;#define ScriptBufSetInLoop(x) { \
                  04757 			;	Eeprom_Write(EEPROM_SCRIPTBUF_INLOOP, x); \
                  04758 			;	gScriptBuf.inLoop = x; \
                  04759 			;}
                  04760 			;
                  04761 			;/**
                  04762 			; * Setter for ScriptBuf.read
                  04763 			; */
                  04764 			;#define ScriptBufSetRead(x) { \
                  04765 			;	Eeprom_Write(EEPROM_SCRIPTBUF_READ, x); \
                  04766 			;	gScriptBuf.read = x; \
                  04767 			;}
                  04768 			;
                  04769 			;/**
                  04770 			; * Setter for ScriptBuf.write
                  04771 			; */
                  04772 			;#define ScriptBufSetWrite(x) { \
                  04773 			;	Eeprom_Write(EEPROM_SCRIPTBUF_WRITE, x); \
                  04774 			;	gScriptBuf.write = x; \
                  04775 			;}
                  04776 			;
                  04777 			;/**
                  04778 			; * save command to eeprom
                  04779 			; */
                  04780 			;uns8 ScriptCtrl_Write(const struct led_cmd* pCmd);
                  04781 			;
                  04782 			;/* private globals */
                  04783 			;struct ScriptBuf gScriptBuf;
                  04784 			;struct led_cmd nextCmd;
                  04785 			;
                  04786 			;uns8 ScriptCtrl_Add(struct led_cmd* pCmd)
                  04787 			;{
                  04788 ScriptCtrl_Add
                  04789 			;	/* We have to reject all commands until buffer was cleared completely */
                  04790 			;	if(gScriptBuf.isClearing)
001454 B037       04791 	BTFSC gScriptBuf+11,0,0
                  04792 			;	{
                  04793 			;		return FALSE;
001456 0C00       04794 	RETLW 0
                  04795 			;	}
                  04796 			;
                  04797 			;	switch(pCmd->cmd)
001458 0E02       04798 	MOVLW 2
00145A 6EEA       04799 	MOVWF FSR0+1,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 81

ADDR   CODE       LINE  SOURCE

00145C C00B FFE9  04800 	MOVFF pCmd_2,FSR0
001460 50EF       04801 	MOVF  INDF0,W,0
001462 0AF8       04802 	XORLW 248
001464 B4D8       04803 	BTFSC 0xFD8,Zero_,0
001466 D01F       04804 	BRA   m135
001468 0A0F       04805 	XORLW 15
00146A B4D8       04806 	BTFSC 0xFD8,Zero_,0
00146C D022       04807 	BRA   m136
00146E 0A01       04808 	XORLW 1
001470 B4D8       04809 	BTFSC 0xFD8,Zero_,0
001472 D02B       04810 	BRA   m137
001474 0A08       04811 	XORLW 8
001476 B4D8       04812 	BTFSC 0xFD8,Zero_,0
001478 D072       04813 	BRA   m138
00147A 0A0B       04814 	XORLW 11
00147C B4D8       04815 	BTFSC 0xFD8,Zero_,0
00147E D074       04816 	BRA   m139
001480 0A06       04817 	XORLW 6
001482 B4D8       04818 	BTFSC 0xFD8,Zero_,0
001484 D07D       04819 	BRA   m140
001486 0A07       04820 	XORLW 7
001488 B4D8       04821 	BTFSC 0xFD8,Zero_,0
00148A D07B       04822 	BRA   m141
00148C 0A05       04823 	XORLW 5
00148E B4D8       04824 	BTFSC 0xFD8,Zero_,0
001490 D0AE       04825 	BRA   m142
001492 0A01       04826 	XORLW 1
001494 B4D8       04827 	BTFSC 0xFD8,Zero_,0
001496 D0B0       04828 	BRA   m143
001498 0A1E       04829 	XORLW 30
00149A B4D8       04830 	BTFSC 0xFD8,Zero_,0
00149C D0AE       04831 	BRA   m144
00149E 0A03       04832 	XORLW 3
0014A0 B4D8       04833 	BTFSC 0xFD8,Zero_,0
0014A2 D0AC       04834 	BRA   m145
0014A4 D0AC       04835 	BRA   m146
                  04836 			;	{
                  04837 			;		case CLEAR_SCRIPT:
                  04838 			;			Trace_String("Clearing script buffer\n");
0014A6 0EAF       04839 m135	MOVLW 175
0014A8 6E0E       04840 	MOVWF string,0
0014AA 6A0F       04841 	CLRF  string+1,0
0014AC D9FA       04842 	RCALL Trace_String
                  04843 			;			gScriptBuf.isClearing = TRUE;
0014AE 8037       04844 	BSF   gScriptBuf+11,0,0
                  04845 			;			return TRUE;
0014B0 0C01       04846 	RETLW 1
                  04847 			;		case LOOP_ON:
                  04848 			;			gScriptBuf.loopStart[gScriptBuf.loopDepth] = gScriptBuf.write;
0014B2 6AEA       04849 m136	CLRF  FSR0+1,0
0014B4 0E2E       04850 	MOVLW 46
0014B6 2432       04851 	ADDWF gScriptBuf+6,W,0
0014B8 6EE9       04852 	MOVWF FSR0,0
0014BA C035 FFEF  04853 	MOVFF gScriptBuf+9,INDF0
                  04854 			;			gScriptBuf.loopDepth++;
0014BE 2A32       04855 	INCF  gScriptBuf+6,1,0
                  04856 			;			return ScriptCtrl_Write(pCmd);
0014C0 0E02       04857 	MOVLW 2
0014C2 6E0F       04858 	MOVWF pCmd_3+1,0
0014C4 C00B F00E  04859 	MOVFF pCmd_2,pCmd_3
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 82

ADDR   CODE       LINE  SOURCE

0014C8 D1B4       04860 	BRA   ScriptCtrl_Write
                  04861 			;		case LOOP_OFF:
                  04862 			;		{
                  04863 			;			gScriptBuf.loopDepth--;
0014CA 0632       04864 m137	DECF  gScriptBuf+6,1,0
                  04865 			;			uns8 loopStart = gScriptBuf.loopStart[gScriptBuf.loopDepth];
0014CC 6AEA       04866 	CLRF  FSR0+1,0
0014CE 0E2E       04867 	MOVLW 46
0014D0 2432       04868 	ADDWF gScriptBuf+6,W,0
0014D2 6EE9       04869 	MOVWF FSR0,0
0014D4 CFEF F00C  04870 	MOVFF INDF0,loopStart
                  04871 			;			pCmd->data.loopEnd.startIndex = ScriptBufInc(loopStart);
0014D8 0E02       04872 	MOVLW 2
0014DA 6EEA       04873 	MOVWF FSR0+1,0
0014DC 280B       04874 	INCF  pCmd_2,W,0
0014DE 6EE9       04875 	MOVWF FSR0,0
0014E0 280C       04876 	INCF  loopStart,W,0
0014E2 0B3F       04877 	ANDLW 63
0014E4 6EEF       04878 	MOVWF INDF0,0
                  04879 			;			pCmd->data.loopEnd.depth = gScriptBuf.loopDepth;
0014E6 0E02       04880 	MOVLW 2
0014E8 6EEA       04881 	MOVWF FSR0+1,0
0014EA 0E04       04882 	MOVLW 4
0014EC 240B       04883 	ADDWF pCmd_2,W,0
0014EE 6EE9       04884 	MOVWF FSR0,0
0014F0 C032 FFEF  04885 	MOVFF gScriptBuf+6,INDF0
                  04886 			;			uns8 numLoops = pCmd->data.loopEnd.numLoops;
0014F4 0E02       04887 	MOVLW 2
0014F6 6EEA       04888 	MOVWF FSR0+1,0
0014F8 0E03       04889 	MOVLW 3
0014FA 240B       04890 	ADDWF pCmd_2,W,0
0014FC 6EE9       04891 	MOVWF FSR0,0
0014FE CFEF F00D  04892 	MOVFF INDF0,numLoops
                  04893 			;			pCmd->data.loopEnd.counter = numLoops;
001502 0E02       04894 	MOVLW 2
001504 6EEA       04895 	MOVWF FSR0+1,0
001506 0E02       04896 	MOVLW 2
001508 240B       04897 	ADDWF pCmd_2,W,0
00150A 6EE9       04898 	MOVWF FSR0,0
00150C C00D FFEF  04899 	MOVFF numLoops,INDF0
                  04900 			;			Trace_String("Add LOOP_OFF: ");
001510 0EC7       04901 	MOVLW 199
001512 6E0E       04902 	MOVWF string,0
001514 6A0F       04903 	CLRF  string+1,0
001516 D9C5       04904 	RCALL Trace_String
                  04905 			;			Trace_Hex(gScriptBuf.write);
001518 C035 F00E  04906 	MOVFF gScriptBuf+9,input_3
00151C DA2C       04907 	RCALL Trace_Hex
                  04908 			;			Trace_Hex(pCmd->data.loopEnd.startIndex);
00151E 0E02       04909 	MOVLW 2
001520 6EEA       04910 	MOVWF FSR0+1,0
001522 280B       04911 	INCF  pCmd_2,W,0
001524 6EE9       04912 	MOVWF FSR0,0
001526 CFEF F00E  04913 	MOVFF INDF0,input_3
00152A DA25       04914 	RCALL Trace_Hex
                  04915 			;			Trace_Hex(pCmd->data.loopEnd.depth);
00152C 0E02       04916 	MOVLW 2
00152E 6EEA       04917 	MOVWF FSR0+1,0
001530 0E04       04918 	MOVLW 4
001532 240B       04919 	ADDWF pCmd_2,W,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 83

ADDR   CODE       LINE  SOURCE

001534 6EE9       04920 	MOVWF FSR0,0
001536 CFEF F00E  04921 	MOVFF INDF0,input_3
00153A DA1D       04922 	RCALL Trace_Hex
                  04923 			;			Trace_Hex(pCmd->data.loopEnd.counter);
00153C 0E02       04924 	MOVLW 2
00153E 6EEA       04925 	MOVWF FSR0+1,0
001540 0E02       04926 	MOVLW 2
001542 240B       04927 	ADDWF pCmd_2,W,0
001544 6EE9       04928 	MOVWF FSR0,0
001546 CFEF F00E  04929 	MOVFF INDF0,input_3
00154A DA15       04930 	RCALL Trace_Hex
                  04931 			;			Trace_String("\n");
00154C 0EC5       04932 	MOVLW 197
00154E 6E0E       04933 	MOVWF string,0
001550 6A0F       04934 	CLRF  string+1,0
001552 D9A7       04935 	RCALL Trace_String
                  04936 			;			return ScriptCtrl_Write(pCmd);
001554 0E02       04937 	MOVLW 2
001556 6E0F       04938 	MOVWF pCmd_3+1,0
001558 C00B F00E  04939 	MOVFF pCmd_2,pCmd_3
00155C D16A       04940 	BRA   ScriptCtrl_Write
                  04941 			;		}
                  04942 			;		case WAIT:
                  04943 			;		{
                  04944 			;			return ScriptCtrl_Write(pCmd);
00155E 0E02       04945 m138	MOVLW 2
001560 6E0F       04946 	MOVWF pCmd_3+1,0
001562 C00B F00E  04947 	MOVFF pCmd_2,pCmd_3
001566 D165       04948 	BRA   ScriptCtrl_Write
                  04949 			;		}
                  04950 			;		case START_BL:
                  04951 			;		{
                  04952 			;			CommandIO_CreateResponse(&g_ResponseBuf, START_BL);
001568 0E60       04953 m139	MOVLW 96
00156A 6E0C       04954 	MOVWF mFrame_2,0
00156C 6A0D       04955 	CLRF  mFrame_2+1,0
00156E 0EF5       04956 	MOVLW 245
001570 DD37       04957 	RCALL CommandIO_CreateResponse
                  04958 			;			CommandIO_SendResponse(&g_ResponseBuf);
001572 0E60       04959 	MOVLW 96
001574 6E0C       04960 	MOVWF mFrame,0
001576 6A0D       04961 	CLRF  mFrame+1,0
001578 DCCB       04962 	RCALL CommandIO_SendResponse
                  04963 			;			Platform_EnableBootloaderAutostart();
00157A DDDC       04964 	RCALL Platform_EnableBootloaderAutostart
                  04965 			;			softReset();
00157C 00FF       04966 	RESET
                  04967 			;			/* never reach this */
                  04968 			;			return FALSE;
00157E 0C00       04969 	RETLW 0
                  04970 			;		}
                  04971 			;#ifdef __CC8E__
                  04972 			;		case GET_RTC:
                  04973 			;		{
                  04974 			;			return TRUE;
001580 0C01       04975 m140	RETLW 1
                  04976 			;		}
                  04977 			;		case SET_RTC:
                  04978 			;		{
                  04979 			;			g_RtcTime.tm_year = pCmd->data.set_rtc.tm_year;
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 84

ADDR   CODE       LINE  SOURCE

001582 0E02       04980 m141	MOVLW 2
001584 6EEA       04981 	MOVWF FSR0+1,0
001586 0E06       04982 	MOVLW 6
001588 240B       04983 	ADDWF pCmd_2,W,0
00158A 6EE9       04984 	MOVWF FSR0,0
00158C CFEF F028  04985 	MOVFF INDF0,g_RtcTime+5
                  04986 			;			g_RtcTime.tm_mon = pCmd->data.set_rtc.tm_mon;
001590 0E02       04987 	MOVLW 2
001592 6EEA       04988 	MOVWF FSR0+1,0
001594 0E05       04989 	MOVLW 5
001596 240B       04990 	ADDWF pCmd_2,W,0
001598 6EE9       04991 	MOVWF FSR0,0
00159A CFEF F027  04992 	MOVFF INDF0,g_RtcTime+4
                  04993 			;			g_RtcTime.tm_mday = pCmd->data.set_rtc.tm_mday;
00159E 0E02       04994 	MOVLW 2
0015A0 6EEA       04995 	MOVWF FSR0+1,0
0015A2 0E04       04996 	MOVLW 4
0015A4 240B       04997 	ADDWF pCmd_2,W,0
0015A6 6EE9       04998 	MOVWF FSR0,0
0015A8 CFEF F026  04999 	MOVFF INDF0,g_RtcTime+3
                  05000 			;			g_RtcTime.tm_wday = pCmd->data.set_rtc.tm_wday;
0015AC 0E02       05001 	MOVLW 2
0015AE 6EEA       05002 	MOVWF FSR0+1,0
0015B0 0E07       05003 	MOVLW 7
0015B2 240B       05004 	ADDWF pCmd_2,W,0
0015B4 6EE9       05005 	MOVWF FSR0,0
0015B6 CFEF F029  05006 	MOVFF INDF0,g_RtcTime+6
                  05007 			;			g_RtcTime.tm_hour = pCmd->data.set_rtc.tm_hour;
0015BA 0E02       05008 	MOVLW 2
0015BC 6EEA       05009 	MOVWF FSR0+1,0
0015BE 0E03       05010 	MOVLW 3
0015C0 240B       05011 	ADDWF pCmd_2,W,0
0015C2 6EE9       05012 	MOVWF FSR0,0
0015C4 CFEF F025  05013 	MOVFF INDF0,g_RtcTime+2
                  05014 			;			g_RtcTime.tm_min = pCmd->data.set_rtc.tm_min;
0015C8 0E02       05015 	MOVLW 2
0015CA 6EEA       05016 	MOVWF FSR0+1,0
0015CC 0E02       05017 	MOVLW 2
0015CE 240B       05018 	ADDWF pCmd_2,W,0
0015D0 6EE9       05019 	MOVWF FSR0,0
0015D2 CFEF F024  05020 	MOVFF INDF0,g_RtcTime+1
                  05021 			;			g_RtcTime.tm_sec = pCmd->data.set_rtc.tm_sec;
0015D6 0E02       05022 	MOVLW 2
0015D8 6EEA       05023 	MOVWF FSR0+1,0
0015DA 280B       05024 	INCF  pCmd_2,W,0
0015DC 6EE9       05025 	MOVWF FSR0,0
0015DE CFEF F023  05026 	MOVFF INDF0,g_RtcTime
                  05027 			;			Rtc_Ctl(RTC_SET_TIME, &g_RtcTime);
0015E2 6A10       05028 	CLRF  req,0
0015E4 0E23       05029 	MOVLW 35
0015E6 6E11       05030 	MOVWF pRtcTime,0
0015E8 6A12       05031 	CLRF  pRtcTime+1,0
0015EA DDF1       05032 	RCALL Rtc_Ctl
                  05033 			;			return TRUE;
0015EC 0C01       05034 	RETLW 1
                  05035 			;		}
                  05036 			;		case SET_COLOR_DIRECT:
                  05037 			;		{
                  05038 			;			Ledstrip_SetColorDirect(&pCmd->data.set_color_direct.ptr_led_array);
0015EE 280B       05039 m142	INCF  pCmd_2,W,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 85

ADDR   CODE       LINE  SOURCE

0015F0 6E0C       05040 	MOVWF pValues,0
0015F2 ECBA F002  05041 	CALL  Ledstrip_SetColorDirect
                  05042 			;			return TRUE;
0015F6 0C01       05043 	RETLW 1
                  05044 			;		}	
                  05045 			;		case GET_CYCLETIME:
                  05046 			;		{
                  05047 			;			return TRUE;
0015F8 0C01       05048 m143	RETLW 1
                  05049 			;		}
                  05050 			;		case GET_TRACE:
                  05051 			;		{
                  05052 			;			return TRUE;
0015FA 0C01       05053 m144	RETLW 1
                  05054 			;		}
                  05055 			;#endif /* #ifndef CC8E */
                  05056 			;		case GET_FW_VERSION:
                  05057 			;		{
                  05058 			;			return TRUE;
0015FC 0C01       05059 m145	RETLW 1
                  05060 			;		}
                  05061 			;	}
                  05062 			;	return ScriptCtrl_Write(pCmd);
0015FE 0E02       05063 m146	MOVLW 2
001600 6E0F       05064 	MOVWF pCmd_3+1,0
001602 C00B F00E  05065 	MOVFF pCmd_2,pCmd_3
001606 D115       05066 	BRA   ScriptCtrl_Write
                  05067 			;}
                  05068 			;
                  05069 			;void ScriptCtrl_Clear(void)
                  05070 			;{
                  05071 ScriptCtrl_Clear
                  05072 			;	ScriptBufSetInLoop(FALSE);
001608 0EFD       05073 	MOVLW 253
00160A 6E1B       05074 	MOVWF adress,0
00160C 0E03       05075 	MOVLW 3
00160E 6E1C       05076 	MOVWF adress+1,0
001610 6A1D       05077 	CLRF  data_2,0
001612 EC3F F001  05078 	CALL  Eeprom_Write
001616 6A36       05079 	CLRF  gScriptBuf+10,0
                  05080 			;	ScriptBufSetRead(EEPROM_SCRIPTBUF_BASE);
001618 0EFB       05081 	MOVLW 251
00161A 6E1B       05082 	MOVWF adress,0
00161C 0E03       05083 	MOVLW 3
00161E 6E1C       05084 	MOVWF adress+1,0
001620 6A1D       05085 	CLRF  data_2,0
001622 EC3F F001  05086 	CALL  Eeprom_Write
001626 6A34       05087 	CLRF  gScriptBuf+8,0
                  05088 			;	ScriptBufSetWrite(EEPROM_SCRIPTBUF_BASE);
001628 0EF9       05089 	MOVLW 249
00162A 6E1B       05090 	MOVWF adress,0
00162C 0E03       05091 	MOVLW 3
00162E 6E1C       05092 	MOVWF adress+1,0
001630 6A1D       05093 	CLRF  data_2,0
001632 EC3F F001  05094 	CALL  Eeprom_Write
001636 6A35       05095 	CLRF  gScriptBuf+9,0
                  05096 			;	gScriptBuf.execute = gScriptBuf.read;
001638 C034 F033  05097 	MOVFF gScriptBuf+8,gScriptBuf+7
                  05098 			;	gScriptBuf.waitValue = 0;
00163C 6A2C       05099 	CLRF  gScriptBuf,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 86

ADDR   CODE       LINE  SOURCE

00163E 6A2D       05100 	CLRF  gScriptBuf+1,0
                  05101 			;	gScriptBuf.isClearing = FALSE;
001640 9037       05102 	BCF   gScriptBuf+11,0,0
                  05103 			;}
001642 0012       05104 	RETURN
                  05105 			;
                  05106 			;void ScriptCtrl_Init(void)
                  05107 			;{
                  05108 ScriptCtrl_Init
                  05109 			;	gScriptBuf.inLoop = Eeprom_Read(EEPROM_SCRIPTBUF_INLOOP);
001644 0EFD       05110 	MOVLW 253
001646 6E12       05111 	MOVWF adress_2,0
001648 0E03       05112 	MOVLW 3
00164A 6E13       05113 	MOVWF adress_2+1,0
00164C EC59 F001  05114 	CALL  Eeprom_Read
001650 6E36       05115 	MOVWF gScriptBuf+10,0
                  05116 			;	gScriptBuf.read = Eeprom_Read(EEPROM_SCRIPTBUF_READ);
001652 0EFB       05117 	MOVLW 251
001654 6E12       05118 	MOVWF adress_2,0
001656 0E03       05119 	MOVLW 3
001658 6E13       05120 	MOVWF adress_2+1,0
00165A EC59 F001  05121 	CALL  Eeprom_Read
00165E 6E34       05122 	MOVWF gScriptBuf+8,0
                  05123 			;	gScriptBuf.write = Eeprom_Read(EEPROM_SCRIPTBUF_WRITE);
001660 0EF9       05124 	MOVLW 249
001662 6E12       05125 	MOVWF adress_2,0
001664 0E03       05126 	MOVLW 3
001666 6E13       05127 	MOVWF adress_2+1,0
001668 EC59 F001  05128 	CALL  Eeprom_Read
00166C 6E35       05129 	MOVWF gScriptBuf+9,0
                  05130 			;	gScriptBuf.execute = gScriptBuf.read;
00166E C034 F033  05131 	MOVFF gScriptBuf+8,gScriptBuf+7
                  05132 			;}
001672 0012       05133 	RETURN
                  05134 			;//TODO Add a Methode to test the Errorbits and there responses
                  05135 			;
                  05136 			;void ScriptCtrl_Run(void)
                  05137 			;{
                  05138 ScriptCtrl_Run
                  05139 			;	/* delete command was triggered? */
                  05140 			;	if(gScriptBuf.isClearing)
001674 B037       05141 	BTFSC gScriptBuf+11,0,0
                  05142 			;	{
                  05143 			;		ScriptCtrl_Clear();
001676 DFC8       05144 	RCALL ScriptCtrl_Clear
                  05145 			;	}
                  05146 			;#ifdef __CC8E__
                  05147 			;	if(gScriptBuf.waitValue > 0)
001678 502C       05148 	MOVF  gScriptBuf,W,0
00167A 102D       05149 	IORWF gScriptBuf+1,W,0
00167C A4D8       05150 	BTFSS 0xFD8,Zero_,0
                  05151 			;	{
                  05152 			;		return;
00167E 0012       05153 	RETURN
                  05154 			;	}
                  05155 			;#endif /* #ifdef CC8E */	
                  05156 			;	/* cmd available? */
                  05157 			;	if(gScriptBuf.execute == gScriptBuf.write)
001680 5033       05158 	MOVF  gScriptBuf+7,W,0
001682 6235       05159 	CPFSEQ gScriptBuf+9,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 87

ADDR   CODE       LINE  SOURCE

001684 D001       05160 	BRA   m147
                  05161 			;	{
                  05162 			;		return;
001686 0012       05163 	RETURN
                  05164 			;	}
                  05165 			;
                  05166 			;	/* read next cmd from buffer */
                  05167 			;	uns16 tempAddress = ScriptBufAddr(gScriptBuf.execute);
001688 C033 F018  05168 m147	MOVFF gScriptBuf+7,arg1
00168C 0E0B       05169 	MOVLW 11
00168E EC0A F002  05170 	CALL  _mult8x8
001692 501A       05171 	MOVF  rval,W,0
001694 6E0A       05172 	MOVWF tempAddress,0
001696 501B       05173 	MOVF  rval+1,W,0
001698 6E0B       05174 	MOVWF tempAddress+1,0
                  05175 			;	Eeprom_ReadBlock((uns8*)&nextCmd, tempAddress, sizeof(nextCmd));
00169A 0E45       05176 	MOVLW 69
00169C 6E0C       05177 	MOVWF array_2,0
00169E C00A F00D  05178 	MOVFF tempAddress,adress_4
0016A2 C00B F00E  05179 	MOVFF tempAddress+1,adress_4+1
0016A6 0E0B       05180 	MOVLW 11
0016A8 6E0F       05181 	MOVWF length_3,0
0016AA EC84 F001  05182 	CALL  Eeprom_ReadBlock
                  05183 			;
                  05184 			;	switch(nextCmd.cmd)
0016AE 5045       05185 	MOVF  nextCmd,W,0
0016B0 0AF7       05186 	XORLW 247
0016B2 B4D8       05187 	BTFSC 0xFD8,Zero_,0
0016B4 D00A       05188 	BRA   m148
0016B6 0A01       05189 	XORLW 1
0016B8 B4D8       05190 	BTFSC 0xFD8,Zero_,0
0016BA D019       05191 	BRA   m149
0016BC 0A0A       05192 	XORLW 10
0016BE B4D8       05193 	BTFSC 0xFD8,Zero_,0
0016C0 D07D       05194 	BRA   m153
0016C2 0A02       05195 	XORLW 2
0016C4 B4D8       05196 	BTFSC 0xFD8,Zero_,0
0016C6 D09B       05197 	BRA   m155
0016C8 D0B3       05198 	BRA   m156
                  05199 			;	{
                  05200 			;		case LOOP_ON:
                  05201 			;		{
                  05202 			;			Trace_String("LOOP_ON\n");
0016CA 0ED6       05203 m148	MOVLW 214
0016CC 6E0E       05204 	MOVWF string,0
0016CE 6A0F       05205 	CLRF  string+1,0
0016D0 D8E8       05206 	RCALL Trace_String
                  05207 			;			/* move execute pointer to the next command */
                  05208 			;			gScriptBuf.execute = ScriptBufInc(gScriptBuf.execute);
0016D2 2833       05209 	INCF  gScriptBuf+7,W,0
0016D4 0B3F       05210 	ANDLW 63
0016D6 6E33       05211 	MOVWF gScriptBuf+7,0
                  05212 			;			ScriptBufSetInLoop(TRUE);
0016D8 0EFD       05213 	MOVLW 253
0016DA 6E1B       05214 	MOVWF adress,0
0016DC 0E03       05215 	MOVLW 3
0016DE 6E1C       05216 	MOVWF adress+1,0
0016E0 0E01       05217 	MOVLW 1
0016E2 6E1D       05218 	MOVWF data_2,0
0016E4 EC3F F001  05219 	CALL  Eeprom_Write
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 88

ADDR   CODE       LINE  SOURCE

0016E8 0E01       05220 	MOVLW 1
0016EA 6E36       05221 	MOVWF gScriptBuf+10,0
                  05222 			;			break;
0016EC D0A1       05223 	BRA   m156
                  05224 			;		}
                  05225 			;		case LOOP_OFF:
                  05226 			;		{
                  05227 			;			if(LOOP_INFINITE == nextCmd.data.loopEnd.counter)
0016EE 5247       05228 m149	MOVF  nextCmd+2,1,0
0016F0 A4D8       05229 	BTFSS 0xFD8,Zero_,0
0016F2 D007       05230 	BRA   m150
                  05231 			;			{
                  05232 			;				Trace_String("End of infinite loop reached\n");
0016F4 0EDF       05233 	MOVLW 223
0016F6 6E0E       05234 	MOVWF string,0
0016F8 6A0F       05235 	CLRF  string+1,0
0016FA D8D3       05236 	RCALL Trace_String
                  05237 			;				/* move execute pointer to the top of this loop */
                  05238 			;				gScriptBuf.execute = nextCmd.data.loopEnd.startIndex;
0016FC C046 F033  05239 	MOVFF nextCmd+1,gScriptBuf+7
                  05240 			;			}
                  05241 			;			else if(nextCmd.data.loopEnd.counter > 1)
001700 D097       05242 	BRA   m156
001702 0E01       05243 m150	MOVLW 1
001704 6447       05244 	CPFSGT nextCmd+2,0
001706 D01D       05245 	BRA   m151
                  05246 			;			{
                  05247 			;				Trace_String("normal loop iteration");
001708 0EFD       05248 	MOVLW 253
00170A 6E0E       05249 	MOVWF string,0
00170C 6A0F       05250 	CLRF  string+1,0
00170E D8C9       05251 	RCALL Trace_String
                  05252 			;				Trace_Hex(nextCmd.data.loopEnd.counter);
001710 C047 F00E  05253 	MOVFF nextCmd+2,input_3
001714 D930       05254 	RCALL Trace_Hex
                  05255 			;				Trace_Hex(nextCmd.data.loopEnd.depth);
001716 C049 F00E  05256 	MOVFF nextCmd+4,input_3
00171A D92D       05257 	RCALL Trace_Hex
                  05258 			;				Trace_String("\n");
00171C 0EC5       05259 	MOVLW 197
00171E 6E0E       05260 	MOVWF string,0
001720 6A0F       05261 	CLRF  string+1,0
001722 D8BF       05262 	RCALL Trace_String
                  05263 			;				/* update counter and set execute pointer to start of the loop */
                  05264 			;				nextCmd.data.loopEnd.counter--;
001724 0647       05265 	DECF  nextCmd+2,1,0
                  05266 			;				Eeprom_WriteBlock((uns8*)&nextCmd, tempAddress, sizeof(struct led_cmd));
001726 0E45       05267 	MOVLW 69
001728 6E13       05268 	MOVWF array,0
00172A 6A14       05269 	CLRF  array+1,0
00172C C00A F015  05270 	MOVFF tempAddress,adress_3
001730 C00B F016  05271 	MOVFF tempAddress+1,adress_3+1
001734 0E0B       05272 	MOVLW 11
001736 6E17       05273 	MOVWF length_2,0
001738 EC64 F001  05274 	CALL  Eeprom_WriteBlock
                  05275 			;
                  05276 			;				/* move execute pointer to the top of this loop */
                  05277 			;				gScriptBuf.execute = nextCmd.data.loopEnd.startIndex;
00173C C046 F033  05278 	MOVFF nextCmd+1,gScriptBuf+7
                  05279 			;			}
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 89

ADDR   CODE       LINE  SOURCE

                  05280 			;			else
001740 D077       05281 	BRA   m156
                  05282 			;			{
                  05283 			;				if(0 == nextCmd.data.loopEnd.depth)
001742 5249       05284 m151	MOVF  nextCmd+4,1,0
001744 A4D8       05285 	BTFSS 0xFD8,Zero_,0
001746 D01B       05286 	BRA   m152
                  05287 			;				{
                  05288 			;					Trace_String("End of top loop reached\n");
001748 0E13       05289 	MOVLW 19
00174A 6E0E       05290 	MOVWF string,0
00174C 0E01       05291 	MOVLW 1
00174E 6E0F       05292 	MOVWF string+1,0
001750 D8A8       05293 	RCALL Trace_String
                  05294 			;					/* move execute pointer to the next command */
                  05295 			;					gScriptBuf.execute = ScriptBufInc(gScriptBuf.execute);
001752 2833       05296 	INCF  gScriptBuf+7,W,0
001754 0B3F       05297 	ANDLW 63
001756 6E33       05298 	MOVWF gScriptBuf+7,0
                  05299 			;
                  05300 			;					/* delete loop body from buffer */
                  05301 			;					ScriptBufSetRead(gScriptBuf.execute);
001758 0EFB       05302 	MOVLW 251
00175A 6E1B       05303 	MOVWF adress,0
00175C 0E03       05304 	MOVLW 3
00175E 6E1C       05305 	MOVWF adress+1,0
001760 C033 F01D  05306 	MOVFF gScriptBuf+7,data_2
001764 EC3F F001  05307 	CALL  Eeprom_Write
001768 C033 F034  05308 	MOVFF gScriptBuf+7,gScriptBuf+8
                  05309 			;					ScriptBufSetInLoop(FALSE);
00176C 0EFD       05310 	MOVLW 253
00176E 6E1B       05311 	MOVWF adress,0
001770 0E03       05312 	MOVLW 3
001772 6E1C       05313 	MOVWF adress+1,0
001774 6A1D       05314 	CLRF  data_2,0
001776 EC3F F001  05315 	CALL  Eeprom_Write
00177A 6A36       05316 	CLRF  gScriptBuf+10,0
                  05317 			;				}
                  05318 			;				else
00177C D059       05319 	BRA   m156
                  05320 			;				{
                  05321 			;					Trace_String("End of inner loop reached\n");
00177E 0E2C       05322 m152	MOVLW 44
001780 6E0E       05323 	MOVWF string,0
001782 0E01       05324 	MOVLW 1
001784 6E0F       05325 	MOVWF string+1,0
001786 D88D       05326 	RCALL Trace_String
                  05327 			;					/* reinit counter for next iteration */
                  05328 			;					nextCmd.data.loopEnd.counter = nextCmd.data.loopEnd.numLoops;
001788 C048 F047  05329 	MOVFF nextCmd+3,nextCmd+2
                  05330 			;					uns16 tempAddress = ScriptBufAddr(gScriptBuf.execute);
00178C C033 F018  05331 	MOVFF gScriptBuf+7,arg1
001790 0E0B       05332 	MOVLW 11
001792 EC0A F002  05333 	CALL  _mult8x8
001796 501A       05334 	MOVF  rval,W,0
001798 6E0C       05335 	MOVWF tempAddress_2,0
00179A 501B       05336 	MOVF  rval+1,W,0
00179C 6E0D       05337 	MOVWF tempAddress_2+1,0
                  05338 			;					Eeprom_WriteBlock((uns8*)&nextCmd, tempAddress, sizeof(struct led_cmd));
00179E 0E45       05339 	MOVLW 69
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 90

ADDR   CODE       LINE  SOURCE

0017A0 6E13       05340 	MOVWF array,0
0017A2 6A14       05341 	CLRF  array+1,0
0017A4 C00C F015  05342 	MOVFF tempAddress_2,adress_3
0017A8 C00D F016  05343 	MOVFF tempAddress_2+1,adress_3+1
0017AC 0E0B       05344 	MOVLW 11
0017AE 6E17       05345 	MOVWF length_2,0
0017B0 EC64 F001  05346 	CALL  Eeprom_WriteBlock
                  05347 			;
                  05348 			;					/* move execute pointer to the next command */
                  05349 			;					gScriptBuf.execute = ScriptBufInc(gScriptBuf.execute);
0017B4 2833       05350 	INCF  gScriptBuf+7,W,0
0017B6 0B3F       05351 	ANDLW 63
0017B8 6E33       05352 	MOVWF gScriptBuf+7,0
                  05353 			;				}
                  05354 			;			}
                  05355 			;			break;
0017BA D03A       05356 	BRA   m156
                  05357 			;		}
                  05358 			;		case SET_FADE:
                  05359 			;		{
                  05360 			;			Ledstrip_SetFade(&nextCmd.data.set_fade);
0017BC 0E46       05361 m153	MOVLW 70
0017BE 6E0C       05362 	MOVWF pCmd,0
0017C0 EC97 F003  05363 	CALL  Ledstrip_SetFade
                  05364 			;			if(nextCmd.data.set_fade.parallelFade == 0)
0017C4 524D       05365 	MOVF  nextCmd+8,1,0
0017C6 A4D8       05366 	BTFSS 0xFD8,Zero_,0
0017C8 D009       05367 	BRA   m154
                  05368 			;			{
                  05369 			;				gScriptBuf.waitValue = ntohs(nextCmd.data.set_fade.fadeTmms);
0017CA C04E F01A  05370 	MOVFF nextCmd+9,networkShort
0017CE C04F F01B  05371 	MOVFF nextCmd+10,networkShort+1
0017D2 DCBC       05372 	RCALL ntohs
0017D4 C01C F02C  05373 	MOVFF retval_2,gScriptBuf
0017D8 C01D F02D  05374 	MOVFF retval_2+1,gScriptBuf+1
                  05375 			;			}
                  05376 			;			
                  05377 			;			/* move execute pointer to the next command */
                  05378 			;			gScriptBuf.execute = ScriptBufInc(gScriptBuf.execute);
0017DC 2833       05379 m154	INCF  gScriptBuf+7,W,0
0017DE 0B3F       05380 	ANDLW 63
0017E0 6E33       05381 	MOVWF gScriptBuf+7,0
                  05382 			;			if(!gScriptBuf.inLoop)
0017E2 5236       05383 	MOVF  gScriptBuf+10,1,0
0017E4 A4D8       05384 	BTFSS 0xFD8,Zero_,0
0017E6 D024       05385 	BRA   m156
                  05386 			;			{
                  05387 			;				ScriptBufSetRead(gScriptBuf.execute);
0017E8 0EFB       05388 	MOVLW 251
0017EA 6E1B       05389 	MOVWF adress,0
0017EC 0E03       05390 	MOVLW 3
0017EE 6E1C       05391 	MOVWF adress+1,0
0017F0 C033 F01D  05392 	MOVFF gScriptBuf+7,data_2
0017F4 EC3F F001  05393 	CALL  Eeprom_Write
0017F8 C033 F034  05394 	MOVFF gScriptBuf+7,gScriptBuf+8
                  05395 			;			}
                  05396 			;			break;
0017FC D019       05397 	BRA   m156
                  05398 			;		}
                  05399 			;		case WAIT:
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 91

ADDR   CODE       LINE  SOURCE

                  05400 			;		{
                  05401 			;			/* TODO we should disable interrupts while changing waitValue */
                  05402 			;			gScriptBuf.waitValue = ntohs(nextCmd.data.wait.waitTmms);
0017FE C046 F01A  05403 m155	MOVFF nextCmd+1,networkShort
001802 C047 F01B  05404 	MOVFF nextCmd+2,networkShort+1
001806 DCA2       05405 	RCALL ntohs
001808 C01C F02C  05406 	MOVFF retval_2,gScriptBuf
00180C C01D F02D  05407 	MOVFF retval_2+1,gScriptBuf+1
                  05408 			;			/* move execute pointer to the next command */
                  05409 			;			gScriptBuf.execute = ScriptBufInc(gScriptBuf.execute);
001810 2833       05410 	INCF  gScriptBuf+7,W,0
001812 0B3F       05411 	ANDLW 63
001814 6E33       05412 	MOVWF gScriptBuf+7,0
                  05413 			;			if(!gScriptBuf.inLoop)
001816 5236       05414 	MOVF  gScriptBuf+10,1,0
001818 A4D8       05415 	BTFSS 0xFD8,Zero_,0
00181A D00A       05416 	BRA   m156
                  05417 			;			{
                  05418 			;				ScriptBufSetRead(gScriptBuf.execute);
00181C 0EFB       05419 	MOVLW 251
00181E 6E1B       05420 	MOVWF adress,0
001820 0E03       05421 	MOVLW 3
001822 6E1C       05422 	MOVWF adress+1,0
001824 C033 F01D  05423 	MOVFF gScriptBuf+7,data_2
001828 EC3F F001  05424 	CALL  Eeprom_Write
00182C C033 F034  05425 	MOVFF gScriptBuf+7,gScriptBuf+8
                  05426 			;			}
                  05427 			;			break;
                  05428 			;		}
                  05429 			;	}
                  05430 			;}
001830 0012       05431 m156	RETURN
                  05432 			;
                  05433 			;uns8 ScriptCtrl_Write(const struct led_cmd* pCmd)
                  05434 			;{
                  05435 ScriptCtrl_Write
                  05436 			;	uns8 writeNext = ScriptBufInc(gScriptBuf.write);
001832 2835       05437 	INCF  gScriptBuf+9,W,0
001834 0B3F       05438 	ANDLW 63
001836 6E10       05439 	MOVWF writeNext_2,0
                  05440 			;	if(writeNext != gScriptBuf.read)
001838 5010       05441 	MOVF  writeNext_2,W,0
00183A 1834       05442 	XORWF gScriptBuf+8,W,0
00183C B4D8       05443 	BTFSC 0xFD8,Zero_,0
00183E D020       05444 	BRA   m157
                  05445 			;	{
                  05446 			;		uns16 tempAddress = ScriptBufAddr(gScriptBuf.write);
001840 C035 F018  05447 	MOVFF gScriptBuf+9,arg1
001844 0E0B       05448 	MOVLW 11
001846 EC0A F002  05449 	CALL  _mult8x8
00184A 501A       05450 	MOVF  rval,W,0
00184C 6E11       05451 	MOVWF tempAddress_3,0
00184E 501B       05452 	MOVF  rval+1,W,0
001850 6E12       05453 	MOVWF tempAddress_3+1,0
                  05454 			;		Eeprom_WriteBlock((const uns8*)pCmd, tempAddress, sizeof(struct led_cmd));
001852 C00E F013  05455 	MOVFF pCmd_3,array
001856 C00F F014  05456 	MOVFF pCmd_3+1,array+1
00185A C011 F015  05457 	MOVFF tempAddress_3,adress_3
00185E C012 F016  05458 	MOVFF tempAddress_3+1,adress_3+1
001862 0E0B       05459 	MOVLW 11
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 92

ADDR   CODE       LINE  SOURCE

001864 6E17       05460 	MOVWF length_2,0
001866 EC64 F001  05461 	CALL  Eeprom_WriteBlock
                  05462 			;		ScriptBufSetWrite(writeNext);
00186A 0EF9       05463 	MOVLW 249
00186C 6E1B       05464 	MOVWF adress,0
00186E 0E03       05465 	MOVLW 3
001870 6E1C       05466 	MOVWF adress+1,0
001872 C010 F01D  05467 	MOVFF writeNext_2,data_2
001876 EC3F F001  05468 	CALL  Eeprom_Write
00187A C010 F035  05469 	MOVFF writeNext_2,gScriptBuf+9
                  05470 			;		return TRUE;
00187E 0C01       05471 	RETLW 1
                  05472 			;	}
                  05473 			;	return FALSE;
001880 0C00       05474 m157	RETLW 0
                  05475 
                  05476   ; FILE trace.c
                  05477 			;/**
                  05478 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  05479 			; 
                  05480 			; This file is part of Wifly_Light.
                  05481 			; 
                  05482 			; Wifly_Light is free software: you can redistribute it and/or modify
                  05483 			; it under the terms of the GNU General Public License as published by
                  05484 			; the Free Software Foundation, either version 3 of the License, or
                  05485 			; (at your option) any later version.
                  05486 			; 
                  05487 			; Wifly_Light is distributed in the hope that it will be useful,
                  05488 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  05489 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  05490 			; GNU General Public License for more details.
                  05491 			; 
                  05492 			; You should have received a copy of the GNU General Public License
                  05493 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  05494 			;
                  05495 			;#include "trace.h"
                  05496 			;
                  05497 			;#if defined(DEBUG) && defined(__CC8E__)
                  05498 			;struct RingBuffer g_TraceBuf;
                  05499 			;
                  05500 			;void PutToBuf(const uns8 Byte)
                  05501 			;{
                  05502 PutToBuf
                  05503 			;	if(RingBuf_HasError(&g_TraceBuf)) return;
001882 0E03       05504 	MOVLW 3
001884 6E02       05505 	MOVWF pBuf_4,0
001886 0E08       05506 	MOVLW 8
001888 6E03       05507 	MOVWF pBuf_4+1,0
00188A EC78 F006  05508 	CALL  RingBuf_HasError
00188E B0D8       05509 	BTFSC 0xFD8,Carry,0
001890 0012       05510 	RETURN
                  05511 			;	RingBuf_Put(&g_TraceBuf, Byte);
001892 0E03       05512 	MOVLW 3
001894 6E02       05513 	MOVWF pBuf_3,0
001896 0E08       05514 	MOVLW 8
001898 6E03       05515 	MOVWF pBuf_3+1,0
00189A C011 F004  05516 	MOVFF Byte,value
00189E EF4A F006  05517 	GOTO  RingBuf_Put
                  05518 			;}
                  05519 			;	
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 93

ADDR   CODE       LINE  SOURCE

                  05520 			;void Trace_String(const char *string)
                  05521 			;{
                  05522 Trace_String
                  05523 			;	if(RingBuf_HasError(&g_TraceBuf)) return;
0018A2 0E03       05524 	MOVLW 3
0018A4 6E02       05525 	MOVWF pBuf_4,0
0018A6 0E08       05526 	MOVLW 8
0018A8 6E03       05527 	MOVWF pBuf_4+1,0
0018AA EC78 F006  05528 	CALL  RingBuf_HasError
0018AE B0D8       05529 	BTFSC 0xFD8,Carry,0
0018B0 0012       05530 	RETURN
                  05531 			;	uns8 ps;
                  05532 			;	ps = *string;
0018B2 C00E F011  05533 	MOVFF string,ci_4
0018B6 C00F F012  05534 	MOVFF string+1,ci_4+1
0018BA D8CA       05535 	RCALL _const4
0018BC 6E10       05536 	MOVWF ps,0
                  05537 			;	while(ps > 0)
0018BE 5210       05538 m158	MOVF  ps,1,0
0018C0 B4D8       05539 	BTFSC 0xFD8,Zero_,0
0018C2 D00D       05540 	BRA   m159
                  05541 			;	{
                  05542 			;		string++;
0018C4 2A0E       05543 	INCF  string,1,0
0018C6 0E00       05544 	MOVLW 0
0018C8 220F       05545 	ADDWFC string+1,1,0
                  05546 			;		PutToBuf(ps);
0018CA C010 F011  05547 	MOVFF ps,Byte
0018CE DFD9       05548 	RCALL PutToBuf
                  05549 			;		ps = *string;
0018D0 C00E F011  05550 	MOVFF string,ci_4
0018D4 C00F F012  05551 	MOVFF string+1,ci_4+1
0018D8 D8BB       05552 	RCALL _const4
0018DA 6E10       05553 	MOVWF ps,0
                  05554 			;   }
0018DC D7F0       05555 	BRA   m158
                  05556 			;}
0018DE 0012       05557 m159	RETURN
                  05558 			;
                  05559 			;void Trace_Char(const uns8 input)
                  05560 			;{
                  05561 Trace_Char
                  05562 			;	PutToBuf(input);
0018E0 CF7F F011  05563 	MOVFF input,Byte
0018E4 D7CE       05564 	BRA   PutToBuf
                  05565 			;}
                  05566 			;	
                  05567 			;void Trace_Number(const uns8 input)
                  05568 			;{
                  05569 Trace_Number
                  05570 			;	if(RingBuf_HasError(&g_TraceBuf)) return;
0018E6 0E03       05571 	MOVLW 3
0018E8 6E02       05572 	MOVWF pBuf_4,0
0018EA 0E08       05573 	MOVLW 8
0018EC 6E03       05574 	MOVWF pBuf_4+1,0
0018EE EC78 F006  05575 	CALL  RingBuf_HasError
0018F2 B0D8       05576 	BTFSC 0xFD8,Carry,0
0018F4 0012       05577 	RETURN
                  05578 			;	uns8 temp;
                  05579 			;	uns8 h,z,e;
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 94

ADDR   CODE       LINE  SOURCE

                  05580 			; 
                  05581 			;	h = 0;
0018F6 6A7F       05582 	CLRF  h,0
                  05583 			;	z = 0;
0018F8 6A7F       05584 	CLRF  z,0
                  05585 			;	e = 0;
0018FA 6A7F       05586 	CLRF  e,0
                  05587 			;   
                  05588 			;	if (input > 99)
0018FC 0E63       05589 	MOVLW 99
0018FE 647F       05590 	CPFSGT input_2,0
001900 D012       05591 	BRA   m160
                  05592 			;	{
                  05593 			;		h = input / 100;
001902 CF7F F01D  05594 	MOVFF input_2,arg1_5
001906 6A1E       05595 	CLRF  arg1_5+1,0
001908 0E64       05596 	MOVLW 100
00190A EC18 F002  05597 	CALL  _divU16_8
00190E C01D FF7F  05598 	MOVFF arg1_5,h
                  05599 			;		temp = 0;
001912 6A7F       05600 	CLRF  temp_5,0
                  05601 			;		temp = 100 * h;
001914 0E64       05602 	MOVLW 100
001916 6E18       05603 	MOVWF arg1,0
001918 507F       05604 	MOVF  h,W,0
00191A EC0A F002  05605 	CALL  _mult8x8
00191E C01A FF7F  05606 	MOVFF rval,temp_5
                  05607 			;		input = input - temp;
001922 507F       05608 	MOVF  temp_5,W,0
001924 5E7F       05609 	SUBWF input_2,1,0
                  05610 			;	}
                  05611 			;
                  05612 			;	if (input > 9)
001926 0E09       05613 m160	MOVLW 9
001928 647F       05614 	CPFSGT input_2,0
00192A D012       05615 	BRA   m161
                  05616 			;	{
                  05617 			;		z = input / 10;
00192C CF7F F01D  05618 	MOVFF input_2,arg1_5
001930 6A1E       05619 	CLRF  arg1_5+1,0
001932 0E0A       05620 	MOVLW 10
001934 EC18 F002  05621 	CALL  _divU16_8
001938 C01D FF7F  05622 	MOVFF arg1_5,z
                  05623 			;		temp = 0;
00193C 6A7F       05624 	CLRF  temp_5,0
                  05625 			;		temp = z * 10;
00193E CF7F F018  05626 	MOVFF z,arg1
001942 0E0A       05627 	MOVLW 10
001944 EC0A F002  05628 	CALL  _mult8x8
001948 C01A FF7F  05629 	MOVFF rval,temp_5
                  05630 			;		input = input - temp;
00194C 507F       05631 	MOVF  temp_5,W,0
00194E 5E7F       05632 	SUBWF input_2,1,0
                  05633 			;	}
                  05634 			;
                  05635 			;	if (input <= 9)
001950 0E09       05636 m161	MOVLW 9
001952 647F       05637 	CPFSGT input_2,0
                  05638 			;	{
                  05639 			;		e = input;
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 95

ADDR   CODE       LINE  SOURCE

001954 CF7F FF7F  05640 	MOVFF input_2,e
                  05641 			;	}
                  05642 			;	   
                  05643 			;	if(h != 0) PutToBuf(h + 0x30);
001958 507F       05644 	MOVF  h,W,0
00195A B4D8       05645 	BTFSC 0xFD8,Zero_,0
00195C D004       05646 	BRA   m162
00195E 0E30       05647 	MOVLW 48
001960 247F       05648 	ADDWF h,W,0
001962 6E11       05649 	MOVWF Byte,0
001964 DF8E       05650 	RCALL PutToBuf
                  05651 			;	
                  05652 			;	PutToBuf(z + 0x30);
001966 0E30       05653 m162	MOVLW 48
001968 247F       05654 	ADDWF z,W,0
00196A 6E11       05655 	MOVWF Byte,0
00196C DF8A       05656 	RCALL PutToBuf
                  05657 			;    
                  05658 			;	PutToBuf(e + 0x30);
00196E 0E30       05659 	MOVLW 48
001970 247F       05660 	ADDWF e,W,0
001972 6E11       05661 	MOVWF Byte,0
001974 D786       05662 	BRA   PutToBuf
                  05663 			;}
                  05664 			;	
                  05665 			;void Trace_Hex(const uns8 input)
                  05666 			;{
                  05667 Trace_Hex
                  05668 			;	if(RingBuf_HasError(&g_TraceBuf)) return;
001976 0E03       05669 	MOVLW 3
001978 6E02       05670 	MOVWF pBuf_4,0
00197A 0E08       05671 	MOVLW 8
00197C 6E03       05672 	MOVWF pBuf_4+1,0
00197E EC78 F006  05673 	CALL  RingBuf_HasError
001982 B0D8       05674 	BTFSC 0xFD8,Carry,0
001984 0012       05675 	RETURN
                  05676 			;	
                  05677 			;	uns8 temp4 = input & 0xf0;
001986 0EF0       05678 	MOVLW 240
001988 140E       05679 	ANDWF input_3,W,0
00198A 6E0F       05680 	MOVWF temp4,0
                  05681 			;	temp4 = temp4 >> 4;
00198C 380F       05682 	SWAPF temp4,W,0
00198E 0B0F       05683 	ANDLW 15
001990 6E0F       05684 	MOVWF temp4,0
                  05685 			;	if(temp4 > 9)
001992 0E09       05686 	MOVLW 9
001994 640F       05687 	CPFSGT temp4,0
001996 D007       05688 	BRA   m163
                  05689 			;	{
                  05690 			;		temp4 -= 10;
001998 0E0A       05691 	MOVLW 10
00199A 5E0F       05692 	SUBWF temp4,1,0
                  05693 			;		PutToBuf(temp4 + 'A');
00199C 0E41       05694 	MOVLW 65
00199E 240F       05695 	ADDWF temp4,W,0
0019A0 6E11       05696 	MOVWF Byte,0
0019A2 DF6F       05697 	RCALL PutToBuf
                  05698 			;	}
                  05699 			;	else
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 96

ADDR   CODE       LINE  SOURCE

0019A4 D004       05700 	BRA   m164
                  05701 			;	{
                  05702 			;		PutToBuf(temp4 + '0');
0019A6 0E30       05703 m163	MOVLW 48
0019A8 240F       05704 	ADDWF temp4,W,0
0019AA 6E11       05705 	MOVWF Byte,0
0019AC DF6A       05706 	RCALL PutToBuf
                  05707 			;	}
                  05708 			;	
                  05709 			;	temp4 = input & 0x0f;
0019AE 0E0F       05710 m164	MOVLW 15
0019B0 140E       05711 	ANDWF input_3,W,0
0019B2 6E0F       05712 	MOVWF temp4,0
                  05713 			;	if(temp4 > 9)
0019B4 0E09       05714 	MOVLW 9
0019B6 640F       05715 	CPFSGT temp4,0
0019B8 D007       05716 	BRA   m165
                  05717 			;	{
                  05718 			;		temp4 -= 10;
0019BA 0E0A       05719 	MOVLW 10
0019BC 5E0F       05720 	SUBWF temp4,1,0
                  05721 			;		PutToBuf(temp4 + 'A');
0019BE 0E41       05722 	MOVLW 65
0019C0 240F       05723 	ADDWF temp4,W,0
0019C2 6E11       05724 	MOVWF Byte,0
0019C4 DF5E       05725 	RCALL PutToBuf
                  05726 			;	}
                  05727 			;	else
0019C6 D004       05728 	BRA   m166
                  05729 			;	{
                  05730 			;		PutToBuf(temp4 + '0');
0019C8 0E30       05731 m165	MOVLW 48
0019CA 240F       05732 	ADDWF temp4,W,0
0019CC 6E11       05733 	MOVWF Byte,0
0019CE D759       05734 	BRA   PutToBuf
                  05735 			;	}
                  05736 			;}
0019D0 0012       05737 m166	RETURN
                  05738 			;
                  05739 			;void Trace_Hex16(const uns16 input)
                  05740 			;{
                  05741 Trace_Hex16
                  05742 			;	Trace_Hex(input.high8);
0019D2 C00D F00E  05743 	MOVFF input_4+1,input_3
0019D6 DFCF       05744 	RCALL Trace_Hex
                  05745 			;    Trace_Hex(input.low8);
0019D8 C00C F00E  05746 	MOVFF input_4,input_3
0019DC D7CC       05747 	BRA   Trace_Hex
                  05748 			;}
                  05749 			;	
                  05750 			;uns8 Trace_Print(uns8 *pArray, const uns16 arraySize)
                  05751 			;{
                  05752 Trace_Print
                  05753 			;	uns16 i = 0;
0019DE 6A15       05754 	CLRF  i_9,0
0019E0 6A16       05755 	CLRF  i_9+1,0
                  05756 			;	uns8 tempByte;
                  05757 			;	while(RingBuf_IsEmpty(&g_TraceBuf) == 0 && i < arraySize)
0019E2 0E03       05758 m167	MOVLW 3
0019E4 6E18       05759 	MOVWF pBuf_5,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 97

ADDR   CODE       LINE  SOURCE

0019E6 0E08       05760 	MOVLW 8
0019E8 6E19       05761 	MOVWF pBuf_5+1,0
0019EA EC82 F006  05762 	CALL  RingBuf_IsEmpty
0019EE B0D8       05763 	BTFSC 0xFD8,Carry,0
0019F0 D01A       05764 	BRA   m168
0019F2 5013       05765 	MOVF  arraySize_2,W,0
0019F4 5C15       05766 	SUBWF i_9,W,0
0019F6 5014       05767 	MOVF  arraySize_2+1,W,0
0019F8 5816       05768 	SUBWFB i_9+1,W,0
0019FA B0D8       05769 	BTFSC 0xFD8,Carry,0
0019FC D014       05770 	BRA   m168
                  05771 			;	{
                  05772 			;	    tempByte = RingBuf_Get(&g_TraceBuf);
0019FE 0E03       05773 	MOVLW 3
001A00 6E18       05774 	MOVWF pBuf_2,0
001A02 0E08       05775 	MOVLW 8
001A04 6E19       05776 	MOVWF pBuf_2+1,0
001A06 EC2D F006  05777 	CALL  RingBuf_Get
001A0A 6E17       05778 	MOVWF tempByte_2,0
                  05779 			;		*pArray = tempByte;
001A0C C011 FFE9  05780 	MOVFF pArray_2,FSR0
001A10 C012 FFEA  05781 	MOVFF pArray_2+1,FSR0+1
001A14 C017 FFEF  05782 	MOVFF tempByte_2,INDF0
                  05783 			;		pArray++;
001A18 2A11       05784 	INCF  pArray_2,1,0
001A1A 0E00       05785 	MOVLW 0
001A1C 2212       05786 	ADDWFC pArray_2+1,1,0
                  05787 			;		i++;
001A1E 2A15       05788 	INCF  i_9,1,0
001A20 0E00       05789 	MOVLW 0
001A22 2216       05790 	ADDWFC i_9+1,1,0
                  05791 			;	}
001A24 D7DE       05792 	BRA   m167
                  05793 			;	return i;
001A26 5015       05794 m168	MOVF  i_9,W,0
001A28 0012       05795 	RETURN
                  05796 _const1
001A2A 0C00       05797 	RETLW 0
                  05798 _const2
001A2C 501C       05799 	MOVF  ci_2,W,0
001A2E 6EE9       05800 	MOVWF FSR0L,0
001A30 501D       05801 	MOVF  ci_2+1,W,0
001A32 6EEA       05802 	MOVWF FSR0+1,0
001A34 50EF       05803 	MOVF  INDF0,W,0
001A36 0012       05804 	RETURN
                  05805 _const3
001A38 6E11       05806 	MOVWF ci_3,0
001A3A 5011       05807 	MOVF  ci_3,W,0
001A3C 0F4E       05808 	ADDLW 78
001A3E 6EF6       05809 	MOVWF TBLPTR,0
001A40 0E1A       05810 	MOVLW 26
001A42 6AF7       05811 	CLRF  TBLPTR+1,0
001A44 22F7       05812 	ADDWFC TBLPTR+1,1,0
001A46 6AF8       05813 	CLRF  TBLPTR+2,0
001A48 0008       05814 	TBLRD *
001A4A 50F5       05815 	MOVF  TABLAT,W,0
001A4C 0012       05816 	RETURN
001A4E 0100       05817 	DW    0x100
                  05818 _const4
001A50 5011       05819 	MOVF  ci_4,W,0
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 98

ADDR   CODE       LINE  SOURCE

001A52 0F64       05820 	ADDLW 100
001A54 6EF6       05821 	MOVWF TBLPTR,0
001A56 0E1A       05822 	MOVLW 26
001A58 2012       05823 	ADDWFC ci_4+1,W,0
001A5A 6EF7       05824 	MOVWF TBLPTR+1,0
001A5C 6AF8       05825 	CLRF  TBLPTR+2,0
001A5E 0008       05826 	TBLRD *
001A60 50F5       05827 	MOVF  TABLAT,W,0
001A62 0012       05828 	RETURN
001A64 6157       05829 	DW    0x6157
001A66 7469       05830 	DW    0x7469
001A68 4500       05831 	DW    0x4500
001A6A 303A       05832 	DW    0x303A
001A6C 3B35       05833 	DW    0x3B35
001A6E 4520       05834 	DW    0x4520
001A70 5252       05835 	DW    0x5252
001A72 524F       05836 	DW    0x524F
001A74 203A       05837 	DW    0x203A
001A76 7254       05838 	DW    0x7254
001A78 6361       05839 	DW    0x6361
001A7A 6265       05840 	DW    0x6265
001A7C 6675       05841 	DW    0x6675
001A7E 6566       05842 	DW    0x6566
001A80 2072       05843 	DW    0x2072
001A82 7566       05844 	DW    0x7566
001A84 6C6C       05845 	DW    0x6C6C
001A86 4500       05846 	DW    0x4500
001A88 303A       05847 	DW    0x303A
001A8A 3B34       05848 	DW    0x3B34
001A8C 4520       05849 	DW    0x4520
001A8E 5252       05850 	DW    0x5252
001A90 524F       05851 	DW    0x524F
001A92 203A       05852 	DW    0x203A
001A94 6F43       05853 	DW    0x6F43
001A96 6D6D       05854 	DW    0x6D6D
001A98 6E61       05855 	DW    0x6E61
001A9A 6264       05856 	DW    0x6264
001A9C 6675       05857 	DW    0x6675
001A9E 6566       05858 	DW    0x6566
001AA0 2072       05859 	DW    0x2072
001AA2 7566       05860 	DW    0x7566
001AA4 6C6C       05861 	DW    0x6C6C
001AA6 4500       05862 	DW    0x4500
001AA8 303A       05863 	DW    0x303A
001AAA 3B33       05864 	DW    0x3B33
001AAC 4520       05865 	DW    0x4520
001AAE 5252       05866 	DW    0x5252
001AB0 524F       05867 	DW    0x524F
001AB2 203A       05868 	DW    0x203A
001AB4 6552       05869 	DW    0x6552
001AB6 6563       05870 	DW    0x6563
001AB8 7669       05871 	DW    0x7669
001ABA 6265       05872 	DW    0x6265
001ABC 6675       05873 	DW    0x6675
001ABE 6566       05874 	DW    0x6566
001AC0 2072       05875 	DW    0x2072
001AC2 7566       05876 	DW    0x7566
001AC4 6C6C       05877 	DW    0x6C6C
001AC6 4500       05878 	DW    0x4500
001AC8 303A       05879 	DW    0x303A
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 99

ADDR   CODE       LINE  SOURCE

001ACA 3B32       05880 	DW    0x3B32
001ACC 4520       05881 	DW    0x4520
001ACE 5252       05882 	DW    0x5252
001AD0 524F       05883 	DW    0x524F
001AD2 203A       05884 	DW    0x203A
001AD4 7243       05885 	DW    0x7243
001AD6 2D63       05886 	DW    0x2D63
001AD8 6843       05887 	DW    0x6843
001ADA 6365       05888 	DW    0x6365
001ADC 206B       05889 	DW    0x206B
001ADE 6166       05890 	DW    0x6166
001AE0 6C69       05891 	DW    0x6C69
001AE2 6465       05892 	DW    0x6465
001AE4 4500       05893 	DW    0x4500
001AE6 303A       05894 	DW    0x303A
001AE8 3B31       05895 	DW    0x3B31
001AEA 4520       05896 	DW    0x4520
001AEC 5252       05897 	DW    0x5252
001AEE 524F       05898 	DW    0x524F
001AF0 203A       05899 	DW    0x203A
001AF2 4545       05900 	DW    0x4545
001AF4 5250       05901 	DW    0x5250
001AF6 4D4F       05902 	DW    0x4D4F
001AF8 6920       05903 	DW    0x6920
001AFA 2073       05904 	DW    0x2073
001AFC 7566       05905 	DW    0x7566
001AFE 6C6C       05906 	DW    0x6C6C
001B00 2000       05907 	DW    0x2000
001B02 6E63       05908 	DW    0x6E63
001B04 7274       05909 	DW    0x7274
001B06 4300       05910 	DW    0x4300
001B08 6372       05911 	DW    0x6372
001B0A 6520       05912 	DW    0x6520
001B0C 7272       05913 	DW    0x7272
001B0E 726F       05914 	DW    0x726F
001B10 203A       05915 	DW    0x203A
001B12 4300       05916 	DW    0x4300
001B14 656C       05917 	DW    0x656C
001B16 7261       05918 	DW    0x7261
001B18 6E69       05919 	DW    0x6E69
001B1A 2067       05920 	DW    0x2067
001B1C 6373       05921 	DW    0x6373
001B1E 6972       05922 	DW    0x6972
001B20 7470       05923 	DW    0x7470
001B22 6220       05924 	DW    0x6220
001B24 6675       05925 	DW    0x6675
001B26 6566       05926 	DW    0x6566
001B28 0A72       05927 	DW    0xA72
001B2A 4100       05928 	DW    0x4100
001B2C 6464       05929 	DW    0x6464
001B2E 4C20       05930 	DW    0x4C20
001B30 4F4F       05931 	DW    0x4F4F
001B32 5F50       05932 	DW    0x5F50
001B34 464F       05933 	DW    0x464F
001B36 3A46       05934 	DW    0x3A46
001B38 0020       05935 	DW    0x20
001B3A 4F4C       05936 	DW    0x4F4C
001B3C 504F       05937 	DW    0x504F
001B3E 4F5F       05938 	DW    0x4F5F
001B40 0A4E       05939 	DW    0xA4E
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 100

ADDR   CODE       LINE  SOURCE

001B42 4500       05940 	DW    0x4500
001B44 646E       05941 	DW    0x646E
001B46 6F20       05942 	DW    0x6F20
001B48 2066       05943 	DW    0x2066
001B4A 6E69       05944 	DW    0x6E69
001B4C 6966       05945 	DW    0x6966
001B4E 696E       05946 	DW    0x696E
001B50 6574       05947 	DW    0x6574
001B52 6C20       05948 	DW    0x6C20
001B54 6F6F       05949 	DW    0x6F6F
001B56 2070       05950 	DW    0x2070
001B58 6572       05951 	DW    0x6572
001B5A 6361       05952 	DW    0x6361
001B5C 6568       05953 	DW    0x6568
001B5E 0A64       05954 	DW    0xA64
001B60 6E00       05955 	DW    0x6E00
001B62 726F       05956 	DW    0x726F
001B64 616D       05957 	DW    0x616D
001B66 206C       05958 	DW    0x206C
001B68 6F6C       05959 	DW    0x6F6C
001B6A 706F       05960 	DW    0x706F
001B6C 6920       05961 	DW    0x6920
001B6E 6574       05962 	DW    0x6574
001B70 6172       05963 	DW    0x6172
001B72 6974       05964 	DW    0x6974
001B74 6E6F       05965 	DW    0x6E6F
001B76 4500       05966 	DW    0x4500
001B78 646E       05967 	DW    0x646E
001B7A 6F20       05968 	DW    0x6F20
001B7C 2066       05969 	DW    0x2066
001B7E 6F74       05970 	DW    0x6F74
001B80 2070       05971 	DW    0x2070
001B82 6F6C       05972 	DW    0x6F6C
001B84 706F       05973 	DW    0x706F
001B86 7220       05974 	DW    0x7220
001B88 6165       05975 	DW    0x6165
001B8A 6863       05976 	DW    0x6863
001B8C 6465       05977 	DW    0x6465
001B8E 000A       05978 	DW    0xA
001B90 6E45       05979 	DW    0x6E45
001B92 2064       05980 	DW    0x2064
001B94 666F       05981 	DW    0x666F
001B96 6920       05982 	DW    0x6920
001B98 6E6E       05983 	DW    0x6E6E
001B9A 7265       05984 	DW    0x7265
001B9C 6C20       05985 	DW    0x6C20
001B9E 6F6F       05986 	DW    0x6F6F
001BA0 2070       05987 	DW    0x2070
001BA2 6572       05988 	DW    0x6572
001BA4 6361       05989 	DW    0x6361
001BA6 6568       05990 	DW    0x6568
001BA8 0A64       05991 	DW    0xA64
001BAA 0000       05992 	DW    0x0
                  05993 
                  05994 	END
                  05995 
                  05996 
                  05997 ; *** KEY INFO ***
                  05998 
                  05999 ; 0x001102   12 word(s)  0 % : Platform_AllowInterrupts
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 101

ADDR   CODE       LINE  SOURCE

                  06000 ; 0x00111A    3 word(s)  0 % : Platform_EnableAllInterrupts
                  06001 ; 0x0010E6   14 word(s)  0 % : Platform_CheckInputs
                  06002 ; 0x001140    6 word(s)  0 % : htons
                  06003 ; 0x00114C    6 word(s)  0 % : ntohs
                  06004 ; 0x001126    7 word(s)  0 % : Platform_DisableBootloaderAutostart
                  06005 ; 0x001134    6 word(s)  0 % : Platform_EnableBootloaderAutostart
                  06006 ; 0x000CF0   10 word(s)  0 % : RingBuf_HasError
                  06007 ; 0x000D04   21 word(s)  0 % : RingBuf_IsEmpty
                  06008 ; 0x000C34   19 word(s)  0 % : RingBuf_Init
                  06009 ; 0x000C5A   29 word(s)  0 % : RingBuf_Get
                  06010 ; 0x000C94   46 word(s)  0 % : RingBuf_Put
                  06011 ; 0x000D2E   15 word(s)  0 % : UART_Init
                  06012 ; 0x000D4C    5 word(s)  0 % : UART_Send
                  06013 ; 0x0011B6   12 word(s)  0 % : Rtc_Init
                  06014 ; 0x0011CE  242 word(s)  0 % : Rtc_Ctl
                  06015 ; 0x000AE4   26 word(s)  0 % : Timer_Init
                  06016 ; 0x000B18   14 word(s)  0 % : Timer_StartStopwatch
                  06017 ; 0x000B34   66 word(s)  0 % : Timer_StopStopwatch
                  06018 ; 0x000BB8   62 word(s)  0 % : Timer_PrintCycletime
                  06019 ; 0x000344   63 word(s)  0 % : Error_Throw
                  06020 ; 0x0003C2   41 word(s)  0 % : Error_FatalError
                  06021 ; 0x00033A    5 word(s)  0 % : Error_GetState
                  06022 ; 0x000DC8    3 word(s)  0 % : CommandIO_Init
                  06023 ; 0x000DCE  161 word(s)  0 % : CommandIO_GetCommands
                  06024 ; 0x000F10  104 word(s)  0 % : CommandIO_SendResponse
                  06025 ; 0x000FE0  131 word(s)  0 % : CommandIO_CreateResponse
                  06026 ; 0x0004BA   93 word(s)  0 % : Ledstrip_Init
                  06027 ; 0x000574   40 word(s)  0 % : Ledstrip_SetColorDirect
                  06028 ; 0x00072E  433 word(s)  1 % : Ledstrip_SetFade
                  06029 ; 0x0005C4  176 word(s)  0 % : Ledstrip_DoFade
                  06030 ; 0x000724    5 word(s)  0 % : Ledstrip_UpdateLed
                  06031 ; 0x000456   18 word(s)  0 % : Ledstrip_NumOfFades
                  06032 ; 0x00047A   32 word(s)  0 % : Ledstrip_ToggleLeds
                  06033 ; 0x001454  218 word(s)  0 % : ScriptCtrl_Add
                  06034 ; 0x001608   30 word(s)  0 % : ScriptCtrl_Clear
                  06035 ; 0x001644   24 word(s)  0 % : ScriptCtrl_Init
                  06036 ; 0x001674  223 word(s)  0 % : ScriptCtrl_Run
                  06037 ; 0x0018A2   31 word(s)  0 % : Trace_String
                  06038 ; 0x0018E6   72 word(s)  0 % : Trace_Number
                  06039 ; 0x001976   46 word(s)  0 % : Trace_Hex
                  06040 ; 0x0019D2    6 word(s)  0 % : Trace_Hex16
                  06041 ; 0x0018E0    3 word(s)  0 % : Trace_Char
                  06042 ; 0x0019DE   38 word(s)  0 % : Trace_Print
                  06043 ; 0x000128   56 word(s)  0 % : InitAll
                  06044 ; 0x000058   28 word(s)  0 % : HighPriorityInterruptFunction
                  06045 ; 0x000008    2 word(s)  0 % : HighPriorityInterrupt
                  06046 ; 0x000018   32 word(s)  0 % : LowPriorityInterrupt
                  06047 ; 0x000090   76 word(s)  0 % : main
                  06048 ; 0x000198   43 word(s)  0 % : Crc_AddCrc
                  06049 ; 0x0001EE    9 word(s)  0 % : Crc_AddCrc16
                  06050 ; 0x000200   44 word(s)  0 % : Crc_BuildCrc
                  06051 ; 0x000258   19 word(s)  0 % : Crc_NewCrc
                  06052 ; 0x001A2A    1 word(s)  0 % : _const1
                  06053 ; 0x00027E   26 word(s)  0 % : Eeprom_Write
                  06054 ; 0x0002B2   11 word(s)  0 % : Eeprom_Read
                  06055 ; 0x0002C8   32 word(s)  0 % : Eeprom_WriteBlock
                  06056 ; 0x000308   25 word(s)  0 % : Eeprom_ReadBlock
                  06057 ; 0x000A90   11 word(s)  0 % : SPI_Init
                  06058 ; 0x000AA6    7 word(s)  0 % : SPI_Send
                  06059 ; 0x000AB4   24 word(s)  0 % : SPI_SendLedBuffer
CC8E Version 1.3F,   File: main.c              16. Mar 2013   0:32   Page 102

ADDR   CODE       LINE  SOURCE

                  06060 ; 0x000414   14 word(s)  0 % : _mult8x8
                  06061 ; 0x000430   19 word(s)  0 % : _divU16_8
                  06062 ; 0x001A2C    6 word(s)  0 % : _const2
                  06063 ; 0x000D56   44 word(s)  0 % : writeByte
                  06064 ; 0x000DAE   13 word(s)  0 % : DeleteBuffer
                  06065 ; 0x001A38   12 word(s)  0 % : _const3
                  06066 ; 0x001120    3 word(s)  0 % : Platform_DisableAllInterrupts
                  06067 ; 0x0013B2    9 word(s)  0 % : I2C_Init
                  06068 ; 0x0013C4   26 word(s)  0 % : I2C_Write
                  06069 ; 0x0013F8   46 word(s)  0 % : I2C_Read
                  06070 ; 0x001158   17 word(s)  0 % : BcdToBin
                  06071 ; 0x00117A   30 word(s)  0 % : BinToBcd
                  06072 ; 0x001832   40 word(s)  0 % : ScriptCtrl_Write
                  06073 ; 0x001882   16 word(s)  0 % : PutToBuf
                  06074 ; 0x001A50  174 word(s)  0 % : _const4
                  06075 
                  06076 ; RAM usage: 2074 bytes (35 local), 1822 bytes free
                  06077 ; Maximum call level: 6 (+3 for interrupt)
                  06078 ; Total of 3534 code words (10 %)
