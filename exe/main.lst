CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 1

ADDR   CODE       LINE  SOURCE

                  00001 
                  00002 ; CC8E Version 1.3F, Copyright (c) B Knudsen Data
                  00003 ; C compiler for the PIC18 microcontrollers
                  00004 ; ************   1. Dec 2014  23:24  *************
                  00005 
                  00006 	processor  PIC18F26K22
                  00007 	radix  DEC
                  00008 
       0FF8       00009 TBLPTRU     EQU   0xFF8
       0FF7       00010 TBLPTRH     EQU   0xFF7
       0FF6       00011 TBLPTRL     EQU   0xFF6
       0FF6       00012 TBLPTR      EQU   0xFF6
       0FF5       00013 TABLAT      EQU   0xFF5
       0FEF       00014 INDF0       EQU   0xFEF
       0FEE       00015 POSTINC0    EQU   0xFEE
       0FED       00016 POSTDEC0    EQU   0xFED
       0FEA       00017 FSR0H       EQU   0xFEA
       0FE9       00018 FSR0L       EQU   0xFE9
       0FE9       00019 FSR0        EQU   0xFE9
       0FE0       00020 BSR         EQU   0xFE0
       0FD8       00021 STATUS      EQU   0xFD8
       0000       00022 Carry       EQU   0
       0002       00023 Zero_       EQU   2
       0FD3       00024 OSCCON      EQU   0xFD3
       0FCD       00025 T1CON       EQU   0xFCD
       0FC9       00026 SSP1BUF     EQU   0xFC9
       0FC6       00027 SSP1CON1    EQU   0xFC6
       0FBB       00028 PR2         EQU   0xFBB
       0FBA       00029 T2CON       EQU   0xFBA
       0FB3       00030 TMR3H       EQU   0xFB3
       0FB2       00031 TMR3L       EQU   0xFB2
       0FB1       00032 T3CON       EQU   0xFB1
       0FB0       00033 SPBRGH1     EQU   0xFB0
       0FAF       00034 SPBRG1      EQU   0xFAF
       0FAE       00035 RCREG1      EQU   0xFAE
       0FAD       00036 TXREG1      EQU   0xFAD
       0FAA       00037 EEADRH      EQU   0xFAA
       0FA9       00038 EEADR       EQU   0xFA9
       0FA8       00039 EEDATA      EQU   0xFA8
       0FA7       00040 EECON2      EQU   0xFA7
       0F94       00041 TRISC       EQU   0xF94
       0F92       00042 TRISA       EQU   0xF92
       0F8A       00043 LATB        EQU   0xF8A
       0F89       00044 LATA        EQU   0xF89
       0F81       00045 PORTB       EQU   0xF81
       0F80       00046 PORTA       EQU   0xF80
       0F6F       00047 SSP2BUF     EQU   0xF6F
       0F6E       00048 SSP2ADD     EQU   0xF6E
       0F6D       00049 SSP2STAT    EQU   0xF6D
       0F6C       00050 SSP2CON1    EQU   0xF6C
       0F6B       00051 SSP2CON2    EQU   0xF6B
       0F52       00052 PR4         EQU   0xF52
       0F51       00053 T4CON       EQU   0xF51
       0F50       00054 TMR5H       EQU   0xF50
       0F4F       00055 TMR5L       EQU   0xF4F
       0F4E       00056 T5CON       EQU   0xF4E
       0F3A       00057 ANSELC      EQU   0xF3A
       0F39       00058 ANSELB      EQU   0xF39
       0F38       00059 ANSELA      EQU   0xF38
       0006       00060 PEIE        EQU   6
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 2

ADDR   CODE       LINE  SOURCE

       0006       00061 GIEL        EQU   6
       0007       00062 GIE         EQU   7
       0007       00063 GIEH        EQU   7
       0007       00064 IPEN        EQU   7
       0000       00065 TMR1ON      EQU   0
       0006       00066 CKE         EQU   6
       0007       00067 SMP         EQU   7
       0004       00068 CKP         EQU   4
       0005       00069 SSPEN       EQU   5
       0002       00070 TMR2ON      EQU   2
       0003       00071 BRG16       EQU   3
       0000       00072 TMR3ON      EQU   0
       0002       00073 BRGH1       EQU   2
       0004       00074 SYNC1       EQU   4
       0005       00075 TXEN1       EQU   5
       0006       00076 TX9_1       EQU   6
       0003       00077 ADDEN1      EQU   3
       0004       00078 CREN1       EQU   4
       0006       00079 RX9_1       EQU   6
       0007       00080 SPEN1       EQU   7
       0000       00081 RD          EQU   0
       0001       00082 WR          EQU   1
       0002       00083 WREN        EQU   2
       0004       00084 FREE        EQU   4
       0006       00085 CFGS        EQU   6
       0007       00086 EEPGD       EQU   7
       0007       00087 SSP2IF      EQU   7
       0001       00088 TMR3IP      EQU   1
       0000       00089 TMR1IP      EQU   0
       0001       00090 TMR2IP      EQU   1
       0005       00091 RC1IP       EQU   5
       0000       00092 TMR1IF      EQU   0
       0003       00093 SSP1IF      EQU   3
       0004       00094 TX1IF       EQU   4
       0005       00095 RC1IF       EQU   5
       0000       00096 TMR1IE      EQU   0
       0001       00097 TMR2IE      EQU   1
       0005       00098 RC1IE       EQU   5
       0006       00099 PLLEN       EQU   6
       0000       00100 TMR4IP      EQU   0
       0001       00101 TMR5IP      EQU   1
       0001       00102 TMR5IF      EQU   1
       0000       00103 TMR4IE      EQU   0
       0001       00104 TMR5IE      EQU   1
       0005       00105 SSPEN2      EQU   5
       0000       00106 SEN2        EQU   0
       0001       00107 RSEN2       EQU   1
       0002       00108 PEN2        EQU   2
       0003       00109 RCEN2       EQU   3
       0004       00110 ACKEN2      EQU   4
       0005       00111 ACKDT2      EQU   5
       0700       00112 g_RingBuf   EQU   0x700
       0024       00113 g_RtcTime   EQU   0x24
       002B       00114 g_RtcAdress EQU   0x2B
       0200       00115 g_CmdBuf    EQU   0x200
       0803       00116 gLedBuf     EQU   0x803
       0060       00117 gScriptBuf  EQU   0x60
       005D       00118 g_UpdateLed EQU   0x5D
       005E       00119 g_UpdateLedStrip EQU   0x5E
       0004       00120 svrSTATUS   EQU   0x04
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 3

ADDR   CODE       LINE  SOURCE

       0005       00121 svrBSR      EQU   0x05
       0006       00122 svrWREG     EQU   0x06
       0000       00123 sv_FSR0     EQU   0x00
       0002       00124 writeNext   EQU   0x02
       0003       00125 write       EQU   0x03
       0002       00126 temp        EQU   0x02
       0014       00127 p_crcH      EQU   0x14
       0016       00128 p_crcL      EQU   0x16
       0018       00129 index       EQU   0x18
       0019       00130 crcH        EQU   0x19
       001A       00131 crcL        EQU   0x1A
       0F7F       00132 pCrc        EQU   0xF7F
       0F7F       00133 data        EQU   0xF7F
       0F7F       00134 crcH_out    EQU   0xF7F
       0F7F       00135 crcL_out    EQU   0xF7F
       0F7F       00136 crcH_2      EQU   0xF7F
       0F7F       00137 crcL_2      EQU   0xF7F
       0F7F       00138 i           EQU   0xF7F
       0F7F       00139 byte_3      EQU   0xF7F
       0013       00140 p_crcH_2    EQU   0x13
       0015       00141 p_crcL_2    EQU   0x15
       0000       00142 GIE_status  EQU   0
       0011       00143 data_3      EQU   0x11
       0012       00144 array       EQU   0x12
       0014       00145 adress_3    EQU   0x14
       0017       00146 i_2         EQU   0x17
       0018       00147 pByte       EQU   0x18
       0009       00148 array_2     EQU   0x09
       000A       00149 adress_4    EQU   0x0A
       000D       00150 i_3         EQU   0x0D
       000E       00151 temp_2      EQU   0x0E
       001E       00152 arg1        EQU   0x1E
       001F       00153 arg2        EQU   0x1F
       0020       00154 rval        EQU   0x20
       0022       00155 counter     EQU   0x22
       001E       00156 arg1_5      EQU   0x1E
       0020       00157 arg2_5      EQU   0x20
       0021       00158 rm          EQU   0x21
       0022       00159 counter_5   EQU   0x22
       0023       00160 tmp         EQU   0x23
       006C       00161 mFade       EQU   0x6C
       0007       00162 i_4         EQU   0x07
       000A       00163 pValues     EQU   0x0A
       000B       00164 k           EQU   0x0B
       000C       00165 red         EQU   0x0C
       000D       00166 green       EQU   0x0D
       000E       00167 blue        EQU   0x0E
       0007       00168 k_2         EQU   0x07
       0008       00169 stepmask    EQU   0x08
       0009       00170 stepSize    EQU   0x09
       000A       00171 stepaddress EQU   0x0A
       000C       00172 periodeLength EQU   0x0C
       0009       00173 pCmd        EQU   0x09
       000A       00174 fadeTmms    EQU   0x0A
       000C       00175 stepAddress EQU   0x0C
       000E       00176 stepMask    EQU   0x0E
       000F       00177 temp16      EQU   0x0F
       0011       00178 red_2       EQU   0x11
       0012       00179 green_2     EQU   0x12
       0013       00180 blue_2      EQU   0x13
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 4

ADDR   CODE       LINE  SOURCE

       0014       00181 delta       EQU   0x14
       0015       00182 stepSize_2  EQU   0x15
       0016       00183 temp8       EQU   0x16
       0017       00184 address     EQU   0x17
       0018       00185 k_3         EQU   0x18
       0019       00186 mask        EQU   0x19
       0009       00187 pCmd_2      EQU   0x09
       000A       00188 fadeTmms_2  EQU   0x0A
       000C       00189 offset      EQU   0x0C
       000D       00190 numOfLeds   EQU   0x0D
       000E       00191 deltaRed    EQU   0x0E
       000F       00192 deltaGreen  EQU   0x0F
       0010       00193 deltaBlue   EQU   0x10
       0011       00194 red_3       EQU   0x11
       0012       00195 green_3     EQU   0x12
       0013       00196 blue_3      EQU   0x13
       0014       00197 temp16_2    EQU   0x14
       0016       00198 k_4         EQU   0x16
       0017       00199 delta_2     EQU   0x17
       0018       00200 stepSize_3  EQU   0x18
       0019       00201 temp8_2     EQU   0x19
       001A       00202 stepAddress_2 EQU   0x1A
       001C       00203 stepMask_2  EQU   0x1C
       0007       00204 array_3     EQU   0x07
       0009       00205 end         EQU   0x09
       0008       00206 tempTime    EQU   0x08
       0008       00207 tempTime_2  EQU   0x08
       000A       00208 temp16_3    EQU   0x0A
       000F       00209 pArray      EQU   0x0F
       0013       00210 i_5         EQU   0x13
       0015       00211 temp16_4    EQU   0x15
       0007       00212 pBuf        EQU   0x07
       0016       00213 pBuf_2      EQU   0x16
       0018       00214 read        EQU   0x18
       0019       00215 result      EQU   0x19
       0015       00216 pBuf_3      EQU   0x15
       0018       00217 writeNext_2 EQU   0x18
       0019       00218 write_2     EQU   0x19
       0015       00219 pBuf_4      EQU   0x15
       0016       00220 pBuf_5      EQU   0x16
       0018       00221 write_3     EQU   0x18
       0019       00222 read_2      EQU   0x19
       0000       00223 g_Odd_STX_Received EQU   0
       0008       00224 byte_4      EQU   0x08
       0007       00225 new_byte    EQU   0x07
       0008       00226 mRetValue   EQU   0x08
       000A       00227 mFrame      EQU   0x0A
       000C       00228 crcH_3      EQU   0x0C
       000D       00229 crcL_3      EQU   0x0D
       000E       00230 tempByte    EQU   0x0E
       000F       00231 pData       EQU   0x0F
       0011       00232 frameLength EQU   0x11
       000A       00233 mFrame_2    EQU   0x0A
       000C       00234 cmd         EQU   0x0C
       000D       00235 mState      EQU   0x0D
       000E       00236 bytesPrint  EQU   0x0E
       000E       00237 bytesPrint_2 EQU   0x0E
       000E       00238 tempVersion EQU   0x0E
       0076       00239 lastSwitchState EQU   0x76
       0017       00240 hostShort   EQU   0x17
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 5

ADDR   CODE       LINE  SOURCE

       0019       00241 retval      EQU   0x19
       001E       00242 networkShort EQU   0x1E
       0020       00243 retval_2    EQU   0x20
       0012       00244 BcdValue    EQU   0x12
       0013       00245 retValue    EQU   0x13
       0012       00246 BinValue    EQU   0x12
       0013       00247 onesValue   EQU   0x13
       0014       00248 tensValue   EQU   0x14
       0015       00249 tempValue   EQU   0x15
       0007       00250 temp_3      EQU   0x07
       000E       00251 req         EQU   0x0E
       000F       00252 pRtcTime    EQU   0x0F
       0011       00253 temp_4      EQU   0x11
       0012       00254 slaveaddr   EQU   0x12
       0F7F       00255 slaveaddr_2 EQU   0xF7F
       0F7F       00256 data_6      EQU   0xF7F
       0F7F       00257 _length     EQU   0xF7F
       0F7F       00258 buffer      EQU   0xF7F
       0F7F       00259 _slaveaddr  EQU   0xF7F
       0F7F       00260 _length_2   EQU   0xF7F
       0014       00261 _slaveaddr_2 EQU   0x14
       0015       00262 _data       EQU   0x15
       0008       00263 returnValue EQU   0x08
       0077       00264 nextCmd     EQU   0x77
       0009       00265 pCmd_3      EQU   0x09
       000A       00266 loopStart   EQU   0x0A
       000B       00267 numLoops    EQU   0x0B
       000C       00268 retVal      EQU   0x0C
       0007       00269 tempAddress EQU   0x07
       0009       00270 tempAddress_2 EQU   0x09
       000D       00271 pCmd_4      EQU   0x0D
       000F       00272 writeNext_3 EQU   0x0F
       0010       00273 tempAddress_3 EQU   0x10
       0012       00274 string      EQU   0x12
       0013       00275 ps          EQU   0x13
       0F7F       00276 input_2     EQU   0xF7F
       0F7F       00277 temp_5      EQU   0xF7F
       0F7F       00278 h           EQU   0xF7F
       0F7F       00279 z           EQU   0xF7F
       0F7F       00280 e           EQU   0xF7F
       0009       00281 temp4       EQU   0x09
       000F       00282 pArray_2    EQU   0x0F
       0013       00283 i_6         EQU   0x13
       0015       00284 tempByte_2  EQU   0x15
       0F7F       00285 data_7      EQU   0xF7F
       0F7F       00286 i_7         EQU   0xF7F
       0F7F       00287 buffer_2    EQU   0xF7F
       0F7F       00288 adress_8    EQU   0xF7F
       0F7F       00289 data_8      EQU   0xF7F
       0F7F       00290 pageAdress  EQU   0xF7F
       0F7F       00291 offset_2    EQU   0xF7F
       0F7F       00292 endAdress   EQU   0xF7F
       0F7F       00293 i_8         EQU   0xF7F
       0F7F       00294 tempAdress  EQU   0xF7F
       0F7F       00295 temp_6      EQU   0xF7F
       0F7F       00296 pageAdress_2 EQU   0xF7F
       0F7F       00297 numBlocks   EQU   0xF7F
       0F7F       00298 pageAdress_3 EQU   0xF7F
       0010       00299 C1tmp       EQU   0x10
       0082       00300 g_ExtEepromDetected EQU   0x82
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 6

ADDR   CODE       LINE  SOURCE

       0F7F       00301 array_4     EQU   0xF7F
       0F7F       00302 array_5     EQU   0xF7F
       001A       00303 ci_2        EQU   0x1A
       0F7F       00304 ci_3        EQU   0xF7F
       0014       00305 ci_4        EQU   0x14
       0F7F       00306 ci_5        EQU   0xF7F
                  00307 
000000 EF71 F000  00308 	GOTO main
                  00309 
                  00310   ; FILE ./firmware/main.c
                  00311 			;/**
                  00312 			; Copyright (C) 2012, 2013 Nils Weiss, Patrick Bruenn.
                  00313 			;
                  00314 			; This file is part of Wifly_Light.
                  00315 			;
                  00316 			; Wifly_Light is free software: you can redistribute it and/or modify
                  00317 			; it under the terms of the GNU General Public License as published by
                  00318 			; the Free Software Foundation, either version 3 of the License, or
                  00319 			; (at your option) any later version.
                  00320 			;
                  00321 			; Wifly_Light is distributed in the hope that it will be useful,
                  00322 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  00323 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  00324 			; GNU General Public License for more details.
                  00325 			;
                  00326 			; You should have received a copy of the GNU General Public License
                  00327 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  00328 			;
                  00329 			;#ifdef __CC8E__
                  00330 			;#define DEBUG
                  00331 			;#pragma optimize 1
                  00332 
                  00333   ; FILE ./firmware/main.c
                  00334 			;#pragma sharedAllocation
                  00335 			;#endif
                  00336 			;
                  00337 			;//*********************** INCLUDEDATEIEN *********************************************
                  00338 			;#include "Version.h"
                  00339 			;#include "platform.h"
                  00340 			;#include "RingBuf.h"
                  00341 			;#include "usart.h"
                  00342 			;#include "CommandIO.h"
                  00343 			;#include "ledstrip.h"
                  00344 			;#include "timer.h"
                  00345 			;#include "rtc.h"
                  00346 			;#include "ScriptCtrl.h"
                  00347 			;#include "trace.h"
                  00348 			;#include "error.h"
                  00349 			;#include "Flash.h"
                  00350 			;#include "external_eeprom.h"
                  00351 			;
                  00352 			;#ifdef __CC8E__
                  00353 			;#include "int18XXX.h"
                  00354 			;#endif /* #ifdef __CC8E__ */
                  00355 			;//#include "MATH16.h"
                  00356 			;
                  00357 			;#ifndef __CC8E__
                  00358 			;#include <unistd.h>
                  00359 			;jmp_buf g_ResetEnvironment;
                  00360 			;#endif /* #ifndef CC8E */
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 7

ADDR   CODE       LINE  SOURCE

                  00361 			;
                  00362 			;//*********************** GLOBAL VARIABLES *******************************************
                  00363 			;uns8 g_UpdateLed;
                  00364 			;uns8 g_UpdateLedStrip;
                  00365 			;
                  00366 			;//*********************** MACROS *****************************************************
                  00367 			;#ifdef DEBUG
                  00368 			;#define do_and_measure(METHOD) { \
                  00369 			;		Timer_StartStopwatch(e ## METHOD); \
                  00370 			;		METHOD(); \
                  00371 			;		Timer_StopStopwatch(e ## METHOD); }
                  00372 			;#else
                  00373 			;#define do_and_measure(METHOD) METHOD();
                  00374 			;#endif /*#ifdef DEBUG */
                  00375 			;
                  00376 			;
                  00377 			;//*********************** FUNKTIONSPROTOTYPEN ****************************************
                  00378 			;void InitAll();
                  00379 			;void HighPriorityInterruptFunction(void);
                  00380 			;#ifdef X86
                  00381 			;void init_x86(int start_gl);
                  00382 			;#endif /* #ifdef X86 */
                  00383 			;
                  00384 			;#ifndef X86
                  00385 			;//*********************** INTERRUPTSERVICEROUTINE ************************************
                  00386 			;#pragma origin 0x8
       0000       00387 	ORG 0x0008
                  00388 			;//Adresse des High Priority Interrupts
                  00389 			;interrupt HighPriorityInterrupt(void)
                  00390 			;{
                  00391 HighPriorityInterrupt
                  00392 			;	HighPriorityInterruptFunction();
000008 D824       00393 	RCALL HighPriorityInterruptFunction
                  00394 			;	#pragma fastMode
                  00395 			;}
00000A 0011       00396 	RETFIE 1
                  00397 			;
                  00398 			;#pragma origin 0x18
       0000       00399 	ORG 0x0018
                  00400 			;interrupt LowPriorityInterrupt(void)
                  00401 			;{
                  00402 LowPriorityInterrupt
                  00403 			;	int_save_registers
000018 CFD8 F004  00404 	MOVFF STATUS,svrSTATUS
00001C CFE0 F005  00405 	MOVFF BSR,svrBSR
000020 6E06       00406 	MOVWF svrWREG,0
                  00407 			;#if 0
                  00408 			;	uns16 sv_FSR0 = FSR0;
                  00409 			;	uns16 sv_FSR1 = FSR1;
                  00410 			;	uns16 sv_FSR2 = FSR2;
                  00411 			;	uns8 sv_PCLATH = PCLATH;
                  00412 			;	uns8 sv_PCLATU = PCLATU;
                  00413 			;	uns8 sv_PRODL = PRODL;
                  00414 			;	uns8 sv_PRODH = PRODH;
                  00415 			;	uns24 sv_TBLPTR = TBLPTR;
                  00416 			;	uns8 sv_TABLAT = TABLAT;
                  00417 			;#endif
                  00418 			;
                  00419 			;	if(TMR5IF) {
000022 A27E       00420 	BTFSS 0xF7E,TMR5IF,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 8

ADDR   CODE       LINE  SOURCE

000024 D009       00421 	BRA   m001
                  00422 			;		g_UpdateLed = g_UpdateLed + 1;
000026 2A5D       00423 	INCF  g_UpdateLed,1,0
                  00424 			;		ScriptCtrl_DecrementWaitValue();
000028 EC98 F011  00425 	CALL  ScriptCtrl_DecrementWaitValue
                  00426 			;		Timer5Interrupt();
00002C 927E       00427 	BCF   0xF7E,TMR5IF,0
00002E 0EEC       00428 	MOVLW 236
000030 010F       00429 	MOVLB 15
000032 6F50       00430 	MOVWF TMR5H,1
000034 0E78       00431 	MOVLW 120
000036 6F4F       00432 	MOVWF TMR5L,1
                  00433 			;	}
                  00434 			;
                  00435 			;	if(TMR1IF) {
000038 A09E       00436 m001	BTFSS 0xF9E,TMR1IF,0
00003A D005       00437 	BRA   m002
                  00438 			;		g_UpdateLedStrip = g_UpdateLedStrip + 1;
00003C 2A5E       00439 	INCF  g_UpdateLedStrip,1,0
                  00440 			;		ScriptCtrl_CheckAndDecrementWaitValue();
00003E ECA1 F011  00441 	CALL  ScriptCtrl_CheckAndDecrementWaitValue
                  00442 			;		Timer1Disable();
000042 90CD       00443 	BCF   0xFCD,TMR1ON,0
                  00444 			;		Timer1Interrupt();
000044 909E       00445 	BCF   0xF9E,TMR1IF,0
                  00446 			;	}
                  00447 			;#if 0
                  00448 			;	FSR0 = sv_FSR0;
                  00449 			;	FSR1 = sv_FSR1;
                  00450 			;	FSR2 = sv_FSR2;
                  00451 			;	PCLATH = sv_PCLATH;
                  00452 			;	PCLATU = sv_PCLATU;
                  00453 			;	PRODL = sv_PRODL;
                  00454 			;	PRODH = sv_PRODH;
                  00455 			;	TBLPTR = sv_TBLPTR;
                  00456 			;	TABLAT = sv_TABLAT;
                  00457 			;#endif
                  00458 			;	int_restore_registers
000046 5006       00459 m002	MOVF  svrWREG,W,0
000048 C005 FFE0  00460 	MOVFF svrBSR,BSR
00004C C004 FFD8  00461 	MOVFF svrSTATUS,STATUS
                  00462 			;}
000050 0010       00463 	RETFIE
                  00464 			;
                  00465 			;void HighPriorityInterruptFunction(void)
                  00466 			;{
                  00467 HighPriorityInterruptFunction
                  00468 			;	uns16 sv_FSR0 = FSR0;
000052 CFE9 F000  00469 	MOVFF FSR0,sv_FSR0
000056 CFEA F001  00470 	MOVFF FSR0+1,sv_FSR0+1
                  00471 			;	if(RC1IF) {
00005A AA9E       00472 	BTFSS 0xF9E,RC1IF,0
00005C D019       00473 	BRA   m005
                  00474 			;		//Replace RingBuf_Put to avoid failures when main-cycle call's RingBuf_Put
                  00475 			;		if(!g_RingBuf.error_full) {
00005E 0108       00476 	MOVLB 8
000060 B102       00477 	BTFSC g_RingBuf+258,0,1
000062 D014       00478 	BRA   m004
                  00479 			;			uns8 writeNext = RingBufInc(g_RingBuf.write);
000064 2901       00480 	INCF  g_RingBuf+257,W,1
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 9

ADDR   CODE       LINE  SOURCE

000066 6E02       00481 	MOVWF writeNext,0
                  00482 			;			if(writeNext != g_RingBuf.read) {
000068 5002       00483 	MOVF  writeNext,W,0
00006A 1900       00484 	XORWF g_RingBuf+256,W,1
00006C B4D8       00485 	BTFSC 0xFD8,Zero_,0
00006E D00B       00486 	BRA   m003
                  00487 			;				uns8 write = g_RingBuf.write;
000070 C801 F003  00488 	MOVFF g_RingBuf+257,write
                  00489 			;				g_RingBuf.data[write] = RCREG1;
000074 5003       00490 	MOVF  write,W,0
000076 6EE9       00491 	MOVWF FSR0,0
000078 0E07       00492 	MOVLW 7
00007A 6EEA       00493 	MOVWF FSR0+1,0
00007C CFAE FFEF  00494 	MOVFF RCREG1,INDF0
                  00495 			;				g_RingBuf.write = writeNext;
000080 C002 F801  00496 	MOVFF writeNext,g_RingBuf+257
                  00497 			;			} else g_RingBuf.error_full = 1;
000084 D005       00498 	BRA   m005
000086 0108       00499 m003	MOVLB 8
000088 8102       00500 	BSF   g_RingBuf+258,0,1
                  00501 			;		} else {
00008A D002       00502 	BRA   m005
                  00503 			;			//Register lesen um Schnittstellen Fehler zu vermeiden
                  00504 			;			uns8 temp = RCREG1;
00008C CFAE F002  00505 m004	MOVFF RCREG1,temp
                  00506 			;		}
                  00507 			;	}
                  00508 			;	FSR0 = sv_FSR0;
000090 C000 FFE9  00509 m005	MOVFF sv_FSR0,FSR0
000094 C001 FFEA  00510 	MOVFF sv_FSR0+1,FSR0+1
                  00511 			;}
000098 0012       00512 	RETURN
                  00513 			;#endif /* #ifndef X86 */
                  00514 			;
                  00515 			;#pragma cdata[VERSION_STRING_ORIGIN]
                  00516 			;#pragma cdata.version = VERSION
                  00517 			;#pragma cdata.CDATA_END
                  00518 			;#pragma origin CDATA_END
       0000       00519 	ORG 0x00E2
                  00520 			;
                  00521 			;//*********************** HAUPTPROGRAMM **********************************************
                  00522 			;#ifdef __CC8E__
                  00523 			;void main(void)
                  00524 			;{
                  00525 main
                  00526 			;#else
                  00527 			;int g_start_gl = 1;
                  00528 			;int main(int argc, const char** argv)
                  00529 			;{
                  00530 			;	if ((argc > 1) && (argv[1][0] == 'h'))
                  00531 			;		g_start_gl = 0;
                  00532 			;#endif
                  00533 			;	/* softReset() on x86 will jump here! */
                  00534 			;	softResetJumpDestination();
                  00535 			;
                  00536 			;	InitAll();
0000E2 D84B       00537 	RCALL InitAll
                  00538 			;
                  00539 			;	while(1)
                  00540 			;	{
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 10

ADDR   CODE       LINE  SOURCE

                  00541 			;		Timer_StartStopwatch(eMAIN);
0000E4 6A07       00542 m006	CLRF  destMethode,0
0000E6 EC33 F009  00543 	CALL  Timer_StartStopwatch
                  00544 			;#ifndef __CC8E__
                  00545 			;		// give opengl thread a chance to run
                  00546 			;		usleep(10);
                  00547 			;#endif /* #ifndef __CC8E__ */
                  00548 			;
                  00549 			;
                  00550 			;
                  00551 			;			do_and_measure(Platform_CheckInputs);
0000EA 0E09       00552 	MOVLW 9
0000EC 6E07       00553 	MOVWF destMethode,0
0000EE EC33 F009  00554 	CALL  Timer_StartStopwatch
0000F2 ECFE F00B  00555 	CALL  Platform_CheckInputs
0000F6 0E09       00556 	MOVLW 9
0000F8 6E07       00557 	MOVWF destMethode_2,0
0000FA EC41 F009  00558 	CALL  Timer_StopStopwatch
                  00559 			;
                  00560 			;			do_and_measure(Error_Throw);
0000FE 0E0A       00561 	MOVLW 10
000100 6E07       00562 	MOVWF destMethode,0
000102 EC33 F009  00563 	CALL  Timer_StartStopwatch
000106 D94B       00564 	RCALL Error_Throw
000108 0E0A       00565 	MOVLW 10
00010A 6E07       00566 	MOVWF destMethode_2,0
00010C EC41 F009  00567 	CALL  Timer_StopStopwatch
                  00568 			;
                  00569 			;			do_and_measure(CommandIO_GetCommands);
000110 0E07       00570 	MOVLW 7
000112 6E07       00571 	MOVWF destMethode,0
000114 EC33 F009  00572 	CALL  Timer_StartStopwatch
000118 EC94 F00A  00573 	CALL  CommandIO_GetCommands
00011C 0E07       00574 	MOVLW 7
00011E 6E07       00575 	MOVWF destMethode_2,0
000120 EC41 F009  00576 	CALL  Timer_StopStopwatch
                  00577 			;
                  00578 			;		if(g_UpdateLedStrip > 0) {
000124 525E       00579 	MOVF  g_UpdateLedStrip,1,0
000126 B4D8       00580 	BTFSC 0xFD8,Zero_,0
000128 D00B       00581 	BRA   m007
                  00582 			;			do_and_measure(Ledstrip_UpdateLed);
00012A 0E06       00583 	MOVLW 6
00012C 6E07       00584 	MOVWF destMethode,0
00012E EC33 F009  00585 	CALL  Timer_StartStopwatch
000132 DAF3       00586 	RCALL Ledstrip_UpdateLed
000134 0E06       00587 	MOVLW 6
000136 6E07       00588 	MOVWF destMethode_2,0
000138 EC41 F009  00589 	CALL  Timer_StopStopwatch
                  00590 			;			Timer1Enable();
00013C 80CD       00591 	BSF   0xFCD,TMR1ON,0
                  00592 			;			g_UpdateLedStrip = 0;
00013E 6A5E       00593 	CLRF  g_UpdateLedStrip,0
                  00594 			;		}
                  00595 			;		Timer_StopStopwatch(eMAIN);
000140 6A07       00596 m007	CLRF  destMethode_2,0
000142 EC41 F009  00597 	CALL  Timer_StopStopwatch
                  00598 			;
                  00599 			;			do_and_measure(ScriptCtrl_Run);
000146 0E08       00600 	MOVLW 8
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 11

ADDR   CODE       LINE  SOURCE

000148 6E07       00601 	MOVWF destMethode,0
00014A EC33 F009  00602 	CALL  Timer_StartStopwatch
00014E EC76 F010  00603 	CALL  ScriptCtrl_Run
000152 0E08       00604 	MOVLW 8
000154 6E07       00605 	MOVWF destMethode_2,0
000156 EC41 F009  00606 	CALL  Timer_StopStopwatch
                  00607 			;
                  00608 			;		if(g_UpdateLed > 0) {
00015A 525D       00609 	MOVF  g_UpdateLed,1,0
00015C B4D8       00610 	BTFSC 0xFD8,Zero_,0
00015E D7C2       00611 	BRA   m006
                  00612 			;			do_and_measure(Ledstrip_DoFade);
000160 0E01       00613 	MOVLW 1
000162 6E07       00614 	MOVWF destMethode,0
000164 EC33 F009  00615 	CALL  Timer_StartStopwatch
000168 DA28       00616 	RCALL Ledstrip_DoFade
00016A 0E01       00617 	MOVLW 1
00016C 6E07       00618 	MOVWF destMethode_2,0
00016E EC41 F009  00619 	CALL  Timer_StopStopwatch
                  00620 			;
                  00621 			;			Timer5InterruptLock();
000172 927D       00622 	BCF   0xF7D,TMR5IE,0
                  00623 			;			g_UpdateLed = 0;
000174 6A5D       00624 	CLRF  g_UpdateLed,0
                  00625 			;			Timer5InterruptUnlock();
000176 827D       00626 	BSF   0xF7D,TMR5IE,0
                  00627 			;
                  00628 			;		}
                  00629 			;	}
000178 D7B5       00630 	BRA   m006
                  00631 			;}
                  00632 			;//*********************** UNTERPROGRAMME **********************************************
                  00633 			;
                  00634 			;void InitAll()
                  00635 			;{
                  00636 InitAll
                  00637 			;	clearRAM();
00017A EE0F F037  00638 	LFSR  0,3895 
00017E 6AED       00639 m008	CLRF  POSTDEC0,0
000180 50EA       00640 	MOVF  FSR0H,W,0
000182 E1FD       00641 	BNZ   m008
000184 50E9       00642 	MOVF  FSR0,W,0
000186 E1FB       00643 	BNZ   m008
000188 6AEF       00644 	CLRF  INDF0,0
                  00645 			;	Trace_Init();
00018A ECAB F011  00646 	CALL  Trace_Init
                  00647 			;	Platform_OsciInit();
00018E 0E72       00648 	MOVLW 114
000190 6ED3       00649 	MOVWF OSCCON,0
000192 8C9B       00650 	BSF   0xF9B,PLLEN,0
                  00651 			;	Platform_IOInit();
000194 6A81       00652 	CLRF  PORTB,0
000196 6A8A       00653 	CLRF  LATB,0
000198 010F       00654 	MOVLB 15
00019A 6B39       00655 	CLRF  ANSELB,1
00019C 6A80       00656 	CLRF  PORTA,0
00019E 6A89       00657 	CLRF  LATA,0
0001A0 6B38       00658 	CLRF  ANSELA,1
0001A2 6A92       00659 	CLRF  TRISA,0
0001A4 0E04       00660 	MOVLW 4
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 12

ADDR   CODE       LINE  SOURCE

0001A6 6E80       00661 	MOVWF PORTA,0
                  00662 			;	RingBuf_Init(&g_RingBuf);
0001A8 6A07       00663 	CLRF  pBuf,0
0001AA 0E07       00664 	MOVLW 7
0001AC 6E08       00665 	MOVWF pBuf+1,0
0001AE ECC5 F009  00666 	CALL  RingBuf_Init
                  00667 			;	UART_Init();
0001B2 EC42 F00A  00668 	CALL  UART_Init
                  00669 			;	Timer_Init();
0001B6 EC19 F009  00670 	CALL  Timer_Init
                  00671 			;	Ledstrip_Init();
0001BA D937       00672 	RCALL Ledstrip_Init
                  00673 			;	CommandIO_Init();
0001BC EC82 F00A  00674 	CALL  CommandIO_Init
                  00675 			;	Rtc_Init();
0001C0 EC6E F00C  00676 	CALL  Rtc_Init
                  00677 			;	ScriptCtrl_Init();
0001C4 EC5C F010  00678 	CALL  ScriptCtrl_Init
                  00679 			;	ExtEeprom_Init();
0001C8 EC81 F013  00680 	CALL  ExtEeprom_Init
                  00681 			;	
                  00682 			;#ifndef __CC8E__
                  00683 			;	init_x86(g_start_gl);
                  00684 			;#endif /* #ifndef CC8E */
                  00685 			;
                  00686 			;	Platform_AllowInterrupts();
0001CC EC15 F00C  00687 	CALL  Platform_AllowInterrupts
                  00688 			;
                  00689 			;	/* Startup Wait-Time 2s
                  00690 			;	 * to protect Wifly-Modul from errors*/
                  00691 			;	gScriptBuf.waitValue = 20;
0001D0 0E14       00692 	MOVLW 20
0001D2 0100       00693 	MOVLB 0
0001D4 6F60       00694 	MOVWF gScriptBuf,1
0001D6 6B61       00695 	CLRF  gScriptBuf+1,1
                  00696 			;	CommandIO_CreateResponse(&g_ResponseBuf, FW_STARTED, OK);
0001D8 6A0A       00697 	CLRF  mFrame_2,0
0001DA 0E05       00698 	MOVLW 5
0001DC 6E0B       00699 	MOVWF mFrame_2+1,0
0001DE 0EEC       00700 	MOVLW 236
0001E0 6E0C       00701 	MOVWF cmd,0
0001E2 6A0D       00702 	CLRF  mState,0
0001E4 EC66 F00B  00703 	CALL  CommandIO_CreateResponse
                  00704 			;	CommandIO_SendResponse(&g_ResponseBuf);
0001E8 6A0A       00705 	CLRF  mFrame,0
0001EA 0E05       00706 	MOVLW 5
0001EC 6E0B       00707 	MOVWF mFrame+1,0
0001EE ECFE F00A  00708 	CALL  CommandIO_SendResponse
                  00709 			;	Trace_String(" Init Done ");
0001F2 6A12       00710 	CLRF  string,0
0001F4 ECBE F011  00711 	CALL  Trace_String
                  00712 			;	Platform_DisableBootloaderAutostart();
0001F8 EF24 F00C  00713 	GOTO  Platform_DisableBootloaderAutostart
                  00714 			;}
                  00715 
                  00716   ; FILE ./firmware\crc.c
                  00717 			;/**
                  00718 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  00719 			;
                  00720 			; This file is part of Wifly_Light.
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 13

ADDR   CODE       LINE  SOURCE

                  00721 			;
                  00722 			; Wifly_Light is free software: you can redistribute it and/or modify
                  00723 			; it under the terms of the GNU General Public License as published by
                  00724 			; the Free Software Foundation, either version 3 of the License, or
                  00725 			; (at your option) any later version.
                  00726 			;
                  00727 			; Wifly_Light is distributed in the hope that it will be useful,
                  00728 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  00729 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  00730 			; GNU General Public License for more details.
                  00731 			;
                  00732 			; You should have received a copy of the GNU General Public License
                  00733 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  00734 			;
                  00735 			;#include "crc.h"
                  00736 			;
                  00737 			;// 16-bit CCIT CRC
                  00738 			;void Crc_AddCrc(const uns8 byte,uns8 *p_crcH,uns8 *p_crcL)
                  00739 			;{
                  00740 Crc_AddCrc
                  00741 			;	uns8 index, crcH, crcL;
                  00742 			;	crcH = *p_crcH;
0001FC C014 FFE9  00743 	MOVFF p_crcH,FSR0
000200 C015 FFEA  00744 	MOVFF p_crcH+1,FSR0+1
000204 CFEF F019  00745 	MOVFF INDF0,crcH
                  00746 			;	crcL = *p_crcL;
000208 C016 FFE9  00747 	MOVFF p_crcL,FSR0
00020C C017 FFEA  00748 	MOVFF p_crcL+1,FSR0+1
000210 CFEF F01A  00749 	MOVFF INDF0,crcL
                  00750 			;#ifdef __CC8E__
                  00751 			;	MOVF(byte,0);
000214 5013       00752 	MOVF  byte,W,0
                  00753 			;
                  00754 			;	XORWF(crcH,0);
000216 1819       00755 	XORWF crcH,W,0
                  00756 			;	MOVWF(index);
000218 6E18       00757 	MOVWF index,0
                  00758 			;	ANDLW(0xf0);
00021A 0BF0       00759 	ANDLW 240
                  00760 			;	SWAPF(index,1);
00021C 3A18       00761 	SWAPF index,1,0
                  00762 			;	XORWF(index,1);
00021E 1A18       00763 	XORWF index,1,0
                  00764 			;
                  00765 			;	MOVF(index,0);
000220 5018       00766 	MOVF  index,W,0
                  00767 			;	ANDLW(0xf0);
000222 0BF0       00768 	ANDLW 240
                  00769 			;	XORWF(crcL,0);
000224 181A       00770 	XORWF crcL,W,0
                  00771 			;	MOVWF(crcH);
000226 6E19       00772 	MOVWF crcH,0
                  00773 			;
                  00774 			;	RLF(index,0);
000228 3418       00775 	RLCF  index,W,0
                  00776 			;	RLF(index,0);
00022A 3418       00777 	RLCF  index,W,0
                  00778 			;	XORWF(crcH,1);
00022C 1A19       00779 	XORWF crcH,1,0
                  00780 			;	ANDLW(0xe0);
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 14

ADDR   CODE       LINE  SOURCE

00022E 0BE0       00781 	ANDLW 224
                  00782 			;	XORWF(crcH,1);
000230 1A19       00783 	XORWF crcH,1,0
                  00784 			;
                  00785 			;	SWAPF(index,1);
000232 3A18       00786 	SWAPF index,1,0
                  00787 			;	XORWF(index,0);
000234 1818       00788 	XORWF index,W,0
                  00789 			;	MOVWF(crcL);
000236 6E1A       00790 	MOVWF crcL,0
                  00791 			;#else
                  00792 			;	uns8 work, temp;
                  00793 			;
                  00794 			;	work = byte;                    //MOVF(byte,0);
                  00795 			;
                  00796 			;	work = work ^ crcH;             //XORWF(crcH,0);
                  00797 			;	index = work;                   //MOVWF(index);
                  00798 			;	work = 0xf0 & work;             //ANDLW(0xf0);
                  00799 			;	index = ((index << 4) & 0xf0) | ((index >> 4) & 0x0f); //SWAPF(index,1);
                  00800 			;	index = work ^ index;           //XORWF(index,1);
                  00801 			;
                  00802 			;	work = index;                   //MOVF(index,0);
                  00803 			;	work = work & 0xf0;             //ANDLW(0xf0);
                  00804 			;	work = work ^ crcL;             //XORWF(crcL,0);
                  00805 			;	crcH = work;                    //MOVWF(crcH);
                  00806 			;
                  00807 			;	temp = 0x80 & index;            //RLF(index,0);
                  00808 			;	work = index << 1;
                  00809 			;	temp = temp >> 7;
                  00810 			;	work = work & 0xfe;
                  00811 			;	work = work | temp;
                  00812 			;
                  00813 			;	crcH = work ^ crcH;             //XORWF(crcH,1);
                  00814 			;	work = work & 0xe0;             //ANDLW(0xe0);
                  00815 			;	crcH = work ^ crcH;             //XORWF(crcH,1);
                  00816 			;
                  00817 			;	index = ((index << 4) & 0xf0) | ((index >> 4) & 0x0f);   //SWAPF(index,1);
                  00818 			;	work = work ^ index;            //XORWF(index,0);
                  00819 			;	crcL = work;                    //MOVWF(crcL);
                  00820 			;#endif /* #ifdef __CC8E__ */
                  00821 			;	*p_crcH = crcH;
000238 C014 FFE9  00822 	MOVFF p_crcH,FSR0
00023C C015 FFEA  00823 	MOVFF p_crcH+1,FSR0+1
000240 C019 FFEF  00824 	MOVFF crcH,INDF0
                  00825 			;	*p_crcL = crcL;
000244 C016 FFE9  00826 	MOVFF p_crcL,FSR0
000248 C017 FFEA  00827 	MOVFF p_crcL+1,FSR0+1
00024C C01A FFEF  00828 	MOVFF crcL,INDF0
                  00829 			;}
000250 0012       00830 	RETURN
                  00831 			;
                  00832 			;/**
                  00833 			; * Wrapper for the Crc_AddCrc function with seperate parameter for high and low
                  00834 			; * crc value. In a next refactoring step we should replace that other functions
                  00835 			; * with this one.
                  00836 			; */
                  00837 			;#ifdef __cplusplus
                  00838 			;extern "C" {
                  00839 			;#endif
                  00840 			;void Crc_AddCrc16(const uns8 byte, uns16 *pCrc)
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 15

ADDR   CODE       LINE  SOURCE

                  00841 			;{
                  00842 Crc_AddCrc16
                  00843 			;		Crc_AddCrc(byte, ((uns8 *)pCrc) + 1, (uns8 *)pCrc);
000252 CF7F F013  00844 	MOVFF byte_2,byte
000256 6A15       00845 	CLRF  p_crcH+1,0
000258 287F       00846 	INCF  pCrc,W,0
00025A 6E14       00847 	MOVWF p_crcH,0
00025C CF7F F016  00848 	MOVFF pCrc,p_crcL
000260 6A17       00849 	CLRF  p_crcL+1,0
000262 D7CC       00850 	BRA   Crc_AddCrc
                  00851 			;}
                  00852 			;#ifdef __cplusplus
                  00853 			;}
                  00854 			;#endif
                  00855 			;
                  00856 			;void Crc_BuildCrc(const uns8 *data, const uns8 length, uns8 *crcH_out, uns8 *crcL_out)
                  00857 			;{
                  00858 Crc_BuildCrc
                  00859 			;	if(!crcH_out) return;
000264 507F       00860 	MOVF  crcH_out,W,0
000266 B4D8       00861 	BTFSC 0xFD8,Zero_,0
000268 0012       00862 	RETURN
                  00863 			;	if(!crcL_out) return;
00026A 507F       00864 	MOVF  crcL_out,W,0
00026C B4D8       00865 	BTFSC 0xFD8,Zero_,0
00026E 0012       00866 	RETURN
                  00867 			;	if(!data) return;
000270 507F       00868 	MOVF  data,W,0
000272 B4D8       00869 	BTFSC 0xFD8,Zero_,0
000274 0012       00870 	RETURN
                  00871 			;	uns8 crcH,crcL,i,byte;
                  00872 			;	crcH = 0xff;
000276 687F       00873 	SETF  crcH_2,0
                  00874 			;	crcL = 0xff;
000278 687F       00875 	SETF  crcL_2,0
                  00876 			;
                  00877 			;	for(i = 0; i < length; i++) {
00027A 6A7F       00878 	CLRF  i,0
00027C 507F       00879 m009	MOVF  length,W,0
00027E 607F       00880 	CPFSLT i,0
000280 D012       00881 	BRA   m010
                  00882 			;		byte = data[i];
000282 507F       00883 	MOVF  i,W,0
000284 247F       00884 	ADDWF data,W,0
000286 ECE8 F013  00885 	CALL  _const1
00028A 6E7F       00886 	MOVWF byte_3,0
                  00887 			;		Crc_AddCrc(byte,&crcH,&crcL);
00028C CF7F F013  00888 	MOVFF byte_3,byte
000290 0E7F       00889 	MOVLW 127
000292 6E14       00890 	MOVWF p_crcH,0
000294 0E0F       00891 	MOVLW 15
000296 6E15       00892 	MOVWF p_crcH+1,0
000298 0E7F       00893 	MOVLW 127
00029A 6E16       00894 	MOVWF p_crcL,0
00029C 0E0F       00895 	MOVLW 15
00029E 6E17       00896 	MOVWF p_crcL+1,0
0002A0 DFAD       00897 	RCALL Crc_AddCrc
                  00898 			;	}
0002A2 2A7F       00899 	INCF  i,1,0
0002A4 D7EB       00900 	BRA   m009
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 16

ADDR   CODE       LINE  SOURCE

                  00901 			;
                  00902 			;	*crcH_out = crcH;
0002A6 CF7F FFE9  00903 m010	MOVFF crcH_out,FSR0
0002AA 6AEA       00904 	CLRF  FSR0+1,0
0002AC CF7F FFEF  00905 	MOVFF crcH_2,INDF0
                  00906 			;	*crcL_out = crcL;
0002B0 CF7F FFE9  00907 	MOVFF crcL_out,FSR0
0002B4 6AEA       00908 	CLRF  FSR0+1,0
0002B6 CF7F FFEF  00909 	MOVFF crcL_2,INDF0
                  00910 			;}
0002BA 0012       00911 	RETURN
                  00912 			;
                  00913 			;void Crc_NewCrc(uns8 *p_crcH, uns8 *p_crcL)
                  00914 			;{
                  00915 Crc_NewCrc
                  00916 			;	if(!p_crcH) return;
0002BC 5013       00917 	MOVF  p_crcH_2,W,0
0002BE 1014       00918 	IORWF p_crcH_2+1,W,0
0002C0 B4D8       00919 	BTFSC 0xFD8,Zero_,0
0002C2 0012       00920 	RETURN
                  00921 			;	if(!p_crcL) return;
0002C4 5015       00922 	MOVF  p_crcL_2,W,0
0002C6 1016       00923 	IORWF p_crcL_2+1,W,0
0002C8 B4D8       00924 	BTFSC 0xFD8,Zero_,0
0002CA 0012       00925 	RETURN
                  00926 			;	// bootloader is using 0x0000 as initial crc not 0xFFFF
                  00927 			;	*p_crcH = 0x00;
0002CC C013 FFE9  00928 	MOVFF p_crcH_2,FSR0
0002D0 C014 FFEA  00929 	MOVFF p_crcH_2+1,FSR0+1
0002D4 6AEF       00930 	CLRF  INDF0,0
                  00931 			;	*p_crcL = 0x00;
0002D6 C015 FFE9  00932 	MOVFF p_crcL_2,FSR0
0002DA C016 FFEA  00933 	MOVFF p_crcL_2+1,FSR0+1
0002DE 6AEF       00934 	CLRF  INDF0,0
                  00935 			;}
0002E0 0012       00936 	RETURN
                  00937 
                  00938   ; FILE ./firmware\eeprom.c
                  00939 			;/**
                  00940 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  00941 			;
                  00942 			; This file is part of Wifly_Light.
                  00943 			;
                  00944 			; Wifly_Light is free software: you can redistribute it and/or modify
                  00945 			; it under the terms of the GNU General Public License as published by
                  00946 			; the Free Software Foundation, either version 3 of the License, or
                  00947 			; (at your option) any later version.
                  00948 			;
                  00949 			; Wifly_Light is distributed in the hope that it will be useful,
                  00950 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  00951 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  00952 			; GNU General Public License for more details.
                  00953 			;
                  00954 			; You should have received a copy of the GNU General Public License
                  00955 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  00956 			;
                  00957 			;#include "eeprom.h"
                  00958 			;
                  00959 			;#define Eeprom_Init()
                  00960 			;
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 17

ADDR   CODE       LINE  SOURCE

                  00961 			;#ifdef __CC8E__
                  00962 			;//*********************** EEPROM BYTE SCHREIBEN  **********************************************
                  00963 			;void Eeprom_Write(const uns16 adress, const uns8 data)
                  00964 			;{
                  00965 Eeprom_Write
                  00966 			;	bit GIE_status;
                  00967 			;	GIE_status = GIE;
0002E2 901D       00968 	BCF   0x1D,GIE_status,0
0002E4 BEF2       00969 	BTFSC 0xFF2,GIE,0
0002E6 801D       00970 	BSF   0x1D,GIE_status,0
                  00971 			;
                  00972 			;	EEADRH = adress.high8;
0002E8 C01B FFAA  00973 	MOVFF adress+1,EEADRH
                  00974 			;	EEADR = adress.low8;            // Adresse in Adressregister übertragen
0002EC C01A FFA9  00975 	MOVFF adress,EEADR
                  00976 			;	EEDATA = data;// Daten in Datenregister übertragen
0002F0 C01C FFA8  00977 	MOVFF data_2,EEDATA
                  00978 			;
                  00979 			;	CFGS = 0;
0002F4 9CA6       00980 	BCF   0xFA6,CFGS,0
                  00981 			;	EEPGD = 0;// Auswahl: Programmspeicher lesen oder EEPROM
0002F6 9EA6       00982 	BCF   0xFA6,EEPGD,0
                  00983 			;	WREN = 1;// Schreiben ins EEPROM erlauben
0002F8 84A6       00984 	BSF   0xFA6,WREN,0
                  00985 			;	GIE = 0;// Interrups verbieten
0002FA 9EF2       00986 	BCF   0xFF2,GIE,0
                  00987 			;
                  00988 			;	EECON2 = 0x55;
0002FC 0E55       00989 	MOVLW 85
0002FE 6EA7       00990 	MOVWF EECON2,0
                  00991 			;	EECON2 = 0xAA;
000300 0EAA       00992 	MOVLW 170
000302 6EA7       00993 	MOVWF EECON2,0
                  00994 			;	WR = 1;// Starten des Schreibens
000304 82A6       00995 	BSF   0xFA6,WR,0
                  00996 			;	GIE = GIE_status;// Interrups erlauben
000306 A01D       00997 	BTFSS 0x1D,GIE_status,0
000308 9EF2       00998 	BCF   0xFF2,GIE,0
00030A B01D       00999 	BTFSC 0x1D,GIE_status,0
00030C 8EF2       01000 	BSF   0xFF2,GIE,0
                  01001 			;	WREN = 0;
00030E 94A6       01002 	BCF   0xFA6,WREN,0
                  01003 			;	while(WR);
000310 B2A6       01004 m011	BTFSC 0xFA6,WR,0
000312 D7FE       01005 	BRA   m011
                  01006 			;}
000314 0012       01007 	RETURN
                  01008 			;
                  01009 			;//*********************** EEPROM BYTE LESEN  **********************************************
                  01010 			;
                  01011 			;uns8 Eeprom_Read(const uns16 adress)
                  01012 			;{
                  01013 Eeprom_Read
                  01014 			;	uns8 data;
                  01015 			;	EEADRH = adress.high8;        // Adresse in Adressregister übertragen
000316 C010 FFAA  01016 	MOVFF adress_2+1,EEADRH
                  01017 			;	EEADR = adress.low8;
00031A C00F FFA9  01018 	MOVFF adress_2,EEADR
                  01019 			;	CFGS = 0;
00031E 9CA6       01020 	BCF   0xFA6,CFGS,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 18

ADDR   CODE       LINE  SOURCE

                  01021 			;	EEPGD = 0;// Auswahl: Programmspeicher lesen oder EEPROM
000320 9EA6       01022 	BCF   0xFA6,EEPGD,0
                  01023 			;	RD = 1;// Starten des Lesesn
000322 80A6       01024 	BSF   0xFA6,RD,0
                  01025 			;	data = EEDATA;// Daten aus Datenregister auslesen
000324 CFA8 F011  01026 	MOVFF EEDATA,data_3
                  01027 			;	return data;
000328 5011       01028 	MOVF  data_3,W,0
00032A 0012       01029 	RETURN
                  01030 			;}
                  01031 			;
                  01032 			;#else /* X86 */
                  01033 			;
                  01034 			;#include "ScriptCtrl.h"
                  01035 			;#include "wifly_cmd.h"
                  01036 			;#include <assert.h>
                  01037 			;static uns8 g_Eeprom[(1 + SCRIPTCTRL_NUM_CMD_MAX) * sizeof(struct led_cmd)];
                  01038 			;
                  01039 			;uns8 Eeprom_Read(const uns16 adress)
                  01040 			;{
                  01041 			;	return g_Eeprom[adress];
                  01042 			;}
                  01043 			;
                  01044 			;void Eeprom_Write(const uns16 adress, const uns8 data)
                  01045 			;{
                  01046 			;	assert(adress < sizeof(g_Eeprom));
                  01047 			;	g_Eeprom[adress] = data;
                  01048 			;}
                  01049 			;#endif /* #ifdef X86 */
                  01050 			;//*********************** EEPROM BYTEARRAY SCHREIBEN  **************************************
                  01051 			;
                  01052 			;void Eeprom_WriteBlock(const uns8 *array, uns16 adress, const uns8 length) //Zum Ausführen eines beliebigen Befehls durch den Programmcode
                  01053 			;{
                  01054 Eeprom_WriteBlock
                  01055 			;	if (!array) return;
00032C 5012       01056 	MOVF  array,W,0
00032E 1013       01057 	IORWF array+1,W,0
000330 B4D8       01058 	BTFSC 0xFD8,Zero_,0
000332 0012       01059 	RETURN
                  01060 			;#ifndef __CC8E__
                  01061 			;	memcpy(&g_Eeprom[adress], array, length);
                  01062 			;#else
                  01063 			;	uns8 i;
                  01064 			;	for(i = 0; i < length; i++) {
000334 6A17       01065 	CLRF  i_2,0
000336 5016       01066 m012	MOVF  length_2,W,0
000338 6017       01067 	CPFSLT i_2,0
00033A D017       01068 	BRA   m013
                  01069 			;		uns8 *pByte = (uns8 *)array;
00033C C012 F018  01070 	MOVFF array,pByte
000340 C013 F019  01071 	MOVFF array+1,pByte+1
                  01072 			;		Eeprom_Write(adress, *pByte);
000344 C014 F01A  01073 	MOVFF adress_3,adress
000348 C015 F01B  01074 	MOVFF adress_3+1,adress+1
00034C C018 FFE9  01075 	MOVFF pByte,FSR0
000350 C019 FFEA  01076 	MOVFF pByte+1,FSR0+1
000354 CFEF F01C  01077 	MOVFF INDF0,data_2
000358 DFC4       01078 	RCALL Eeprom_Write
                  01079 			;		adress++;
00035A 2A14       01080 	INCF  adress_3,1,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 19

ADDR   CODE       LINE  SOURCE

00035C 0E00       01081 	MOVLW 0
00035E 2215       01082 	ADDWFC adress_3+1,1,0
                  01083 			;		array++;
000360 2A12       01084 	INCF  array,1,0
000362 0E00       01085 	MOVLW 0
000364 2213       01086 	ADDWFC array+1,1,0
                  01087 			;	}
000366 2A17       01088 	INCF  i_2,1,0
000368 D7E6       01089 	BRA   m012
                  01090 			;#endif
                  01091 			;}
00036A 0012       01092 m013	RETURN
                  01093 			;
                  01094 			;//*********************** EEPROM BYTEARRAY LESEN  **************************************
                  01095 			;
                  01096 			;void Eeprom_ReadBlock(uns8 *array, uns16 adress, const uns8 length) //Zum Ausführen eines beliebigen Befehls durch den Programmcode
                  01097 			;{
                  01098 Eeprom_ReadBlock
                  01099 			;	if (!array) return;
00036C 5209       01100 	MOVF  array_2,1,0
00036E B4D8       01101 	BTFSC 0xFD8,Zero_,0
000370 0012       01102 	RETURN
                  01103 			;#ifndef __CC8E__
                  01104 			;	memcpy(array, &g_Eeprom[adress], length);
                  01105 			;#else
                  01106 			;	uns8 i, temp;
                  01107 			;	for(i = 0; i < length; i++) {
000372 6A0D       01108 	CLRF  i_3,0
000374 500C       01109 m014	MOVF  length_3,W,0
000376 600D       01110 	CPFSLT i_3,0
000378 D011       01111 	BRA   m015
                  01112 			;		temp = Eeprom_Read(adress);
00037A C00A F00F  01113 	MOVFF adress_4,adress_2
00037E C00B F010  01114 	MOVFF adress_4+1,adress_2+1
000382 DFC9       01115 	RCALL Eeprom_Read
000384 6E0E       01116 	MOVWF temp_2,0
                  01117 			;		array[i] = temp;
000386 6AEA       01118 	CLRF  FSR0+1,0
000388 500D       01119 	MOVF  i_3,W,0
00038A 2409       01120 	ADDWF array_2,W,0
00038C 6EE9       01121 	MOVWF FSR0,0
00038E C00E FFEF  01122 	MOVFF temp_2,INDF0
                  01123 			;		adress++;
000392 2A0A       01124 	INCF  adress_4,1,0
000394 0E00       01125 	MOVLW 0
000396 220B       01126 	ADDWFC adress_4+1,1,0
                  01127 			;	}
000398 2A0D       01128 	INCF  i_3,1,0
00039A D7EC       01129 	BRA   m014
                  01130 			;#endif
                  01131 			;}
00039C 0012       01132 m015	RETURN
                  01133 
                  01134   ; FILE ./firmware\error.c
                  01135 			;/*
                  01136 			; Copyright (C) 2012, 2013 Nils Weiss, Patrick BrÃ¼nn.
                  01137 			;
                  01138 			; This file is part of Wifly_Light.
                  01139 			;
                  01140 			; Wifly_Light is free software: you can redistribute it and/or modify
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 20

ADDR   CODE       LINE  SOURCE

                  01141 			; it under the terms of the GNU General Public License as published by
                  01142 			; the Free Software Foundation, either version 3 of the License, or
                  01143 			; (at your option) any later version.
                  01144 			;
                  01145 			; Wifly_Light is distributed in the hope that it will be useful,
                  01146 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  01147 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  01148 			; GNU General Public License for more details.
                  01149 			;
                  01150 			; You should have received a copy of the GNU General Public License
                  01151 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  01152 			;
                  01153 			;#include "error.h"
                  01154 			;#include "RingBuf.h"
                  01155 			;#include "trace.h"
                  01156 			;
                  01157 			;void Error_Throw()
                  01158 			;{
                  01159 Error_Throw
                  01160 			;#ifdef DEBUG
                  01161 			;	if(RingBuf_HasError(&g_TraceBuf)) {
00039E 0E83       01162 	MOVLW 131
0003A0 6E15       01163 	MOVWF pBuf_4,0
0003A2 6A16       01164 	CLRF  pBuf_4+1,0
0003A4 EC23 F00A  01165 	CALL  RingBuf_HasError
0003A8 A0D8       01166 	BTFSS 0xFD8,Carry,0
0003AA D009       01167 	BRA   m016
                  01168 			;		// *** Re-init the Ringbuffer
                  01169 			;		RingBuf_Init(&g_TraceBuf);
0003AC 0E83       01170 	MOVLW 131
0003AE 6E07       01171 	MOVWF pBuf,0
0003B0 6A08       01172 	CLRF  pBuf+1,0
0003B2 ECC5 F009  01173 	CALL  RingBuf_Init
                  01174 			;		Trace_String(ERROR_TRACEBUFFER_FULL);
0003B6 0E0C       01175 	MOVLW 12
0003B8 6E12       01176 	MOVWF string,0
0003BA EFBE F011  01177 	GOTO  Trace_String
                  01178 			;	}
                  01179 			;#endif
                  01180 			;}
0003BE 0012       01181 m016	RETURN
                  01182 
                  01183   ; FILE ./firmware\MATH16.H
                  01184 			;// SIZE
                  01185 			;#pragma codepage 1
                  01186 			;#pragma library 1
                  01187 			;/*
                  01188 			;uns16 operator* _mult8x8( uns8 arg1, uns8 arg2);
                  01189 			;int16 operator* _multS8x8( int8 arg1, int8 arg2);
                  01190 			;uns16 operator* _multU16x8( uns16 arg1, uns8 arg2);
                  01191 			;uns16 operator* _mult16x16( uns16 arg1, uns16 arg2);
                  01192 			;uns16 operator/ _divU16_8( uns16 arg1, uns8 arg2);
                  01193 			;uns16 operator/ _divU16_16( uns16 arg1, uns16 arg2);
                  01194 			;int16 operator/ _divS16_8( int16 arg1, int8 arg2);
                  01195 			;int16 operator/ _divS16_16( int16 arg1, int16 arg2);
                  01196 			;uns8 operator% _remU16_8( uns16 arg1, uns8 arg2);
                  01197 			;uns16 operator% _remU16_16( uns16 arg1, uns16 arg2);
                  01198 			;int8 operator% _remS16_8( int16 arg1, int8 arg2);
                  01199 			;int16 operator% _remS16_16( int16 arg1, int16 arg2);
                  01200 			;*/
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 21

ADDR   CODE       LINE  SOURCE

                  01201 			;
                  01202 			;#if __CoreSet__ < 1410
                  01203 			; #define genAdd(r,a) W=a; btsc(Carry); W=incsz(a); r+=W
                  01204 			; #define genSub(r,a) W=a; btss(Carry); W=incsz(a); r-=W
                  01205 			; #define genAddW(r,a) W=a; btsc(Carry); W=incsz(a); W=r+W
                  01206 			; #define genSubW(r,a) W=a; btss(Carry); W=incsz(a); W=r-W
                  01207 			;#else
                  01208 			; #define genAdd(r,a) W=a; r=addWFC(r)
                  01209 			; #define genSub(r,a) W=a; r=subWFB(r)
                  01210 			; #define genAddW(r,a) W=a; W=addWFC(r)
                  01211 			; #define genSubW(r,a) W=a; W=subWFB(r)
                  01212 			;#endif
                  01213 			;
                  01214 			;
                  01215 			;int8 operator*( int8 arg1, int8 arg2)  @
                  01216 			;
                  01217 			;uns16 operator* _mult8x8( uns8 arg1, uns8 arg2)
                  01218 			;{
                  01219 _mult8x8
0003C0 6E1F       01220 	MOVWF arg2,0
                  01221 			;    uns16 rval;
                  01222 			;    char counter = sizeof(arg2)*8;
0003C2 0E08       01223 	MOVLW 8
0003C4 6E22       01224 	MOVWF counter,0
                  01225 			;    rval.high8 = 0;
0003C6 6A21       01226 	CLRF  rval+1,0
                  01227 			;    W = arg1;
0003C8 501E       01228 	MOVF  arg1,W,0
                  01229 			;    do  {
                  01230 			;        arg2 = rr( arg2);
0003CA 321F       01231 m017	RRCF  arg2,1,0
                  01232 			;        if (Carry)
0003CC B0D8       01233 	BTFSC 0xFD8,Carry,0
                  01234 			;            rval.high8 += W;
0003CE 2621       01235 	ADDWF rval+1,1,0
                  01236 			;        rval = rr( rval);
0003D0 3221       01237 	RRCF  rval+1,1,0
0003D2 3220       01238 	RRCF  rval,1,0
                  01239 			;        counter = decsz(counter);
0003D4 2E22       01240 	DECFSZ counter,1,0
                  01241 			;    } while (1);
0003D6 D7F9       01242 	BRA   m017
                  01243 			;    return rval;
0003D8 5020       01244 	MOVF  rval,W,0
0003DA 0012       01245 	RETURN
                  01246 			;}
                  01247 			;
                  01248 			;
                  01249 			;int16 operator* _multS8x8( int8 arg1, int8 arg2)
                  01250 			;{
                  01251 _multS8x8
                  01252 			;    uns16 rval;
                  01253 			;    char counter = sizeof(arg2)*8;
                  01254 			;    int8 tmpArg2 = arg2;
                  01255 			;    rval.high8 = 0;
                  01256 			;    W = arg1;
                  01257 			;    do  {
                  01258 			;        tmpArg2 = rr( tmpArg2);
                  01259 			;        if (Carry)
                  01260 			;            rval.high8 += W;
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 22

ADDR   CODE       LINE  SOURCE

                  01261 			;        rval = rr( rval);
                  01262 			;        counter = decsz(counter);
                  01263 			;    } while (1);
                  01264 			;    W = arg2;
                  01265 			;    if (arg1 < 0)
                  01266 			;        rval.high8 -= W;
                  01267 			;    W = arg1;
                  01268 			;    if (arg2 < 0)
                  01269 			;        rval.high8 -= W;
                  01270 			;    return rval;
                  01271 			;}
                  01272 			;
                  01273 			;
                  01274 			;uns16 operator*( uns8 arg1, uns16 arg2) exchangeArgs @
                  01275 			;
                  01276 			;uns16 operator* _multU16x8( uns16 arg1, uns8 arg2)
                  01277 			;{
                  01278 _multU16x8
                  01279 			;    uns16 rval;
                  01280 			;    uns8 rvalH = 0;
                  01281 			;    char counter = sizeof(arg1)*8;
                  01282 			;    W = arg2;
                  01283 			;    do  {
                  01284 			;        arg1 = rr( arg1);
                  01285 			;        if (Carry)
                  01286 			;            rvalH += W;
                  01287 			;        rvalH = rr(rvalH);
                  01288 			;        rval = rr(rval);
                  01289 			;        counter = decsz(counter);
                  01290 			;    } while (1);
                  01291 			;    return rval;
                  01292 			;}
                  01293 			;
                  01294 			;
                  01295 			;int16 operator*( int16 arg1, int16 arg2) @
                  01296 			;
                  01297 			;uns16 operator* _mult16x16( uns16 arg1, uns16 arg2)
                  01298 			;{
                  01299 _mult16x16
                  01300 			;    uns16 rval;
                  01301 			;    char counter = sizeof(arg1)*8;
                  01302 			;    do  {
                  01303 			;        Carry = 0;
                  01304 			;        rval = rl( rval);
                  01305 			;        arg1 = rl( arg1);
                  01306 			;        if (Carry)
                  01307 			;            rval += arg2;
                  01308 			;        counter = decsz(counter);
                  01309 			;    } while (1);
                  01310 			;    return rval;
                  01311 			;}
                  01312 			;
                  01313 			;
                  01314 			;
                  01315 			;uns16 operator/ _divU16_8( uns16 arg1, uns8 arg2)
                  01316 			;{
                  01317 _divU16_8
0003DC 6E20       01318 	MOVWF arg2_5,0
                  01319 			;    uns8 rm = 0;
0003DE 6A21       01320 	CLRF  rm,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 23

ADDR   CODE       LINE  SOURCE

                  01321 			;    char counter = sizeof(arg1)*8+1;
0003E0 0E11       01322 	MOVLW 17
0003E2 6E22       01323 	MOVWF counter_5,0
                  01324 			;    goto ENTRY_ML;
0003E4 D008       01325 	BRA   m019
                  01326 			;    do  {
                  01327 			;        rm = rl( rm);
0003E6 3621       01328 m018	RLCF  rm,1,0
                  01329 			;        uns8 tmp = rl( tmp);
0003E8 3623       01330 	RLCF  tmp,1,0
                  01331 			;        W = rm - arg2;
0003EA 5020       01332 	MOVF  arg2_5,W,0
0003EC 5C21       01333 	SUBWF rm,W,0
                  01334 			;        if (tmp&1)
0003EE B023       01335 	BTFSC tmp,0,0
                  01336 			;            Carry = 1;
0003F0 80D8       01337 	BSF   0xFD8,Carry,0
                  01338 			;        if (Carry)
0003F2 B0D8       01339 	BTFSC 0xFD8,Carry,0
                  01340 			;            rm = W;
0003F4 6E21       01341 	MOVWF rm,0
                  01342 			;       ENTRY_ML:
                  01343 			;        arg1 = rl( arg1);
0003F6 361E       01344 m019	RLCF  arg1_5,1,0
0003F8 361F       01345 	RLCF  arg1_5+1,1,0
                  01346 			;        counter = decsz(counter);
0003FA 2E22       01347 	DECFSZ counter_5,1,0
                  01348 			;    } while (1);
0003FC D7F4       01349 	BRA   m018
                  01350 			;    return arg1;
0003FE 501E       01351 	MOVF  arg1_5,W,0
000400 0012       01352 	RETURN
                  01353 			;}
                  01354 			;
                  01355 			;
                  01356 			;uns16 operator/ _divU16_16( uns16 arg1, uns16 arg2)
                  01357 			;{
                  01358 _divU16_16
                  01359 			;    uns16 rm = 0;
                  01360 			;    char counter = sizeof(arg1)*8+1;
                  01361 			;    goto ENTRY_ML;
                  01362 			;    do  {
                  01363 			;        rm = rl( rm);
                  01364 			;        W = rm.low8 - arg2.low8;
                  01365 			;        genSubW( rm.high8, arg2.high8);
                  01366 			;        if (!Carry)
                  01367 			;            goto ENTRY_ML;
                  01368 			;        rm.high8 = W;
                  01369 			;        rm.low8 -= arg2.low8;
                  01370 			;        Carry = 1;
                  01371 			;       ENTRY_ML:
                  01372 			;        arg1 = rl( arg1);
                  01373 			;        counter = decsz(counter);
                  01374 			;    } while (1);
                  01375 			;    return arg1;
                  01376 			;}
                  01377 			;
                  01378 			;
                  01379 			;int8  operator/ (int8 arg1, int8 arg2) @
                  01380 			;
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 24

ADDR   CODE       LINE  SOURCE

                  01381 			;int16 operator/ _divS16_8( int16 arg1, int8 arg2)
                  01382 			;{
                  01383 _divS16_8
                  01384 			;    uns8 rm = 0;
                  01385 			;    char counter = 16+1;
                  01386 			;    char sign = arg1.high8 ^ arg2.high8;
                  01387 			;    if (arg1 < 0)  {
                  01388 			;       INVERT_ML:
                  01389 			;        arg1 = -arg1;
                  01390 			;        if (!counter)
                  01391 			;            return arg1;
                  01392 			;    }
                  01393 			;    if (arg2 < 0)
                  01394 			;        arg2 = -arg2;
                  01395 			;    goto ENTRY_ML;
                  01396 			;    do  {
                  01397 			;        rm = rl( rm);
                  01398 			;        W = rm - arg2;
                  01399 			;        if (Carry)
                  01400 			;            rm = W;
                  01401 			;       ENTRY_ML:
                  01402 			;        arg1 = rl( arg1);
                  01403 			;        counter = decsz(counter);
                  01404 			;    } while (1);
                  01405 			;    if (sign & 0x80)
                  01406 			;        goto INVERT_ML;
                  01407 			;    return arg1;
                  01408 			;}
                  01409 			;
                  01410 			;
                  01411 			;int16 operator/ _divS16_16( int16 arg1, int16 arg2)
                  01412 			;{
                  01413 _divS16_16
                  01414 			;    uns16 rm = 0;
                  01415 			;    char counter = sizeof(arg1)*8+1;
                  01416 			;    char sign = arg1.high8 ^ arg2.high8;
                  01417 			;    if (arg1 < 0)  {
                  01418 			;       INVERT_ML:
                  01419 			;        arg1 = -arg1;
                  01420 			;        if (!counter)
                  01421 			;            return arg1;
                  01422 			;    }
                  01423 			;    if (arg2 < 0)
                  01424 			;        arg2 = -arg2;
                  01425 			;    goto ENTRY_ML;
                  01426 			;    do  {
                  01427 			;        rm = rl( rm);
                  01428 			;        W = rm.low8 - arg2.low8;
                  01429 			;        genSubW( rm.high8, arg2.high8);
                  01430 			;        if (!Carry)
                  01431 			;            goto ENTRY_ML;
                  01432 			;        rm.high8 = W;
                  01433 			;        rm.low8 -= arg2.low8;
                  01434 			;        Carry = 1;
                  01435 			;       ENTRY_ML:
                  01436 			;        arg1 = rl( arg1);
                  01437 			;        counter = decsz(counter);
                  01438 			;    } while (1);
                  01439 			;    if (sign & 0x80)
                  01440 			;        goto INVERT_ML;
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 25

ADDR   CODE       LINE  SOURCE

                  01441 			;    return arg1;
                  01442 			;}
                  01443 			;
                  01444 			;
                  01445 			;uns8 operator% _remU16_8( uns16 arg1, uns8 arg2)
                  01446 			;{
                  01447 _remU16_8
                  01448 			;    uns8 rm = 0;
                  01449 			;    char counter = sizeof(arg1)*8;
                  01450 			;    do  {
                  01451 			;        arg1 = rl( arg1);
                  01452 			;        rm = rl( rm);
                  01453 			;        uns8 tmp = rl( tmp);
                  01454 			;        W = rm - arg2;
                  01455 			;        if (tmp&1)
                  01456 			;            Carry = 1;
                  01457 			;        if (Carry)
                  01458 			;            rm = W;
                  01459 			;        counter = decsz(counter);
                  01460 			;    } while (1);
                  01461 			;    return rm;
                  01462 			;}
                  01463 			;
                  01464 			;
                  01465 			;uns16 operator% _remU16_16( uns16 arg1, uns16 arg2)
                  01466 			;{
                  01467 _remU16_16
                  01468 			;    uns16 rm = 0;
                  01469 			;    char counter = sizeof(arg1)*8;
                  01470 			;    do  {
                  01471 			;        arg1 = rl( arg1);
                  01472 			;        rm = rl( rm);
                  01473 			;        W = rm.low8 - arg2.low8;
                  01474 			;        genSubW( rm.high8, arg2.high8);
                  01475 			;        if (!Carry)
                  01476 			;            goto NOSUB;
                  01477 			;        rm.high8 = W;
                  01478 			;        rm.low8 -= arg2.low8;
                  01479 			;      NOSUB:
                  01480 			;        counter = decsz(counter);
                  01481 			;    } while (1);
                  01482 			;    return rm;
                  01483 			;}
                  01484 			;
                  01485 			;
                  01486 			;int8 operator% (int8 arg1, int8 arg2) @
                  01487 			;
                  01488 			;int8 operator% _remS16_8( int16 arg1, int8 arg2)
                  01489 			;{
                  01490 _remS16_8
                  01491 			;    int8 rm = 0;
                  01492 			;    char counter = 16;
                  01493 			;    char sign = arg1.high8;
                  01494 			;    if (arg1 < 0)
                  01495 			;        arg1 = -arg1;
                  01496 			;    if (arg2 < 0)
                  01497 			;        arg2 = -arg2;
                  01498 			;    do  {
                  01499 			;        arg1 = rl( arg1);
                  01500 			;        rm = rl( rm);
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 26

ADDR   CODE       LINE  SOURCE

                  01501 			;        W = rm - arg2;
                  01502 			;        if (Carry)
                  01503 			;            rm = W;
                  01504 			;        counter = decsz(counter);
                  01505 			;    } while (1);
                  01506 			;    if (sign & 0x80)
                  01507 			;        rm = -rm;
                  01508 			;    return rm;
                  01509 			;}
                  01510 			;
                  01511 			;
                  01512 			;int16 operator% _remS16_16( int16 arg1, int16 arg2)
                  01513 			;{
                  01514 _remS16_16
                  01515 			;    int16 rm = 0;
                  01516 			;    char counter = sizeof(arg1)*8;
                  01517 			;    char sign = arg1.high8;
                  01518 			;    if (arg1 < 0)
                  01519 			;        arg1 = -arg1;
                  01520 			;    if (arg2 < 0)
                  01521 			;        arg2 = -arg2;
                  01522 			;    do  {
                  01523 			;        arg1 = rl( arg1);
                  01524 			;        rm = rl( rm);
                  01525 			;        W = rm.low8 - arg2.low8;
                  01526 			;        genSubW( rm.high8, arg2.high8);
                  01527 			;        if (!Carry)
                  01528 			;            goto NOSUB;
                  01529 			;        rm.high8 = W;
                  01530 			;        rm.low8 -= arg2.low8;
                  01531 			;      NOSUB:
                  01532 			;        counter = decsz(counter);
                  01533 			;    } while (1);
                  01534 			;    if (sign & 0x80)
                  01535 			;        rm = -rm;
                  01536 			;    return rm;
                  01537 
                  01538   ; FILE ./firmware\ledstrip.c
                  01539 			;/**
                  01540 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  01541 			;
                  01542 			; This file is part of Wifly_Light.
                  01543 			;
                  01544 			; Wifly_Light is free software: you can redistribute it and/or modify
                  01545 			; it under the terms of the GNU General Public License as published by
                  01546 			; the Free Software Foundation, either version 3 of the License, or
                  01547 			; (at your option) any later version.
                  01548 			;
                  01549 			; Wifly_Light is distributed in the hope that it will be useful,
                  01550 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  01551 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  01552 			; GNU General Public License for more details.
                  01553 			;
                  01554 			; You should have received a copy of the GNU General Public License
                  01555 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  01556 			;
                  01557 			;#include "ledstrip.h"
                  01558 			;#include "spi.h"
                  01559 			;
                  01560 			;#ifdef __CC8E__
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 27

ADDR   CODE       LINE  SOURCE

                  01561 			;#include "MATH16.H"
                  01562 			;#endif /* #ifdef __CC8E__ */
                  01563 			;
                  01564 			;#ifdef cc3200 /* ifdef cc3200 */
                  01565 			;
                  01566 			;#include "socket.h"
                  01567 			;#include "pwm.h"
                  01568 			;#include "osi.h"
                  01569 			;#include "FreeRTOS.h"
                  01570 			;#include "task.h"
                  01571 			;#include "semphr.h"
                  01572 			;
                  01573 			;static xSemaphoreHandle g_AccessLedBufferMutex;
                  01574 			;OsiLockObj_t AccessLedBufferMutex = &g_AccessLedBufferMutex;
                  01575 			;
                  01576 			;#endif /* #ifndef cc3200 */
                  01577 			;
                  01578 			;struct LedBuffer gLedBuf;
                  01579 			;struct cmd_set_fade mFade;
                  01580 			;
                  01581 			;/**
                  01582 			; * Since we often work with a rotating bitmask which is greater
                  01583 			; * than 1 byte we use this macro to keep the mask and the bitfield
                  01584 			; * in sync.
                  01585 			; */
                  01586 			;#define INC_BIT_COUNTER(PTR, MASK) { \
                  01587 			;		MASK <<= 1; \
                  01588 			;		if(0 == MASK) { \
                  01589 			;			PTR++; \
                  01590 			;			MASK = 0x01; \
                  01591 			;		} \
                  01592 			;}
                  01593 			;
                  01594 			;/**
                  01595 			; * This macro is used to iterate over each led and each color.
                  01596 			; * <BLOCK> is executed if the led color was selected in <pCmd->addr>
                  01597 			; * <ELSE> is executed if not
                  01598 			; */
                  01599 			;#define FOR_EACH_MASKED_LED_DO(BLOCK, ELSE) { \
                  01600 			;		uns8 *address = pCmd->addr; \
                  01601 			;		uns8 k,mask; \
                  01602 			;		mask = 0x01; \
                  01603 			;		for(k = 0; k < sizeof(gLedBuf.led_array); k++) {        \
                  01604 			;			if(0 != (*address & mask)) { \
                  01605 			;				BLOCK \
                  01606 			;			} \
                  01607 			;			else { \
                  01608 			;				ELSE \
                  01609 			;			} \
                  01610 			;			INC_BIT_COUNTER(address, mask); \
                  01611 			;		} \
                  01612 			;}
                  01613 			;
                  01614 			;/**
                  01615 			; * This is a sub-macro of <FOR_EACH_MASKED_LED_DO> used in fade precalculations
                  01616 			; * to calculate the fading parameters(<periodeLength>, <stepSize> and <delta>) for <newColor>
                  01617 			;**/
                  01618 			;#define CALC_COLOR(newColor)  \
                  01619 			;	{ \
                  01620 			;		delta = gLedBuf.led_array[k]; \
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 28

ADDR   CODE       LINE  SOURCE

                  01621 			;		if(delta > newColor)  \
                  01622 			;		{ \
                  01623 			;			delta = delta - newColor;  \
                  01624 			;			*(stepAddress) |= (stepMask);  \
                  01625 			;		} \
                  01626 			;		else  \
                  01627 			;		{  \
                  01628 			;			delta = newColor - delta;  \
                  01629 			;			*(stepAddress) &= ~(stepMask); \
                  01630 			;		}  \
                  01631 			;			INC_BIT_COUNTER(stepAddress, stepMask); \
                  01632 			;		stepSize = 0x01; \
                  01633 			;		temp16 = 0; \
                  01634 			;		if((0 != delta))  \
                  01635 			;		{ \
                  01636 			;			do { \
                  01637 			;				temp8 = delta / stepSize; \
                  01638 			;				temp16 = fadeTmms / temp8;  \
                  01639 			;				if(temp16 < 1) { \
                  01640 			;					stepSize += 1; } \
                  01641 			;			} \
                  01642 			;			while(temp16 < 1); \
                  01643 			;		} \
                  01644 			;		gLedBuf.stepSize[k] = stepSize; \
                  01645 			;		gLedBuf.delta[k] = delta; \
                  01646 			;		gLedBuf.periodeLength[k] = temp16;  \
                  01647 			;		gLedBuf.cyclesLeft[k] = temp16;  \
                  01648 			;	};
                  01649 			;
                  01650 			;void Ledstrip_FadeOffLeds(void)
                  01651 			;{
                  01652 Ledstrip_FadeOffLeds
                  01653 			;	//check current status of led
                  01654 			;	mFade.addr[0] = 0xff;
000402 0100       01655 	MOVLB 0
000404 696C       01656 	SETF  mFade,1
                  01657 			;	mFade.addr[1] = 0xff;
000406 696D       01658 	SETF  mFade+1,1
                  01659 			;	mFade.addr[2] = 0xff;
000408 696E       01660 	SETF  mFade+2,1
                  01661 			;	mFade.addr[3] = 0xff;
00040A 696F       01662 	SETF  mFade+3,1
                  01663 			;	mFade.fadeTmms = htons(200);
00040C 0EC8       01664 	MOVLW 200
00040E 6E17       01665 	MOVWF hostShort,0
000410 6A18       01666 	CLRF  hostShort+1,0
000412 EC31 F00C  01667 	CALL  htons
000416 C019 F074  01668 	MOVFF retval,mFade+8
00041A C01A F075  01669 	MOVFF retval+1,mFade+9
                  01670 			;
                  01671 			;	mFade.red = 0x00;
00041E 6B70       01672 	CLRF  mFade+4,1
                  01673 			;	mFade.green = 0x00;
000420 6B71       01674 	CLRF  mFade+5,1
                  01675 			;	mFade.blue = 0x00;
000422 6B72       01676 	CLRF  mFade+6,1
                  01677 			;
                  01678 			;	Ledstrip_SetFade(&mFade);
000424 0E6C       01679 	MOVLW 108
000426 6E09       01680 	MOVWF pCmd,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 29

ADDR   CODE       LINE  SOURCE

000428 D17E       01681 	BRA   Ledstrip_SetFade
                  01682 			;}
                  01683 			;
                  01684 			;void Ledstrip_Init(void)
                  01685 			;{
                  01686 Ledstrip_Init
                  01687 			;#ifdef cc3200
                  01688 			;	osi_LockObjCreate(AccessLedBufferMutex);
                  01689 			;#endif
                  01690 			;	// initialize interface to ledstrip
                  01691 			;	SPI_Init();
00042A ECEF F008  01692 	CALL  SPI_Init
                  01693 			;#ifdef cc3200
                  01694 			;	osi_LockObjLock(AccessLedBufferMutex, OSI_WAIT_FOREVER);
                  01695 			;#endif
                  01696 			;	// initialize variables
                  01697 			;	uns8 i = sizeof(gLedBuf.led_array);
00042E 0E60       01698 	MOVLW 96
000430 6E07       01699 	MOVWF i_4,0
                  01700 			;	do {
                  01701 			;		i--;
000432 0607       01702 m020	DECF  i_4,1,0
                  01703 			;		gLedBuf.led_array[i] = 0;
000434 0E03       01704 	MOVLW 3
000436 2407       01705 	ADDWF i_4,W,0
000438 6EE9       01706 	MOVWF FSR0,0
00043A 0E08       01707 	MOVLW 8
00043C 6AEA       01708 	CLRF  FSR0+1,0
00043E 22EA       01709 	ADDWFC FSR0+1,1,0
000440 6AEF       01710 	CLRF  INDF0,0
                  01711 			;	}
                  01712 			;	while(0 != i);
000442 5207       01713 	MOVF  i_4,1,0
000444 A4D8       01714 	BTFSS 0xFD8,Zero_,0
000446 D7F5       01715 	BRA   m020
                  01716 			;	/*-------------------------------------*/
                  01717 			;	i = sizeof(gLedBuf.delta);
000448 0E60       01718 	MOVLW 96
00044A 6E07       01719 	MOVWF i_4,0
                  01720 			;	do {
                  01721 			;		i--;
00044C 0607       01722 m021	DECF  i_4,1,0
                  01723 			;		gLedBuf.delta[i] = 0;
00044E 0E63       01724 	MOVLW 99
000450 2407       01725 	ADDWF i_4,W,0
000452 6EE9       01726 	MOVWF FSR0,0
000454 0E08       01727 	MOVLW 8
000456 6AEA       01728 	CLRF  FSR0+1,0
000458 22EA       01729 	ADDWFC FSR0+1,1,0
00045A 6AEF       01730 	CLRF  INDF0,0
                  01731 			;	}
                  01732 			;	while(0 != i);
00045C 5207       01733 	MOVF  i_4,1,0
00045E A4D8       01734 	BTFSS 0xFD8,Zero_,0
000460 D7F5       01735 	BRA   m021
                  01736 			;	/*-------------------------------------*/
                  01737 			;	i = sizeof(gLedBuf.cyclesLeft);
000462 0EC0       01738 	MOVLW 192
000464 6E07       01739 	MOVWF i_4,0
                  01740 			;	do {
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 30

ADDR   CODE       LINE  SOURCE

                  01741 			;		i--;
000466 0607       01742 m022	DECF  i_4,1,0
                  01743 			;		gLedBuf.cyclesLeft[i] = 0;
000468 90D8       01744 	BCF   0xFD8,Carry,0
00046A 3407       01745 	RLCF  i_4,W,0
00046C 6EE9       01746 	MOVWF FSR0,0
00046E 6AEA       01747 	CLRF  FSR0+1,0
000470 36EA       01748 	RLCF  FSR0+1,1,0
000472 0EC3       01749 	MOVLW 195
000474 26E9       01750 	ADDWF FSR0,1,0
000476 0E08       01751 	MOVLW 8
000478 22EA       01752 	ADDWFC FSR0+1,1,0
00047A 6AEE       01753 	CLRF  POSTINC0,0
00047C 6AEF       01754 	CLRF  INDF0,0
                  01755 			;	}
                  01756 			;	while(0 != i);
00047E 5207       01757 	MOVF  i_4,1,0
000480 A4D8       01758 	BTFSS 0xFD8,Zero_,0
000482 D7F1       01759 	BRA   m022
                  01760 			;	/*-------------------------------------*/
                  01761 			;	i = sizeof(gLedBuf.periodeLength);
000484 0EC0       01762 	MOVLW 192
000486 6E07       01763 	MOVWF i_4,0
                  01764 			;	do {
                  01765 			;		i--;
000488 0607       01766 m023	DECF  i_4,1,0
                  01767 			;		gLedBuf.periodeLength[i] = 0;
00048A 90D8       01768 	BCF   0xFD8,Carry,0
00048C 3407       01769 	RLCF  i_4,W,0
00048E 6EE9       01770 	MOVWF FSR0,0
000490 6AEA       01771 	CLRF  FSR0+1,0
000492 36EA       01772 	RLCF  FSR0+1,1,0
000494 0E83       01773 	MOVLW 131
000496 26E9       01774 	ADDWF FSR0,1,0
000498 0E09       01775 	MOVLW 9
00049A 22EA       01776 	ADDWFC FSR0+1,1,0
00049C 6AEE       01777 	CLRF  POSTINC0,0
00049E 6AEF       01778 	CLRF  INDF0,0
                  01779 			;	}
                  01780 			;	while(0 != i);
0004A0 5207       01781 	MOVF  i_4,1,0
0004A2 A4D8       01782 	BTFSS 0xFD8,Zero_,0
0004A4 D7F1       01783 	BRA   m023
                  01784 			;	/*-------------------------------------*/
                  01785 			;	i = sizeof(gLedBuf.step);
0004A6 0E0C       01786 	MOVLW 12
0004A8 6E07       01787 	MOVWF i_4,0
                  01788 			;	do {
                  01789 			;		i--;
0004AA 0607       01790 m024	DECF  i_4,1,0
                  01791 			;		gLedBuf.step[i] = 0;
0004AC 0E43       01792 	MOVLW 67
0004AE 2407       01793 	ADDWF i_4,W,0
0004B0 6EE9       01794 	MOVWF FSR0,0
0004B2 0E0A       01795 	MOVLW 10
0004B4 6AEA       01796 	CLRF  FSR0+1,0
0004B6 22EA       01797 	ADDWFC FSR0+1,1,0
0004B8 6AEF       01798 	CLRF  INDF0,0
                  01799 			;	}
                  01800 			;	while(0 != i);
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 31

ADDR   CODE       LINE  SOURCE

0004BA 5207       01801 	MOVF  i_4,1,0
0004BC A4D8       01802 	BTFSS 0xFD8,Zero_,0
0004BE D7F5       01803 	BRA   m024
                  01804 			;	/*-------------------------------------*/
                  01805 			;	i = sizeof(gLedBuf.stepSize);
0004C0 0E60       01806 	MOVLW 96
0004C2 6E07       01807 	MOVWF i_4,0
                  01808 			;	do {
                  01809 			;		i--;
0004C4 0607       01810 m025	DECF  i_4,1,0
                  01811 			;		gLedBuf.stepSize[i] = 0;
0004C6 0E4F       01812 	MOVLW 79
0004C8 2407       01813 	ADDWF i_4,W,0
0004CA 6EE9       01814 	MOVWF FSR0,0
0004CC 0E0A       01815 	MOVLW 10
0004CE 6AEA       01816 	CLRF  FSR0+1,0
0004D0 22EA       01817 	ADDWFC FSR0+1,1,0
0004D2 6AEF       01818 	CLRF  INDF0,0
                  01819 			;	}
                  01820 			;	while(0 != i);
0004D4 5207       01821 	MOVF  i_4,1,0
0004D6 A4D8       01822 	BTFSS 0xFD8,Zero_,0
0004D8 D7F5       01823 	BRA   m025
                  01824 			;
                  01825 			;	gLedBuf.fadeTmms = 0;
0004DA 010A       01826 	MOVLB 10
0004DC 6BAF       01827 	CLRF  gLedBuf+684,1
0004DE 6BB0       01828 	CLRF  gLedBuf+685,1
                  01829 			;#ifdef cc3200
                  01830 			;	osi_LockObjUnlock(AccessLedBufferMutex);
                  01831 			;#endif
                  01832 			;}
0004E0 0012       01833 	RETURN
                  01834 			;
                  01835 			;void Ledstrip_SetColorDirect(uns8 *pValues)
                  01836 			;{
                  01837 Ledstrip_SetColorDirect
                  01838 			;#ifdef cc3200
                  01839 			;	osi_LockObjLock(AccessLedBufferMutex, OSI_WAIT_FOREVER);
                  01840 			;#endif
                  01841 			;	uns8 k, red, green, blue;
                  01842 			;	for(k = 0; k < sizeof(gLedBuf.led_array); ) {
0004E2 6A0B       01843 	CLRF  k,0
0004E4 0E60       01844 m026	MOVLW 96
0004E6 600B       01845 	CPFSLT k,0
0004E8 D067       01846 	BRA   m027
                  01847 			;		red = *pValues;
0004EA 0E02       01848 	MOVLW 2
0004EC 6EEA       01849 	MOVWF FSR0+1,0
0004EE C00A FFE9  01850 	MOVFF pValues,FSR0
0004F2 CFEF F00C  01851 	MOVFF INDF0,red
                  01852 			;		++pValues;
0004F6 2A0A       01853 	INCF  pValues,1,0
                  01854 			;		green = *pValues;
0004F8 0E02       01855 	MOVLW 2
0004FA 6EEA       01856 	MOVWF FSR0+1,0
0004FC C00A FFE9  01857 	MOVFF pValues,FSR0
000500 CFEF F00D  01858 	MOVFF INDF0,green
                  01859 			;		++pValues;
000504 2A0A       01860 	INCF  pValues,1,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 32

ADDR   CODE       LINE  SOURCE

                  01861 			;		blue = *pValues;
000506 0E02       01862 	MOVLW 2
000508 6EEA       01863 	MOVWF FSR0+1,0
00050A C00A FFE9  01864 	MOVFF pValues,FSR0
00050E CFEF F00E  01865 	MOVFF INDF0,blue
                  01866 			;		++pValues;
000512 2A0A       01867 	INCF  pValues,1,0
                  01868 			;		gLedBuf.led_array[k] = blue;
000514 0E03       01869 	MOVLW 3
000516 240B       01870 	ADDWF k,W,0
000518 6EE9       01871 	MOVWF FSR0,0
00051A 0E08       01872 	MOVLW 8
00051C 6AEA       01873 	CLRF  FSR0+1,0
00051E 22EA       01874 	ADDWFC FSR0+1,1,0
000520 C00E FFEF  01875 	MOVFF blue,INDF0
                  01876 			;		gLedBuf.cyclesLeft[k] = 0;
000524 90D8       01877 	BCF   0xFD8,Carry,0
000526 340B       01878 	RLCF  k,W,0
000528 6EE9       01879 	MOVWF FSR0,0
00052A 6AEA       01880 	CLRF  FSR0+1,0
00052C 36EA       01881 	RLCF  FSR0+1,1,0
00052E 0EC3       01882 	MOVLW 195
000530 26E9       01883 	ADDWF FSR0,1,0
000532 0E08       01884 	MOVLW 8
000534 22EA       01885 	ADDWFC FSR0+1,1,0
000536 6AEE       01886 	CLRF  POSTINC0,0
000538 6AEF       01887 	CLRF  INDF0,0
                  01888 			;		gLedBuf.delta[k] = 0;
00053A 0E63       01889 	MOVLW 99
00053C 240B       01890 	ADDWF k,W,0
00053E 6EE9       01891 	MOVWF FSR0,0
000540 0E08       01892 	MOVLW 8
000542 6AEA       01893 	CLRF  FSR0+1,0
000544 22EA       01894 	ADDWFC FSR0+1,1,0
000546 6AEF       01895 	CLRF  INDF0,0
                  01896 			;		++k;
000548 2A0B       01897 	INCF  k,1,0
                  01898 			;		gLedBuf.led_array[k] = green;
00054A 0E03       01899 	MOVLW 3
00054C 240B       01900 	ADDWF k,W,0
00054E 6EE9       01901 	MOVWF FSR0,0
000550 0E08       01902 	MOVLW 8
000552 6AEA       01903 	CLRF  FSR0+1,0
000554 22EA       01904 	ADDWFC FSR0+1,1,0
000556 C00D FFEF  01905 	MOVFF green,INDF0
                  01906 			;		gLedBuf.cyclesLeft[k] = 0;
00055A 90D8       01907 	BCF   0xFD8,Carry,0
00055C 340B       01908 	RLCF  k,W,0
00055E 6EE9       01909 	MOVWF FSR0,0
000560 6AEA       01910 	CLRF  FSR0+1,0
000562 36EA       01911 	RLCF  FSR0+1,1,0
000564 0EC3       01912 	MOVLW 195
000566 26E9       01913 	ADDWF FSR0,1,0
000568 0E08       01914 	MOVLW 8
00056A 22EA       01915 	ADDWFC FSR0+1,1,0
00056C 6AEE       01916 	CLRF  POSTINC0,0
00056E 6AEF       01917 	CLRF  INDF0,0
                  01918 			;		gLedBuf.delta[k] = 0;
000570 0E63       01919 	MOVLW 99
000572 240B       01920 	ADDWF k,W,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 33

ADDR   CODE       LINE  SOURCE

000574 6EE9       01921 	MOVWF FSR0,0
000576 0E08       01922 	MOVLW 8
000578 6AEA       01923 	CLRF  FSR0+1,0
00057A 22EA       01924 	ADDWFC FSR0+1,1,0
00057C 6AEF       01925 	CLRF  INDF0,0
                  01926 			;		++k;
00057E 2A0B       01927 	INCF  k,1,0
                  01928 			;		gLedBuf.led_array[k] = red;
000580 0E03       01929 	MOVLW 3
000582 240B       01930 	ADDWF k,W,0
000584 6EE9       01931 	MOVWF FSR0,0
000586 0E08       01932 	MOVLW 8
000588 6AEA       01933 	CLRF  FSR0+1,0
00058A 22EA       01934 	ADDWFC FSR0+1,1,0
00058C C00C FFEF  01935 	MOVFF red,INDF0
                  01936 			;		gLedBuf.cyclesLeft[k] = 0;
000590 90D8       01937 	BCF   0xFD8,Carry,0
000592 340B       01938 	RLCF  k,W,0
000594 6EE9       01939 	MOVWF FSR0,0
000596 6AEA       01940 	CLRF  FSR0+1,0
000598 36EA       01941 	RLCF  FSR0+1,1,0
00059A 0EC3       01942 	MOVLW 195
00059C 26E9       01943 	ADDWF FSR0,1,0
00059E 0E08       01944 	MOVLW 8
0005A0 22EA       01945 	ADDWFC FSR0+1,1,0
0005A2 6AEE       01946 	CLRF  POSTINC0,0
0005A4 6AEF       01947 	CLRF  INDF0,0
                  01948 			;		gLedBuf.delta[k] = 0;
0005A6 0E63       01949 	MOVLW 99
0005A8 240B       01950 	ADDWF k,W,0
0005AA 6EE9       01951 	MOVWF FSR0,0
0005AC 0E08       01952 	MOVLW 8
0005AE 6AEA       01953 	CLRF  FSR0+1,0
0005B0 22EA       01954 	ADDWFC FSR0+1,1,0
0005B2 6AEF       01955 	CLRF  INDF0,0
                  01956 			;		++k;
0005B4 2A0B       01957 	INCF  k,1,0
                  01958 			;	}
0005B6 D796       01959 	BRA   m026
                  01960 			;#ifdef cc3200
                  01961 			;	osi_LockObjUnlock(AccessLedBufferMutex);
                  01962 			;#endif
                  01963 			;}
0005B8 0012       01964 m027	RETURN
                  01965 			;
                  01966 			;void Ledstrip_DoFade(void)
                  01967 			;{
                  01968 Ledstrip_DoFade
                  01969 			;#ifdef cc3200
                  01970 			;	osi_LockObjLock(AccessLedBufferMutex, OSI_WAIT_FOREVER);
                  01971 			;#endif
                  01972 			;	uns8 k, stepmask, stepSize;
                  01973 			;	uns8 *stepaddress = gLedBuf.step;
0005BA 0E43       01974 	MOVLW 67
0005BC 6E0A       01975 	MOVWF stepaddress,0
0005BE 0E0A       01976 	MOVLW 10
0005C0 6E0B       01977 	MOVWF stepaddress+1,0
                  01978 			;	stepmask = 0x01;
0005C2 0E01       01979 	MOVLW 1
0005C4 6E08       01980 	MOVWF stepmask,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 34

ADDR   CODE       LINE  SOURCE

                  01981 			;	uns16 periodeLength;
                  01982 			;
                  01983 			;	/* Update cyclesLeft Value for all LED's */
                  01984 			;
                  01985 			;	for(k = 0; k < sizeof(gLedBuf.delta); k++) {
0005C6 6A07       01986 	CLRF  k_2,0
0005C8 0E60       01987 m028	MOVLW 96
0005CA 6007       01988 	CPFSLT k_2,0
0005CC D024       01989 	BRA   m030
                  01990 			;		if((gLedBuf.delta[k] > 0) && (gLedBuf.cyclesLeft[k] > 0)) {
0005CE 0E63       01991 	MOVLW 99
0005D0 2407       01992 	ADDWF k_2,W,0
0005D2 6EE9       01993 	MOVWF FSR0,0
0005D4 0E08       01994 	MOVLW 8
0005D6 6AEA       01995 	CLRF  FSR0+1,0
0005D8 22EA       01996 	ADDWFC FSR0+1,1,0
0005DA 50EF       01997 	MOVF  INDF0,W,0
0005DC B4D8       01998 	BTFSC 0xFD8,Zero_,0
0005DE D019       01999 	BRA   m029
0005E0 90D8       02000 	BCF   0xFD8,Carry,0
0005E2 3407       02001 	RLCF  k_2,W,0
0005E4 6EE9       02002 	MOVWF FSR0,0
0005E6 6AEA       02003 	CLRF  FSR0+1,0
0005E8 36EA       02004 	RLCF  FSR0+1,1,0
0005EA 0EC3       02005 	MOVLW 195
0005EC 26E9       02006 	ADDWF FSR0,1,0
0005EE 0E08       02007 	MOVLW 8
0005F0 22EA       02008 	ADDWFC FSR0+1,1,0
0005F2 50EE       02009 	MOVF  POSTINC0,W,0
0005F4 10EF       02010 	IORWF INDF0,W,0
0005F6 B4D8       02011 	BTFSC 0xFD8,Zero_,0
0005F8 D00C       02012 	BRA   m029
                  02013 			;			gLedBuf.cyclesLeft[k]--;
0005FA 90D8       02014 	BCF   0xFD8,Carry,0
0005FC 3407       02015 	RLCF  k_2,W,0
0005FE 6EE9       02016 	MOVWF FSR0,0
000600 6AEA       02017 	CLRF  FSR0+1,0
000602 36EA       02018 	RLCF  FSR0+1,1,0
000604 0EC3       02019 	MOVLW 195
000606 26E9       02020 	ADDWF FSR0,1,0
000608 0E08       02021 	MOVLW 8
00060A 22EA       02022 	ADDWFC FSR0+1,1,0
00060C 06EE       02023 	DECF  POSTINC0,1,0
00060E 0E00       02024 	MOVLW 0
000610 5AEF       02025 	SUBWFB INDF0,1,0
                  02026 			;		}
                  02027 			;	}
000612 2A07       02028 m029	INCF  k_2,1,0
000614 D7D9       02029 	BRA   m028
                  02030 			;
                  02031 			;	for(k = 0; k < sizeof(gLedBuf.delta); k++) {
000616 6A07       02032 m030	CLRF  k_2,0
000618 0E60       02033 m031	MOVLW 96
00061A 6007       02034 	CPFSLT k_2,0
00061C D07D       02035 	BRA   m037
                  02036 			;		// fade active on this led and current periode is over?
                  02037 			;		if((gLedBuf.delta[k] > 0) && (gLedBuf.cyclesLeft[k] == 0)) {
00061E 0E63       02038 	MOVLW 99
000620 2407       02039 	ADDWF k_2,W,0
000622 6EE9       02040 	MOVWF FSR0,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 35

ADDR   CODE       LINE  SOURCE

000624 0E08       02041 	MOVLW 8
000626 6AEA       02042 	CLRF  FSR0+1,0
000628 22EA       02043 	ADDWFC FSR0+1,1,0
00062A 50EF       02044 	MOVF  INDF0,W,0
00062C B4D8       02045 	BTFSC 0xFD8,Zero_,0
00062E D069       02046 	BRA   m035
000630 90D8       02047 	BCF   0xFD8,Carry,0
000632 3407       02048 	RLCF  k_2,W,0
000634 6EE9       02049 	MOVWF FSR0,0
000636 6AEA       02050 	CLRF  FSR0+1,0
000638 36EA       02051 	RLCF  FSR0+1,1,0
00063A 0EC3       02052 	MOVLW 195
00063C 26E9       02053 	ADDWF FSR0,1,0
00063E 0E08       02054 	MOVLW 8
000640 22EA       02055 	ADDWFC FSR0+1,1,0
000642 50EE       02056 	MOVF  POSTINC0,W,0
000644 10EF       02057 	IORWF INDF0,W,0
000646 A4D8       02058 	BTFSS 0xFD8,Zero_,0
000648 D05C       02059 	BRA   m035
                  02060 			;			stepSize = gLedBuf.stepSize[k];
00064A 0E4F       02061 	MOVLW 79
00064C 2407       02062 	ADDWF k_2,W,0
00064E 6EE9       02063 	MOVWF FSR0,0
000650 0E0A       02064 	MOVLW 10
000652 6AEA       02065 	CLRF  FSR0+1,0
000654 22EA       02066 	ADDWFC FSR0+1,1,0
000656 CFEF F009  02067 	MOVFF INDF0,stepSize
                  02068 			;			// reset cycle counters
                  02069 			;			if(gLedBuf.delta[k] < stepSize) {
00065A 0E63       02070 	MOVLW 99
00065C 2407       02071 	ADDWF k_2,W,0
00065E 6EE9       02072 	MOVWF FSR0,0
000660 0E08       02073 	MOVLW 8
000662 6AEA       02074 	CLRF  FSR0+1,0
000664 22EA       02075 	ADDWFC FSR0+1,1,0
000666 5009       02076 	MOVF  stepSize,W,0
000668 60EF       02077 	CPFSLT INDF0,0
00066A D010       02078 	BRA   m032
                  02079 			;				stepSize = gLedBuf.delta[k];
00066C 0E63       02080 	MOVLW 99
00066E 2407       02081 	ADDWF k_2,W,0
000670 6EE9       02082 	MOVWF FSR0,0
000672 0E08       02083 	MOVLW 8
000674 6AEA       02084 	CLRF  FSR0+1,0
000676 22EA       02085 	ADDWFC FSR0+1,1,0
000678 CFEF F009  02086 	MOVFF INDF0,stepSize
                  02087 			;				gLedBuf.delta[k] = 0;
00067C 0E63       02088 	MOVLW 99
00067E 2407       02089 	ADDWF k_2,W,0
000680 6EE9       02090 	MOVWF FSR0,0
000682 0E08       02091 	MOVLW 8
000684 6AEA       02092 	CLRF  FSR0+1,0
000686 22EA       02093 	ADDWFC FSR0+1,1,0
000688 6AEF       02094 	CLRF  INDF0,0
                  02095 			;			} else {
00068A D008       02096 	BRA   m033
                  02097 			;				gLedBuf.delta[k] -= stepSize;
00068C 0E63       02098 m032	MOVLW 99
00068E 2407       02099 	ADDWF k_2,W,0
000690 6EE9       02100 	MOVWF FSR0,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 36

ADDR   CODE       LINE  SOURCE

000692 0E08       02101 	MOVLW 8
000694 6AEA       02102 	CLRF  FSR0+1,0
000696 22EA       02103 	ADDWFC FSR0+1,1,0
000698 5009       02104 	MOVF  stepSize,W,0
00069A 5EEF       02105 	SUBWF INDF0,1,0
                  02106 			;			}
                  02107 			;			periodeLength = gLedBuf.periodeLength[k];
00069C 90D8       02108 m033	BCF   0xFD8,Carry,0
00069E 3407       02109 	RLCF  k_2,W,0
0006A0 6EE9       02110 	MOVWF FSR0,0
0006A2 6AEA       02111 	CLRF  FSR0+1,0
0006A4 36EA       02112 	RLCF  FSR0+1,1,0
0006A6 0E83       02113 	MOVLW 131
0006A8 26E9       02114 	ADDWF FSR0,1,0
0006AA 0E09       02115 	MOVLW 9
0006AC 22EA       02116 	ADDWFC FSR0+1,1,0
0006AE CFEE F00C  02117 	MOVFF POSTINC0,periodeLength
0006B2 CFEE F00D  02118 	MOVFF POSTINC0,periodeLength+1
                  02119 			;			gLedBuf.cyclesLeft[k] = periodeLength;
0006B6 90D8       02120 	BCF   0xFD8,Carry,0
0006B8 3407       02121 	RLCF  k_2,W,0
0006BA 6EE9       02122 	MOVWF FSR0,0
0006BC 6AEA       02123 	CLRF  FSR0+1,0
0006BE 36EA       02124 	RLCF  FSR0+1,1,0
0006C0 0EC3       02125 	MOVLW 195
0006C2 26E9       02126 	ADDWF FSR0,1,0
0006C4 0E08       02127 	MOVLW 8
0006C6 22EA       02128 	ADDWFC FSR0+1,1,0
0006C8 C00C FFEE  02129 	MOVFF periodeLength,POSTINC0
0006CC C00D FFEE  02130 	MOVFF periodeLength+1,POSTINC0
                  02131 			;
                  02132 			;			// update rgb value by one step
                  02133 			;			if(0 != ((*stepaddress) & stepmask)) {
0006D0 C00A FFE9  02134 	MOVFF stepaddress,FSR0
0006D4 C00B FFEA  02135 	MOVFF stepaddress+1,FSR0+1
0006D8 5008       02136 	MOVF  stepmask,W,0
0006DA 14EF       02137 	ANDWF INDF0,W,0
0006DC B4D8       02138 	BTFSC 0xFD8,Zero_,0
0006DE D009       02139 	BRA   m034
                  02140 			;				gLedBuf.led_array[k] -= stepSize;
0006E0 0E03       02141 	MOVLW 3
0006E2 2407       02142 	ADDWF k_2,W,0
0006E4 6EE9       02143 	MOVWF FSR0,0
0006E6 0E08       02144 	MOVLW 8
0006E8 6AEA       02145 	CLRF  FSR0+1,0
0006EA 22EA       02146 	ADDWFC FSR0+1,1,0
0006EC 5009       02147 	MOVF  stepSize,W,0
0006EE 5EEF       02148 	SUBWF INDF0,1,0
                  02149 			;			} else {
0006F0 D008       02150 	BRA   m035
                  02151 			;				gLedBuf.led_array[k] += stepSize;
0006F2 0E03       02152 m034	MOVLW 3
0006F4 2407       02153 	ADDWF k_2,W,0
0006F6 6EE9       02154 	MOVWF FSR0,0
0006F8 0E08       02155 	MOVLW 8
0006FA 6AEA       02156 	CLRF  FSR0+1,0
0006FC 22EA       02157 	ADDWFC FSR0+1,1,0
0006FE 5009       02158 	MOVF  stepSize,W,0
000700 26EF       02159 	ADDWF INDF0,1,0
                  02160 			;			}
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 37

ADDR   CODE       LINE  SOURCE

                  02161 			;		}
                  02162 			;		INC_BIT_COUNTER(stepaddress, stepmask);
000702 90D8       02163 m035	BCF   0xFD8,Carry,0
000704 3608       02164 	RLCF  stepmask,1,0
000706 A4D8       02165 	BTFSS 0xFD8,Zero_,0
000708 D005       02166 	BRA   m036
00070A 2A0A       02167 	INCF  stepaddress,1,0
00070C 0E00       02168 	MOVLW 0
00070E 220B       02169 	ADDWFC stepaddress+1,1,0
000710 0E01       02170 	MOVLW 1
000712 6E08       02171 	MOVWF stepmask,0
                  02172 			;	}
000714 2A07       02173 m036	INCF  k_2,1,0
000716 D780       02174 	BRA   m031
                  02175 			;#ifdef cc3200
                  02176 			;	osi_LockObjUnlock(AccessLedBufferMutex);
                  02177 			;#endif
                  02178 			;}
000718 0012       02179 m037	RETURN
                  02180 			;
                  02181 			;void Ledstrip_UpdateLed(void)
                  02182 			;{
                  02183 Ledstrip_UpdateLed
                  02184 			;#ifdef cc3200
                  02185 			;	osi_LockObjLock(AccessLedBufferMutex,OSI_WAIT_FOREVER);
                  02186 			;#endif
                  02187 			;	SPI_SendLedBuffer(gLedBuf.led_array);
00071A 0E03       02188 	MOVLW 3
00071C 6E07       02189 	MOVWF array_3,0
00071E 0E08       02190 	MOVLW 8
000720 6E08       02191 	MOVWF array_3+1,0
000722 EF01 F009  02192 	GOTO  SPI_SendLedBuffer
                  02193 			;#ifdef cc3200
                  02194 			;	osi_MsgQWrite(PwmMessageQ,gLedBuf.led_array,OSI_NO_WAIT);
                  02195 			;	osi_LockObjUnlock(AccessLedBufferMutex);
                  02196 			;#endif
                  02197 			;}
                  02198 			;
                  02199 			;void Ledstrip_SetFade(struct cmd_set_fade *pCmd)
                  02200 			;{
                  02201 Ledstrip_SetFade
                  02202 			;#ifdef cc3200
                  02203 			;	osi_LockObjLock(AccessLedBufferMutex, OSI_WAIT_FOREVER);
                  02204 			;#endif
                  02205 			;	// constant for this fade used in CALC_COLOR
                  02206 			;	uns16 fadeTmms = ntohs(pCmd->fadeTmms);
000726 6AEA       02207 	CLRF  FSR0+1,0
000728 0E08       02208 	MOVLW 8
00072A 2409       02209 	ADDWF pCmd,W,0
00072C 6EE9       02210 	MOVWF FSR0,0
00072E CFEE F01E  02211 	MOVFF POSTINC0,networkShort
000732 CFEE F01F  02212 	MOVFF POSTINC0,networkShort+1
000736 EC37 F00C  02213 	CALL  ntohs
00073A C020 F00A  02214 	MOVFF retval_2,fadeTmms
00073E C021 F00B  02215 	MOVFF retval_2+1,fadeTmms+1
                  02216 			;
                  02217 			;	uns8 *stepAddress = gLedBuf.step;
000742 0E43       02218 	MOVLW 67
000744 6E0C       02219 	MOVWF stepAddress,0
000746 0E0A       02220 	MOVLW 10
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 38

ADDR   CODE       LINE  SOURCE

000748 6E0D       02221 	MOVWF stepAddress+1,0
                  02222 			;	uns8 stepMask = 0x01;
00074A 0E01       02223 	MOVLW 1
00074C 6E0E       02224 	MOVWF stepMask,0
                  02225 			;	uns16 temp16;
                  02226 			;	uns8 red,green,blue,delta,stepSize,temp8;
                  02227 			;
                  02228 			;	red = pCmd->red;
00074E 6AEA       02229 	CLRF  FSR0+1,0
000750 0E04       02230 	MOVLW 4
000752 2409       02231 	ADDWF pCmd,W,0
000754 6EE9       02232 	MOVWF FSR0,0
000756 CFEF F011  02233 	MOVFF INDF0,red_2
                  02234 			;	green = pCmd->green;
00075A 6AEA       02235 	CLRF  FSR0+1,0
00075C 0E05       02236 	MOVLW 5
00075E 2409       02237 	ADDWF pCmd,W,0
000760 6EE9       02238 	MOVWF FSR0,0
000762 CFEF F012  02239 	MOVFF INDF0,green_2
                  02240 			;	blue = pCmd->blue;
000766 6AEA       02241 	CLRF  FSR0+1,0
000768 0E06       02242 	MOVLW 6
00076A 2409       02243 	ADDWF pCmd,W,0
00076C 6EE9       02244 	MOVWF FSR0,0
00076E CFEF F013  02245 	MOVFF INDF0,blue_2
                  02246 			;	// calc fade parameters for each led
                  02247 			;	FOR_EACH_MASKED_LED_DO(
                  02248 			;		{
                  02249 			;			CALC_COLOR(blue);
                  02250 			;			k++;
                  02251 			;			CALC_COLOR(green);
                  02252 			;			k++;
                  02253 			;			CALC_COLOR(red);
                  02254 			;		},
                  02255 			;		{
                  02256 			;	                // if led is not fade, we have to increment our pointers and rotate the mask
                  02257 			;			k++; k++;
                  02258 			;			INC_BIT_COUNTER(stepAddress, stepMask);
                  02259 			;			INC_BIT_COUNTER(stepAddress, stepMask);
                  02260 			;			INC_BIT_COUNTER(stepAddress, stepMask);
                  02261 			;		}
                  02262 			;		);
000772 C009 F017  02263 	MOVFF pCmd,address
000776 0E01       02264 	MOVLW 1
000778 6E19       02265 	MOVWF mask,0
00077A 6A18       02266 	CLRF  k_3,0
00077C 0E60       02267 m038	MOVLW 96
00077E 6018       02268 	CPFSLT k_3,0
000780 D180       02269 	BRA   m059
000782 C017 FFE9  02270 	MOVFF address,FSR0
000786 6AEA       02271 	CLRF  FSR0+1,0
000788 5019       02272 	MOVF  mask,W,0
00078A 14EF       02273 	ANDWF INDF0,W,0
00078C B4D8       02274 	BTFSC 0xFD8,Zero_,0
00078E D153       02275 	BRA   m054
000790 0E03       02276 	MOVLW 3
000792 2418       02277 	ADDWF k_3,W,0
000794 6EE9       02278 	MOVWF FSR0,0
000796 0E08       02279 	MOVLW 8
000798 6AEA       02280 	CLRF  FSR0+1,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 39

ADDR   CODE       LINE  SOURCE

00079A 22EA       02281 	ADDWFC FSR0+1,1,0
00079C CFEF F014  02282 	MOVFF INDF0,delta
0007A0 5014       02283 	MOVF  delta,W,0
0007A2 6013       02284 	CPFSLT blue_2,0
0007A4 D009       02285 	BRA   m039
0007A6 5013       02286 	MOVF  blue_2,W,0
0007A8 5E14       02287 	SUBWF delta,1,0
0007AA C00C FFE9  02288 	MOVFF stepAddress,FSR0
0007AE C00D FFEA  02289 	MOVFF stepAddress+1,FSR0+1
0007B2 500E       02290 	MOVF  stepMask,W,0
0007B4 12EF       02291 	IORWF INDF0,1,0
0007B6 D009       02292 	BRA   m040
0007B8 5014       02293 m039	MOVF  delta,W,0
0007BA 5C13       02294 	SUBWF blue_2,W,0
0007BC 6E14       02295 	MOVWF delta,0
0007BE C00C FFE9  02296 	MOVFF stepAddress,FSR0
0007C2 C00D FFEA  02297 	MOVFF stepAddress+1,FSR0+1
0007C6 1C0E       02298 	COMF  stepMask,W,0
0007C8 16EF       02299 	ANDWF INDF0,1,0
0007CA 90D8       02300 m040	BCF   0xFD8,Carry,0
0007CC 360E       02301 	RLCF  stepMask,1,0
0007CE A4D8       02302 	BTFSS 0xFD8,Zero_,0
0007D0 D005       02303 	BRA   m041
0007D2 2A0C       02304 	INCF  stepAddress,1,0
0007D4 0E00       02305 	MOVLW 0
0007D6 220D       02306 	ADDWFC stepAddress+1,1,0
0007D8 0E01       02307 	MOVLW 1
0007DA 6E0E       02308 	MOVWF stepMask,0
0007DC 0E01       02309 m041	MOVLW 1
0007DE 6E15       02310 	MOVWF stepSize_2,0
0007E0 6A0F       02311 	CLRF  temp16,0
0007E2 6A10       02312 	CLRF  temp16+1,0
0007E4 5214       02313 	MOVF  delta,1,0
0007E6 B4D8       02314 	BTFSC 0xFD8,Zero_,0
0007E8 D019       02315 	BRA   m043
0007EA C014 F01E  02316 m042	MOVFF delta,arg1_5
0007EE 6A1F       02317 	CLRF  arg1_5+1,0
0007F0 5015       02318 	MOVF  stepSize_2,W,0
0007F2 DDF4       02319 	RCALL _divU16_8
0007F4 C01E F016  02320 	MOVFF arg1_5,temp8
0007F8 C00A F01E  02321 	MOVFF fadeTmms,arg1_5
0007FC C00B F01F  02322 	MOVFF fadeTmms+1,arg1_5+1
000800 5016       02323 	MOVF  temp8,W,0
000802 DDEC       02324 	RCALL _divU16_8
000804 C01E F00F  02325 	MOVFF arg1_5,temp16
000808 C01F F010  02326 	MOVFF arg1_5+1,temp16+1
00080C 500F       02327 	MOVF  temp16,W,0
00080E 1010       02328 	IORWF temp16+1,W,0
000810 B4D8       02329 	BTFSC 0xFD8,Zero_,0
000812 2A15       02330 	INCF  stepSize_2,1,0
000814 500F       02331 	MOVF  temp16,W,0
000816 1010       02332 	IORWF temp16+1,W,0
000818 B4D8       02333 	BTFSC 0xFD8,Zero_,0
00081A D7E7       02334 	BRA   m042
00081C 0E4F       02335 m043	MOVLW 79
00081E 2418       02336 	ADDWF k_3,W,0
000820 6EE9       02337 	MOVWF FSR0,0
000822 0E0A       02338 	MOVLW 10
000824 6AEA       02339 	CLRF  FSR0+1,0
000826 22EA       02340 	ADDWFC FSR0+1,1,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 40

ADDR   CODE       LINE  SOURCE

000828 C015 FFEF  02341 	MOVFF stepSize_2,INDF0
00082C 0E63       02342 	MOVLW 99
00082E 2418       02343 	ADDWF k_3,W,0
000830 6EE9       02344 	MOVWF FSR0,0
000832 0E08       02345 	MOVLW 8
000834 6AEA       02346 	CLRF  FSR0+1,0
000836 22EA       02347 	ADDWFC FSR0+1,1,0
000838 C014 FFEF  02348 	MOVFF delta,INDF0
00083C 90D8       02349 	BCF   0xFD8,Carry,0
00083E 3418       02350 	RLCF  k_3,W,0
000840 6EE9       02351 	MOVWF FSR0,0
000842 6AEA       02352 	CLRF  FSR0+1,0
000844 36EA       02353 	RLCF  FSR0+1,1,0
000846 0E83       02354 	MOVLW 131
000848 26E9       02355 	ADDWF FSR0,1,0
00084A 0E09       02356 	MOVLW 9
00084C 22EA       02357 	ADDWFC FSR0+1,1,0
00084E C00F FFEE  02358 	MOVFF temp16,POSTINC0
000852 C010 FFEE  02359 	MOVFF temp16+1,POSTINC0
000856 90D8       02360 	BCF   0xFD8,Carry,0
000858 3418       02361 	RLCF  k_3,W,0
00085A 6EE9       02362 	MOVWF FSR0,0
00085C 6AEA       02363 	CLRF  FSR0+1,0
00085E 36EA       02364 	RLCF  FSR0+1,1,0
000860 0EC3       02365 	MOVLW 195
000862 26E9       02366 	ADDWF FSR0,1,0
000864 0E08       02367 	MOVLW 8
000866 22EA       02368 	ADDWFC FSR0+1,1,0
000868 C00F FFEE  02369 	MOVFF temp16,POSTINC0
00086C C010 FFEE  02370 	MOVFF temp16+1,POSTINC0
000870 2A18       02371 	INCF  k_3,1,0
000872 0E03       02372 	MOVLW 3
000874 2418       02373 	ADDWF k_3,W,0
000876 6EE9       02374 	MOVWF FSR0,0
000878 0E08       02375 	MOVLW 8
00087A 6AEA       02376 	CLRF  FSR0+1,0
00087C 22EA       02377 	ADDWFC FSR0+1,1,0
00087E CFEF F014  02378 	MOVFF INDF0,delta
000882 5014       02379 	MOVF  delta,W,0
000884 6012       02380 	CPFSLT green_2,0
000886 D009       02381 	BRA   m044
000888 5012       02382 	MOVF  green_2,W,0
00088A 5E14       02383 	SUBWF delta,1,0
00088C C00C FFE9  02384 	MOVFF stepAddress,FSR0
000890 C00D FFEA  02385 	MOVFF stepAddress+1,FSR0+1
000894 500E       02386 	MOVF  stepMask,W,0
000896 12EF       02387 	IORWF INDF0,1,0
000898 D009       02388 	BRA   m045
00089A 5014       02389 m044	MOVF  delta,W,0
00089C 5C12       02390 	SUBWF green_2,W,0
00089E 6E14       02391 	MOVWF delta,0
0008A0 C00C FFE9  02392 	MOVFF stepAddress,FSR0
0008A4 C00D FFEA  02393 	MOVFF stepAddress+1,FSR0+1
0008A8 1C0E       02394 	COMF  stepMask,W,0
0008AA 16EF       02395 	ANDWF INDF0,1,0
0008AC 90D8       02396 m045	BCF   0xFD8,Carry,0
0008AE 360E       02397 	RLCF  stepMask,1,0
0008B0 A4D8       02398 	BTFSS 0xFD8,Zero_,0
0008B2 D005       02399 	BRA   m046
0008B4 2A0C       02400 	INCF  stepAddress,1,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 41

ADDR   CODE       LINE  SOURCE

0008B6 0E00       02401 	MOVLW 0
0008B8 220D       02402 	ADDWFC stepAddress+1,1,0
0008BA 0E01       02403 	MOVLW 1
0008BC 6E0E       02404 	MOVWF stepMask,0
0008BE 0E01       02405 m046	MOVLW 1
0008C0 6E15       02406 	MOVWF stepSize_2,0
0008C2 6A0F       02407 	CLRF  temp16,0
0008C4 6A10       02408 	CLRF  temp16+1,0
0008C6 5214       02409 	MOVF  delta,1,0
0008C8 B4D8       02410 	BTFSC 0xFD8,Zero_,0
0008CA D019       02411 	BRA   m048
0008CC C014 F01E  02412 m047	MOVFF delta,arg1_5
0008D0 6A1F       02413 	CLRF  arg1_5+1,0
0008D2 5015       02414 	MOVF  stepSize_2,W,0
0008D4 DD83       02415 	RCALL _divU16_8
0008D6 C01E F016  02416 	MOVFF arg1_5,temp8
0008DA C00A F01E  02417 	MOVFF fadeTmms,arg1_5
0008DE C00B F01F  02418 	MOVFF fadeTmms+1,arg1_5+1
0008E2 5016       02419 	MOVF  temp8,W,0
0008E4 DD7B       02420 	RCALL _divU16_8
0008E6 C01E F00F  02421 	MOVFF arg1_5,temp16
0008EA C01F F010  02422 	MOVFF arg1_5+1,temp16+1
0008EE 500F       02423 	MOVF  temp16,W,0
0008F0 1010       02424 	IORWF temp16+1,W,0
0008F2 B4D8       02425 	BTFSC 0xFD8,Zero_,0
0008F4 2A15       02426 	INCF  stepSize_2,1,0
0008F6 500F       02427 	MOVF  temp16,W,0
0008F8 1010       02428 	IORWF temp16+1,W,0
0008FA B4D8       02429 	BTFSC 0xFD8,Zero_,0
0008FC D7E7       02430 	BRA   m047
0008FE 0E4F       02431 m048	MOVLW 79
000900 2418       02432 	ADDWF k_3,W,0
000902 6EE9       02433 	MOVWF FSR0,0
000904 0E0A       02434 	MOVLW 10
000906 6AEA       02435 	CLRF  FSR0+1,0
000908 22EA       02436 	ADDWFC FSR0+1,1,0
00090A C015 FFEF  02437 	MOVFF stepSize_2,INDF0
00090E 0E63       02438 	MOVLW 99
000910 2418       02439 	ADDWF k_3,W,0
000912 6EE9       02440 	MOVWF FSR0,0
000914 0E08       02441 	MOVLW 8
000916 6AEA       02442 	CLRF  FSR0+1,0
000918 22EA       02443 	ADDWFC FSR0+1,1,0
00091A C014 FFEF  02444 	MOVFF delta,INDF0
00091E 90D8       02445 	BCF   0xFD8,Carry,0
000920 3418       02446 	RLCF  k_3,W,0
000922 6EE9       02447 	MOVWF FSR0,0
000924 6AEA       02448 	CLRF  FSR0+1,0
000926 36EA       02449 	RLCF  FSR0+1,1,0
000928 0E83       02450 	MOVLW 131
00092A 26E9       02451 	ADDWF FSR0,1,0
00092C 0E09       02452 	MOVLW 9
00092E 22EA       02453 	ADDWFC FSR0+1,1,0
000930 C00F FFEE  02454 	MOVFF temp16,POSTINC0
000934 C010 FFEE  02455 	MOVFF temp16+1,POSTINC0
000938 90D8       02456 	BCF   0xFD8,Carry,0
00093A 3418       02457 	RLCF  k_3,W,0
00093C 6EE9       02458 	MOVWF FSR0,0
00093E 6AEA       02459 	CLRF  FSR0+1,0
000940 36EA       02460 	RLCF  FSR0+1,1,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 42

ADDR   CODE       LINE  SOURCE

000942 0EC3       02461 	MOVLW 195
000944 26E9       02462 	ADDWF FSR0,1,0
000946 0E08       02463 	MOVLW 8
000948 22EA       02464 	ADDWFC FSR0+1,1,0
00094A C00F FFEE  02465 	MOVFF temp16,POSTINC0
00094E C010 FFEE  02466 	MOVFF temp16+1,POSTINC0
000952 2A18       02467 	INCF  k_3,1,0
000954 0E03       02468 	MOVLW 3
000956 2418       02469 	ADDWF k_3,W,0
000958 6EE9       02470 	MOVWF FSR0,0
00095A 0E08       02471 	MOVLW 8
00095C 6AEA       02472 	CLRF  FSR0+1,0
00095E 22EA       02473 	ADDWFC FSR0+1,1,0
000960 CFEF F014  02474 	MOVFF INDF0,delta
000964 5014       02475 	MOVF  delta,W,0
000966 6011       02476 	CPFSLT red_2,0
000968 D009       02477 	BRA   m049
00096A 5011       02478 	MOVF  red_2,W,0
00096C 5E14       02479 	SUBWF delta,1,0
00096E C00C FFE9  02480 	MOVFF stepAddress,FSR0
000972 C00D FFEA  02481 	MOVFF stepAddress+1,FSR0+1
000976 500E       02482 	MOVF  stepMask,W,0
000978 12EF       02483 	IORWF INDF0,1,0
00097A D009       02484 	BRA   m050
00097C 5014       02485 m049	MOVF  delta,W,0
00097E 5C11       02486 	SUBWF red_2,W,0
000980 6E14       02487 	MOVWF delta,0
000982 C00C FFE9  02488 	MOVFF stepAddress,FSR0
000986 C00D FFEA  02489 	MOVFF stepAddress+1,FSR0+1
00098A 1C0E       02490 	COMF  stepMask,W,0
00098C 16EF       02491 	ANDWF INDF0,1,0
00098E 90D8       02492 m050	BCF   0xFD8,Carry,0
000990 360E       02493 	RLCF  stepMask,1,0
000992 A4D8       02494 	BTFSS 0xFD8,Zero_,0
000994 D005       02495 	BRA   m051
000996 2A0C       02496 	INCF  stepAddress,1,0
000998 0E00       02497 	MOVLW 0
00099A 220D       02498 	ADDWFC stepAddress+1,1,0
00099C 0E01       02499 	MOVLW 1
00099E 6E0E       02500 	MOVWF stepMask,0
0009A0 0E01       02501 m051	MOVLW 1
0009A2 6E15       02502 	MOVWF stepSize_2,0
0009A4 6A0F       02503 	CLRF  temp16,0
0009A6 6A10       02504 	CLRF  temp16+1,0
0009A8 5214       02505 	MOVF  delta,1,0
0009AA B4D8       02506 	BTFSC 0xFD8,Zero_,0
0009AC D019       02507 	BRA   m053
0009AE C014 F01E  02508 m052	MOVFF delta,arg1_5
0009B2 6A1F       02509 	CLRF  arg1_5+1,0
0009B4 5015       02510 	MOVF  stepSize_2,W,0
0009B6 DD12       02511 	RCALL _divU16_8
0009B8 C01E F016  02512 	MOVFF arg1_5,temp8
0009BC C00A F01E  02513 	MOVFF fadeTmms,arg1_5
0009C0 C00B F01F  02514 	MOVFF fadeTmms+1,arg1_5+1
0009C4 5016       02515 	MOVF  temp8,W,0
0009C6 DD0A       02516 	RCALL _divU16_8
0009C8 C01E F00F  02517 	MOVFF arg1_5,temp16
0009CC C01F F010  02518 	MOVFF arg1_5+1,temp16+1
0009D0 500F       02519 	MOVF  temp16,W,0
0009D2 1010       02520 	IORWF temp16+1,W,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 43

ADDR   CODE       LINE  SOURCE

0009D4 B4D8       02521 	BTFSC 0xFD8,Zero_,0
0009D6 2A15       02522 	INCF  stepSize_2,1,0
0009D8 500F       02523 	MOVF  temp16,W,0
0009DA 1010       02524 	IORWF temp16+1,W,0
0009DC B4D8       02525 	BTFSC 0xFD8,Zero_,0
0009DE D7E7       02526 	BRA   m052
0009E0 0E4F       02527 m053	MOVLW 79
0009E2 2418       02528 	ADDWF k_3,W,0
0009E4 6EE9       02529 	MOVWF FSR0,0
0009E6 0E0A       02530 	MOVLW 10
0009E8 6AEA       02531 	CLRF  FSR0+1,0
0009EA 22EA       02532 	ADDWFC FSR0+1,1,0
0009EC C015 FFEF  02533 	MOVFF stepSize_2,INDF0
0009F0 0E63       02534 	MOVLW 99
0009F2 2418       02535 	ADDWF k_3,W,0
0009F4 6EE9       02536 	MOVWF FSR0,0
0009F6 0E08       02537 	MOVLW 8
0009F8 6AEA       02538 	CLRF  FSR0+1,0
0009FA 22EA       02539 	ADDWFC FSR0+1,1,0
0009FC C014 FFEF  02540 	MOVFF delta,INDF0
000A00 90D8       02541 	BCF   0xFD8,Carry,0
000A02 3418       02542 	RLCF  k_3,W,0
000A04 6EE9       02543 	MOVWF FSR0,0
000A06 6AEA       02544 	CLRF  FSR0+1,0
000A08 36EA       02545 	RLCF  FSR0+1,1,0
000A0A 0E83       02546 	MOVLW 131
000A0C 26E9       02547 	ADDWF FSR0,1,0
000A0E 0E09       02548 	MOVLW 9
000A10 22EA       02549 	ADDWFC FSR0+1,1,0
000A12 C00F FFEE  02550 	MOVFF temp16,POSTINC0
000A16 C010 FFEE  02551 	MOVFF temp16+1,POSTINC0
000A1A 90D8       02552 	BCF   0xFD8,Carry,0
000A1C 3418       02553 	RLCF  k_3,W,0
000A1E 6EE9       02554 	MOVWF FSR0,0
000A20 6AEA       02555 	CLRF  FSR0+1,0
000A22 36EA       02556 	RLCF  FSR0+1,1,0
000A24 0EC3       02557 	MOVLW 195
000A26 26E9       02558 	ADDWF FSR0,1,0
000A28 0E08       02559 	MOVLW 8
000A2A 22EA       02560 	ADDWFC FSR0+1,1,0
000A2C C00F FFEE  02561 	MOVFF temp16,POSTINC0
000A30 C010 FFEE  02562 	MOVFF temp16+1,POSTINC0
000A34 D01D       02563 	BRA   m057
000A36 2A18       02564 m054	INCF  k_3,1,0
000A38 2A18       02565 	INCF  k_3,1,0
000A3A 90D8       02566 	BCF   0xFD8,Carry,0
000A3C 360E       02567 	RLCF  stepMask,1,0
000A3E A4D8       02568 	BTFSS 0xFD8,Zero_,0
000A40 D005       02569 	BRA   m055
000A42 2A0C       02570 	INCF  stepAddress,1,0
000A44 0E00       02571 	MOVLW 0
000A46 220D       02572 	ADDWFC stepAddress+1,1,0
000A48 0E01       02573 	MOVLW 1
000A4A 6E0E       02574 	MOVWF stepMask,0
000A4C 90D8       02575 m055	BCF   0xFD8,Carry,0
000A4E 360E       02576 	RLCF  stepMask,1,0
000A50 A4D8       02577 	BTFSS 0xFD8,Zero_,0
000A52 D005       02578 	BRA   m056
000A54 2A0C       02579 	INCF  stepAddress,1,0
000A56 0E00       02580 	MOVLW 0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 44

ADDR   CODE       LINE  SOURCE

000A58 220D       02581 	ADDWFC stepAddress+1,1,0
000A5A 0E01       02582 	MOVLW 1
000A5C 6E0E       02583 	MOVWF stepMask,0
000A5E 90D8       02584 m056	BCF   0xFD8,Carry,0
000A60 360E       02585 	RLCF  stepMask,1,0
000A62 A4D8       02586 	BTFSS 0xFD8,Zero_,0
000A64 D005       02587 	BRA   m057
000A66 2A0C       02588 	INCF  stepAddress,1,0
000A68 0E00       02589 	MOVLW 0
000A6A 220D       02590 	ADDWFC stepAddress+1,1,0
000A6C 0E01       02591 	MOVLW 1
000A6E 6E0E       02592 	MOVWF stepMask,0
000A70 90D8       02593 m057	BCF   0xFD8,Carry,0
000A72 3619       02594 	RLCF  mask,1,0
000A74 A4D8       02595 	BTFSS 0xFD8,Zero_,0
000A76 D003       02596 	BRA   m058
000A78 2A17       02597 	INCF  address,1,0
000A7A 0E01       02598 	MOVLW 1
000A7C 6E19       02599 	MOVWF mask,0
000A7E 2A18       02600 m058	INCF  k_3,1,0
000A80 D67D       02601 	BRA   m038
                  02602 			;#ifdef cc3200
                  02603 			;	osi_LockObjUnlock(AccessLedBufferMutex);
                  02604 			;#endif
                  02605 			;}
000A82 0012       02606 m059	RETURN
                  02607 			;
                  02608 			;#define CALC_DELTA(target,source_1,source_2) { \
                  02609 			;		target = source_1; \
                  02610 			;		if(target > source_2) \
                  02611 			;			target = target - source_2; \
                  02612 			;		else \
                  02613 			;			target = source_2 - target; \
                  02614 			;		target = target / numOfLeds; }
                  02615 			;
                  02616 			;// To add or sub the diff from color by each loop run to get the right color for
                  02617 			;// every led. If compare is greater then color, this macro add's diff, otherwise it sub's diff
                  02618 			;#define ADJUST_COLOR(color,compare,diff) { \
                  02619 			;		if(color > compare) \
                  02620 			;			color -= diff; \
                  02621 			;		else \
                  02622 			;			color += diff; } \
                  02623 			;
                  02624 			;void Ledstrip_SetGradient(struct cmd_set_gradient *pCmd)
                  02625 			;{
                  02626 Ledstrip_SetGradient
                  02627 			;	uns16 fadeTmms = ntohs(pCmd->fadeTmms);
000A84 6AEA       02628 	CLRF  FSR0+1,0
000A86 0E08       02629 	MOVLW 8
000A88 2409       02630 	ADDWF pCmd_2,W,0
000A8A 6EE9       02631 	MOVWF FSR0,0
000A8C CFEE F01E  02632 	MOVFF POSTINC0,networkShort
000A90 CFEE F01F  02633 	MOVFF POSTINC0,networkShort+1
000A94 EC37 F00C  02634 	CALL  ntohs
000A98 C020 F00A  02635 	MOVFF retval_2,fadeTmms_2
000A9C C021 F00B  02636 	MOVFF retval_2+1,fadeTmms_2+1
                  02637 			;
                  02638 			;	uns8 offset = pCmd->parallelAndOffset & 0x7f;
000AA0 6AEA       02639 	CLRF  FSR0+1,0
000AA2 0E06       02640 	MOVLW 6
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 45

ADDR   CODE       LINE  SOURCE

000AA4 2409       02641 	ADDWF pCmd_2,W,0
000AA6 6EE9       02642 	MOVWF FSR0,0
000AA8 0E7F       02643 	MOVLW 127
000AAA 14EF       02644 	ANDWF INDF0,W,0
000AAC 6E0C       02645 	MOVWF offset,0
                  02646 			;	uns8 numOfLeds = pCmd->numberOfLeds - 1;
000AAE 6AEA       02647 	CLRF  FSR0+1,0
000AB0 0E07       02648 	MOVLW 7
000AB2 2409       02649 	ADDWF pCmd_2,W,0
000AB4 6EE9       02650 	MOVWF FSR0,0
000AB6 04EF       02651 	DECF  INDF0,W,0
000AB8 6E0D       02652 	MOVWF numOfLeds,0
                  02653 			;	uns8 deltaRed, deltaGreen, deltaBlue;
                  02654 			;
                  02655 			;	if(numOfLeds == 255 || numOfLeds == 0)
000ABA 480D       02656 	INFSNZ numOfLeds,W,0
000ABC D003       02657 	BRA   m060
000ABE 520D       02658 	MOVF  numOfLeds,1,0
000AC0 A4D8       02659 	BTFSS 0xFD8,Zero_,0
000AC2 D002       02660 	BRA   m061
                  02661 			;		numOfLeds = 1;
000AC4 0E01       02662 m060	MOVLW 1
000AC6 6E0D       02663 	MOVWF numOfLeds,0
                  02664 			;
                  02665 			;	CALC_DELTA(deltaRed,   pCmd->red_1,   pCmd->red_2);
000AC8 C009 FFE9  02666 m061	MOVFF pCmd_2,FSR0
000ACC 6AEA       02667 	CLRF  FSR0+1,0
000ACE CFEF F00E  02668 	MOVFF INDF0,deltaRed
000AD2 6AEA       02669 	CLRF  FSR0+1,0
000AD4 0E03       02670 	MOVLW 3
000AD6 2409       02671 	ADDWF pCmd_2,W,0
000AD8 6EE9       02672 	MOVWF FSR0,0
000ADA 500E       02673 	MOVF  deltaRed,W,0
000ADC 60EF       02674 	CPFSLT INDF0,0
000ADE D007       02675 	BRA   m062
000AE0 6AEA       02676 	CLRF  FSR0+1,0
000AE2 0E03       02677 	MOVLW 3
000AE4 2409       02678 	ADDWF pCmd_2,W,0
000AE6 6EE9       02679 	MOVWF FSR0,0
000AE8 50EF       02680 	MOVF  INDF0,W,0
000AEA 5E0E       02681 	SUBWF deltaRed,1,0
000AEC D007       02682 	BRA   m063
000AEE 6AEA       02683 m062	CLRF  FSR0+1,0
000AF0 0E03       02684 	MOVLW 3
000AF2 2409       02685 	ADDWF pCmd_2,W,0
000AF4 6EE9       02686 	MOVWF FSR0,0
000AF6 500E       02687 	MOVF  deltaRed,W,0
000AF8 5CEF       02688 	SUBWF INDF0,W,0
000AFA 6E0E       02689 	MOVWF deltaRed,0
000AFC C00E F01E  02690 m063	MOVFF deltaRed,arg1_5
000B00 6A1F       02691 	CLRF  arg1_5+1,0
000B02 500D       02692 	MOVF  numOfLeds,W,0
000B04 DC6B       02693 	RCALL _divU16_8
000B06 C01E F00E  02694 	MOVFF arg1_5,deltaRed
                  02695 			;	CALC_DELTA(deltaGreen, pCmd->green_1, pCmd->green_2);
000B0A 6AEA       02696 	CLRF  FSR0+1,0
000B0C 2809       02697 	INCF  pCmd_2,W,0
000B0E 6EE9       02698 	MOVWF FSR0,0
000B10 CFEF F00F  02699 	MOVFF INDF0,deltaGreen
000B14 6AEA       02700 	CLRF  FSR0+1,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 46

ADDR   CODE       LINE  SOURCE

000B16 0E04       02701 	MOVLW 4
000B18 2409       02702 	ADDWF pCmd_2,W,0
000B1A 6EE9       02703 	MOVWF FSR0,0
000B1C 500F       02704 	MOVF  deltaGreen,W,0
000B1E 60EF       02705 	CPFSLT INDF0,0
000B20 D007       02706 	BRA   m064
000B22 6AEA       02707 	CLRF  FSR0+1,0
000B24 0E04       02708 	MOVLW 4
000B26 2409       02709 	ADDWF pCmd_2,W,0
000B28 6EE9       02710 	MOVWF FSR0,0
000B2A 50EF       02711 	MOVF  INDF0,W,0
000B2C 5E0F       02712 	SUBWF deltaGreen,1,0
000B2E D007       02713 	BRA   m065
000B30 6AEA       02714 m064	CLRF  FSR0+1,0
000B32 0E04       02715 	MOVLW 4
000B34 2409       02716 	ADDWF pCmd_2,W,0
000B36 6EE9       02717 	MOVWF FSR0,0
000B38 500F       02718 	MOVF  deltaGreen,W,0
000B3A 5CEF       02719 	SUBWF INDF0,W,0
000B3C 6E0F       02720 	MOVWF deltaGreen,0
000B3E C00F F01E  02721 m065	MOVFF deltaGreen,arg1_5
000B42 6A1F       02722 	CLRF  arg1_5+1,0
000B44 500D       02723 	MOVF  numOfLeds,W,0
000B46 DC4A       02724 	RCALL _divU16_8
000B48 C01E F00F  02725 	MOVFF arg1_5,deltaGreen
                  02726 			;	CALC_DELTA(deltaBlue,  pCmd->blue_1,  pCmd->blue_2);
000B4C 6AEA       02727 	CLRF  FSR0+1,0
000B4E 0E02       02728 	MOVLW 2
000B50 2409       02729 	ADDWF pCmd_2,W,0
000B52 6EE9       02730 	MOVWF FSR0,0
000B54 CFEF F010  02731 	MOVFF INDF0,deltaBlue
000B58 6AEA       02732 	CLRF  FSR0+1,0
000B5A 0E05       02733 	MOVLW 5
000B5C 2409       02734 	ADDWF pCmd_2,W,0
000B5E 6EE9       02735 	MOVWF FSR0,0
000B60 5010       02736 	MOVF  deltaBlue,W,0
000B62 60EF       02737 	CPFSLT INDF0,0
000B64 D007       02738 	BRA   m066
000B66 6AEA       02739 	CLRF  FSR0+1,0
000B68 0E05       02740 	MOVLW 5
000B6A 2409       02741 	ADDWF pCmd_2,W,0
000B6C 6EE9       02742 	MOVWF FSR0,0
000B6E 50EF       02743 	MOVF  INDF0,W,0
000B70 5E10       02744 	SUBWF deltaBlue,1,0
000B72 D007       02745 	BRA   m067
000B74 6AEA       02746 m066	CLRF  FSR0+1,0
000B76 0E05       02747 	MOVLW 5
000B78 2409       02748 	ADDWF pCmd_2,W,0
000B7A 6EE9       02749 	MOVWF FSR0,0
000B7C 5010       02750 	MOVF  deltaBlue,W,0
000B7E 5CEF       02751 	SUBWF INDF0,W,0
000B80 6E10       02752 	MOVWF deltaBlue,0
000B82 C010 F01E  02753 m067	MOVFF deltaBlue,arg1_5
000B86 6A1F       02754 	CLRF  arg1_5+1,0
000B88 500D       02755 	MOVF  numOfLeds,W,0
000B8A DC28       02756 	RCALL _divU16_8
000B8C C01E F010  02757 	MOVFF arg1_5,deltaBlue
                  02758 			;
                  02759 			;	uns8 red = pCmd->red_1;
000B90 C009 FFE9  02760 	MOVFF pCmd_2,FSR0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 47

ADDR   CODE       LINE  SOURCE

000B94 6AEA       02761 	CLRF  FSR0+1,0
000B96 CFEF F011  02762 	MOVFF INDF0,red_3
                  02763 			;	uns8 green = pCmd->green_1;
000B9A 6AEA       02764 	CLRF  FSR0+1,0
000B9C 2809       02765 	INCF  pCmd_2,W,0
000B9E 6EE9       02766 	MOVWF FSR0,0
000BA0 CFEF F012  02767 	MOVFF INDF0,green_3
                  02768 			;	uns8 blue = pCmd->blue_1;
000BA4 6AEA       02769 	CLRF  FSR0+1,0
000BA6 0E02       02770 	MOVLW 2
000BA8 2409       02771 	ADDWF pCmd_2,W,0
000BAA 6EE9       02772 	MOVWF FSR0,0
000BAC CFEF F013  02773 	MOVFF INDF0,blue_3
                  02774 			;
                  02775 			;	//define variables for CALC_COLOR macro
                  02776 			;	uns16 temp16;
                  02777 			;	uns8 k,delta,stepSize,temp8;
                  02778 			;	uns8 *stepAddress = gLedBuf.step;
000BB0 0E43       02779 	MOVLW 67
000BB2 6E1A       02780 	MOVWF stepAddress_2,0
000BB4 0E0A       02781 	MOVLW 10
000BB6 6E1B       02782 	MOVWF stepAddress_2+1,0
                  02783 			;	uns8 stepMask = 0x01;
000BB8 0E01       02784 	MOVLW 1
000BBA 6E1C       02785 	MOVWF stepMask_2,0
                  02786 			;
                  02787 			;	offset = offset * 3;
000BBC C00C F01E  02788 	MOVFF offset,arg1
000BC0 0E03       02789 	MOVLW 3
000BC2 ECE0 F001  02790 	CALL  _mult8x8
000BC6 C020 F00C  02791 	MOVFF rval,offset
                  02792 			;	numOfLeds = numOfLeds * 3;
000BCA C00D F01E  02793 	MOVFF numOfLeds,arg1
000BCE 0E03       02794 	MOVLW 3
000BD0 ECE0 F001  02795 	CALL  _mult8x8
000BD4 C020 F00D  02796 	MOVFF rval,numOfLeds
                  02797 			;
                  02798 			;	const uns8 endPosition = offset + numOfLeds;
000BD8 500D       02799 	MOVF  numOfLeds,W,0
000BDA 240C       02800 	ADDWF offset,W,0
000BDC 6E1D       02801 	MOVWF endPosition,0
                  02802 			;
                  02803 			;	for(k = 0; k < NUM_OF_LED * 3; k++) {
000BDE 6A16       02804 	CLRF  k_4,0
000BE0 0E60       02805 m068	MOVLW 96
000BE2 6016       02806 	CPFSLT k_4,0
000BE4 D2FB       02807 	BRA   m107
                  02808 			;		if(k >= endPosition) {
000BE6 501D       02809 	MOVF  endPosition,W,0
000BE8 5C16       02810 	SUBWF k_4,W,0
000BEA A0D8       02811 	BTFSS 0xFD8,Carry,0
000BEC D16B       02812 	BRA   m084
                  02813 			;			red = pCmd->red_2;
000BEE 6AEA       02814 	CLRF  FSR0+1,0
000BF0 0E03       02815 	MOVLW 3
000BF2 2409       02816 	ADDWF pCmd_2,W,0
000BF4 6EE9       02817 	MOVWF FSR0,0
000BF6 CFEF F011  02818 	MOVFF INDF0,red_3
                  02819 			;			green = pCmd->green_2;
000BFA 6AEA       02820 	CLRF  FSR0+1,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 48

ADDR   CODE       LINE  SOURCE

000BFC 0E04       02821 	MOVLW 4
000BFE 2409       02822 	ADDWF pCmd_2,W,0
000C00 6EE9       02823 	MOVWF FSR0,0
000C02 CFEF F012  02824 	MOVFF INDF0,green_3
                  02825 			;			blue = pCmd->blue_2;
000C06 6AEA       02826 	CLRF  FSR0+1,0
000C08 0E05       02827 	MOVLW 5
000C0A 2409       02828 	ADDWF pCmd_2,W,0
000C0C 6EE9       02829 	MOVWF FSR0,0
000C0E CFEF F013  02830 	MOVFF INDF0,blue_3
                  02831 			;
                  02832 			;			CALC_COLOR(blue);
000C12 0E03       02833 	MOVLW 3
000C14 2416       02834 	ADDWF k_4,W,0
000C16 6EE9       02835 	MOVWF FSR0,0
000C18 0E08       02836 	MOVLW 8
000C1A 6AEA       02837 	CLRF  FSR0+1,0
000C1C 22EA       02838 	ADDWFC FSR0+1,1,0
000C1E CFEF F017  02839 	MOVFF INDF0,delta_2
000C22 5017       02840 	MOVF  delta_2,W,0
000C24 6013       02841 	CPFSLT blue_3,0
000C26 D009       02842 	BRA   m069
000C28 5013       02843 	MOVF  blue_3,W,0
000C2A 5E17       02844 	SUBWF delta_2,1,0
000C2C C01A FFE9  02845 	MOVFF stepAddress_2,FSR0
000C30 C01B FFEA  02846 	MOVFF stepAddress_2+1,FSR0+1
000C34 501C       02847 	MOVF  stepMask_2,W,0
000C36 12EF       02848 	IORWF INDF0,1,0
000C38 D009       02849 	BRA   m070
000C3A 5017       02850 m069	MOVF  delta_2,W,0
000C3C 5C13       02851 	SUBWF blue_3,W,0
000C3E 6E17       02852 	MOVWF delta_2,0
000C40 C01A FFE9  02853 	MOVFF stepAddress_2,FSR0
000C44 C01B FFEA  02854 	MOVFF stepAddress_2+1,FSR0+1
000C48 1C1C       02855 	COMF  stepMask_2,W,0
000C4A 16EF       02856 	ANDWF INDF0,1,0
000C4C 90D8       02857 m070	BCF   0xFD8,Carry,0
000C4E 361C       02858 	RLCF  stepMask_2,1,0
000C50 A4D8       02859 	BTFSS 0xFD8,Zero_,0
000C52 D005       02860 	BRA   m071
000C54 2A1A       02861 	INCF  stepAddress_2,1,0
000C56 0E00       02862 	MOVLW 0
000C58 221B       02863 	ADDWFC stepAddress_2+1,1,0
000C5A 0E01       02864 	MOVLW 1
000C5C 6E1C       02865 	MOVWF stepMask_2,0
000C5E 0E01       02866 m071	MOVLW 1
000C60 6E18       02867 	MOVWF stepSize_3,0
000C62 6A14       02868 	CLRF  temp16_2,0
000C64 6A15       02869 	CLRF  temp16_2+1,0
000C66 5217       02870 	MOVF  delta_2,1,0
000C68 B4D8       02871 	BTFSC 0xFD8,Zero_,0
000C6A D01B       02872 	BRA   m073
000C6C C017 F01E  02873 m072	MOVFF delta_2,arg1_5
000C70 6A1F       02874 	CLRF  arg1_5+1,0
000C72 5018       02875 	MOVF  stepSize_3,W,0
000C74 ECEE F001  02876 	CALL  _divU16_8
000C78 C01E F019  02877 	MOVFF arg1_5,temp8_2
000C7C C00A F01E  02878 	MOVFF fadeTmms_2,arg1_5
000C80 C00B F01F  02879 	MOVFF fadeTmms_2+1,arg1_5+1
000C84 5019       02880 	MOVF  temp8_2,W,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 49

ADDR   CODE       LINE  SOURCE

000C86 ECEE F001  02881 	CALL  _divU16_8
000C8A C01E F014  02882 	MOVFF arg1_5,temp16_2
000C8E C01F F015  02883 	MOVFF arg1_5+1,temp16_2+1
000C92 5014       02884 	MOVF  temp16_2,W,0
000C94 1015       02885 	IORWF temp16_2+1,W,0
000C96 B4D8       02886 	BTFSC 0xFD8,Zero_,0
000C98 2A18       02887 	INCF  stepSize_3,1,0
000C9A 5014       02888 	MOVF  temp16_2,W,0
000C9C 1015       02889 	IORWF temp16_2+1,W,0
000C9E B4D8       02890 	BTFSC 0xFD8,Zero_,0
000CA0 D7E5       02891 	BRA   m072
000CA2 0E4F       02892 m073	MOVLW 79
000CA4 2416       02893 	ADDWF k_4,W,0
000CA6 6EE9       02894 	MOVWF FSR0,0
000CA8 0E0A       02895 	MOVLW 10
000CAA 6AEA       02896 	CLRF  FSR0+1,0
000CAC 22EA       02897 	ADDWFC FSR0+1,1,0
000CAE C018 FFEF  02898 	MOVFF stepSize_3,INDF0
000CB2 0E63       02899 	MOVLW 99
000CB4 2416       02900 	ADDWF k_4,W,0
000CB6 6EE9       02901 	MOVWF FSR0,0
000CB8 0E08       02902 	MOVLW 8
000CBA 6AEA       02903 	CLRF  FSR0+1,0
000CBC 22EA       02904 	ADDWFC FSR0+1,1,0
000CBE C017 FFEF  02905 	MOVFF delta_2,INDF0
000CC2 90D8       02906 	BCF   0xFD8,Carry,0
000CC4 3416       02907 	RLCF  k_4,W,0
000CC6 6EE9       02908 	MOVWF FSR0,0
000CC8 6AEA       02909 	CLRF  FSR0+1,0
000CCA 36EA       02910 	RLCF  FSR0+1,1,0
000CCC 0E83       02911 	MOVLW 131
000CCE 26E9       02912 	ADDWF FSR0,1,0
000CD0 0E09       02913 	MOVLW 9
000CD2 22EA       02914 	ADDWFC FSR0+1,1,0
000CD4 C014 FFEE  02915 	MOVFF temp16_2,POSTINC0
000CD8 C015 FFEE  02916 	MOVFF temp16_2+1,POSTINC0
000CDC 90D8       02917 	BCF   0xFD8,Carry,0
000CDE 3416       02918 	RLCF  k_4,W,0
000CE0 6EE9       02919 	MOVWF FSR0,0
000CE2 6AEA       02920 	CLRF  FSR0+1,0
000CE4 36EA       02921 	RLCF  FSR0+1,1,0
000CE6 0EC3       02922 	MOVLW 195
000CE8 26E9       02923 	ADDWF FSR0,1,0
000CEA 0E08       02924 	MOVLW 8
000CEC 22EA       02925 	ADDWFC FSR0+1,1,0
000CEE C014 FFEE  02926 	MOVFF temp16_2,POSTINC0
000CF2 C015 FFEE  02927 	MOVFF temp16_2+1,POSTINC0
                  02928 			;			k++;
000CF6 2A16       02929 	INCF  k_4,1,0
                  02930 			;			CALC_COLOR(green);
000CF8 0E03       02931 	MOVLW 3
000CFA 2416       02932 	ADDWF k_4,W,0
000CFC 6EE9       02933 	MOVWF FSR0,0
000CFE 0E08       02934 	MOVLW 8
000D00 6AEA       02935 	CLRF  FSR0+1,0
000D02 22EA       02936 	ADDWFC FSR0+1,1,0
000D04 CFEF F017  02937 	MOVFF INDF0,delta_2
000D08 5017       02938 	MOVF  delta_2,W,0
000D0A 6012       02939 	CPFSLT green_3,0
000D0C D009       02940 	BRA   m074
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 50

ADDR   CODE       LINE  SOURCE

000D0E 5012       02941 	MOVF  green_3,W,0
000D10 5E17       02942 	SUBWF delta_2,1,0
000D12 C01A FFE9  02943 	MOVFF stepAddress_2,FSR0
000D16 C01B FFEA  02944 	MOVFF stepAddress_2+1,FSR0+1
000D1A 501C       02945 	MOVF  stepMask_2,W,0
000D1C 12EF       02946 	IORWF INDF0,1,0
000D1E D009       02947 	BRA   m075
000D20 5017       02948 m074	MOVF  delta_2,W,0
000D22 5C12       02949 	SUBWF green_3,W,0
000D24 6E17       02950 	MOVWF delta_2,0
000D26 C01A FFE9  02951 	MOVFF stepAddress_2,FSR0
000D2A C01B FFEA  02952 	MOVFF stepAddress_2+1,FSR0+1
000D2E 1C1C       02953 	COMF  stepMask_2,W,0
000D30 16EF       02954 	ANDWF INDF0,1,0
000D32 90D8       02955 m075	BCF   0xFD8,Carry,0
000D34 361C       02956 	RLCF  stepMask_2,1,0
000D36 A4D8       02957 	BTFSS 0xFD8,Zero_,0
000D38 D005       02958 	BRA   m076
000D3A 2A1A       02959 	INCF  stepAddress_2,1,0
000D3C 0E00       02960 	MOVLW 0
000D3E 221B       02961 	ADDWFC stepAddress_2+1,1,0
000D40 0E01       02962 	MOVLW 1
000D42 6E1C       02963 	MOVWF stepMask_2,0
000D44 0E01       02964 m076	MOVLW 1
000D46 6E18       02965 	MOVWF stepSize_3,0
000D48 6A14       02966 	CLRF  temp16_2,0
000D4A 6A15       02967 	CLRF  temp16_2+1,0
000D4C 5217       02968 	MOVF  delta_2,1,0
000D4E B4D8       02969 	BTFSC 0xFD8,Zero_,0
000D50 D01B       02970 	BRA   m078
000D52 C017 F01E  02971 m077	MOVFF delta_2,arg1_5
000D56 6A1F       02972 	CLRF  arg1_5+1,0
000D58 5018       02973 	MOVF  stepSize_3,W,0
000D5A ECEE F001  02974 	CALL  _divU16_8
000D5E C01E F019  02975 	MOVFF arg1_5,temp8_2
000D62 C00A F01E  02976 	MOVFF fadeTmms_2,arg1_5
000D66 C00B F01F  02977 	MOVFF fadeTmms_2+1,arg1_5+1
000D6A 5019       02978 	MOVF  temp8_2,W,0
000D6C ECEE F001  02979 	CALL  _divU16_8
000D70 C01E F014  02980 	MOVFF arg1_5,temp16_2
000D74 C01F F015  02981 	MOVFF arg1_5+1,temp16_2+1
000D78 5014       02982 	MOVF  temp16_2,W,0
000D7A 1015       02983 	IORWF temp16_2+1,W,0
000D7C B4D8       02984 	BTFSC 0xFD8,Zero_,0
000D7E 2A18       02985 	INCF  stepSize_3,1,0
000D80 5014       02986 	MOVF  temp16_2,W,0
000D82 1015       02987 	IORWF temp16_2+1,W,0
000D84 B4D8       02988 	BTFSC 0xFD8,Zero_,0
000D86 D7E5       02989 	BRA   m077
000D88 0E4F       02990 m078	MOVLW 79
000D8A 2416       02991 	ADDWF k_4,W,0
000D8C 6EE9       02992 	MOVWF FSR0,0
000D8E 0E0A       02993 	MOVLW 10
000D90 6AEA       02994 	CLRF  FSR0+1,0
000D92 22EA       02995 	ADDWFC FSR0+1,1,0
000D94 C018 FFEF  02996 	MOVFF stepSize_3,INDF0
000D98 0E63       02997 	MOVLW 99
000D9A 2416       02998 	ADDWF k_4,W,0
000D9C 6EE9       02999 	MOVWF FSR0,0
000D9E 0E08       03000 	MOVLW 8
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 51

ADDR   CODE       LINE  SOURCE

000DA0 6AEA       03001 	CLRF  FSR0+1,0
000DA2 22EA       03002 	ADDWFC FSR0+1,1,0
000DA4 C017 FFEF  03003 	MOVFF delta_2,INDF0
000DA8 90D8       03004 	BCF   0xFD8,Carry,0
000DAA 3416       03005 	RLCF  k_4,W,0
000DAC 6EE9       03006 	MOVWF FSR0,0
000DAE 6AEA       03007 	CLRF  FSR0+1,0
000DB0 36EA       03008 	RLCF  FSR0+1,1,0
000DB2 0E83       03009 	MOVLW 131
000DB4 26E9       03010 	ADDWF FSR0,1,0
000DB6 0E09       03011 	MOVLW 9
000DB8 22EA       03012 	ADDWFC FSR0+1,1,0
000DBA C014 FFEE  03013 	MOVFF temp16_2,POSTINC0
000DBE C015 FFEE  03014 	MOVFF temp16_2+1,POSTINC0
000DC2 90D8       03015 	BCF   0xFD8,Carry,0
000DC4 3416       03016 	RLCF  k_4,W,0
000DC6 6EE9       03017 	MOVWF FSR0,0
000DC8 6AEA       03018 	CLRF  FSR0+1,0
000DCA 36EA       03019 	RLCF  FSR0+1,1,0
000DCC 0EC3       03020 	MOVLW 195
000DCE 26E9       03021 	ADDWF FSR0,1,0
000DD0 0E08       03022 	MOVLW 8
000DD2 22EA       03023 	ADDWFC FSR0+1,1,0
000DD4 C014 FFEE  03024 	MOVFF temp16_2,POSTINC0
000DD8 C015 FFEE  03025 	MOVFF temp16_2+1,POSTINC0
                  03026 			;			k++;
000DDC 2A16       03027 	INCF  k_4,1,0
                  03028 			;			CALC_COLOR(red);
000DDE 0E03       03029 	MOVLW 3
000DE0 2416       03030 	ADDWF k_4,W,0
000DE2 6EE9       03031 	MOVWF FSR0,0
000DE4 0E08       03032 	MOVLW 8
000DE6 6AEA       03033 	CLRF  FSR0+1,0
000DE8 22EA       03034 	ADDWFC FSR0+1,1,0
000DEA CFEF F017  03035 	MOVFF INDF0,delta_2
000DEE 5017       03036 	MOVF  delta_2,W,0
000DF0 6011       03037 	CPFSLT red_3,0
000DF2 D009       03038 	BRA   m079
000DF4 5011       03039 	MOVF  red_3,W,0
000DF6 5E17       03040 	SUBWF delta_2,1,0
000DF8 C01A FFE9  03041 	MOVFF stepAddress_2,FSR0
000DFC C01B FFEA  03042 	MOVFF stepAddress_2+1,FSR0+1
000E00 501C       03043 	MOVF  stepMask_2,W,0
000E02 12EF       03044 	IORWF INDF0,1,0
000E04 D009       03045 	BRA   m080
000E06 5017       03046 m079	MOVF  delta_2,W,0
000E08 5C11       03047 	SUBWF red_3,W,0
000E0A 6E17       03048 	MOVWF delta_2,0
000E0C C01A FFE9  03049 	MOVFF stepAddress_2,FSR0
000E10 C01B FFEA  03050 	MOVFF stepAddress_2+1,FSR0+1
000E14 1C1C       03051 	COMF  stepMask_2,W,0
000E16 16EF       03052 	ANDWF INDF0,1,0
000E18 90D8       03053 m080	BCF   0xFD8,Carry,0
000E1A 361C       03054 	RLCF  stepMask_2,1,0
000E1C A4D8       03055 	BTFSS 0xFD8,Zero_,0
000E1E D005       03056 	BRA   m081
000E20 2A1A       03057 	INCF  stepAddress_2,1,0
000E22 0E00       03058 	MOVLW 0
000E24 221B       03059 	ADDWFC stepAddress_2+1,1,0
000E26 0E01       03060 	MOVLW 1
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 52

ADDR   CODE       LINE  SOURCE

000E28 6E1C       03061 	MOVWF stepMask_2,0
000E2A 0E01       03062 m081	MOVLW 1
000E2C 6E18       03063 	MOVWF stepSize_3,0
000E2E 6A14       03064 	CLRF  temp16_2,0
000E30 6A15       03065 	CLRF  temp16_2+1,0
000E32 5217       03066 	MOVF  delta_2,1,0
000E34 B4D8       03067 	BTFSC 0xFD8,Zero_,0
000E36 D01B       03068 	BRA   m083
000E38 C017 F01E  03069 m082	MOVFF delta_2,arg1_5
000E3C 6A1F       03070 	CLRF  arg1_5+1,0
000E3E 5018       03071 	MOVF  stepSize_3,W,0
000E40 ECEE F001  03072 	CALL  _divU16_8
000E44 C01E F019  03073 	MOVFF arg1_5,temp8_2
000E48 C00A F01E  03074 	MOVFF fadeTmms_2,arg1_5
000E4C C00B F01F  03075 	MOVFF fadeTmms_2+1,arg1_5+1
000E50 5019       03076 	MOVF  temp8_2,W,0
000E52 ECEE F001  03077 	CALL  _divU16_8
000E56 C01E F014  03078 	MOVFF arg1_5,temp16_2
000E5A C01F F015  03079 	MOVFF arg1_5+1,temp16_2+1
000E5E 5014       03080 	MOVF  temp16_2,W,0
000E60 1015       03081 	IORWF temp16_2+1,W,0
000E62 B4D8       03082 	BTFSC 0xFD8,Zero_,0
000E64 2A18       03083 	INCF  stepSize_3,1,0
000E66 5014       03084 	MOVF  temp16_2,W,0
000E68 1015       03085 	IORWF temp16_2+1,W,0
000E6A B4D8       03086 	BTFSC 0xFD8,Zero_,0
000E6C D7E5       03087 	BRA   m082
000E6E 0E4F       03088 m083	MOVLW 79
000E70 2416       03089 	ADDWF k_4,W,0
000E72 6EE9       03090 	MOVWF FSR0,0
000E74 0E0A       03091 	MOVLW 10
000E76 6AEA       03092 	CLRF  FSR0+1,0
000E78 22EA       03093 	ADDWFC FSR0+1,1,0
000E7A C018 FFEF  03094 	MOVFF stepSize_3,INDF0
000E7E 0E63       03095 	MOVLW 99
000E80 2416       03096 	ADDWF k_4,W,0
000E82 6EE9       03097 	MOVWF FSR0,0
000E84 0E08       03098 	MOVLW 8
000E86 6AEA       03099 	CLRF  FSR0+1,0
000E88 22EA       03100 	ADDWFC FSR0+1,1,0
000E8A C017 FFEF  03101 	MOVFF delta_2,INDF0
000E8E 90D8       03102 	BCF   0xFD8,Carry,0
000E90 3416       03103 	RLCF  k_4,W,0
000E92 6EE9       03104 	MOVWF FSR0,0
000E94 6AEA       03105 	CLRF  FSR0+1,0
000E96 36EA       03106 	RLCF  FSR0+1,1,0
000E98 0E83       03107 	MOVLW 131
000E9A 26E9       03108 	ADDWF FSR0,1,0
000E9C 0E09       03109 	MOVLW 9
000E9E 22EA       03110 	ADDWFC FSR0+1,1,0
000EA0 C014 FFEE  03111 	MOVFF temp16_2,POSTINC0
000EA4 C015 FFEE  03112 	MOVFF temp16_2+1,POSTINC0
000EA8 90D8       03113 	BCF   0xFD8,Carry,0
000EAA 3416       03114 	RLCF  k_4,W,0
000EAC 6EE9       03115 	MOVWF FSR0,0
000EAE 6AEA       03116 	CLRF  FSR0+1,0
000EB0 36EA       03117 	RLCF  FSR0+1,1,0
000EB2 0EC3       03118 	MOVLW 195
000EB4 26E9       03119 	ADDWF FSR0,1,0
000EB6 0E08       03120 	MOVLW 8
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 53

ADDR   CODE       LINE  SOURCE

000EB8 22EA       03121 	ADDWFC FSR0+1,1,0
000EBA C014 FFEE  03122 	MOVFF temp16_2,POSTINC0
000EBE C015 FFEE  03123 	MOVFF temp16_2+1,POSTINC0
                  03124 			;			break;
000EC2 D18C       03125 	BRA   m107
                  03126 			;		}
                  03127 			;
                  03128 			;		if(k >= offset) {
000EC4 500C       03129 m084	MOVF  offset,W,0
000EC6 5C16       03130 	SUBWF k_4,W,0
000EC8 A0D8       03131 	BTFSS 0xFD8,Carry,0
000ECA D17D       03132 	BRA   m105
                  03133 			;			CALC_COLOR(blue);
000ECC 0E03       03134 	MOVLW 3
000ECE 2416       03135 	ADDWF k_4,W,0
000ED0 6EE9       03136 	MOVWF FSR0,0
000ED2 0E08       03137 	MOVLW 8
000ED4 6AEA       03138 	CLRF  FSR0+1,0
000ED6 22EA       03139 	ADDWFC FSR0+1,1,0
000ED8 CFEF F017  03140 	MOVFF INDF0,delta_2
000EDC 5017       03141 	MOVF  delta_2,W,0
000EDE 6013       03142 	CPFSLT blue_3,0
000EE0 D009       03143 	BRA   m085
000EE2 5013       03144 	MOVF  blue_3,W,0
000EE4 5E17       03145 	SUBWF delta_2,1,0
000EE6 C01A FFE9  03146 	MOVFF stepAddress_2,FSR0
000EEA C01B FFEA  03147 	MOVFF stepAddress_2+1,FSR0+1
000EEE 501C       03148 	MOVF  stepMask_2,W,0
000EF0 12EF       03149 	IORWF INDF0,1,0
000EF2 D009       03150 	BRA   m086
000EF4 5017       03151 m085	MOVF  delta_2,W,0
000EF6 5C13       03152 	SUBWF blue_3,W,0
000EF8 6E17       03153 	MOVWF delta_2,0
000EFA C01A FFE9  03154 	MOVFF stepAddress_2,FSR0
000EFE C01B FFEA  03155 	MOVFF stepAddress_2+1,FSR0+1
000F02 1C1C       03156 	COMF  stepMask_2,W,0
000F04 16EF       03157 	ANDWF INDF0,1,0
000F06 90D8       03158 m086	BCF   0xFD8,Carry,0
000F08 361C       03159 	RLCF  stepMask_2,1,0
000F0A A4D8       03160 	BTFSS 0xFD8,Zero_,0
000F0C D005       03161 	BRA   m087
000F0E 2A1A       03162 	INCF  stepAddress_2,1,0
000F10 0E00       03163 	MOVLW 0
000F12 221B       03164 	ADDWFC stepAddress_2+1,1,0
000F14 0E01       03165 	MOVLW 1
000F16 6E1C       03166 	MOVWF stepMask_2,0
000F18 0E01       03167 m087	MOVLW 1
000F1A 6E18       03168 	MOVWF stepSize_3,0
000F1C 6A14       03169 	CLRF  temp16_2,0
000F1E 6A15       03170 	CLRF  temp16_2+1,0
000F20 5217       03171 	MOVF  delta_2,1,0
000F22 B4D8       03172 	BTFSC 0xFD8,Zero_,0
000F24 D01B       03173 	BRA   m089
000F26 C017 F01E  03174 m088	MOVFF delta_2,arg1_5
000F2A 6A1F       03175 	CLRF  arg1_5+1,0
000F2C 5018       03176 	MOVF  stepSize_3,W,0
000F2E ECEE F001  03177 	CALL  _divU16_8
000F32 C01E F019  03178 	MOVFF arg1_5,temp8_2
000F36 C00A F01E  03179 	MOVFF fadeTmms_2,arg1_5
000F3A C00B F01F  03180 	MOVFF fadeTmms_2+1,arg1_5+1
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 54

ADDR   CODE       LINE  SOURCE

000F3E 5019       03181 	MOVF  temp8_2,W,0
000F40 ECEE F001  03182 	CALL  _divU16_8
000F44 C01E F014  03183 	MOVFF arg1_5,temp16_2
000F48 C01F F015  03184 	MOVFF arg1_5+1,temp16_2+1
000F4C 5014       03185 	MOVF  temp16_2,W,0
000F4E 1015       03186 	IORWF temp16_2+1,W,0
000F50 B4D8       03187 	BTFSC 0xFD8,Zero_,0
000F52 2A18       03188 	INCF  stepSize_3,1,0
000F54 5014       03189 	MOVF  temp16_2,W,0
000F56 1015       03190 	IORWF temp16_2+1,W,0
000F58 B4D8       03191 	BTFSC 0xFD8,Zero_,0
000F5A D7E5       03192 	BRA   m088
000F5C 0E4F       03193 m089	MOVLW 79
000F5E 2416       03194 	ADDWF k_4,W,0
000F60 6EE9       03195 	MOVWF FSR0,0
000F62 0E0A       03196 	MOVLW 10
000F64 6AEA       03197 	CLRF  FSR0+1,0
000F66 22EA       03198 	ADDWFC FSR0+1,1,0
000F68 C018 FFEF  03199 	MOVFF stepSize_3,INDF0
000F6C 0E63       03200 	MOVLW 99
000F6E 2416       03201 	ADDWF k_4,W,0
000F70 6EE9       03202 	MOVWF FSR0,0
000F72 0E08       03203 	MOVLW 8
000F74 6AEA       03204 	CLRF  FSR0+1,0
000F76 22EA       03205 	ADDWFC FSR0+1,1,0
000F78 C017 FFEF  03206 	MOVFF delta_2,INDF0
000F7C 90D8       03207 	BCF   0xFD8,Carry,0
000F7E 3416       03208 	RLCF  k_4,W,0
000F80 6EE9       03209 	MOVWF FSR0,0
000F82 6AEA       03210 	CLRF  FSR0+1,0
000F84 36EA       03211 	RLCF  FSR0+1,1,0
000F86 0E83       03212 	MOVLW 131
000F88 26E9       03213 	ADDWF FSR0,1,0
000F8A 0E09       03214 	MOVLW 9
000F8C 22EA       03215 	ADDWFC FSR0+1,1,0
000F8E C014 FFEE  03216 	MOVFF temp16_2,POSTINC0
000F92 C015 FFEE  03217 	MOVFF temp16_2+1,POSTINC0
000F96 90D8       03218 	BCF   0xFD8,Carry,0
000F98 3416       03219 	RLCF  k_4,W,0
000F9A 6EE9       03220 	MOVWF FSR0,0
000F9C 6AEA       03221 	CLRF  FSR0+1,0
000F9E 36EA       03222 	RLCF  FSR0+1,1,0
000FA0 0EC3       03223 	MOVLW 195
000FA2 26E9       03224 	ADDWF FSR0,1,0
000FA4 0E08       03225 	MOVLW 8
000FA6 22EA       03226 	ADDWFC FSR0+1,1,0
000FA8 C014 FFEE  03227 	MOVFF temp16_2,POSTINC0
000FAC C015 FFEE  03228 	MOVFF temp16_2+1,POSTINC0
                  03229 			;			k++;
000FB0 2A16       03230 	INCF  k_4,1,0
                  03231 			;			CALC_COLOR(green);
000FB2 0E03       03232 	MOVLW 3
000FB4 2416       03233 	ADDWF k_4,W,0
000FB6 6EE9       03234 	MOVWF FSR0,0
000FB8 0E08       03235 	MOVLW 8
000FBA 6AEA       03236 	CLRF  FSR0+1,0
000FBC 22EA       03237 	ADDWFC FSR0+1,1,0
000FBE CFEF F017  03238 	MOVFF INDF0,delta_2
000FC2 5017       03239 	MOVF  delta_2,W,0
000FC4 6012       03240 	CPFSLT green_3,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 55

ADDR   CODE       LINE  SOURCE

000FC6 D009       03241 	BRA   m090
000FC8 5012       03242 	MOVF  green_3,W,0
000FCA 5E17       03243 	SUBWF delta_2,1,0
000FCC C01A FFE9  03244 	MOVFF stepAddress_2,FSR0
000FD0 C01B FFEA  03245 	MOVFF stepAddress_2+1,FSR0+1
000FD4 501C       03246 	MOVF  stepMask_2,W,0
000FD6 12EF       03247 	IORWF INDF0,1,0
000FD8 D009       03248 	BRA   m091
000FDA 5017       03249 m090	MOVF  delta_2,W,0
000FDC 5C12       03250 	SUBWF green_3,W,0
000FDE 6E17       03251 	MOVWF delta_2,0
000FE0 C01A FFE9  03252 	MOVFF stepAddress_2,FSR0
000FE4 C01B FFEA  03253 	MOVFF stepAddress_2+1,FSR0+1
000FE8 1C1C       03254 	COMF  stepMask_2,W,0
000FEA 16EF       03255 	ANDWF INDF0,1,0
000FEC 90D8       03256 m091	BCF   0xFD8,Carry,0
000FEE 361C       03257 	RLCF  stepMask_2,1,0
000FF0 A4D8       03258 	BTFSS 0xFD8,Zero_,0
000FF2 D005       03259 	BRA   m092
000FF4 2A1A       03260 	INCF  stepAddress_2,1,0
000FF6 0E00       03261 	MOVLW 0
000FF8 221B       03262 	ADDWFC stepAddress_2+1,1,0
000FFA 0E01       03263 	MOVLW 1
000FFC 6E1C       03264 	MOVWF stepMask_2,0
000FFE 0E01       03265 m092	MOVLW 1
001000 6E18       03266 	MOVWF stepSize_3,0
001002 6A14       03267 	CLRF  temp16_2,0
001004 6A15       03268 	CLRF  temp16_2+1,0
001006 5217       03269 	MOVF  delta_2,1,0
001008 B4D8       03270 	BTFSC 0xFD8,Zero_,0
00100A D01B       03271 	BRA   m094
00100C C017 F01E  03272 m093	MOVFF delta_2,arg1_5
001010 6A1F       03273 	CLRF  arg1_5+1,0
001012 5018       03274 	MOVF  stepSize_3,W,0
001014 ECEE F001  03275 	CALL  _divU16_8
001018 C01E F019  03276 	MOVFF arg1_5,temp8_2
00101C C00A F01E  03277 	MOVFF fadeTmms_2,arg1_5
001020 C00B F01F  03278 	MOVFF fadeTmms_2+1,arg1_5+1
001024 5019       03279 	MOVF  temp8_2,W,0
001026 ECEE F001  03280 	CALL  _divU16_8
00102A C01E F014  03281 	MOVFF arg1_5,temp16_2
00102E C01F F015  03282 	MOVFF arg1_5+1,temp16_2+1
001032 5014       03283 	MOVF  temp16_2,W,0
001034 1015       03284 	IORWF temp16_2+1,W,0
001036 B4D8       03285 	BTFSC 0xFD8,Zero_,0
001038 2A18       03286 	INCF  stepSize_3,1,0
00103A 5014       03287 	MOVF  temp16_2,W,0
00103C 1015       03288 	IORWF temp16_2+1,W,0
00103E B4D8       03289 	BTFSC 0xFD8,Zero_,0
001040 D7E5       03290 	BRA   m093
001042 0E4F       03291 m094	MOVLW 79
001044 2416       03292 	ADDWF k_4,W,0
001046 6EE9       03293 	MOVWF FSR0,0
001048 0E0A       03294 	MOVLW 10
00104A 6AEA       03295 	CLRF  FSR0+1,0
00104C 22EA       03296 	ADDWFC FSR0+1,1,0
00104E C018 FFEF  03297 	MOVFF stepSize_3,INDF0
001052 0E63       03298 	MOVLW 99
001054 2416       03299 	ADDWF k_4,W,0
001056 6EE9       03300 	MOVWF FSR0,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 56

ADDR   CODE       LINE  SOURCE

001058 0E08       03301 	MOVLW 8
00105A 6AEA       03302 	CLRF  FSR0+1,0
00105C 22EA       03303 	ADDWFC FSR0+1,1,0
00105E C017 FFEF  03304 	MOVFF delta_2,INDF0
001062 90D8       03305 	BCF   0xFD8,Carry,0
001064 3416       03306 	RLCF  k_4,W,0
001066 6EE9       03307 	MOVWF FSR0,0
001068 6AEA       03308 	CLRF  FSR0+1,0
00106A 36EA       03309 	RLCF  FSR0+1,1,0
00106C 0E83       03310 	MOVLW 131
00106E 26E9       03311 	ADDWF FSR0,1,0
001070 0E09       03312 	MOVLW 9
001072 22EA       03313 	ADDWFC FSR0+1,1,0
001074 C014 FFEE  03314 	MOVFF temp16_2,POSTINC0
001078 C015 FFEE  03315 	MOVFF temp16_2+1,POSTINC0
00107C 90D8       03316 	BCF   0xFD8,Carry,0
00107E 3416       03317 	RLCF  k_4,W,0
001080 6EE9       03318 	MOVWF FSR0,0
001082 6AEA       03319 	CLRF  FSR0+1,0
001084 36EA       03320 	RLCF  FSR0+1,1,0
001086 0EC3       03321 	MOVLW 195
001088 26E9       03322 	ADDWF FSR0,1,0
00108A 0E08       03323 	MOVLW 8
00108C 22EA       03324 	ADDWFC FSR0+1,1,0
00108E C014 FFEE  03325 	MOVFF temp16_2,POSTINC0
001092 C015 FFEE  03326 	MOVFF temp16_2+1,POSTINC0
                  03327 			;			k++;
001096 2A16       03328 	INCF  k_4,1,0
                  03329 			;			CALC_COLOR(red);
001098 0E03       03330 	MOVLW 3
00109A 2416       03331 	ADDWF k_4,W,0
00109C 6EE9       03332 	MOVWF FSR0,0
00109E 0E08       03333 	MOVLW 8
0010A0 6AEA       03334 	CLRF  FSR0+1,0
0010A2 22EA       03335 	ADDWFC FSR0+1,1,0
0010A4 CFEF F017  03336 	MOVFF INDF0,delta_2
0010A8 5017       03337 	MOVF  delta_2,W,0
0010AA 6011       03338 	CPFSLT red_3,0
0010AC D009       03339 	BRA   m095
0010AE 5011       03340 	MOVF  red_3,W,0
0010B0 5E17       03341 	SUBWF delta_2,1,0
0010B2 C01A FFE9  03342 	MOVFF stepAddress_2,FSR0
0010B6 C01B FFEA  03343 	MOVFF stepAddress_2+1,FSR0+1
0010BA 501C       03344 	MOVF  stepMask_2,W,0
0010BC 12EF       03345 	IORWF INDF0,1,0
0010BE D009       03346 	BRA   m096
0010C0 5017       03347 m095	MOVF  delta_2,W,0
0010C2 5C11       03348 	SUBWF red_3,W,0
0010C4 6E17       03349 	MOVWF delta_2,0
0010C6 C01A FFE9  03350 	MOVFF stepAddress_2,FSR0
0010CA C01B FFEA  03351 	MOVFF stepAddress_2+1,FSR0+1
0010CE 1C1C       03352 	COMF  stepMask_2,W,0
0010D0 16EF       03353 	ANDWF INDF0,1,0
0010D2 90D8       03354 m096	BCF   0xFD8,Carry,0
0010D4 361C       03355 	RLCF  stepMask_2,1,0
0010D6 A4D8       03356 	BTFSS 0xFD8,Zero_,0
0010D8 D005       03357 	BRA   m097
0010DA 2A1A       03358 	INCF  stepAddress_2,1,0
0010DC 0E00       03359 	MOVLW 0
0010DE 221B       03360 	ADDWFC stepAddress_2+1,1,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 57

ADDR   CODE       LINE  SOURCE

0010E0 0E01       03361 	MOVLW 1
0010E2 6E1C       03362 	MOVWF stepMask_2,0
0010E4 0E01       03363 m097	MOVLW 1
0010E6 6E18       03364 	MOVWF stepSize_3,0
0010E8 6A14       03365 	CLRF  temp16_2,0
0010EA 6A15       03366 	CLRF  temp16_2+1,0
0010EC 5217       03367 	MOVF  delta_2,1,0
0010EE B4D8       03368 	BTFSC 0xFD8,Zero_,0
0010F0 D01B       03369 	BRA   m099
0010F2 C017 F01E  03370 m098	MOVFF delta_2,arg1_5
0010F6 6A1F       03371 	CLRF  arg1_5+1,0
0010F8 5018       03372 	MOVF  stepSize_3,W,0
0010FA ECEE F001  03373 	CALL  _divU16_8
0010FE C01E F019  03374 	MOVFF arg1_5,temp8_2
001102 C00A F01E  03375 	MOVFF fadeTmms_2,arg1_5
001106 C00B F01F  03376 	MOVFF fadeTmms_2+1,arg1_5+1
00110A 5019       03377 	MOVF  temp8_2,W,0
00110C ECEE F001  03378 	CALL  _divU16_8
001110 C01E F014  03379 	MOVFF arg1_5,temp16_2
001114 C01F F015  03380 	MOVFF arg1_5+1,temp16_2+1
001118 5014       03381 	MOVF  temp16_2,W,0
00111A 1015       03382 	IORWF temp16_2+1,W,0
00111C B4D8       03383 	BTFSC 0xFD8,Zero_,0
00111E 2A18       03384 	INCF  stepSize_3,1,0
001120 5014       03385 	MOVF  temp16_2,W,0
001122 1015       03386 	IORWF temp16_2+1,W,0
001124 B4D8       03387 	BTFSC 0xFD8,Zero_,0
001126 D7E5       03388 	BRA   m098
001128 0E4F       03389 m099	MOVLW 79
00112A 2416       03390 	ADDWF k_4,W,0
00112C 6EE9       03391 	MOVWF FSR0,0
00112E 0E0A       03392 	MOVLW 10
001130 6AEA       03393 	CLRF  FSR0+1,0
001132 22EA       03394 	ADDWFC FSR0+1,1,0
001134 C018 FFEF  03395 	MOVFF stepSize_3,INDF0
001138 0E63       03396 	MOVLW 99
00113A 2416       03397 	ADDWF k_4,W,0
00113C 6EE9       03398 	MOVWF FSR0,0
00113E 0E08       03399 	MOVLW 8
001140 6AEA       03400 	CLRF  FSR0+1,0
001142 22EA       03401 	ADDWFC FSR0+1,1,0
001144 C017 FFEF  03402 	MOVFF delta_2,INDF0
001148 90D8       03403 	BCF   0xFD8,Carry,0
00114A 3416       03404 	RLCF  k_4,W,0
00114C 6EE9       03405 	MOVWF FSR0,0
00114E 6AEA       03406 	CLRF  FSR0+1,0
001150 36EA       03407 	RLCF  FSR0+1,1,0
001152 0E83       03408 	MOVLW 131
001154 26E9       03409 	ADDWF FSR0,1,0
001156 0E09       03410 	MOVLW 9
001158 22EA       03411 	ADDWFC FSR0+1,1,0
00115A C014 FFEE  03412 	MOVFF temp16_2,POSTINC0
00115E C015 FFEE  03413 	MOVFF temp16_2+1,POSTINC0
001162 90D8       03414 	BCF   0xFD8,Carry,0
001164 3416       03415 	RLCF  k_4,W,0
001166 6EE9       03416 	MOVWF FSR0,0
001168 6AEA       03417 	CLRF  FSR0+1,0
00116A 36EA       03418 	RLCF  FSR0+1,1,0
00116C 0EC3       03419 	MOVLW 195
00116E 26E9       03420 	ADDWF FSR0,1,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 58

ADDR   CODE       LINE  SOURCE

001170 0E08       03421 	MOVLW 8
001172 22EA       03422 	ADDWFC FSR0+1,1,0
001174 C014 FFEE  03423 	MOVFF temp16_2,POSTINC0
001178 C015 FFEE  03424 	MOVFF temp16_2+1,POSTINC0
                  03425 			;			ADJUST_COLOR(red,   pCmd->red_2,   deltaRed);
00117C 6AEA       03426 	CLRF  FSR0+1,0
00117E 0E03       03427 	MOVLW 3
001180 2409       03428 	ADDWF pCmd_2,W,0
001182 6EE9       03429 	MOVWF FSR0,0
001184 5011       03430 	MOVF  red_3,W,0
001186 60EF       03431 	CPFSLT INDF0,0
001188 D003       03432 	BRA   m100
00118A 500E       03433 	MOVF  deltaRed,W,0
00118C 5E11       03434 	SUBWF red_3,1,0
00118E D002       03435 	BRA   m101
001190 500E       03436 m100	MOVF  deltaRed,W,0
001192 2611       03437 	ADDWF red_3,1,0
                  03438 			;			ADJUST_COLOR(green, pCmd->green_2, deltaGreen);
001194 6AEA       03439 m101	CLRF  FSR0+1,0
001196 0E04       03440 	MOVLW 4
001198 2409       03441 	ADDWF pCmd_2,W,0
00119A 6EE9       03442 	MOVWF FSR0,0
00119C 5012       03443 	MOVF  green_3,W,0
00119E 60EF       03444 	CPFSLT INDF0,0
0011A0 D003       03445 	BRA   m102
0011A2 500F       03446 	MOVF  deltaGreen,W,0
0011A4 5E12       03447 	SUBWF green_3,1,0
0011A6 D002       03448 	BRA   m103
0011A8 500F       03449 m102	MOVF  deltaGreen,W,0
0011AA 2612       03450 	ADDWF green_3,1,0
                  03451 			;			ADJUST_COLOR(blue,  pCmd->blue_2,  deltaBlue);
0011AC 6AEA       03452 m103	CLRF  FSR0+1,0
0011AE 0E05       03453 	MOVLW 5
0011B0 2409       03454 	ADDWF pCmd_2,W,0
0011B2 6EE9       03455 	MOVWF FSR0,0
0011B4 5013       03456 	MOVF  blue_3,W,0
0011B6 60EF       03457 	CPFSLT INDF0,0
0011B8 D003       03458 	BRA   m104
0011BA 5010       03459 	MOVF  deltaBlue,W,0
0011BC 5E13       03460 	SUBWF blue_3,1,0
0011BE D00C       03461 	BRA   m106
0011C0 5010       03462 m104	MOVF  deltaBlue,W,0
0011C2 2613       03463 	ADDWF blue_3,1,0
                  03464 			;		} else
0011C4 D009       03465 	BRA   m106
                  03466 			;			INC_BIT_COUNTER(stepAddress, stepMask);
0011C6 90D8       03467 m105	BCF   0xFD8,Carry,0
0011C8 361C       03468 	RLCF  stepMask_2,1,0
0011CA A4D8       03469 	BTFSS 0xFD8,Zero_,0
0011CC D005       03470 	BRA   m106
0011CE 2A1A       03471 	INCF  stepAddress_2,1,0
0011D0 0E00       03472 	MOVLW 0
0011D2 221B       03473 	ADDWFC stepAddress_2+1,1,0
0011D4 0E01       03474 	MOVLW 1
0011D6 6E1C       03475 	MOVWF stepMask_2,0
                  03476 			;	}
0011D8 2A16       03477 m106	INCF  k_4,1,0
0011DA D502       03478 	BRA   m068
                  03479 			;}
0011DC 0012       03480 m107	RETURN
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 59

ADDR   CODE       LINE  SOURCE

                  03481 
                  03482   ; FILE ./firmware\spi.c
                  03483 			;/**
                  03484 			; Copyright (C) 2012 Nils Weiss, Patrick Brnn.
                  03485 			;
                  03486 			; This file is part of Wifly_Light.
                  03487 			;
                  03488 			; Wifly_Light is free software: you can redistribute it and/or modify
                  03489 			; it under the terms of the GNU General Public License as published by
                  03490 			; the Free Software Foundation, either version 3 of the License, or
                  03491 			; (at your option) any later version.
                  03492 			;
                  03493 			; Wifly_Light is distributed in the hope that it will be useful,
                  03494 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  03495 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  03496 			; GNU General Public License for more details.
                  03497 			;
                  03498 			; You should have received a copy of the GNU General Public License
                  03499 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  03500 			;
                  03501 			;#include "spi.h"
                  03502 			;
                  03503 			;#ifdef __CC8E__
                  03504 			;void SPI_Init()
                  03505 			;{
                  03506 SPI_Init
                  03507 			;	ANSELC = FALSE;         /* Set PORTC to digital IO */
0011DE 010F       03508 	MOVLB 15
0011E0 6B3A       03509 	CLRF  ANSELC,1
                  03510 			;	TRISC .3 = FALSE;       /* Make port RC3 an output(SPI Clock) */
0011E2 9694       03511 	BCF   TRISC,3,0
                  03512 			;	TRISC .4 = TRUE;         /* Make port RC4 an input(SPI Data In) */
0011E4 8894       03513 	BSF   TRISC,4,0
                  03514 			;	TRISC .5 = FALSE;       /* Make port RC5 an output(SPI Data Out) */
0011E6 9A94       03515 	BCF   TRISC,5,0
                  03516 			;
                  03517 			;	SMP = TRUE;             /* Input data sampeld at end of data output time */
0011E8 8EC7       03518 	BSF   0xFC7,SMP,0
                  03519 			;	CKP = FALSE;            /* Idle state for clock is low level */
0011EA 98C6       03520 	BCF   0xFC6,CKP,0
                  03521 			;	CKE = TRUE;             /* Transmit occures on transition from active to Idle clock state */
0011EC 8CC7       03522 	BSF   0xFC7,CKE,0
                  03523 			;	SSP1CON1 .0 = TRUE;      /* SPI MASTER mode, clock = Fosc/16 */
0011EE 80C6       03524 	BSF   SSP1CON1,0,0
                  03525 			;	SSPEN = TRUE;           /* Enables the serial port and configures SCK, SDO, SDI */
0011F0 8AC6       03526 	BSF   0xFC6,SSPEN,0
                  03527 			;}
0011F2 0012       03528 	RETURN
                  03529 			;
                  03530 			;uns8 SPI_Send(const uns8 data)
                  03531 			;{
                  03532 SPI_Send
                  03533 			;	SSP1IF = FALSE;         /* Reset interruptflag, that end of transmisson can be detected */
0011F4 969E       03534 	BCF   0xF9E,SSP1IF,0
                  03535 			;	SSP1BUF = data;
0011F6 C00E FFC9  03536 	MOVFF data_4,SSP1BUF
                  03537 			;	while(SSP1IF == 0) ;    /* Wait for end of transmission */
0011FA A69E       03538 m108	BTFSS 0xF9E,SSP1IF,0
0011FC D7FE       03539 	BRA   m108
                  03540 			;
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 60

ADDR   CODE       LINE  SOURCE

                  03541 			;	return SSP1BUF;
0011FE 50C9       03542 	MOVF  SSP1BUF,W,0
001200 0012       03543 	RETURN
                  03544 			;}
                  03545 			;
                  03546 			;void SPI_SendLedBuffer(uns8 *array)
                  03547 			;{
                  03548 SPI_SendLedBuffer
                  03549 			;	const uns8 *end = (uns8 *) (array + (NUM_OF_LED * 3));                           /* array must be the address of the first byte*/
001202 0E60       03550 	MOVLW 96
001204 2407       03551 	ADDWF array_3,W,0
001206 6E09       03552 	MOVWF end,0
001208 0E00       03553 	MOVLW 0
00120A 2008       03554 	ADDWFC array_3+1,W,0
00120C 6E0A       03555 	MOVWF end+1,0
                  03556 			;	/* calculate where the end is */
                  03557 			;	for(; array < end; array++) {           /* send all data */
00120E 5009       03558 m109	MOVF  end,W,0
001210 5C07       03559 	SUBWF array_3,W,0
001212 500A       03560 	MOVF  end+1,W,0
001214 5808       03561 	SUBWFB array_3+1,W,0
001216 B0D8       03562 	BTFSC 0xFD8,Carry,0
001218 D00B       03563 	BRA   m110
                  03564 			;		SPI_Send(*array);
00121A C007 FFE9  03565 	MOVFF array_3,FSR0
00121E C008 FFEA  03566 	MOVFF array_3+1,FSR0+1
001222 CFEF F00E  03567 	MOVFF INDF0,data_4
001226 DFE6       03568 	RCALL SPI_Send
                  03569 			;	}
001228 2A07       03570 	INCF  array_3,1,0
00122A 0E00       03571 	MOVLW 0
00122C 2208       03572 	ADDWFC array_3+1,1,0
00122E D7EF       03573 	BRA   m109
                  03574 			;
                  03575 			;/* If we really have to garantee a sleep after data was written to the LEDs, it should be added here.
                  03576 			; * Other locations would be more attractive to avoid a waiting core, but here it is much clearer and easier
                  03577 			; * to find for later optimization. In my opinion we should spend this 1ms waste here, before we make the main
                  03578 			; * loop more complex. */
                  03579 			;}
001230 0012       03580 m110	RETURN
                  03581 
                  03582   ; FILE ./firmware\timer.c
                  03583 			;/**
                  03584 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  03585 			;
                  03586 			; This file is part of Wifly_Light.
                  03587 			;
                  03588 			; Wifly_Light is free software: you can redistribute it and/or modify
                  03589 			; it under the terms of the GNU General Public License as published by
                  03590 			; the Free Software Foundation, either version 3 of the License, or
                  03591 			; (at your option) any later version.
                  03592 			;
                  03593 			; Wifly_Light is distributed in the hope that it will be useful,
                  03594 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  03595 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  03596 			; GNU General Public License for more details.
                  03597 			;
                  03598 			; You should have received a copy of the GNU General Public License
                  03599 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  03600 			;
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 61

ADDR   CODE       LINE  SOURCE

                  03601 			;#include "timer.h"
                  03602 			;#include "trace.h"
                  03603 			;
                  03604 			;struct CycleTimeBuffer g_CycleTimeBuffer;
                  03605 			;enum CYCLETIME_METHODE enumMethode;
                  03606 			;
                  03607 			;void Timer_Init()
                  03608 			;{
                  03609 Timer_Init
                  03610 			;#ifdef __CC8E__
                  03611 			;	/*
                  03612 			;	 * T1 Interrupt every 10 Millisecounds if clock is 64MHz
                  03613 			;	 * Calculation
                  03614 			;	 * 64000000 Hz / 4 / 4 / 65536
                  03615 			;	 * T1 Interrupt occures with a frequency of 60 Hz.
                  03616 			;	 * This is used to update the ledstrip with the current colorvalue
                  03617 			;	 */
                  03618 			;	T1CON = 0b00100111;
001232 0E27       03619 	MOVLW 39
001234 6ECD       03620 	MOVWF T1CON,0
                  03621 			;	TMR1IE = TRUE;
001236 809D       03622 	BSF   0xF9D,TMR1IE,0
                  03623 			;
                  03624 			;	/*
                  03625 			;	 * T5 Interrupt every 5 Millisecounds if clock is 64MHz
                  03626 			;	 * Calculation
                  03627 			;	 * 64000000 Hz / 4 / 8 / 5000
                  03628 			;	 */
                  03629 			;	T5CON = 0b00110111;
001238 0E37       03630 	MOVLW 55
00123A 010F       03631 	MOVLB 15
00123C 6F4E       03632 	MOVWF T5CON,1
                  03633 			;	TMR5IE = TRUE;
00123E 827D       03634 	BSF   0xF7D,TMR5IE,0
                  03635 			;	TMR5H = 0xEC;
001240 0EEC       03636 	MOVLW 236
001242 6F50       03637 	MOVWF TMR5H,1
                  03638 			;	TMR5L = 0x78;
001244 0E78       03639 	MOVLW 120
001246 6F4F       03640 	MOVWF TMR5L,1
                  03641 			;	/*
                  03642 			;	** T4 Interrupt every 4 Millisecound if clock is 64MHz
                  03643 			;	** Calculation
                  03644 			;	** 64000000 Hz / 4 / 16 / 250 / 16
                  03645 			;	*/
                  03646 			;	T4CON = 0b01111111;
001248 0E7F       03647 	MOVLW 127
00124A 6F51       03648 	MOVWF T4CON,1
                  03649 			;	TMR4IE = FALSE;
00124C 907D       03650 	BCF   0xF7D,TMR4IE,0
                  03651 			;	PR4 = 250;
00124E 0EFA       03652 	MOVLW 250
001250 6F52       03653 	MOVWF PR4,1
                  03654 			;
                  03655 			;	/*
                  03656 			;	** T2 Interrupt every 0.5 Millisecound if clock is 64MHz
                  03657 			;	** Calculation
                  03658 			;	** 64000000 Hz / 4 / 16 / 75 / 10
                  03659 			;	*/
                  03660 			;	T2CON = 0b01001111;
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 62

ADDR   CODE       LINE  SOURCE

001252 0E4F       03661 	MOVLW 79
001254 6EBA       03662 	MOVWF T2CON,0
                  03663 			;	TMR2ON = 0;
001256 94BA       03664 	BCF   0xFBA,TMR2ON,0
                  03665 			;	TMR2IE = 0;
001258 929D       03666 	BCF   0xF9D,TMR2IE,0
                  03667 			;	PR2 = 75;
00125A 0E4B       03668 	MOVLW 75
00125C 6EBB       03669 	MOVWF PR2,0
                  03670 			;
                  03671 			;	/*
                  03672 			;	** T3 Modul count with a frequency of 2MHz
                  03673 			;	** T3 is used as PerformanceCounter
                  03674 			;	** Calculation:
                  03675 			;	** 64MHz / 4 / 8
                  03676 			;	*/
                  03677 			;	T3CON = 0b00110110;
00125E 0E36       03678 	MOVLW 54
001260 6EB1       03679 	MOVWF T3CON,0
                  03680 			;	TMR3ON = 1;
001262 80B1       03681 	BSF   0xFB1,TMR3ON,0
                  03682 			;#endif /* #ifdef __CC8E__ */
                  03683 			;}
001264 0012       03684 	RETURN
                  03685 			;
                  03686 			;#ifdef DEBUG
                  03687 			;void Timer_StartStopwatch(const enum CYCLETIME_METHODE destMethode)
                  03688 			;{
                  03689 Timer_StartStopwatch
                  03690 			;	uns16 tempTime;
                  03691 			;
                  03692 			;	Platform_ReadPerformanceCounter(tempTime);
001266 CFB2 F008  03693 	MOVFF TMR3L,tempTime
00126A CFB3 F009  03694 	MOVFF TMR3H,tempTime+1
                  03695 			;
                  03696 			;	g_CycleTimeBuffer.tempCycleTime[destMethode] = tempTime;
00126E 6AEA       03697 	CLRF  FSR0+1,0
001270 90D8       03698 	BCF   0xFD8,Carry,0
001272 3407       03699 	RLCF  destMethode,W,0
001274 0F45       03700 	ADDLW 69
001276 6EE9       03701 	MOVWF FSR0,0
001278 C008 FFEE  03702 	MOVFF tempTime,POSTINC0
00127C C009 FFEE  03703 	MOVFF tempTime+1,POSTINC0
                  03704 			;}
001280 0012       03705 	RETURN
                  03706 			;
                  03707 			;void Timer_StopStopwatch(const enum CYCLETIME_METHODE destMethode)
                  03708 			;{
                  03709 Timer_StopStopwatch
                  03710 			;	uns16 tempTime,temp16;
                  03711 			;
                  03712 			;	Platform_ReadPerformanceCounter(tempTime);
001282 CFB2 F008  03713 	MOVFF TMR3L,tempTime_2
001286 CFB3 F009  03714 	MOVFF TMR3H,tempTime_2+1
                  03715 			;
                  03716 			;	if(g_CycleTimeBuffer.tempCycleTime[destMethode] < tempTime) {
00128A 6AEA       03717 	CLRF  FSR0+1,0
00128C 90D8       03718 	BCF   0xFD8,Carry,0
00128E 3407       03719 	RLCF  destMethode_2,W,0
001290 0F45       03720 	ADDLW 69
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 63

ADDR   CODE       LINE  SOURCE

001292 6EE9       03721 	MOVWF FSR0,0
001294 5008       03722 	MOVF  tempTime_2,W,0
001296 5CEE       03723 	SUBWF POSTINC0,W,0
001298 5009       03724 	MOVF  tempTime_2+1,W,0
00129A 58EF       03725 	SUBWFB INDF0,W,0
00129C B0D8       03726 	BTFSC 0xFD8,Carry,0
00129E D00A       03727 	BRA   m111
                  03728 			;		tempTime = tempTime - g_CycleTimeBuffer.tempCycleTime[destMethode];
0012A0 6AEA       03729 	CLRF  FSR0+1,0
0012A2 90D8       03730 	BCF   0xFD8,Carry,0
0012A4 3407       03731 	RLCF  destMethode_2,W,0
0012A6 0F45       03732 	ADDLW 69
0012A8 6EE9       03733 	MOVWF FSR0,0
0012AA 50EE       03734 	MOVF  POSTINC0,W,0
0012AC 5E08       03735 	SUBWF tempTime_2,1,0
0012AE 50EF       03736 	MOVF  INDF0,W,0
0012B0 5A09       03737 	SUBWFB tempTime_2+1,1,0
                  03738 			;	} else {
0012B2 D00D       03739 	BRA   m112
                  03740 			;		temp16 = 0xffff - g_CycleTimeBuffer.tempCycleTime[destMethode];
0012B4 6AEA       03741 m111	CLRF  FSR0+1,0
0012B6 90D8       03742 	BCF   0xFD8,Carry,0
0012B8 3407       03743 	RLCF  destMethode_2,W,0
0012BA 0F45       03744 	ADDLW 69
0012BC 6EE9       03745 	MOVWF FSR0,0
0012BE 1CEE       03746 	COMF  POSTINC0,W,0
0012C0 6E0A       03747 	MOVWF temp16_3,0
0012C2 1CEF       03748 	COMF  INDF0,W,0
0012C4 6E0B       03749 	MOVWF temp16_3+1,0
                  03750 			;		tempTime += temp16;
0012C6 500A       03751 	MOVF  temp16_3,W,0
0012C8 2608       03752 	ADDWF tempTime_2,1,0
0012CA 500B       03753 	MOVF  temp16_3+1,W,0
0012CC 2209       03754 	ADDWFC tempTime_2+1,1,0
                  03755 			;	}
                  03756 			;
                  03757 			;	if(tempTime > g_CycleTimeBuffer.maxCycleTime[destMethode]) {
0012CE 6AEA       03758 m112	CLRF  FSR0+1,0
0012D0 90D8       03759 	BCF   0xFD8,Carry,0
0012D2 3407       03760 	RLCF  destMethode_2,W,0
0012D4 0F2D       03761 	ADDLW 45
0012D6 6EE9       03762 	MOVWF FSR0,0
0012D8 5008       03763 	MOVF  tempTime_2,W,0
0012DA 5CEE       03764 	SUBWF POSTINC0,W,0
0012DC 5009       03765 	MOVF  tempTime_2+1,W,0
0012DE 58EF       03766 	SUBWFB INDF0,W,0
0012E0 B0D8       03767 	BTFSC 0xFD8,Carry,0
0012E2 D009       03768 	BRA   m113
                  03769 			;		g_CycleTimeBuffer.maxCycleTime[destMethode] = tempTime;
0012E4 6AEA       03770 	CLRF  FSR0+1,0
0012E6 90D8       03771 	BCF   0xFD8,Carry,0
0012E8 3407       03772 	RLCF  destMethode_2,W,0
0012EA 0F2D       03773 	ADDLW 45
0012EC 6EE9       03774 	MOVWF FSR0,0
0012EE C008 FFEE  03775 	MOVFF tempTime_2,POSTINC0
0012F2 C009 FFEE  03776 	MOVFF tempTime_2+1,POSTINC0
                  03777 			;	}
                  03778 			;	g_CycleTimeBuffer.tempCycleTime[destMethode] = 0;
0012F6 6AEA       03779 m113	CLRF  FSR0+1,0
0012F8 90D8       03780 	BCF   0xFD8,Carry,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 64

ADDR   CODE       LINE  SOURCE

0012FA 3407       03781 	RLCF  destMethode_2,W,0
0012FC 0F45       03782 	ADDLW 69
0012FE 6EE9       03783 	MOVWF FSR0,0
001300 6AEE       03784 	CLRF  POSTINC0,0
001302 6AEF       03785 	CLRF  INDF0,0
                  03786 			;}
001304 0012       03787 	RETURN
                  03788 			;
                  03789 			;uns8 Timer_PrintCycletime(uns16 *pArray, const uns16 arraySize)
                  03790 			;{
                  03791 Timer_PrintCycletime
                  03792 			;	uns16 i, temp16;
                  03793 			;	for(i = 0; i < CYCLETIME_METHODE_ENUM_SIZE && i < arraySize; i++) {
001306 6A13       03794 	CLRF  i_5,0
001308 6A14       03795 	CLRF  i_5+1,0
00130A 5014       03796 m114	MOVF  i_5+1,W,0
00130C A4D8       03797 	BTFSS 0xFD8,Zero_,0
00130E D03A       03798 	BRA   m115
001310 0E0C       03799 	MOVLW 12
001312 6013       03800 	CPFSLT i_5,0
001314 D037       03801 	BRA   m115
001316 5011       03802 	MOVF  arraySize,W,0
001318 5C13       03803 	SUBWF i_5,W,0
00131A 5012       03804 	MOVF  arraySize+1,W,0
00131C 5814       03805 	SUBWFB i_5+1,W,0
00131E B0D8       03806 	BTFSC 0xFD8,Carry,0
001320 D031       03807 	BRA   m115
                  03808 			;		temp16 = g_CycleTimeBuffer.maxCycleTime[i];
001322 90D8       03809 	BCF   0xFD8,Carry,0
001324 3413       03810 	RLCF  i_5,W,0
001326 6EE9       03811 	MOVWF FSR0,0
001328 3414       03812 	RLCF  i_5+1,W,0
00132A 6EEA       03813 	MOVWF FSR0+1,0
00132C 0E2D       03814 	MOVLW 45
00132E 26E9       03815 	ADDWF FSR0,1,0
001330 0E00       03816 	MOVLW 0
001332 22EA       03817 	ADDWFC FSR0+1,1,0
001334 CFEE F015  03818 	MOVFF POSTINC0,temp16_4
001338 CFEE F016  03819 	MOVFF POSTINC0,temp16_4+1
                  03820 			;		temp16 = htons(temp16);
00133C C015 F017  03821 	MOVFF temp16_4,hostShort
001340 C016 F018  03822 	MOVFF temp16_4+1,hostShort+1
001344 DA8E       03823 	RCALL htons
001346 C019 F015  03824 	MOVFF retval,temp16_4
00134A C01A F016  03825 	MOVFF retval+1,temp16_4+1
                  03826 			;		*pArray = temp16;
00134E C00F FFE9  03827 	MOVFF pArray,FSR0
001352 C010 FFEA  03828 	MOVFF pArray+1,FSR0+1
001356 C015 FFEE  03829 	MOVFF temp16_4,POSTINC0
00135A C016 FFEE  03830 	MOVFF temp16_4+1,POSTINC0
                  03831 			;		pArray++;
00135E 0E02       03832 	MOVLW 2
001360 260F       03833 	ADDWF pArray,1,0
001362 0E00       03834 	MOVLW 0
001364 2210       03835 	ADDWFC pArray+1,1,0
                  03836 			;		g_CycleTimeBuffer.maxCycleTime[i] = 0;
001366 90D8       03837 	BCF   0xFD8,Carry,0
001368 3413       03838 	RLCF  i_5,W,0
00136A 6EE9       03839 	MOVWF FSR0,0
00136C 3414       03840 	RLCF  i_5+1,W,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 65

ADDR   CODE       LINE  SOURCE

00136E 6EEA       03841 	MOVWF FSR0+1,0
001370 0E2D       03842 	MOVLW 45
001372 26E9       03843 	ADDWF FSR0,1,0
001374 0E00       03844 	MOVLW 0
001376 22EA       03845 	ADDWFC FSR0+1,1,0
001378 6AEE       03846 	CLRF  POSTINC0,0
00137A 6AEF       03847 	CLRF  INDF0,0
                  03848 			;	}
00137C 2A13       03849 	INCF  i_5,1,0
00137E 0E00       03850 	MOVLW 0
001380 2214       03851 	ADDWFC i_5+1,1,0
001382 D7C3       03852 	BRA   m114
                  03853 			;	return i + i;
001384 5013       03854 m115	MOVF  i_5,W,0
001386 2413       03855 	ADDWF i_5,W,0
001388 0012       03856 	RETURN
                  03857 
                  03858   ; FILE ./firmware\RingBuf.c
                  03859 			;/*
                  03860 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  03861 			;
                  03862 			; This file is part of Wifly_Light.
                  03863 			;
                  03864 			; Wifly_Light is free software: you can redistribute it and/or modify
                  03865 			; it under the terms of the GNU General Public License as published by
                  03866 			; the Free Software Foundation, either version 3 of the License, or
                  03867 			; (at your option) any later version.
                  03868 			;
                  03869 			; Wifly_Light is distributed in the hope that it will be useful,
                  03870 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  03871 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  03872 			; GNU General Public License for more details.
                  03873 			;
                  03874 			; You should have received a copy of the GNU General Public License
                  03875 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  03876 			;
                  03877 			;#include "RingBuf.h"
                  03878 			;
                  03879 			;#ifdef cc3200
                  03880 			;#include "osi.h"
                  03881 			;
                  03882 			;struct RingBuffer g_RingBuf_Tx;
                  03883 			;#endif
                  03884 			;
                  03885 			;bank7 struct RingBuffer g_RingBuf;
                  03886 			;
                  03887 			;void RingBuf_Init(struct RingBuffer *pBuf) {
                  03888 RingBuf_Init
                  03889 			;	pBuf->read = 0;
00138A 5007       03890 	MOVF  pBuf,W,0
00138C 6EE9       03891 	MOVWF FSR0,0
00138E 2808       03892 	INCF  pBuf+1,W,0
001390 6EEA       03893 	MOVWF FSR0+1,0
001392 6AEF       03894 	CLRF  INDF0,0
                  03895 			;	pBuf->write = 0;
001394 2807       03896 	INCF  pBuf,W,0
001396 6EE9       03897 	MOVWF FSR0,0
001398 0E01       03898 	MOVLW 1
00139A 2008       03899 	ADDWFC pBuf+1,W,0
00139C 6EEA       03900 	MOVWF FSR0+1,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 66

ADDR   CODE       LINE  SOURCE

00139E 6AEF       03901 	CLRF  INDF0,0
                  03902 			;	pBuf->error_full = 0;
0013A0 0E02       03903 	MOVLW 2
0013A2 2407       03904 	ADDWF pBuf,W,0
0013A4 6EE9       03905 	MOVWF FSR0,0
0013A6 0E01       03906 	MOVLW 1
0013A8 2008       03907 	ADDWFC pBuf+1,W,0
0013AA 6EEA       03908 	MOVWF FSR0+1,0
0013AC 90EF       03909 	BCF   INDF0,0,0
                  03910 			;}
0013AE 0012       03911 	RETURN
                  03912 			;
                  03913 			;uns8 RingBuf_Get(struct RingBuffer *pBuf) {
                  03914 RingBuf_Get
                  03915 			;#ifdef cc3200
                  03916 			;	unsigned long key = osi_EnterCritical();
                  03917 			;#endif
                  03918 			;	uns8 read = pBuf->read;
0013B0 5016       03919 	MOVF  pBuf_2,W,0
0013B2 6EE9       03920 	MOVWF FSR0,0
0013B4 2817       03921 	INCF  pBuf_2+1,W,0
0013B6 6EEA       03922 	MOVWF FSR0+1,0
0013B8 CFEF F018  03923 	MOVFF INDF0,read
                  03924 			;	uns8 result = pBuf->data[read];
0013BC 5018       03925 	MOVF  read,W,0
0013BE 2416       03926 	ADDWF pBuf_2,W,0
0013C0 6EE9       03927 	MOVWF FSR0,0
0013C2 0E00       03928 	MOVLW 0
0013C4 2017       03929 	ADDWFC pBuf_2+1,W,0
0013C6 6EEA       03930 	MOVWF FSR0+1,0
0013C8 CFEF F019  03931 	MOVFF INDF0,result
                  03932 			;	pBuf->read = RingBufInc(read);
0013CC 5016       03933 	MOVF  pBuf_2,W,0
0013CE 6EE9       03934 	MOVWF FSR0,0
0013D0 2817       03935 	INCF  pBuf_2+1,W,0
0013D2 6EEA       03936 	MOVWF FSR0+1,0
0013D4 2818       03937 	INCF  read,W,0
0013D6 6EEF       03938 	MOVWF INDF0,0
                  03939 			;	pBuf->error_full = FALSE;
0013D8 0E02       03940 	MOVLW 2
0013DA 2416       03941 	ADDWF pBuf_2,W,0
0013DC 6EE9       03942 	MOVWF FSR0,0
0013DE 0E01       03943 	MOVLW 1
0013E0 2017       03944 	ADDWFC pBuf_2+1,W,0
0013E2 6EEA       03945 	MOVWF FSR0+1,0
0013E4 90EF       03946 	BCF   INDF0,0,0
                  03947 			;#ifdef cc3200
                  03948 			;	osi_ExitCritical(key);
                  03949 			;#endif
                  03950 			;	return result;
0013E6 5019       03951 	MOVF  result,W,0
0013E8 0012       03952 	RETURN
                  03953 			;}
                  03954 			;
                  03955 			;void RingBuf_Put(struct RingBuffer *pBuf, const uns8 value) {
                  03956 RingBuf_Put
                  03957 			;#ifdef cc3200
                  03958 			;	unsigned long key = osi_EnterCritical();
                  03959 			;#endif
                  03960 			;	uns8 writeNext = RingBufInc(pBuf->write);
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 67

ADDR   CODE       LINE  SOURCE

0013EA 2815       03961 	INCF  pBuf_3,W,0
0013EC 6EE9       03962 	MOVWF FSR0,0
0013EE 0E01       03963 	MOVLW 1
0013F0 2016       03964 	ADDWFC pBuf_3+1,W,0
0013F2 6EEA       03965 	MOVWF FSR0+1,0
0013F4 28EF       03966 	INCF  INDF0,W,0
0013F6 6E18       03967 	MOVWF writeNext_2,0
                  03968 			;	if (writeNext != pBuf->read) {
0013F8 5015       03969 	MOVF  pBuf_3,W,0
0013FA 6EE9       03970 	MOVWF FSR0,0
0013FC 2816       03971 	INCF  pBuf_3+1,W,0
0013FE 6EEA       03972 	MOVWF FSR0+1,0
001400 5018       03973 	MOVF  writeNext_2,W,0
001402 18EF       03974 	XORWF INDF0,W,0
001404 B4D8       03975 	BTFSC 0xFD8,Zero_,0
001406 D017       03976 	BRA   m116
                  03977 			;		uns8 write = pBuf->write;
001408 2815       03978 	INCF  pBuf_3,W,0
00140A 6EE9       03979 	MOVWF FSR0,0
00140C 0E01       03980 	MOVLW 1
00140E 2016       03981 	ADDWFC pBuf_3+1,W,0
001410 6EEA       03982 	MOVWF FSR0+1,0
001412 CFEF F019  03983 	MOVFF INDF0,write_2
                  03984 			;		pBuf->data[write] = value;
001416 5019       03985 	MOVF  write_2,W,0
001418 2415       03986 	ADDWF pBuf_3,W,0
00141A 6EE9       03987 	MOVWF FSR0,0
00141C 0E00       03988 	MOVLW 0
00141E 2016       03989 	ADDWFC pBuf_3+1,W,0
001420 6EEA       03990 	MOVWF FSR0+1,0
001422 C017 FFEF  03991 	MOVFF value,INDF0
                  03992 			;		pBuf->write = writeNext;
001426 2815       03993 	INCF  pBuf_3,W,0
001428 6EE9       03994 	MOVWF FSR0,0
00142A 0E01       03995 	MOVLW 1
00142C 2016       03996 	ADDWFC pBuf_3+1,W,0
00142E 6EEA       03997 	MOVWF FSR0+1,0
001430 C018 FFEF  03998 	MOVFF writeNext_2,INDF0
                  03999 			;	} else pBuf->error_full = 1;
001434 D007       04000 	BRA   m117
001436 0E02       04001 m116	MOVLW 2
001438 2415       04002 	ADDWF pBuf_3,W,0
00143A 6EE9       04003 	MOVWF FSR0,0
00143C 0E01       04004 	MOVLW 1
00143E 2016       04005 	ADDWFC pBuf_3+1,W,0
001440 6EEA       04006 	MOVWF FSR0+1,0
001442 80EF       04007 	BSF   INDF0,0,0
                  04008 			;#ifdef cc3200
                  04009 			;	osi_ExitCritical(key);
                  04010 			;#endif
                  04011 			;}
001444 0012       04012 m117	RETURN
                  04013 			;
                  04014 			;bit RingBuf_HasError(struct RingBuffer *pBuf) {
                  04015 RingBuf_HasError
                  04016 			;	return pBuf->error_full;
001446 0E02       04017 	MOVLW 2
001448 2415       04018 	ADDWF pBuf_4,W,0
00144A 6EE9       04019 	MOVWF FSR0,0
00144C 0E01       04020 	MOVLW 1
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 68

ADDR   CODE       LINE  SOURCE

00144E 2016       04021 	ADDWFC pBuf_4+1,W,0
001450 6EEA       04022 	MOVWF FSR0+1,0
001452 90D8       04023 	BCF   0xFD8,Carry,0
001454 B0EF       04024 	BTFSC INDF0,0,0
001456 80D8       04025 	BSF   0xFD8,Carry,0
001458 0012       04026 	RETURN
                  04027 			;}
                  04028 			;
                  04029 			;bit RingBuf_IsEmpty(const struct RingBuffer *pBuf) {
                  04030 RingBuf_IsEmpty
                  04031 			;#ifdef cc3200
                  04032 			;	unsigned long key = osi_EnterCritical();
                  04033 			;#endif
                  04034 			;	uns8 write = pBuf->write;
00145A 2816       04035 	INCF  pBuf_5,W,0
00145C 6E1A       04036 	MOVWF ci_2,0
00145E 0E01       04037 	MOVLW 1
001460 2017       04038 	ADDWFC pBuf_5+1,W,0
001462 6E1B       04039 	MOVWF ci_2+1,0
001464 ECE9 F013  04040 	CALL  _const2
001468 6E18       04041 	MOVWF write_3,0
                  04042 			;	uns8 read = pBuf->read;
00146A 5016       04043 	MOVF  pBuf_5,W,0
00146C 6E1A       04044 	MOVWF ci_2,0
00146E 2817       04045 	INCF  pBuf_5+1,W,0
001470 6E1B       04046 	MOVWF ci_2+1,0
001472 ECE9 F013  04047 	CALL  _const2
001476 6E19       04048 	MOVWF read_2,0
                  04049 			;#ifdef cc3200
                  04050 			;	osi_ExitCritical(key);
                  04051 			;#endif
                  04052 			;	return write == read;
001478 90D8       04053 	BCF   0xFD8,Carry,0
00147A 5018       04054 	MOVF  write_3,W,0
00147C 6219       04055 	CPFSEQ read_2,0
00147E D001       04056 	BRA   m118
001480 80D8       04057 	BSF   0xFD8,Carry,0
001482 0012       04058 m118	RETURN
                  04059 
                  04060   ; FILE ./firmware\usart.c
                  04061 			;/**
                  04062 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  04063 			;
                  04064 			; This file is part of Wifly_Light.
                  04065 			;
                  04066 			; Wifly_Light is free software: you can redistribute it and/or modify
                  04067 			; it under the terms of the GNU General Public License as published by
                  04068 			; the Free Software Foundation, either version 3 of the License, or
                  04069 			; (at your option) any later version.
                  04070 			;
                  04071 			; Wifly_Light is distributed in the hope that it will be useful,
                  04072 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  04073 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  04074 			; GNU General Public License for more details.
                  04075 			;
                  04076 			; You should have received a copy of the GNU General Public License
                  04077 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  04078 			;
                  04079 			;#include "usart.h"
                  04080 			;
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 69

ADDR   CODE       LINE  SOURCE

                  04081 			;#ifdef __CC8E__
                  04082 			;//*******  Initialisierungs-Funktion  *************************************************
                  04083 			;void UART_Init()
                  04084 			;{
                  04085 UART_Init
                  04086 			;	//USART TX Pin als Ausgang
                  04087 			;	TRISC .6 = 0;
001484 9C94       04088 	BCF   TRISC,6,0
                  04089 			;	BRGH1 = 1;                                        // High Baudrate activated
001486 84AC       04090 	BSF   0xFAC,BRGH1,0
                  04091 			;	BRG16 = 1;
001488 86B8       04092 	BSF   0xFB8,BRG16,0
                  04093 			;	SPBRG1 = 34;                              // 115200 Bps @ 64 MHz Clock
00148A 0E22       04094 	MOVLW 34
00148C 6EAF       04095 	MOVWF SPBRG1,0
                  04096 			;	SPBRGH1 = 0;
00148E 6AB0       04097 	CLRF  SPBRGH1,0
                  04098 			;	SPEN1 = 1;               // Set_Serial_Pins;
001490 8EAB       04099 	BSF   0xFAB,SPEN1,0
                  04100 			;	SYNC1 = 0;               // Set_Async_Mode;
001492 98AC       04101 	BCF   0xFAC,SYNC1,0
                  04102 			;	TX9_1 = 0;                // Set_8bit_Tx;
001494 9CAC       04103 	BCF   0xFAC,TX9_1,0
                  04104 			;	RX9_1 = 0;                // Set_8bit_Rx;
001496 9CAB       04105 	BCF   0xFAB,RX9_1,0
                  04106 			;	CREN1 = 1;               // Enable_Rx;
001498 88AB       04107 	BSF   0xFAB,CREN1,0
                  04108 			;	TXEN1 = 1;               // Enable_Tx;
00149A 8AAC       04109 	BSF   0xFAC,TXEN1,0
                  04110 			;	RC1IE = 1;                 // Rx Interrupt aus
00149C 8A9D       04111 	BSF   0xF9D,RC1IE,0
                  04112 			;	ADDEN1 = 0;                               // Disable Adressdetection
00149E 96AB       04113 	BCF   0xFAB,ADDEN1,0
                  04114 			;}
0014A0 0012       04115 	RETURN
                  04116 			;
                  04117 			;//*******  Sende-char-Funktion  *************************************************
                  04118 			;void UART_Send(const uns8 ch)
                  04119 			;{
                  04120 UART_Send
                  04121 			;	while(!TX1IF) ;
0014A2 A89E       04122 m119	BTFSS 0xF9E,TX1IF,0
0014A4 D7FE       04123 	BRA   m119
                  04124 			;	TXREG1 = ch;
0014A6 C013 FFAD  04125 	MOVFF ch,TXREG1
                  04126 			;}
0014AA 0012       04127 	RETURN
                  04128 
                  04129   ; FILE ./firmware\CommandIO.c
                  04130 			;/**
                  04131 			; Copyright (C) 2012, 2013 Nils Weiss, Patrick Bruenn.
                  04132 			;
                  04133 			; This file is part of Wifly_Light.
                  04134 			;
                  04135 			; Wifly_Light is free software: you can redistribute it and/or modify
                  04136 			; it under the terms of the GNU General Public License as published by
                  04137 			; the Free Software Foundation, either version 3 of the License, or
                  04138 			; (at your option) any later version.
                  04139 			;
                  04140 			; Wifly_Light is distributed in the hope that it will be useful,
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 70

ADDR   CODE       LINE  SOURCE

                  04141 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  04142 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  04143 			; GNU General Public License for more details.
                  04144 			;
                  04145 			; You should have received a copy of the GNU General Public License
                  04146 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  04147 			;
                  04148 			;#ifndef cc3200
                  04149 			;
                  04150 			;#include "usart.h"
                  04151 			;#include "spi.h"
                  04152 			;#include "crc.h"
                  04153 			;
                  04154 			;#else /* cc3200 */
                  04155 			;
                  04156 			;#include "wy_crc.h"
                  04157 			;#include "uart_if.h"
                  04158 			;#define UART_PRINT Report
                  04159 			;
                  04160 			;#endif /* cc3200 */
                  04161 			;
                  04162 			;#include "ScriptCtrl.h"
                  04163 			;#include "CommandIO.h"
                  04164 			;#include "trace.h"
                  04165 			;#include "RingBuf.h"
                  04166 			;#include "error.h"
                  04167 			;#include "Version.h"
                  04168 			;#include "wifly_cmd.h"
                  04169 			;#include "rtc.h"
                  04170 			;
                  04171 			;bank2 struct CommandBuffer g_CmdBuf;
                  04172 			;bank5 struct response_frame g_ResponseBuf;
                  04173 			;static bit g_Odd_STX_Received;
                  04174 			;
                  04175 			;/** PRIVATE METHODES **/
                  04176 			;
                  04177 			;#ifdef cc3200
                  04178 			;
                  04179 			;static void UART_Send(const uns8 data) {
                  04180 			;	if (RingBuf_HasError(&g_RingBuf_Tx)) {
                  04181 			;		UART_PRINT("g_RingBuf_Tx Error \r\n");
                  04182 			;		RingBuf_Init(&g_RingBuf_Tx);
                  04183 			;	}
                  04184 			;	RingBuf_Put(&g_RingBuf_Tx, data);
                  04185 			;}
                  04186 			;
                  04187 			;#define Rtc_Ctl(x,y)
                  04188 			;#define Timer_PrintCycletime(x,y) 0
                  04189 			;#define Trace_Print(x,y) 0
                  04190 			;#define SPI_Send(x) 0
                  04191 			;#endif
                  04192 			;
                  04193 			;static void WriteByte(uns8 byte)
                  04194 			;{
                  04195 WriteByte
0014AC 6E08       04196 	MOVWF byte_4,0
                  04197 			;	if(g_CmdBuf.counter < sizeof(g_CmdBuf.buffer)) {
0014AE 0E6E       04198 	MOVLW 110
0014B0 0102       04199 	MOVLB 2
0014B2 616E       04200 	CPFSLT g_CmdBuf+110,1
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 71

ADDR   CODE       LINE  SOURCE

0014B4 D02C       04201 	BRA   CommandIO_Error
                  04202 			;		g_CmdBuf.buffer[g_CmdBuf.counter] = byte;
0014B6 EE02 F000  04203 	LFSR  0,512 
0014BA 516E       04204 	MOVF  g_CmdBuf+110,W,1
0014BC 26E9       04205 	ADDWF FSR0,1,0
0014BE C008 FFEF  04206 	MOVFF byte_4,INDF0
                  04207 			;		g_CmdBuf.counter++;
0014C2 2B6E       04208 	INCF  g_CmdBuf+110,1,1
                  04209 			;		Crc_AddCrc(byte, &g_CmdBuf.CrcH, &g_CmdBuf.CrcL);
0014C4 C008 F013  04210 	MOVFF byte_4,byte
0014C8 0E70       04211 	MOVLW 112
0014CA 6E14       04212 	MOVWF p_crcH,0
0014CC 0E02       04213 	MOVLW 2
0014CE 6E15       04214 	MOVWF p_crcH+1,0
0014D0 0E71       04215 	MOVLW 113
0014D2 6E16       04216 	MOVWF p_crcL,0
0014D4 0E02       04217 	MOVLW 2
0014D6 6E17       04218 	MOVWF p_crcL+1,0
0014D8 ECFE F000  04219 	CALL  Crc_AddCrc
                  04220 			;	} else {
                  04221 			;		CommandIO_Error();
                  04222 			;	}
                  04223 			;}
0014DC 0012       04224 m120	RETURN
                  04225 			;
                  04226 			;static void DeleteBuffer()
                  04227 			;{
                  04228 DeleteBuffer
                  04229 			;	g_CmdBuf.counter = 0;
0014DE 0102       04230 	MOVLB 2
0014E0 6B6E       04231 	CLRF  g_CmdBuf+110,1
                  04232 			;	Crc_NewCrc(&g_CmdBuf.CrcH, &g_CmdBuf.CrcL);
0014E2 0E70       04233 	MOVLW 112
0014E4 6E13       04234 	MOVWF p_crcH_2,0
0014E6 0E02       04235 	MOVLW 2
0014E8 6E14       04236 	MOVWF p_crcH_2+1,0
0014EA 0E71       04237 	MOVLW 113
0014EC 6E15       04238 	MOVWF p_crcL_2,0
0014EE 0E02       04239 	MOVLW 2
0014F0 6E16       04240 	MOVWF p_crcL_2+1,0
0014F2 EF5E F001  04241 	GOTO  Crc_NewCrc
                  04242 			;}
                  04243 			;
                  04244 			;static void CheckForFwIdentMessage()
                  04245 			;{
                  04246 CheckForFwIdentMessage
                  04247 			;	g_Odd_STX_Received = !g_Odd_STX_Received;
0014F6 705F       04248 	BTG   0x5F,g_Odd_STX_Received,0
                  04249 			;	if (g_Odd_STX_Received == FALSE) {
0014F8 B05F       04250 	BTFSC 0x5F,g_Odd_STX_Received,0
0014FA D003       04251 	BRA   m121
                  04252 			;		UART_Send(FW_IDENT);
0014FC 0E0D       04253 	MOVLW 13
0014FE 6E13       04254 	MOVWF ch,0
001500 D7D0       04255 	BRA   UART_Send
                  04256 			;	}
                  04257 			;}
001502 0012       04258 m121	RETURN
                  04259 			;
                  04260 			;/** PUBLIC METHODES **/
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 72

ADDR   CODE       LINE  SOURCE

                  04261 			;
                  04262 			;void CommandIO_Init()
                  04263 			;{
                  04264 CommandIO_Init
                  04265 			;	g_CmdBuf.state = CS_WaitForSTX;
001504 0102       04266 	MOVLB 2
001506 6B6F       04267 	CLRF  g_CmdBuf+111,1
                  04268 			;	DeleteBuffer();
001508 DFEA       04269 	RCALL DeleteBuffer
                  04270 			;	g_Odd_STX_Received = FALSE;
00150A 905F       04271 	BCF   0x5F,g_Odd_STX_Received,0
                  04272 			;#ifdef cc3200
                  04273 			;	Crc_Init();
                  04274 			;#endif
                  04275 			;}
00150C 0012       04276 	RETURN
                  04277 			;
                  04278 			;void CommandIO_Error()
                  04279 			;{
                  04280 CommandIO_Error
                  04281 			;	CommandIO_CreateResponse(&g_ResponseBuf, g_CmdBuf.buffer[1], BAD_PACKET);
00150E 6A0A       04282 	CLRF  mFrame_2,0
001510 0E05       04283 	MOVLW 5
001512 6E0B       04284 	MOVWF mFrame_2+1,0
001514 C201 F00C  04285 	MOVFF g_CmdBuf+1,cmd
001518 0E03       04286 	MOVLW 3
00151A 6E0D       04287 	MOVWF mState,0
00151C D8D7       04288 	RCALL CommandIO_CreateResponse
                  04289 			;	CommandIO_SendResponse(&g_ResponseBuf);
00151E 6A0A       04290 	CLRF  mFrame,0
001520 0E05       04291 	MOVLW 5
001522 6E0B       04292 	MOVWF mFrame+1,0
001524 D86B       04293 	RCALL CommandIO_SendResponse
                  04294 			;	CommandIO_Init();
001526 D7EE       04295 	BRA   CommandIO_Init
                  04296 			;}
                  04297 			;
                  04298 			;
                  04299 			;
                  04300 			;/** STATEMACHINE FOR GetCommands:
                  04301 			; * All ASCII-Chars are seperatet in 4 Groups
                  04302 			; *      Group1: STX
                  04303 			; *      Group2: ETX
                  04304 			; *      Group3: DLE
                  04305 			; *      Group4: All Elements of ASCII-Table without STX,ETX,DLE. I will call it CHAR in further description
                  04306 			; *
                  04307 			; * The Statemachine has 4 different states
                  04308 			; *      state 0: Wait for STX           		--> representet from CS_WaitForSTX
                  04309 			; *              read DLE or ETX or CHAR         --> new state = state 0 (nothing happens)
                  04310 			; *				read STX						--> new state = state 1
                  04311 			; *
                  04312 			; *      state 1: Read mask character			--> representet from CS_UnMaskChar
                  04313 			; *              read STX or ETX or DLE or CHAR	--> new state = state 3, save byte to commandbuffer, increment counter
                  04314 			; *
                  04315 			; *      state 2: Save Char              		--> representet from CS_SaveChar
                  04316 			; *              read CHAR						--> new state = state 3, save CHAR to commandbuffer, increment counter
                  04317 			; *              read DLE						--> new state = state 2
                  04318 			; *              read STX						--> new state = state 1
                  04319 			; *              read ETX						--> new state = state 0, do CRC-check, save dataframe
                  04320 			; *
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 73

ADDR   CODE       LINE  SOURCE

                  04321 			; * **/
                  04322 			;
                  04323 			;void CommandIO_GetCommands()
                  04324 			;{
                  04325 CommandIO_GetCommands
                  04326 			;	if(RingBuf_HasError(&g_RingBuf)) {
001528 6A15       04327 	CLRF  pBuf_4,0
00152A 0E07       04328 	MOVLW 7
00152C 6E16       04329 	MOVWF pBuf_4+1,0
00152E DF8B       04330 	RCALL RingBuf_HasError
001530 A0D8       04331 	BTFSS 0xFD8,Carry,0
001532 D009       04332 	BRA   m122
                  04333 			;		Trace_String(ERROR_RECEIVEBUFFER_FULL);//RingbufferFull
001534 0E12       04334 	MOVLW 18
001536 6E12       04335 	MOVWF string,0
001538 ECBE F011  04336 	CALL  Trace_String
                  04337 			;#ifdef cc3200
                  04338 			;		UART_PRINT("[ERROR]g_RingBuf Overflow\r\n");
                  04339 			;#endif
                  04340 			;		// *** if a RingBufError occure, I have to throw away the current command,
                  04341 			;		// *** because the last byte was not saved. Commandstring is inconsistent
                  04342 			;		RingBuf_Init(&g_RingBuf);
00153C 6A07       04343 	CLRF  pBuf,0
00153E 0E07       04344 	MOVLW 7
001540 6E08       04345 	MOVWF pBuf+1,0
001542 DF23       04346 	RCALL RingBuf_Init
                  04347 			;		CommandIO_Error();
001544 D7E4       04348 	BRA   CommandIO_Error
                  04349 			;		return;
                  04350 			;	}
                  04351 			;
                  04352 			;	while(!RingBuf_IsEmpty(&g_RingBuf))
001546 6A16       04353 m122	CLRF  pBuf_5,0
001548 0E07       04354 	MOVLW 7
00154A 6E17       04355 	MOVWF pBuf_5+1,0
00154C DF86       04356 	RCALL RingBuf_IsEmpty
00154E B0D8       04357 	BTFSC 0xFD8,Carry,0
001550 D054       04358 	BRA   m131
                  04359 			;	{
                  04360 			;		// *** get new_byte from ringbuffer
                  04361 			;		uns8 new_byte = RingBuf_Get(&g_RingBuf);
001552 6A16       04362 	CLRF  pBuf_2,0
001554 0E07       04363 	MOVLW 7
001556 6E17       04364 	MOVWF pBuf_2+1,0
001558 DF2B       04365 	RCALL RingBuf_Get
00155A 6E07       04366 	MOVWF new_byte,0
                  04367 			;		switch(g_CmdBuf.state)
00155C 0102       04368 	MOVLB 2
00155E 516F       04369 	MOVF  g_CmdBuf+111,W,1
001560 B4D8       04370 	BTFSC 0xFD8,Zero_,0
001562 D007       04371 	BRA   m123
001564 0A01       04372 	XORLW 1
001566 B4D8       04373 	BTFSC 0xFD8,Zero_,0
001568 D00D       04374 	BRA   m124
00156A 0A03       04375 	XORLW 3
00156C B4D8       04376 	BTFSC 0xFD8,Zero_,0
00156E D010       04377 	BRA   m125
001570 D7EA       04378 	BRA   m122
                  04379 			;		{
                  04380 			;			case CS_WaitForSTX:
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 74

ADDR   CODE       LINE  SOURCE

                  04381 			;			{
                  04382 			;				if(new_byte == STX) {
001572 0E0F       04383 m123	MOVLW 15
001574 6207       04384 	CPFSEQ new_byte,0
001576 D7E7       04385 	BRA   m122
                  04386 			;					CheckForFwIdentMessage();
001578 DFBE       04387 	RCALL CheckForFwIdentMessage
                  04388 			;					DeleteBuffer();
00157A DFB1       04389 	RCALL DeleteBuffer
                  04390 			;					g_CmdBuf.state = CS_SaveChar;
00157C 0E02       04391 	MOVLW 2
00157E 0102       04392 	MOVLB 2
001580 6F6F       04393 	MOVWF g_CmdBuf+111,1
                  04394 			;				}
                  04395 			;				break;
001582 D7E1       04396 	BRA   m122
                  04397 			;			}
                  04398 			;			case CS_UnMaskChar:
                  04399 			;			{
                  04400 			;				WriteByte(new_byte);
001584 5007       04401 m124	MOVF  new_byte,W,0
001586 DF92       04402 	RCALL WriteByte
                  04403 			;				g_CmdBuf.state = CS_SaveChar;
001588 0E02       04404 	MOVLW 2
00158A 0102       04405 	MOVLB 2
00158C 6F6F       04406 	MOVWF g_CmdBuf+111,1
                  04407 			;				break;
00158E D7DB       04408 	BRA   m122
                  04409 			;			}
                  04410 			;			case CS_SaveChar:
                  04411 			;			{
                  04412 			;				if(new_byte == DLE) {
001590 0E05       04413 m125	MOVLW 5
001592 6207       04414 	CPFSEQ new_byte,0
001594 D004       04415 	BRA   m126
                  04416 			;					g_CmdBuf.state = CS_UnMaskChar;
001596 0E01       04417 	MOVLW 1
001598 0102       04418 	MOVLB 2
00159A 6F6F       04419 	MOVWF g_CmdBuf+111,1
                  04420 			;					break;
00159C D7D4       04421 	BRA   m122
                  04422 			;				}
                  04423 			;				if(new_byte == STX) {
00159E 0E0F       04424 m126	MOVLW 15
0015A0 6207       04425 	CPFSEQ new_byte,0
0015A2 D003       04426 	BRA   m127
                  04427 			;					CheckForFwIdentMessage();
0015A4 DFA8       04428 	RCALL CheckForFwIdentMessage
                  04429 			;					DeleteBuffer();
0015A6 DF9B       04430 	RCALL DeleteBuffer
                  04431 			;					break;
0015A8 D7CE       04432 	BRA   m122
                  04433 			;				}
                  04434 			;				if(new_byte == ETX) {
0015AA 0E04       04435 m127	MOVLW 4
0015AC 6207       04436 	CPFSEQ new_byte,0
0015AE D022       04437 	BRA   m130
                  04438 			;					/* Setup statemachine for new state */
                  04439 			;					g_Odd_STX_Received = FALSE;
0015B0 905F       04440 	BCF   0x5F,g_Odd_STX_Received,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 75

ADDR   CODE       LINE  SOURCE

                  04441 			;					g_CmdBuf.state = CS_WaitForSTX;
0015B2 0102       04442 	MOVLB 2
0015B4 6B6F       04443 	CLRF  g_CmdBuf+111,1
                  04444 			;					
                  04445 			;					/* Set default answer value */
                  04446 			;					ErrorCode mRetValue = BAD_PACKET;
0015B6 0E03       04447 	MOVLW 3
0015B8 6E08       04448 	MOVWF mRetValue,0
                  04449 			;					
                  04450 			;					/* CRC Check */
                  04451 			;					if((0 == g_CmdBuf.CrcL) && (0 == g_CmdBuf.CrcH)) {
0015BA 5371       04452 	MOVF  g_CmdBuf+113,1,1
0015BC A4D8       04453 	BTFSS 0xFD8,Zero_,0
0015BE D00B       04454 	BRA   m128
0015C0 5370       04455 	MOVF  g_CmdBuf+112,1,1
0015C2 A4D8       04456 	BTFSS 0xFD8,Zero_,0
0015C4 D008       04457 	BRA   m128
                  04458 			;						// [0] contains cmd_frame->cmd. Reply this cmd as response to client
                  04459 			;	#ifndef __CC8E__
                  04460 			;						mRetValue = (ErrorCode)ScriptCtrl_Add((struct led_cmd *)&g_CmdBuf.buffer[0]);
                  04461 			;	#else
                  04462 			;						mRetValue = ScriptCtrl_Add(&g_CmdBuf.buffer[0]);
0015C6 6A09       04463 	CLRF  pCmd_3,0
0015C8 EC6E F00F  04464 	CALL  ScriptCtrl_Add
0015CC 6E08       04465 	MOVWF mRetValue,0
                  04466 			;	#endif
                  04467 			;						if(mRetValue == NO_RESPONSE) {
0015CE 0E05       04468 	MOVLW 5
0015D0 6208       04469 	CPFSEQ mRetValue,0
0015D2 D003       04470 	BRA   m129
                  04471 			;							/* do not send a response if client does not want an echo */
                  04472 			;							break;
0015D4 D7B8       04473 	BRA   m122
                  04474 			;						}
                  04475 			;					} else {
                  04476 			;						mRetValue = CRC_CHECK_FAILED;
0015D6 0E02       04477 m128	MOVLW 2
0015D8 6E08       04478 	MOVWF mRetValue,0
                  04479 			;					}
                  04480 			;					/* send response */
                  04481 			;					CommandIO_CreateResponse(&g_ResponseBuf, g_CmdBuf.buffer[0], mRetValue);
0015DA 6A0A       04482 m129	CLRF  mFrame_2,0
0015DC 0E05       04483 	MOVLW 5
0015DE 6E0B       04484 	MOVWF mFrame_2+1,0
0015E0 C200 F00C  04485 	MOVFF g_CmdBuf,cmd
0015E4 C008 F00D  04486 	MOVFF mRetValue,mState
0015E8 D871       04487 	RCALL CommandIO_CreateResponse
                  04488 			;					CommandIO_SendResponse(&g_ResponseBuf);
0015EA 6A0A       04489 	CLRF  mFrame,0
0015EC 0E05       04490 	MOVLW 5
0015EE 6E0B       04491 	MOVWF mFrame+1,0
0015F0 D805       04492 	RCALL CommandIO_SendResponse
                  04493 			;					break;
0015F2 D7A9       04494 	BRA   m122
                  04495 			;				}
                  04496 			;				WriteByte(new_byte);
0015F4 5007       04497 m130	MOVF  new_byte,W,0
0015F6 DF5A       04498 	RCALL WriteByte
                  04499 			;				break;
0015F8 D7A6       04500 	BRA   m122
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 76

ADDR   CODE       LINE  SOURCE

                  04501 			;			}
                  04502 			;		}
                  04503 			;	}
                  04504 			;}
0015FA 0012       04505 m131	RETURN
                  04506 			;
                  04507 			;
                  04508 			;void CommandIO_SendResponse(struct response_frame *mFrame)
                  04509 			;{
                  04510 CommandIO_SendResponse
                  04511 			;	uns8 crcH, crcL, tempByte, *pData;
                  04512 			;	uns16 frameLength;
                  04513 			;
                  04514 			;	frameLength = mFrame->length;
0015FC C00A FFE9  04515 	MOVFF mFrame,FSR0
001600 C00B FFEA  04516 	MOVFF mFrame+1,FSR0+1
001604 CFEE F011  04517 	MOVFF POSTINC0,frameLength
001608 CFEE F012  04518 	MOVFF POSTINC0,frameLength+1
                  04519 			;
                  04520 			;	pData = (uns8 *)mFrame;
00160C C00A F00F  04521 	MOVFF mFrame,pData
001610 C00B F010  04522 	MOVFF mFrame+1,pData+1
                  04523 			;
                  04524 			;	Crc_NewCrc(&crcH, &crcL);
001614 0E0C       04525 	MOVLW 12
001616 6E13       04526 	MOVWF p_crcH_2,0
001618 6A14       04527 	CLRF  p_crcH_2+1,0
00161A 0E0D       04528 	MOVLW 13
00161C 6E15       04529 	MOVWF p_crcL_2,0
00161E 6A16       04530 	CLRF  p_crcL_2+1,0
001620 EC5E F001  04531 	CALL  Crc_NewCrc
                  04532 			;
                  04533 			;	UART_Send(STX);
001624 0E0F       04534 	MOVLW 15
001626 6E13       04535 	MOVWF ch,0
001628 DF3C       04536 	RCALL UART_Send
                  04537 			;
                  04538 			;	while(frameLength > 0)
00162A 5011       04539 m132	MOVF  frameLength,W,0
00162C 1012       04540 	IORWF frameLength+1,W,0
00162E B4D8       04541 	BTFSC 0xFD8,Zero_,0
001630 D028       04542 	BRA   m135
                  04543 			;	{
                  04544 			;		frameLength--;
001632 0611       04545 	DECF  frameLength,1,0
001634 0E00       04546 	MOVLW 0
001636 5A12       04547 	SUBWFB frameLength+1,1,0
                  04548 			;		tempByte = *pData++;
001638 C00F FFE9  04549 	MOVFF pData,FSR0
00163C C010 FFEA  04550 	MOVFF pData+1,FSR0+1
001640 CFEF F00E  04551 	MOVFF INDF0,tempByte
001644 2A0F       04552 	INCF  pData,1,0
001646 0E00       04553 	MOVLW 0
001648 2210       04554 	ADDWFC pData+1,1,0
                  04555 			;		Crc_AddCrc(tempByte, &crcH, &crcL);
00164A C00E F013  04556 	MOVFF tempByte,byte
00164E 0E0C       04557 	MOVLW 12
001650 6E14       04558 	MOVWF p_crcH,0
001652 6A15       04559 	CLRF  p_crcH+1,0
001654 0E0D       04560 	MOVLW 13
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 77

ADDR   CODE       LINE  SOURCE

001656 6E16       04561 	MOVWF p_crcL,0
001658 6A17       04562 	CLRF  p_crcL+1,0
00165A ECFE F000  04563 	CALL  Crc_AddCrc
                  04564 			;		if(tempByte == STX || tempByte == DLE || tempByte == ETX) {
00165E 500E       04565 	MOVF  tempByte,W,0
001660 0A0F       04566 	XORLW 15
001662 B4D8       04567 	BTFSC 0xFD8,Zero_,0
001664 D007       04568 	BRA   m133
001666 500E       04569 	MOVF  tempByte,W,0
001668 0A05       04570 	XORLW 5
00166A B4D8       04571 	BTFSC 0xFD8,Zero_,0
00166C D003       04572 	BRA   m133
00166E 0E04       04573 	MOVLW 4
001670 620E       04574 	CPFSEQ tempByte,0
001672 D003       04575 	BRA   m134
                  04576 			;			UART_Send(DLE);
001674 0E05       04577 m133	MOVLW 5
001676 6E13       04578 	MOVWF ch,0
001678 DF14       04579 	RCALL UART_Send
                  04580 			;		}
                  04581 			;			UART_Send(tempByte);
00167A C00E F013  04582 m134	MOVFF tempByte,ch
00167E DF11       04583 	RCALL UART_Send
                  04584 			;	}
001680 D7D4       04585 	BRA   m132
                  04586 			;	if(crcH == STX || crcH == DLE || crcH == ETX) {
001682 500C       04587 m135	MOVF  crcH_3,W,0
001684 0A0F       04588 	XORLW 15
001686 B4D8       04589 	BTFSC 0xFD8,Zero_,0
001688 D007       04590 	BRA   m136
00168A 500C       04591 	MOVF  crcH_3,W,0
00168C 0A05       04592 	XORLW 5
00168E B4D8       04593 	BTFSC 0xFD8,Zero_,0
001690 D003       04594 	BRA   m136
001692 0E04       04595 	MOVLW 4
001694 620C       04596 	CPFSEQ crcH_3,0
001696 D003       04597 	BRA   m137
                  04598 			;			UART_Send(DLE);
001698 0E05       04599 m136	MOVLW 5
00169A 6E13       04600 	MOVWF ch,0
00169C DF02       04601 	RCALL UART_Send
                  04602 			;	}
                  04603 			;			UART_Send(crcH);
00169E C00C F013  04604 m137	MOVFF crcH_3,ch
0016A2 DEFF       04605 	RCALL UART_Send
                  04606 			;	if(crcL == STX || crcL == DLE || crcL == ETX) {
0016A4 500D       04607 	MOVF  crcL_3,W,0
0016A6 0A0F       04608 	XORLW 15
0016A8 B4D8       04609 	BTFSC 0xFD8,Zero_,0
0016AA D007       04610 	BRA   m138
0016AC 500D       04611 	MOVF  crcL_3,W,0
0016AE 0A05       04612 	XORLW 5
0016B0 B4D8       04613 	BTFSC 0xFD8,Zero_,0
0016B2 D003       04614 	BRA   m138
0016B4 0E04       04615 	MOVLW 4
0016B6 620D       04616 	CPFSEQ crcL_3,0
0016B8 D003       04617 	BRA   m139
                  04618 			;			UART_Send(DLE);
0016BA 0E05       04619 m138	MOVLW 5
0016BC 6E13       04620 	MOVWF ch,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 78

ADDR   CODE       LINE  SOURCE

0016BE DEF1       04621 	RCALL UART_Send
                  04622 			;	}
                  04623 			;			UART_Send(crcL);
0016C0 C00D F013  04624 m139	MOVFF crcL_3,ch
0016C4 DEEE       04625 	RCALL UART_Send
                  04626 			;			UART_Send(ETX);
0016C6 0E04       04627 	MOVLW 4
0016C8 6E13       04628 	MOVWF ch,0
0016CA D6EB       04629 	BRA   UART_Send
                  04630 			;}
                  04631 			;
                  04632 			;#define SPI_LOOPBACK_TESTVALUE 0x54
                  04633 			;
                  04634 			;void CommandIO_CreateResponse(struct response_frame *mFrame, uns8 cmd, ErrorCode mState)
                  04635 			;{
                  04636 CommandIO_CreateResponse
                  04637 			;	mFrame->cmd = cmd;
0016CC 0E02       04638 	MOVLW 2
0016CE 240A       04639 	ADDWF mFrame_2,W,0
0016D0 6EE9       04640 	MOVWF FSR0,0
0016D2 0E00       04641 	MOVLW 0
0016D4 200B       04642 	ADDWFC mFrame_2+1,W,0
0016D6 6EEA       04643 	MOVWF FSR0+1,0
0016D8 C00C FFEF  04644 	MOVFF cmd,INDF0
                  04645 			;	mFrame->state = mState;
0016DC 0E03       04646 	MOVLW 3
0016DE 240A       04647 	ADDWF mFrame_2,W,0
0016E0 6EE9       04648 	MOVWF FSR0,0
0016E2 0E00       04649 	MOVLW 0
0016E4 200B       04650 	ADDWFC mFrame_2+1,W,0
0016E6 6EEA       04651 	MOVWF FSR0+1,0
0016E8 C00D FFEF  04652 	MOVFF mState,INDF0
                  04653 			;	mFrame->length = sizeof(uns8) + sizeof(ErrorCode) + sizeof(uns16);
0016EC C00A FFE9  04654 	MOVFF mFrame_2,FSR0
0016F0 C00B FFEA  04655 	MOVFF mFrame_2+1,FSR0+1
0016F4 0E04       04656 	MOVLW 4
0016F6 6EEE       04657 	MOVWF POSTINC0,0
0016F8 6AEF       04658 	CLRF  INDF0,0
                  04659 			;	switch(cmd) {
0016FA 500C       04660 	MOVF  cmd,W,0
0016FC 0AF3       04661 	XORLW 243
0016FE B4D8       04662 	BTFSC 0xFD8,Zero_,0
001700 D00D       04663 	BRA   m140
001702 0A03       04664 	XORLW 3
001704 B4D8       04665 	BTFSC 0xFD8,Zero_,0
001706 D01C       04666 	BRA   m141
001708 0A1E       04667 	XORLW 30
00170A B4D8       04668 	BTFSC 0xFD8,Zero_,0
00170C D02C       04669 	BRA   m142
00170E 0A03       04670 	XORLW 3
001710 B4D8       04671 	BTFSC 0xFD8,Zero_,0
001712 D03D       04672 	BRA   m143
001714 0A06       04673 	XORLW 6
001716 B4D8       04674 	BTFSC 0xFD8,Zero_,0
001718 D053       04675 	BRA   m144
00171A D06F       04676 	BRA   m147
                  04677 			;	case GET_RTC:
                  04678 			;	{
                  04679 			;		Rtc_Ctl(RTC_RD_TIME, &mFrame->data.time);
00171C 0E01       04680 m140	MOVLW 1
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 79

ADDR   CODE       LINE  SOURCE

00171E 6E0E       04681 	MOVWF req,0
001720 0E04       04682 	MOVLW 4
001722 240A       04683 	ADDWF mFrame_2,W,0
001724 6E0F       04684 	MOVWF pRtcTime,0
001726 0E00       04685 	MOVLW 0
001728 200B       04686 	ADDWFC mFrame_2+1,W,0
00172A 6E10       04687 	MOVWF pRtcTime+1,0
00172C D930       04688 	RCALL Rtc_Ctl
                  04689 			;		mFrame->length += sizeof(struct rtc_time);
00172E C00A FFE9  04690 	MOVFF mFrame_2,FSR0
001732 C00B FFEA  04691 	MOVFF mFrame_2+1,FSR0+1
001736 0E07       04692 	MOVLW 7
001738 26EE       04693 	ADDWF POSTINC0,1,0
00173A 0E00       04694 	MOVLW 0
00173C 22EF       04695 	ADDWFC INDF0,1,0
                  04696 			;		break;
00173E D05D       04697 	BRA   m147
                  04698 			;	};
                  04699 			;	case GET_CYCLETIME:
                  04700 			;	{
                  04701 			;		uns8 bytesPrint = Timer_PrintCycletime(&(mFrame->data.max_cycle_times[0]), sizeof(struct response_frame) - 4);
001740 0E04       04702 m141	MOVLW 4
001742 240A       04703 	ADDWF mFrame_2,W,0
001744 6E0F       04704 	MOVWF pArray,0
001746 0E00       04705 	MOVLW 0
001748 200B       04706 	ADDWFC mFrame_2+1,W,0
00174A 6E10       04707 	MOVWF pArray+1,0
00174C 6811       04708 	SETF  arraySize,0
00174E 6A12       04709 	CLRF  arraySize+1,0
001750 DDDA       04710 	RCALL Timer_PrintCycletime
001752 6E0E       04711 	MOVWF bytesPrint,0
                  04712 			;		mFrame->length += bytesPrint;
001754 C00A FFE9  04713 	MOVFF mFrame_2,FSR0
001758 C00B FFEA  04714 	MOVFF mFrame_2+1,FSR0+1
00175C 500E       04715 	MOVF  bytesPrint,W,0
00175E 26EE       04716 	ADDWF POSTINC0,1,0
001760 0E00       04717 	MOVLW 0
001762 22EF       04718 	ADDWFC INDF0,1,0
                  04719 			;		break;
001764 D04A       04720 	BRA   m147
                  04721 			;	};
                  04722 			;	case GET_TRACE:
                  04723 			;	{
                  04724 			;		uns8 bytesPrint = Trace_Print(&(mFrame->data.trace_string[0]), sizeof(struct response_frame) - 4);
001766 0E04       04725 m142	MOVLW 4
001768 240A       04726 	ADDWF mFrame_2,W,0
00176A 6E0F       04727 	MOVWF pArray_2,0
00176C 0E00       04728 	MOVLW 0
00176E 200B       04729 	ADDWFC mFrame_2+1,W,0
001770 6E10       04730 	MOVWF pArray_2+1,0
001772 6811       04731 	SETF  arraySize_2,0
001774 6A12       04732 	CLRF  arraySize_2+1,0
001776 EC52 F012  04733 	CALL  Trace_Print
00177A 6E0E       04734 	MOVWF bytesPrint_2,0
                  04735 			;		mFrame->length += bytesPrint;
00177C C00A FFE9  04736 	MOVFF mFrame_2,FSR0
001780 C00B FFEA  04737 	MOVFF mFrame_2+1,FSR0+1
001784 500E       04738 	MOVF  bytesPrint_2,W,0
001786 26EE       04739 	ADDWF POSTINC0,1,0
001788 0E00       04740 	MOVLW 0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 80

ADDR   CODE       LINE  SOURCE

00178A 22EF       04741 	ADDWFC INDF0,1,0
                  04742 			;		break;
00178C D036       04743 	BRA   m147
                  04744 			;	};
                  04745 			;	case GET_FW_VERSION:
                  04746 			;	{
                  04747 			;		uns16 tempVersion = Version_Print();
00178E EC73 F013  04748 m143	CALL  Version_Print
001792 C010 F00E  04749 	MOVFF C1tmp,tempVersion
001796 C011 F00F  04750 	MOVFF C1tmp+1,tempVersion+1
                  04751 			;		mFrame->data.versionData = tempVersion;
00179A 0E04       04752 	MOVLW 4
00179C 240A       04753 	ADDWF mFrame_2,W,0
00179E 6EE9       04754 	MOVWF FSR0,0
0017A0 0E00       04755 	MOVLW 0
0017A2 200B       04756 	ADDWFC mFrame_2+1,W,0
0017A4 6EEA       04757 	MOVWF FSR0+1,0
0017A6 C00E FFEE  04758 	MOVFF tempVersion,POSTINC0
0017AA C00F FFEE  04759 	MOVFF tempVersion+1,POSTINC0
                  04760 			;		mFrame->length += sizeof(uns16);
0017AE C00A FFE9  04761 	MOVFF mFrame_2,FSR0
0017B2 C00B FFEA  04762 	MOVFF mFrame_2+1,FSR0+1
0017B6 0E02       04763 	MOVLW 2
0017B8 26EE       04764 	ADDWF POSTINC0,1,0
0017BA 0E00       04765 	MOVLW 0
0017BC 22EF       04766 	ADDWFC INDF0,1,0
                  04767 			;		break;
0017BE D01D       04768 	BRA   m147
                  04769 			;	}
                  04770 			;	case GET_LED_TYP:
                  04771 			;	{
                  04772 			;		if (SPI_LOOPBACK_TESTVALUE == SPI_Send(SPI_LOOPBACK_TESTVALUE)) {
0017C0 0E54       04773 m144	MOVLW 84
0017C2 6E0E       04774 	MOVWF data_4,0
0017C4 DD17       04775 	RCALL SPI_Send
0017C6 0A54       04776 	XORLW 84
0017C8 A4D8       04777 	BTFSS 0xFD8,Zero_,0
0017CA D009       04778 	BRA   m145
                  04779 			;			mFrame->data.ledTyp = LED_TYP_WS2801;
0017CC 0E04       04780 	MOVLW 4
0017CE 240A       04781 	ADDWF mFrame_2,W,0
0017D0 6EE9       04782 	MOVWF FSR0,0
0017D2 0E00       04783 	MOVLW 0
0017D4 200B       04784 	ADDWFC mFrame_2+1,W,0
0017D6 6EEA       04785 	MOVWF FSR0+1,0
0017D8 0E01       04786 	MOVLW 1
0017DA 6EEF       04787 	MOVWF INDF0,0
                  04788 			;		} else {
0017DC D007       04789 	BRA   m146
                  04790 			;			mFrame->data.ledTyp = LED_TYP_RGB;
0017DE 0E04       04791 m145	MOVLW 4
0017E0 240A       04792 	ADDWF mFrame_2,W,0
0017E2 6EE9       04793 	MOVWF FSR0,0
0017E4 0E00       04794 	MOVLW 0
0017E6 200B       04795 	ADDWFC mFrame_2+1,W,0
0017E8 6EEA       04796 	MOVWF FSR0+1,0
0017EA 6AEF       04797 	CLRF  INDF0,0
                  04798 			;		}
                  04799 			;		mFrame->length += sizeof(uns8);
0017EC C00A FFE9  04800 m146	MOVFF mFrame_2,FSR0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 81

ADDR   CODE       LINE  SOURCE

0017F0 C00B FFEA  04801 	MOVFF mFrame_2+1,FSR0+1
0017F4 2AEE       04802 	INCF  POSTINC0,1,0
0017F6 0E00       04803 	MOVLW 0
0017F8 22EF       04804 	ADDWFC INDF0,1,0
                  04805 			;		break;
                  04806 			;	}
                  04807 			;	default:
                  04808 			;		break;
                  04809 			;	}
                  04810 			;}
0017FA 0012       04811 m147	RETURN
                  04812 
                  04813   ; FILE ./firmware\platform.c
                  04814 			;/**
                  04815 			; Copyright (C) 2012 Nils Weiss, Patrick BrÃ¼nn.
                  04816 			;
                  04817 			; This file is part of Wifly_Light.
                  04818 			;
                  04819 			; Wifly_Light is free software: you can redistribute it and/or modify
                  04820 			; it under the terms of the GNU General Public License as published by
                  04821 			; the Free Software Foundation, either version 3 of the License, or
                  04822 			; (at your option) any later version.
                  04823 			;
                  04824 			; Wifly_Light is distributed in the hope that it will be useful,
                  04825 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  04826 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  04827 			; GNU General Public License for more details.
                  04828 			;
                  04829 			; You should have received a copy of the GNU General Public License
                  04830 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  04831 			;
                  04832 			;#include "platform.h"
                  04833 			;//#include "ScriptCtrl.h"
                  04834 			;#include "ledstrip.h"
                  04835 			;
                  04836 			;#ifdef __CC8E__
                  04837 			;void Platform_CheckInputs()
                  04838 			;{
                  04839 Platform_CheckInputs
                  04840 			;	static uns8 lastSwitchState;
                  04841 			;	if(PORTB .5 == 0) {
0017FC BA81       04842 	BTFSC PORTB,5,0
0017FE D004       04843 	BRA   m148
                  04844 			;		lastSwitchState = 1;
001800 0E01       04845 	MOVLW 1
001802 0100       04846 	MOVLB 0
001804 6F76       04847 	MOVWF lastSwitchState,1
                  04848 			;		return;
001806 0012       04849 	RETURN
                  04850 			;	}
                  04851 			;	if(PORTB .5 == 1) {
001808 AA81       04852 m148	BTFSS PORTB,5,0
00180A D00E       04853 	BRA   m151
                  04854 			;		if(lastSwitchState == 1) {
00180C 0100       04855 	MOVLB 0
00180E 2D76       04856 	DECFSZ lastSwitchState,W,1
001810 D009       04857 	BRA   m150
                  04858 			;			if(gScriptBuf.isRunning) {
001812 A16B       04859 	BTFSS gScriptBuf+11,0,1
001814 D005       04860 	BRA   m149
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 82

ADDR   CODE       LINE  SOURCE

                  04861 			;				Ledstrip_FadeOffLeds();
001816 EC01 F002  04862 	CALL  Ledstrip_FadeOffLeds
                  04863 			;				gScriptBuf.isRunning = FALSE;
00181A 0100       04864 	MOVLB 0
00181C 916B       04865 	BCF   gScriptBuf+11,0,1
                  04866 			;			} else
00181E D002       04867 	BRA   m150
                  04868 			;				gScriptBuf.isRunning = TRUE;
001820 0100       04869 m149	MOVLB 0
001822 816B       04870 	BSF   gScriptBuf+11,0,1
                  04871 			;
                  04872 			;		}
                  04873 			;		lastSwitchState = 0;
001824 0100       04874 m150	MOVLB 0
001826 6B76       04875 	CLRF  lastSwitchState,1
                  04876 			;	}
                  04877 			;	/*
                  04878 			;	//Goto Bootloader if PORTB.0 is low
                  04879 			;	if(PORTB.5 == 0)
                  04880 			;	{
                  04881 			;	        softReset();
                  04882 			;	}*/
                  04883 			;}
001828 0012       04884 m151	RETURN
                  04885 			;
                  04886 			;void Platform_AllowInterrupts()
                  04887 			;{
                  04888 Platform_AllowInterrupts
                  04889 			;	IPEN = 1;
00182A 8ED0       04890 	BSF   0xFD0,IPEN,0
                  04891 			;	TMR1IP = 0;
00182C 909F       04892 	BCF   0xF9F,TMR1IP,0
                  04893 			;	TMR2IP = 0;
00182E 929F       04894 	BCF   0xF9F,TMR2IP,0
                  04895 			;	TMR3IP = 0;
001830 92A2       04896 	BCF   0xFA2,TMR3IP,0
                  04897 			;	TMR4IP = 0;
001832 907F       04898 	BCF   0xF7F,TMR4IP,0
                  04899 			;	TMR5IP = 0;
001834 927F       04900 	BCF   0xF7F,TMR5IP,0
                  04901 			;	RC1IP = 1;
001836 8A9F       04902 	BSF   0xF9F,RC1IP,0
                  04903 			;	RC1IE = 1;
001838 8A9D       04904 	BSF   0xF9D,RC1IE,0
                  04905 			;	PEIE = 1;
00183A 8CF2       04906 	BSF   0xFF2,PEIE,0
                  04907 			;	GIEL = 1;
00183C 8CF2       04908 	BSF   0xFF2,GIEL,0
                  04909 			;	GIEH = 1;
00183E 8EF2       04910 	BSF   0xFF2,GIEH,0
                  04911 			;}
001840 0012       04912 	RETURN
                  04913 			;
                  04914 			;void Platform_EnableAllInterrupts()
                  04915 			;{
                  04916 Platform_EnableAllInterrupts
                  04917 			;	GIEL = 1;
001842 8CF2       04918 	BSF   0xFF2,GIEL,0
                  04919 			;	GIEH = 1;
001844 8EF2       04920 	BSF   0xFF2,GIEH,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 83

ADDR   CODE       LINE  SOURCE

                  04921 			;}
001846 0012       04922 	RETURN
                  04923 			;/*
                  04924 			;void Platform_DisableAllInterrupts()
                  04925 			;{
                  04926 			;        GIEL = 0;
                  04927 			;        GIEH = 0;
                  04928 			;}*/
                  04929 			;
                  04930 			;void Platform_DisableBootloaderAutostart()
                  04931 			;{
                  04932 Platform_DisableBootloaderAutostart
                  04933 			;	Eeprom_Write(0x3ff, 1);
001848 681A       04934 	SETF  adress,0
00184A 0E03       04935 	MOVLW 3
00184C 6E1B       04936 	MOVWF adress+1,0
00184E 0E01       04937 	MOVLW 1
001850 6E1C       04938 	MOVWF data_2,0
001852 EF71 F001  04939 	GOTO  Eeprom_Write
                  04940 			;}
                  04941 			;
                  04942 			;void Platform_EnableBootloaderAutostart()
                  04943 			;{
                  04944 Platform_EnableBootloaderAutostart
                  04945 			;	Eeprom_Write(0x3ff, 0xff);
001856 681A       04946 	SETF  adress,0
001858 0E03       04947 	MOVLW 3
00185A 6E1B       04948 	MOVWF adress+1,0
00185C 681C       04949 	SETF  data_2,0
00185E EF71 F001  04950 	GOTO  Eeprom_Write
                  04951 			;}
                  04952 			;
                  04953 			;uns16 htons(uns16 hostShort)
                  04954 			;{
                  04955 htons
                  04956 			;	uns16 retval;
                  04957 			;	retval.low8 = hostShort.high8;
001862 C018 F019  04958 	MOVFF hostShort+1,retval
                  04959 			;	retval.high8 = hostShort.low8;
001866 C017 F01A  04960 	MOVFF hostShort,retval+1
                  04961 			;	return retval;
00186A 5019       04962 	MOVF  retval,W,0
00186C 0012       04963 	RETURN
                  04964 			;}
                  04965 			;
                  04966 			;uns16 ntohs(uns16 networkShort)
                  04967 			;{
                  04968 ntohs
                  04969 			;	uns16 retval;
                  04970 			;	retval.low8 = networkShort.high8;
00186E C01F F020  04971 	MOVFF networkShort+1,retval_2
                  04972 			;	retval.high8 = networkShort.low8;
001872 C01E F021  04973 	MOVFF networkShort,retval_2+1
                  04974 			;	return retval;
001876 5020       04975 	MOVF  retval_2,W,0
001878 0012       04976 	RETURN
                  04977 
                  04978   ; FILE ./firmware\rtc.c
                  04979 			;/**
                  04980 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 84

ADDR   CODE       LINE  SOURCE

                  04981 			;
                  04982 			; This file is part of Wifly_Light.
                  04983 			;
                  04984 			; Wifly_Light is free software: you can redistribute it and/or modify
                  04985 			; it under the terms of the GNU General Public License as published by
                  04986 			; the Free Software Foundation, either version 3 of the License, or
                  04987 			; (at your option) any later version.
                  04988 			;
                  04989 			; Wifly_Light is distributed in the hope that it will be useful,
                  04990 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  04991 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  04992 			; GNU General Public License for more details.
                  04993 			;
                  04994 			; You should have received a copy of the GNU General Public License
                  04995 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  04996 			;
                  04997 			;#include "rtc.h"
                  04998 			;#include "iic.h"
                  04999 			;#include "trace.h"
                  05000 			;#ifdef __CC8E__
                  05001 			;#include "INLINE.H"
                  05002 			;#endif
                  05003 			;
                  05004 			;//*********************** PRIVATE FUNCTIONS *********************************************
                  05005 			;
                  05006 			;uns8 BcdToBin(uns8 BcdValue)
                  05007 			;{
                  05008 BcdToBin
00187A 6E12       05009 	MOVWF BcdValue,0
                  05010 			;	uns8 retValue = 0x00;
00187C 6A13       05011 	CLRF  retValue,0
                  05012 			;
                  05013 			;	retValue = BcdValue & 0x0f;
00187E 0E0F       05014 	MOVLW 15
001880 1412       05015 	ANDWF BcdValue,W,0
001882 6E13       05016 	MOVWF retValue,0
                  05017 			;	BcdValue = BcdValue >> 4;
001884 3812       05018 	SWAPF BcdValue,W,0
001886 0B0F       05019 	ANDLW 15
001888 6E12       05020 	MOVWF BcdValue,0
                  05021 			;	BcdValue = BcdValue * 0x0a;
00188A C012 F01E  05022 	MOVFF BcdValue,arg1
00188E 0E0A       05023 	MOVLW 10
001890 ECE0 F001  05024 	CALL  _mult8x8
001894 C020 F012  05025 	MOVFF rval,BcdValue
                  05026 			;
                  05027 			;	return retValue + BcdValue;
001898 5012       05028 	MOVF  BcdValue,W,0
00189A 2413       05029 	ADDWF retValue,W,0
00189C 0012       05030 	RETURN
                  05031 			;}
                  05032 			;
                  05033 			;uns8 BinToBcd(uns8 BinValue)
                  05034 			;{
                  05035 BinToBcd
00189E 6E12       05036 	MOVWF BinValue,0
                  05037 			;	uns8 onesValue, tensValue, tempValue;
                  05038 			;
                  05039 			;	onesValue = 0x00;
0018A0 6A13       05040 	CLRF  onesValue,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 85

ADDR   CODE       LINE  SOURCE

                  05041 			;	tensValue = 0x00;
0018A2 6A14       05042 	CLRF  tensValue,0
                  05043 			;
                  05044 			;	if(BinValue > 9) {
0018A4 0E09       05045 	MOVLW 9
0018A6 6412       05046 	CPFSGT BinValue,0
0018A8 D011       05047 	BRA   m152
                  05048 			;		tensValue = BinValue / 0x0a;
0018AA C012 F01E  05049 	MOVFF BinValue,arg1_5
0018AE 6A1F       05050 	CLRF  arg1_5+1,0
0018B0 0E0A       05051 	MOVLW 10
0018B2 ECEE F001  05052 	CALL  _divU16_8
0018B6 C01E F014  05053 	MOVFF arg1_5,tensValue
                  05054 			;		tempValue = tensValue * 10;
0018BA C014 F01E  05055 	MOVFF tensValue,arg1
0018BE 0E0A       05056 	MOVLW 10
0018C0 ECE0 F001  05057 	CALL  _mult8x8
0018C4 C020 F015  05058 	MOVFF rval,tempValue
                  05059 			;		BinValue -= tempValue;
0018C8 5015       05060 	MOVF  tempValue,W,0
0018CA 5E12       05061 	SUBWF BinValue,1,0
                  05062 			;	}
                  05063 			;	onesValue = BinValue;
0018CC C012 F013  05064 m152	MOVFF BinValue,onesValue
                  05065 			;	tensValue = tensValue << 4;
0018D0 3814       05066 	SWAPF tensValue,W,0
0018D2 0BF0       05067 	ANDLW 240
0018D4 6E14       05068 	MOVWF tensValue,0
                  05069 			;
                  05070 			;	return tensValue + onesValue;
0018D6 5013       05071 	MOVF  onesValue,W,0
0018D8 2414       05072 	ADDWF tensValue,W,0
0018DA 0012       05073 	RETURN
                  05074 			;}
                  05075 			;
                  05076 			;//*********************** PUBLIC FUNCTIONS *********************************************
                  05077 			;
                  05078 			;
                  05079 			;struct rtc_time g_RtcTime;
                  05080 			;uns8 g_RtcAdress;
                  05081 			;
                  05082 			;void Rtc_Init(void)
                  05083 			;{
                  05084 Rtc_Init
                  05085 			;	I2C_Init();
0018DC DA34       05086 	RCALL I2C_Init
                  05087 			;	
                  05088 			;	if (I2C_DetectSlave(RTC_MCP79410)) {
0018DE 0EDE       05089 	MOVLW 222
0018E0 6E07       05090 	MOVWF slaveaddr_5,0
0018E2 DAE7       05091 	RCALL I2C_DetectSlave
0018E4 0A00       05092 	XORLW 0
0018E6 B4D8       05093 	BTFSC 0xFD8,Zero_,0
0018E8 D007       05094 	BRA   m153
                  05095 			;		Trace_String(" 79410 detected ");
0018EA 0E18       05096 	MOVLW 24
0018EC 6E12       05097 	MOVWF string,0
0018EE ECBE F011  05098 	CALL  Trace_String
                  05099 			;		g_RtcAdress = RTC_MCP79410;
0018F2 0EDE       05100 	MOVLW 222
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 86

ADDR   CODE       LINE  SOURCE

0018F4 6E2B       05101 	MOVWF g_RtcAdress,0
                  05102 			;	} else if (I2C_DetectSlave(RTC_8564JE)) {
0018F6 D012       05103 	BRA   m155
0018F8 0EA2       05104 m153	MOVLW 162
0018FA 6E07       05105 	MOVWF slaveaddr_5,0
0018FC DADA       05106 	RCALL I2C_DetectSlave
0018FE 0A00       05107 	XORLW 0
001900 B4D8       05108 	BTFSC 0xFD8,Zero_,0
001902 D007       05109 	BRA   m154
                  05110 			;		Trace_String(" 8564JE detected");
001904 0E29       05111 	MOVLW 41
001906 6E12       05112 	MOVWF string,0
001908 ECBE F011  05113 	CALL  Trace_String
                  05114 			;		g_RtcAdress = RTC_8564JE;
00190C 0EA2       05115 	MOVLW 162
00190E 6E2B       05116 	MOVWF g_RtcAdress,0
                  05117 			;	} else {
001910 D005       05118 	BRA   m155
                  05119 			;		Trace_String(" NO RTC detected");
001912 0E3A       05120 m154	MOVLW 58
001914 6E12       05121 	MOVWF string,0
001916 ECBE F011  05122 	CALL  Trace_String
                  05123 			;		g_RtcAdress = 0x00;
00191A 6A2B       05124 	CLRF  g_RtcAdress,0
                  05125 			;	}
                  05126 			;	
                  05127 			;	if (g_RtcAdress == RTC_MCP79410) {
00191C 0EDE       05128 m155	MOVLW 222
00191E 622B       05129 	CPFSEQ g_RtcAdress,0
001920 D027       05130 	BRA   m156
                  05131 			;		uns8 temp;
                  05132 			;		//set ST bit in RTC 0x00
                  05133 			;		//set EXTOSC bit in RTC 0x00
                  05134 			;		temp = I2C_Read(g_RtcAdress, 0x00);
001922 C02B F012  05135 	MOVFF g_RtcAdress,slaveaddr_4
001926 6A13       05136 	CLRF  readaddr_2,0
001928 DA96       05137 	RCALL I2C_Read
00192A 6E07       05138 	MOVWF temp_3,0
                  05139 			;		I2C_Write(g_RtcAdress, 0x00, temp | 0b10001000);
00192C C02B F012  05140 	MOVFF g_RtcAdress,slaveaddr
001930 6A13       05141 	CLRF  dataaddr,0
001932 0E88       05142 	MOVLW 136
001934 1007       05143 	IORWF temp_3,W,0
001936 6E14       05144 	MOVWF data_5,0
001938 DA0F       05145 	RCALL I2C_Write
                  05146 			;		//set enable Battery bit in RTC 0x03
                  05147 			;		temp = I2C_Read(g_RtcAdress, 0x03);
00193A C02B F012  05148 	MOVFF g_RtcAdress,slaveaddr_4
00193E 0E03       05149 	MOVLW 3
001940 6E13       05150 	MOVWF readaddr_2,0
001942 DA89       05151 	RCALL I2C_Read
001944 6E07       05152 	MOVWF temp_3,0
                  05153 			;		I2C_Write(g_RtcAdress, 0x03, temp | 0b00001000);
001946 C02B F012  05154 	MOVFF g_RtcAdress,slaveaddr
00194A 0E03       05155 	MOVLW 3
00194C 6E13       05156 	MOVWF dataaddr,0
00194E 0E08       05157 	MOVLW 8
001950 1007       05158 	IORWF temp_3,W,0
001952 6E14       05159 	MOVWF data_5,0
001954 DA01       05160 	RCALL I2C_Write
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 87

ADDR   CODE       LINE  SOURCE

                  05161 			;		
                  05162 			;		//print statusregister
                  05163 			;		Trace_String(" RTC 03:");
001956 0E4B       05164 	MOVLW 75
001958 6E12       05165 	MOVWF string,0
00195A ECBE F011  05166 	CALL  Trace_String
                  05167 			;		Trace_Hex(I2C_Read(g_RtcAdress, 0x03));
00195E C02B F012  05168 	MOVFF g_RtcAdress,slaveaddr_4
001962 0E03       05169 	MOVLW 3
001964 6E13       05170 	MOVWF readaddr_2,0
001966 DA77       05171 	RCALL I2C_Read
001968 6E08       05172 	MOVWF input_3,0
00196A EC1F F012  05173 	CALL  Trace_Hex
                  05174 			;	} else if (g_RtcAdress == RTC_8564JE) {
00196E D00E       05175 	BRA   m157
001970 0EA2       05176 m156	MOVLW 162
001972 622B       05177 	CPFSEQ g_RtcAdress,0
001974 D00B       05178 	BRA   m157
                  05179 			;		I2C_Write(g_RtcAdress,0x00,0x00);       //Make sure that the TEST-Bits in the RTC-Device are set to zero
001976 C02B F012  05180 	MOVFF g_RtcAdress,slaveaddr
00197A 6A13       05181 	CLRF  dataaddr,0
00197C 6A14       05182 	CLRF  data_5,0
00197E D9EC       05183 	RCALL I2C_Write
                  05184 			;		I2C_Write(g_RtcAdress,0x01,0x00);       //Disable Interrupts in the RTC-Device
001980 C02B F012  05185 	MOVFF g_RtcAdress,slaveaddr
001984 0E01       05186 	MOVLW 1
001986 6E13       05187 	MOVWF dataaddr,0
001988 6A14       05188 	CLRF  data_5,0
00198A D1E6       05189 	BRA   I2C_Write
                  05190 			;	}
                  05191 			;	
                  05192 			;	
                  05193 			;
                  05194 			;}
00198C 0012       05195 m157	RETURN
                  05196 			;
                  05197 			;void Rtc_Ctl(enum RTC_request req,struct rtc_time *pRtcTime)
                  05198 			;{
                  05199 Rtc_Ctl
                  05200 			;	uns8 temp;
                  05201 			;	switch(req)
00198E 500E       05202 	MOVF  req,W,0
001990 0A01       05203 	XORLW 1
001992 B4D8       05204 	BTFSC 0xFD8,Zero_,0
001994 D004       05205 	BRA   m158
001996 0A01       05206 	XORLW 1
001998 B4D8       05207 	BTFSC 0xFD8,Zero_,0
00199A D0E9       05208 	BRA   m161
00199C D1D3       05209 	BRA   m164
                  05210 			;	{
                  05211 			;	case RTC_RD_TIME:
                  05212 			;	{
                  05213 			;		if (g_RtcAdress == RTC_MCP79410) {
00199E 0EDE       05214 m158	MOVLW 222
0019A0 622B       05215 	CPFSEQ g_RtcAdress,0
0019A2 D06E       05216 	BRA   m159
                  05217 			;			
                  05218 			;			temp = BcdToBin( I2C_Read(g_RtcAdress, 0x00) & 0b01111111);
0019A4 C02B F012  05219 	MOVFF g_RtcAdress,slaveaddr_4
0019A8 6A13       05220 	CLRF  readaddr_2,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 88

ADDR   CODE       LINE  SOURCE

0019AA DA55       05221 	RCALL I2C_Read
0019AC 0B7F       05222 	ANDLW 127
0019AE DF65       05223 	RCALL BcdToBin
0019B0 6E11       05224 	MOVWF temp_4,0
                  05225 			;			pRtcTime->tm_sec = temp;
0019B2 C00F FFE9  05226 	MOVFF pRtcTime,FSR0
0019B6 C010 FFEA  05227 	MOVFF pRtcTime+1,FSR0+1
0019BA C011 FFEF  05228 	MOVFF temp_4,INDF0
                  05229 			;			temp = BcdToBin( I2C_Read(g_RtcAdress, 0x01) & 0b01111111);
0019BE C02B F012  05230 	MOVFF g_RtcAdress,slaveaddr_4
0019C2 0E01       05231 	MOVLW 1
0019C4 6E13       05232 	MOVWF readaddr_2,0
0019C6 DA47       05233 	RCALL I2C_Read
0019C8 0B7F       05234 	ANDLW 127
0019CA DF57       05235 	RCALL BcdToBin
0019CC 6E11       05236 	MOVWF temp_4,0
                  05237 			;			pRtcTime->tm_min = temp;
0019CE 280F       05238 	INCF  pRtcTime,W,0
0019D0 6EE9       05239 	MOVWF FSR0,0
0019D2 0E00       05240 	MOVLW 0
0019D4 2010       05241 	ADDWFC pRtcTime+1,W,0
0019D6 6EEA       05242 	MOVWF FSR0+1,0
0019D8 C011 FFEF  05243 	MOVFF temp_4,INDF0
                  05244 			;			temp = BcdToBin( I2C_Read(g_RtcAdress, 0x02) & 0b00111111);
0019DC C02B F012  05245 	MOVFF g_RtcAdress,slaveaddr_4
0019E0 0E02       05246 	MOVLW 2
0019E2 6E13       05247 	MOVWF readaddr_2,0
0019E4 DA38       05248 	RCALL I2C_Read
0019E6 0B3F       05249 	ANDLW 63
0019E8 DF48       05250 	RCALL BcdToBin
0019EA 6E11       05251 	MOVWF temp_4,0
                  05252 			;			pRtcTime->tm_hour = temp;
0019EC 0E02       05253 	MOVLW 2
0019EE 240F       05254 	ADDWF pRtcTime,W,0
0019F0 6EE9       05255 	MOVWF FSR0,0
0019F2 0E00       05256 	MOVLW 0
0019F4 2010       05257 	ADDWFC pRtcTime+1,W,0
0019F6 6EEA       05258 	MOVWF FSR0+1,0
0019F8 C011 FFEF  05259 	MOVFF temp_4,INDF0
                  05260 			;			temp = BcdToBin( I2C_Read(g_RtcAdress, 0x04) & 0b00111111);
0019FC C02B F012  05261 	MOVFF g_RtcAdress,slaveaddr_4
001A00 0E04       05262 	MOVLW 4
001A02 6E13       05263 	MOVWF readaddr_2,0
001A04 DA28       05264 	RCALL I2C_Read
001A06 0B3F       05265 	ANDLW 63
001A08 DF38       05266 	RCALL BcdToBin
001A0A 6E11       05267 	MOVWF temp_4,0
                  05268 			;			pRtcTime->tm_mday = temp;
001A0C 0E03       05269 	MOVLW 3
001A0E 240F       05270 	ADDWF pRtcTime,W,0
001A10 6EE9       05271 	MOVWF FSR0,0
001A12 0E00       05272 	MOVLW 0
001A14 2010       05273 	ADDWFC pRtcTime+1,W,0
001A16 6EEA       05274 	MOVWF FSR0+1,0
001A18 C011 FFEF  05275 	MOVFF temp_4,INDF0
                  05276 			;			temp = BcdToBin( I2C_Read(g_RtcAdress, 0x03) & 0b00000111);
001A1C C02B F012  05277 	MOVFF g_RtcAdress,slaveaddr_4
001A20 0E03       05278 	MOVLW 3
001A22 6E13       05279 	MOVWF readaddr_2,0
001A24 DA18       05280 	RCALL I2C_Read
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 89

ADDR   CODE       LINE  SOURCE

001A26 0B07       05281 	ANDLW 7
001A28 DF28       05282 	RCALL BcdToBin
001A2A 6E11       05283 	MOVWF temp_4,0
                  05284 			;			pRtcTime->tm_wday = temp;
001A2C 0E06       05285 	MOVLW 6
001A2E 240F       05286 	ADDWF pRtcTime,W,0
001A30 6EE9       05287 	MOVWF FSR0,0
001A32 0E00       05288 	MOVLW 0
001A34 2010       05289 	ADDWFC pRtcTime+1,W,0
001A36 6EEA       05290 	MOVWF FSR0+1,0
001A38 C011 FFEF  05291 	MOVFF temp_4,INDF0
                  05292 			;			temp = BcdToBin( I2C_Read(g_RtcAdress, 0x05) & 0b00011111);
001A3C C02B F012  05293 	MOVFF g_RtcAdress,slaveaddr_4
001A40 0E05       05294 	MOVLW 5
001A42 6E13       05295 	MOVWF readaddr_2,0
001A44 DA08       05296 	RCALL I2C_Read
001A46 0B1F       05297 	ANDLW 31
001A48 DF18       05298 	RCALL BcdToBin
001A4A 6E11       05299 	MOVWF temp_4,0
                  05300 			;			temp -= 1;
001A4C 0611       05301 	DECF  temp_4,1,0
                  05302 			;			pRtcTime->tm_mon = temp;
001A4E 0E04       05303 	MOVLW 4
001A50 240F       05304 	ADDWF pRtcTime,W,0
001A52 6EE9       05305 	MOVWF FSR0,0
001A54 0E00       05306 	MOVLW 0
001A56 2010       05307 	ADDWFC pRtcTime+1,W,0
001A58 6EEA       05308 	MOVWF FSR0+1,0
001A5A C011 FFEF  05309 	MOVFF temp_4,INDF0
                  05310 			;			temp = BcdToBin( I2C_Read(g_RtcAdress, 0x06) & 0b11111111);
001A5E C02B F012  05311 	MOVFF g_RtcAdress,slaveaddr_4
001A62 0E06       05312 	MOVLW 6
001A64 6E13       05313 	MOVWF readaddr_2,0
001A66 D9F7       05314 	RCALL I2C_Read
001A68 0BFF       05315 	ANDLW 255
001A6A DF07       05316 	RCALL BcdToBin
001A6C 6E11       05317 	MOVWF temp_4,0
                  05318 			;			pRtcTime->tm_year = temp;
001A6E 0E05       05319 	MOVLW 5
001A70 240F       05320 	ADDWF pRtcTime,W,0
001A72 6EE9       05321 	MOVWF FSR0,0
001A74 0E00       05322 	MOVLW 0
001A76 2010       05323 	ADDWFC pRtcTime+1,W,0
001A78 6EEA       05324 	MOVWF FSR0+1,0
001A7A C011 FFEF  05325 	MOVFF temp_4,INDF0
                  05326 			;			
                  05327 			;		} else if (g_RtcAdress == RTC_8564JE) {
001A7E D162       05328 	BRA   m164
001A80 0EA2       05329 m159	MOVLW 162
001A82 622B       05330 	CPFSEQ g_RtcAdress,0
001A84 D06F       05331 	BRA   m160
                  05332 			;			
                  05333 			;			temp = BcdToBin( I2C_Read(g_RtcAdress, 0x02) & 0b01111111);
001A86 C02B F012  05334 	MOVFF g_RtcAdress,slaveaddr_4
001A8A 0E02       05335 	MOVLW 2
001A8C 6E13       05336 	MOVWF readaddr_2,0
001A8E D9E3       05337 	RCALL I2C_Read
001A90 0B7F       05338 	ANDLW 127
001A92 DEF3       05339 	RCALL BcdToBin
001A94 6E11       05340 	MOVWF temp_4,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 90

ADDR   CODE       LINE  SOURCE

                  05341 			;			pRtcTime->tm_sec = temp;
001A96 C00F FFE9  05342 	MOVFF pRtcTime,FSR0
001A9A C010 FFEA  05343 	MOVFF pRtcTime+1,FSR0+1
001A9E C011 FFEF  05344 	MOVFF temp_4,INDF0
                  05345 			;			temp = BcdToBin( I2C_Read(g_RtcAdress, 0x03) & 0b01111111);
001AA2 C02B F012  05346 	MOVFF g_RtcAdress,slaveaddr_4
001AA6 0E03       05347 	MOVLW 3
001AA8 6E13       05348 	MOVWF readaddr_2,0
001AAA D9D5       05349 	RCALL I2C_Read
001AAC 0B7F       05350 	ANDLW 127
001AAE DEE5       05351 	RCALL BcdToBin
001AB0 6E11       05352 	MOVWF temp_4,0
                  05353 			;			pRtcTime->tm_min = temp;
001AB2 280F       05354 	INCF  pRtcTime,W,0
001AB4 6EE9       05355 	MOVWF FSR0,0
001AB6 0E00       05356 	MOVLW 0
001AB8 2010       05357 	ADDWFC pRtcTime+1,W,0
001ABA 6EEA       05358 	MOVWF FSR0+1,0
001ABC C011 FFEF  05359 	MOVFF temp_4,INDF0
                  05360 			;			temp = BcdToBin( I2C_Read(g_RtcAdress, 0x04) & 0b00111111);
001AC0 C02B F012  05361 	MOVFF g_RtcAdress,slaveaddr_4
001AC4 0E04       05362 	MOVLW 4
001AC6 6E13       05363 	MOVWF readaddr_2,0
001AC8 D9C6       05364 	RCALL I2C_Read
001ACA 0B3F       05365 	ANDLW 63
001ACC DED6       05366 	RCALL BcdToBin
001ACE 6E11       05367 	MOVWF temp_4,0
                  05368 			;			pRtcTime->tm_hour = temp;
001AD0 0E02       05369 	MOVLW 2
001AD2 240F       05370 	ADDWF pRtcTime,W,0
001AD4 6EE9       05371 	MOVWF FSR0,0
001AD6 0E00       05372 	MOVLW 0
001AD8 2010       05373 	ADDWFC pRtcTime+1,W,0
001ADA 6EEA       05374 	MOVWF FSR0+1,0
001ADC C011 FFEF  05375 	MOVFF temp_4,INDF0
                  05376 			;			temp = BcdToBin( I2C_Read(g_RtcAdress, 0x05) & 0b00111111);
001AE0 C02B F012  05377 	MOVFF g_RtcAdress,slaveaddr_4
001AE4 0E05       05378 	MOVLW 5
001AE6 6E13       05379 	MOVWF readaddr_2,0
001AE8 D9B6       05380 	RCALL I2C_Read
001AEA 0B3F       05381 	ANDLW 63
001AEC DEC6       05382 	RCALL BcdToBin
001AEE 6E11       05383 	MOVWF temp_4,0
                  05384 			;			pRtcTime->tm_mday = temp;
001AF0 0E03       05385 	MOVLW 3
001AF2 240F       05386 	ADDWF pRtcTime,W,0
001AF4 6EE9       05387 	MOVWF FSR0,0
001AF6 0E00       05388 	MOVLW 0
001AF8 2010       05389 	ADDWFC pRtcTime+1,W,0
001AFA 6EEA       05390 	MOVWF FSR0+1,0
001AFC C011 FFEF  05391 	MOVFF temp_4,INDF0
                  05392 			;			temp = BcdToBin( I2C_Read(g_RtcAdress, 0x06) & 0b00000111);
001B00 C02B F012  05393 	MOVFF g_RtcAdress,slaveaddr_4
001B04 0E06       05394 	MOVLW 6
001B06 6E13       05395 	MOVWF readaddr_2,0
001B08 D9A6       05396 	RCALL I2C_Read
001B0A 0B07       05397 	ANDLW 7
001B0C DEB6       05398 	RCALL BcdToBin
001B0E 6E11       05399 	MOVWF temp_4,0
                  05400 			;			pRtcTime->tm_wday = temp;
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 91

ADDR   CODE       LINE  SOURCE

001B10 0E06       05401 	MOVLW 6
001B12 240F       05402 	ADDWF pRtcTime,W,0
001B14 6EE9       05403 	MOVWF FSR0,0
001B16 0E00       05404 	MOVLW 0
001B18 2010       05405 	ADDWFC pRtcTime+1,W,0
001B1A 6EEA       05406 	MOVWF FSR0+1,0
001B1C C011 FFEF  05407 	MOVFF temp_4,INDF0
                  05408 			;			temp = BcdToBin( I2C_Read(g_RtcAdress, 0x07) & 0b00011111);
001B20 C02B F012  05409 	MOVFF g_RtcAdress,slaveaddr_4
001B24 0E07       05410 	MOVLW 7
001B26 6E13       05411 	MOVWF readaddr_2,0
001B28 D996       05412 	RCALL I2C_Read
001B2A 0B1F       05413 	ANDLW 31
001B2C DEA6       05414 	RCALL BcdToBin
001B2E 6E11       05415 	MOVWF temp_4,0
                  05416 			;			temp -= 1;
001B30 0611       05417 	DECF  temp_4,1,0
                  05418 			;			pRtcTime->tm_mon = temp;
001B32 0E04       05419 	MOVLW 4
001B34 240F       05420 	ADDWF pRtcTime,W,0
001B36 6EE9       05421 	MOVWF FSR0,0
001B38 0E00       05422 	MOVLW 0
001B3A 2010       05423 	ADDWFC pRtcTime+1,W,0
001B3C 6EEA       05424 	MOVWF FSR0+1,0
001B3E C011 FFEF  05425 	MOVFF temp_4,INDF0
                  05426 			;			temp = BcdToBin( I2C_Read(g_RtcAdress, 0x08) & 0b11111111);
001B42 C02B F012  05427 	MOVFF g_RtcAdress,slaveaddr_4
001B46 0E08       05428 	MOVLW 8
001B48 6E13       05429 	MOVWF readaddr_2,0
001B4A D985       05430 	RCALL I2C_Read
001B4C 0BFF       05431 	ANDLW 255
001B4E DE95       05432 	RCALL BcdToBin
001B50 6E11       05433 	MOVWF temp_4,0
                  05434 			;			pRtcTime->tm_year = temp;
001B52 0E05       05435 	MOVLW 5
001B54 240F       05436 	ADDWF pRtcTime,W,0
001B56 6EE9       05437 	MOVWF FSR0,0
001B58 0E00       05438 	MOVLW 0
001B5A 2010       05439 	ADDWFC pRtcTime+1,W,0
001B5C 6EEA       05440 	MOVWF FSR0+1,0
001B5E C011 FFEF  05441 	MOVFF temp_4,INDF0
                  05442 			;			
                  05443 			;		} else {
001B62 D0F0       05444 	BRA   m164
                  05445 			;			Trace_String("NO RTC");
001B64 0E54       05446 m160	MOVLW 84
001B66 6E12       05447 	MOVWF string,0
001B68 ECBE F011  05448 	CALL  Trace_String
                  05449 			;		}
                  05450 			;	}
                  05451 			;	break;
001B6C D0EB       05452 	BRA   m164
                  05453 			;	case RTC_SET_TIME:
                  05454 			;	{
                  05455 			;		if (g_RtcAdress == RTC_MCP79410) {
001B6E 0EDE       05456 m161	MOVLW 222
001B70 622B       05457 	CPFSEQ g_RtcAdress,0
001B72 D074       05458 	BRA   m162
                  05459 			;			//clear ST Bit
                  05460 			;			I2C_Write(g_RtcAdress, 0x00, 0x00);
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 92

ADDR   CODE       LINE  SOURCE

001B74 C02B F012  05461 	MOVFF g_RtcAdress,slaveaddr
001B78 6A13       05462 	CLRF  dataaddr,0
001B7A 6A14       05463 	CLRF  data_5,0
001B7C D8ED       05464 	RCALL I2C_Write
                  05465 			;		
                  05466 			;			temp = BinToBcd(pRtcTime->tm_min);
001B7E 280F       05467 	INCF  pRtcTime,W,0
001B80 6EE9       05468 	MOVWF FSR0,0
001B82 0E00       05469 	MOVLW 0
001B84 2010       05470 	ADDWFC pRtcTime+1,W,0
001B86 6EEA       05471 	MOVWF FSR0+1,0
001B88 50EF       05472 	MOVF  INDF0,W,0
001B8A DE89       05473 	RCALL BinToBcd
001B8C 6E11       05474 	MOVWF temp_4,0
                  05475 			;			I2C_Write(g_RtcAdress,0x01,(temp));
001B8E C02B F012  05476 	MOVFF g_RtcAdress,slaveaddr
001B92 0E01       05477 	MOVLW 1
001B94 6E13       05478 	MOVWF dataaddr,0
001B96 C011 F014  05479 	MOVFF temp_4,data_5
001B9A D8DE       05480 	RCALL I2C_Write
                  05481 			;			temp = BinToBcd(pRtcTime->tm_hour);
001B9C 0E02       05482 	MOVLW 2
001B9E 240F       05483 	ADDWF pRtcTime,W,0
001BA0 6EE9       05484 	MOVWF FSR0,0
001BA2 0E00       05485 	MOVLW 0
001BA4 2010       05486 	ADDWFC pRtcTime+1,W,0
001BA6 6EEA       05487 	MOVWF FSR0+1,0
001BA8 50EF       05488 	MOVF  INDF0,W,0
001BAA DE79       05489 	RCALL BinToBcd
001BAC 6E11       05490 	MOVWF temp_4,0
                  05491 			;			I2C_Write(g_RtcAdress,0x02,(temp));
001BAE C02B F012  05492 	MOVFF g_RtcAdress,slaveaddr
001BB2 0E02       05493 	MOVLW 2
001BB4 6E13       05494 	MOVWF dataaddr,0
001BB6 C011 F014  05495 	MOVFF temp_4,data_5
001BBA D8CE       05496 	RCALL I2C_Write
                  05497 			;			temp = BinToBcd(pRtcTime->tm_mday);
001BBC 0E03       05498 	MOVLW 3
001BBE 240F       05499 	ADDWF pRtcTime,W,0
001BC0 6EE9       05500 	MOVWF FSR0,0
001BC2 0E00       05501 	MOVLW 0
001BC4 2010       05502 	ADDWFC pRtcTime+1,W,0
001BC6 6EEA       05503 	MOVWF FSR0+1,0
001BC8 50EF       05504 	MOVF  INDF0,W,0
001BCA DE69       05505 	RCALL BinToBcd
001BCC 6E11       05506 	MOVWF temp_4,0
                  05507 			;			I2C_Write(g_RtcAdress,0x04,(temp));
001BCE C02B F012  05508 	MOVFF g_RtcAdress,slaveaddr
001BD2 0E04       05509 	MOVLW 4
001BD4 6E13       05510 	MOVWF dataaddr,0
001BD6 C011 F014  05511 	MOVFF temp_4,data_5
001BDA D8BE       05512 	RCALL I2C_Write
                  05513 			;			temp = BinToBcd(pRtcTime->tm_wday);
001BDC 0E06       05514 	MOVLW 6
001BDE 240F       05515 	ADDWF pRtcTime,W,0
001BE0 6EE9       05516 	MOVWF FSR0,0
001BE2 0E00       05517 	MOVLW 0
001BE4 2010       05518 	ADDWFC pRtcTime+1,W,0
001BE6 6EEA       05519 	MOVWF FSR0+1,0
001BE8 50EF       05520 	MOVF  INDF0,W,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 93

ADDR   CODE       LINE  SOURCE

001BEA DE59       05521 	RCALL BinToBcd
001BEC 6E11       05522 	MOVWF temp_4,0
                  05523 			;			I2C_Write(g_RtcAdress,0x03,(temp | 0b00001000));
001BEE C02B F012  05524 	MOVFF g_RtcAdress,slaveaddr
001BF2 0E03       05525 	MOVLW 3
001BF4 6E13       05526 	MOVWF dataaddr,0
001BF6 0E08       05527 	MOVLW 8
001BF8 1011       05528 	IORWF temp_4,W,0
001BFA 6E14       05529 	MOVWF data_5,0
001BFC D8AD       05530 	RCALL I2C_Write
                  05531 			;			temp = BinToBcd((pRtcTime->tm_mon + 1));
001BFE 0E04       05532 	MOVLW 4
001C00 240F       05533 	ADDWF pRtcTime,W,0
001C02 6EE9       05534 	MOVWF FSR0,0
001C04 0E00       05535 	MOVLW 0
001C06 2010       05536 	ADDWFC pRtcTime+1,W,0
001C08 6EEA       05537 	MOVWF FSR0+1,0
001C0A 28EF       05538 	INCF  INDF0,W,0
001C0C DE48       05539 	RCALL BinToBcd
001C0E 6E11       05540 	MOVWF temp_4,0
                  05541 			;			I2C_Write(g_RtcAdress,0x05,(temp));
001C10 C02B F012  05542 	MOVFF g_RtcAdress,slaveaddr
001C14 0E05       05543 	MOVLW 5
001C16 6E13       05544 	MOVWF dataaddr,0
001C18 C011 F014  05545 	MOVFF temp_4,data_5
001C1C D89D       05546 	RCALL I2C_Write
                  05547 			;			temp = BinToBcd(pRtcTime->tm_year);
001C1E 0E05       05548 	MOVLW 5
001C20 240F       05549 	ADDWF pRtcTime,W,0
001C22 6EE9       05550 	MOVWF FSR0,0
001C24 0E00       05551 	MOVLW 0
001C26 2010       05552 	ADDWFC pRtcTime+1,W,0
001C28 6EEA       05553 	MOVWF FSR0+1,0
001C2A 50EF       05554 	MOVF  INDF0,W,0
001C2C DE38       05555 	RCALL BinToBcd
001C2E 6E11       05556 	MOVWF temp_4,0
                  05557 			;			I2C_Write(g_RtcAdress,0x06,(temp));
001C30 C02B F012  05558 	MOVFF g_RtcAdress,slaveaddr
001C34 0E06       05559 	MOVLW 6
001C36 6E13       05560 	MOVWF dataaddr,0
001C38 C011 F014  05561 	MOVFF temp_4,data_5
001C3C D88D       05562 	RCALL I2C_Write
                  05563 			;			//set sec and ST bit
                  05564 			;			temp = BinToBcd(pRtcTime->tm_sec);
001C3E C00F FFE9  05565 	MOVFF pRtcTime,FSR0
001C42 C010 FFEA  05566 	MOVFF pRtcTime+1,FSR0+1
001C46 50EF       05567 	MOVF  INDF0,W,0
001C48 DE2A       05568 	RCALL BinToBcd
001C4A 6E11       05569 	MOVWF temp_4,0
                  05570 			;			I2C_Write(g_RtcAdress,0x00,(temp | 0b10000000));
001C4C C02B F012  05571 	MOVFF g_RtcAdress,slaveaddr
001C50 6A13       05572 	CLRF  dataaddr,0
001C52 0E80       05573 	MOVLW 128
001C54 1011       05574 	IORWF temp_4,W,0
001C56 6E14       05575 	MOVWF data_5,0
001C58 D87F       05576 	RCALL I2C_Write
                  05577 			;			
                  05578 			;		} else if (g_RtcAdress == RTC_8564JE) {
001C5A D074       05579 	BRA   m164
001C5C 0EA2       05580 m162	MOVLW 162
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 94

ADDR   CODE       LINE  SOURCE

001C5E 622B       05581 	CPFSEQ g_RtcAdress,0
001C60 D06E       05582 	BRA   m163
                  05583 			;			
                  05584 			;			temp = BinToBcd(pRtcTime->tm_sec);
001C62 C00F FFE9  05585 	MOVFF pRtcTime,FSR0
001C66 C010 FFEA  05586 	MOVFF pRtcTime+1,FSR0+1
001C6A 50EF       05587 	MOVF  INDF0,W,0
001C6C DE18       05588 	RCALL BinToBcd
001C6E 6E11       05589 	MOVWF temp_4,0
                  05590 			;			I2C_Write(g_RtcAdress,0x02,(temp));
001C70 C02B F012  05591 	MOVFF g_RtcAdress,slaveaddr
001C74 0E02       05592 	MOVLW 2
001C76 6E13       05593 	MOVWF dataaddr,0
001C78 C011 F014  05594 	MOVFF temp_4,data_5
001C7C D86D       05595 	RCALL I2C_Write
                  05596 			;			temp = BinToBcd(pRtcTime->tm_min);
001C7E 280F       05597 	INCF  pRtcTime,W,0
001C80 6EE9       05598 	MOVWF FSR0,0
001C82 0E00       05599 	MOVLW 0
001C84 2010       05600 	ADDWFC pRtcTime+1,W,0
001C86 6EEA       05601 	MOVWF FSR0+1,0
001C88 50EF       05602 	MOVF  INDF0,W,0
001C8A DE09       05603 	RCALL BinToBcd
001C8C 6E11       05604 	MOVWF temp_4,0
                  05605 			;			I2C_Write(g_RtcAdress,0x03,(temp));
001C8E C02B F012  05606 	MOVFF g_RtcAdress,slaveaddr
001C92 0E03       05607 	MOVLW 3
001C94 6E13       05608 	MOVWF dataaddr,0
001C96 C011 F014  05609 	MOVFF temp_4,data_5
001C9A D85E       05610 	RCALL I2C_Write
                  05611 			;			temp = BinToBcd(pRtcTime->tm_hour);
001C9C 0E02       05612 	MOVLW 2
001C9E 240F       05613 	ADDWF pRtcTime,W,0
001CA0 6EE9       05614 	MOVWF FSR0,0
001CA2 0E00       05615 	MOVLW 0
001CA4 2010       05616 	ADDWFC pRtcTime+1,W,0
001CA6 6EEA       05617 	MOVWF FSR0+1,0
001CA8 50EF       05618 	MOVF  INDF0,W,0
001CAA DDF9       05619 	RCALL BinToBcd
001CAC 6E11       05620 	MOVWF temp_4,0
                  05621 			;			I2C_Write(g_RtcAdress,0x04,(temp));
001CAE C02B F012  05622 	MOVFF g_RtcAdress,slaveaddr
001CB2 0E04       05623 	MOVLW 4
001CB4 6E13       05624 	MOVWF dataaddr,0
001CB6 C011 F014  05625 	MOVFF temp_4,data_5
001CBA D84E       05626 	RCALL I2C_Write
                  05627 			;			temp = BinToBcd(pRtcTime->tm_mday);
001CBC 0E03       05628 	MOVLW 3
001CBE 240F       05629 	ADDWF pRtcTime,W,0
001CC0 6EE9       05630 	MOVWF FSR0,0
001CC2 0E00       05631 	MOVLW 0
001CC4 2010       05632 	ADDWFC pRtcTime+1,W,0
001CC6 6EEA       05633 	MOVWF FSR0+1,0
001CC8 50EF       05634 	MOVF  INDF0,W,0
001CCA DDE9       05635 	RCALL BinToBcd
001CCC 6E11       05636 	MOVWF temp_4,0
                  05637 			;			I2C_Write(g_RtcAdress,0x05,(temp));
001CCE C02B F012  05638 	MOVFF g_RtcAdress,slaveaddr
001CD2 0E05       05639 	MOVLW 5
001CD4 6E13       05640 	MOVWF dataaddr,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 95

ADDR   CODE       LINE  SOURCE

001CD6 C011 F014  05641 	MOVFF temp_4,data_5
001CDA D83E       05642 	RCALL I2C_Write
                  05643 			;			temp = BinToBcd(pRtcTime->tm_wday);
001CDC 0E06       05644 	MOVLW 6
001CDE 240F       05645 	ADDWF pRtcTime,W,0
001CE0 6EE9       05646 	MOVWF FSR0,0
001CE2 0E00       05647 	MOVLW 0
001CE4 2010       05648 	ADDWFC pRtcTime+1,W,0
001CE6 6EEA       05649 	MOVWF FSR0+1,0
001CE8 50EF       05650 	MOVF  INDF0,W,0
001CEA DDD9       05651 	RCALL BinToBcd
001CEC 6E11       05652 	MOVWF temp_4,0
                  05653 			;			I2C_Write(g_RtcAdress,0x06,(temp));
001CEE C02B F012  05654 	MOVFF g_RtcAdress,slaveaddr
001CF2 0E06       05655 	MOVLW 6
001CF4 6E13       05656 	MOVWF dataaddr,0
001CF6 C011 F014  05657 	MOVFF temp_4,data_5
001CFA D82E       05658 	RCALL I2C_Write
                  05659 			;			temp = BinToBcd((pRtcTime->tm_mon + 1));
001CFC 0E04       05660 	MOVLW 4
001CFE 240F       05661 	ADDWF pRtcTime,W,0
001D00 6EE9       05662 	MOVWF FSR0,0
001D02 0E00       05663 	MOVLW 0
001D04 2010       05664 	ADDWFC pRtcTime+1,W,0
001D06 6EEA       05665 	MOVWF FSR0+1,0
001D08 28EF       05666 	INCF  INDF0,W,0
001D0A DDC9       05667 	RCALL BinToBcd
001D0C 6E11       05668 	MOVWF temp_4,0
                  05669 			;			I2C_Write(g_RtcAdress,0x07,(temp));
001D0E C02B F012  05670 	MOVFF g_RtcAdress,slaveaddr
001D12 0E07       05671 	MOVLW 7
001D14 6E13       05672 	MOVWF dataaddr,0
001D16 C011 F014  05673 	MOVFF temp_4,data_5
001D1A D81E       05674 	RCALL I2C_Write
                  05675 			;			temp = BinToBcd(pRtcTime->tm_year);
001D1C 0E05       05676 	MOVLW 5
001D1E 240F       05677 	ADDWF pRtcTime,W,0
001D20 6EE9       05678 	MOVWF FSR0,0
001D22 0E00       05679 	MOVLW 0
001D24 2010       05680 	ADDWFC pRtcTime+1,W,0
001D26 6EEA       05681 	MOVWF FSR0+1,0
001D28 50EF       05682 	MOVF  INDF0,W,0
001D2A DDB9       05683 	RCALL BinToBcd
001D2C 6E11       05684 	MOVWF temp_4,0
                  05685 			;			I2C_Write(g_RtcAdress,0x08,(temp));
001D2E C02B F012  05686 	MOVFF g_RtcAdress,slaveaddr
001D32 0E08       05687 	MOVLW 8
001D34 6E13       05688 	MOVWF dataaddr,0
001D36 C011 F014  05689 	MOVFF temp_4,data_5
001D3A D80E       05690 	RCALL I2C_Write
                  05691 			;			
                  05692 			;		} else {
001D3C D003       05693 	BRA   m164
                  05694 			;			Trace_String("NO RTC");
001D3E 0E54       05695 m163	MOVLW 84
001D40 6E12       05696 	MOVWF string,0
001D42 DB1C       05697 	RCALL Trace_String
                  05698 			;		}
                  05699 			;	}
                  05700 			;	break;
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 96

ADDR   CODE       LINE  SOURCE

                  05701 			;	}
                  05702 			;}
001D44 0012       05703 m164	RETURN
                  05704 
                  05705   ; FILE ./firmware\iic.c
                  05706 			;/**
                  05707 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  05708 			;
                  05709 			; This file is part of Wifly_Light.
                  05710 			;
                  05711 			; Wifly_Light is free software: you can redistribute it and/or modify
                  05712 			; it under the terms of the GNU General Public License as published by
                  05713 			; the Free Software Foundation, either version 3 of the License, or
                  05714 			; (at your option) any later version.
                  05715 			;
                  05716 			; Wifly_Light is distributed in the hope that it will be useful,
                  05717 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  05718 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  05719 			; GNU General Public License for more details.
                  05720 			;
                  05721 			; You should have received a copy of the GNU General Public License
                  05722 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  05723 			;
                  05724 			;//Befehle:
                  05725 			;//I2C_Init() zum initialisieren
                  05726 			;//IICwrite(Slave-Adresse,Register-Adresse,Datenbyte) zum Schreiben eines Byte in einen Slave
                  05727 			;//IICread(Slave-Adresse,Register-Adresse) ließt ein Byte von der angegebenen Adresse
                  05728 			;
                  05729 			;#include "iic.h"
                  05730 			;
                  05731 			;void I2C_Init()
                  05732 			;{
                  05733 I2C_Init
                  05734 			;	ANSELB = 0;
001D46 010F       05735 	MOVLB 15
001D48 6B39       05736 	CLRF  ANSELB,1
                  05737 			;	SSP2ADD = 39;                             //Takt des IIC-Bus auf 400kHz einstellen
001D4A 0E27       05738 	MOVLW 39
001D4C 6E6E       05739 	MOVWF SSP2ADD,0
                  05740 			;	SSP2STAT = 0x00;
001D4E 6A6D       05741 	CLRF  SSP2STAT,0
                  05742 			;	SSP2CON1 = 0x08;                  //Betriebsart des MSSP-Modul festlegen
001D50 0E08       05743 	MOVLW 8
001D52 6E6C       05744 	MOVWF SSP2CON1,0
                  05745 			;	SSPEN2 = 1;                               //MSSP-Modul einschalten
001D54 8A6C       05746 	BSF   0xF6C,SSPEN2,0
                  05747 			;}
001D56 0012       05748 	RETURN
                  05749 			;
                  05750 			;void I2C_Write(uns8 slaveaddr, const uns8 dataaddr, const uns8 data)
                  05751 			;{
                  05752 I2C_Write
                  05753 			;	//Writebit in Slaveadresse setzen
                  05754 			;
                  05755 			;	slaveaddr = slaveaddr & 0b11111110;
001D58 9012       05756 	BCF   slaveaddr,0,0
                  05757 			;
                  05758 			;	//Bus übernehmen
                  05759 			;	SSP2IF = 0;
001D5A 9EA4       05760 	BCF   0xFA4,SSP2IF,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 97

ADDR   CODE       LINE  SOURCE

                  05761 			;	SEN2 = 1;
001D5C 806B       05762 	BSF   0xF6B,SEN2,0
                  05763 			;	while(!SSP2IF) ;
001D5E AEA4       05764 m165	BTFSS 0xFA4,SSP2IF,0
001D60 D7FE       05765 	BRA   m165
                  05766 			;	SSP2IF = 0;
001D62 9EA4       05767 	BCF   0xFA4,SSP2IF,0
                  05768 			;
                  05769 			;	//Slave ansprechen
                  05770 			;	SSP2BUF = slaveaddr;
001D64 C012 FF6F  05771 	MOVFF slaveaddr,SSP2BUF
                  05772 			;	while(!SSP2IF) ;
001D68 AEA4       05773 m166	BTFSS 0xFA4,SSP2IF,0
001D6A D7FE       05774 	BRA   m166
                  05775 			;	SSP2IF = 0;
001D6C 9EA4       05776 	BCF   0xFA4,SSP2IF,0
                  05777 			;
                  05778 			;	//Datenregisteradresse übertragen
                  05779 			;	SSP2BUF = dataaddr;
001D6E C013 FF6F  05780 	MOVFF dataaddr,SSP2BUF
                  05781 			;	while(!SSP2IF) ;
001D72 AEA4       05782 m167	BTFSS 0xFA4,SSP2IF,0
001D74 D7FE       05783 	BRA   m167
                  05784 			;	SSP2IF = 0;
001D76 9EA4       05785 	BCF   0xFA4,SSP2IF,0
                  05786 			;
                  05787 			;	//Daten schreiben
                  05788 			;	SSP2BUF = data;
001D78 C014 FF6F  05789 	MOVFF data_5,SSP2BUF
                  05790 			;	while(!SSP2IF) ;
001D7C AEA4       05791 m168	BTFSS 0xFA4,SSP2IF,0
001D7E D7FE       05792 	BRA   m168
                  05793 			;	SSP2IF = 0;
001D80 9EA4       05794 	BCF   0xFA4,SSP2IF,0
                  05795 			;
                  05796 			;	//Bus freigeben
                  05797 			;	PEN2 = 1;
001D82 846B       05798 	BSF   0xF6B,PEN2,0
                  05799 			;	while(!SSP2IF) ;
001D84 AEA4       05800 m169	BTFSS 0xFA4,SSP2IF,0
001D86 D7FE       05801 	BRA   m169
                  05802 			;	SSP2IF = 0;
001D88 9EA4       05803 	BCF   0xFA4,SSP2IF,0
                  05804 			;}
001D8A 0012       05805 	RETURN
                  05806 			;
                  05807 			;void I2C_WriteBlock(uns8 slaveaddr, const uns8* data, const uns8 dataaddr,const uns8 length)
                  05808 			;{
                  05809 I2C_WriteBlock
                  05810 			;	//Writebit in Slaveadresse setzen
                  05811 			;	
                  05812 			;	slaveaddr = slaveaddr & 0b11111110;
001D8C 907F       05813 	BCF   slaveaddr_2,0,0
                  05814 			;	uns8 _length = length;
001D8E CF7F FF7F  05815 	MOVFF length_4,_length
                  05816 			;	//Bus übernehmen
                  05817 			;	SSP2IF = 0;
001D92 9EA4       05818 	BCF   0xFA4,SSP2IF,0
                  05819 			;	SEN2 = 1;
001D94 806B       05820 	BSF   0xF6B,SEN2,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 98

ADDR   CODE       LINE  SOURCE

                  05821 			;	while(!SSP2IF) ;
001D96 AEA4       05822 m170	BTFSS 0xFA4,SSP2IF,0
001D98 D7FE       05823 	BRA   m170
                  05824 			;	SSP2IF = 0;
001D9A 9EA4       05825 	BCF   0xFA4,SSP2IF,0
                  05826 			;	
                  05827 			;	//Slave ansprechen
                  05828 			;	SSP2BUF = slaveaddr;
001D9C CF7F FF6F  05829 	MOVFF slaveaddr_2,SSP2BUF
                  05830 			;	while(!SSP2IF) ;
001DA0 AEA4       05831 m171	BTFSS 0xFA4,SSP2IF,0
001DA2 D7FE       05832 	BRA   m171
                  05833 			;	SSP2IF = 0;
001DA4 9EA4       05834 	BCF   0xFA4,SSP2IF,0
                  05835 			;	
                  05836 			;	//Datenregisteradresse übertragen
                  05837 			;	SSP2BUF = dataaddr;
001DA6 CF7F FF6F  05838 	MOVFF dataaddr_2,SSP2BUF
                  05839 			;	while(!SSP2IF) ;
001DAA AEA4       05840 m172	BTFSS 0xFA4,SSP2IF,0
001DAC D7FE       05841 	BRA   m172
                  05842 			;	SSP2IF = 0;
001DAE 9EA4       05843 	BCF   0xFA4,SSP2IF,0
                  05844 			;	
                  05845 			;	while (_length) {
001DB0 507F       05846 m173	MOVF  _length,W,0
001DB2 B4D8       05847 	BTFSC 0xFD8,Zero_,0
001DB4 D00A       05848 	BRA   m175
                  05849 			;		_length--;
001DB6 067F       05850 	DECF  _length,1,0
                  05851 			;		//Daten schreiben
                  05852 			;		SSP2BUF = *data;
001DB8 507F       05853 	MOVF  data_6,W,0
001DBA ECEF F013  05854 	CALL  _const3
001DBE 6E6F       05855 	MOVWF SSP2BUF,0
                  05856 			;		data++;
001DC0 2A7F       05857 	INCF  data_6,1,0
                  05858 			;		while(!SSP2IF) ;
001DC2 AEA4       05859 m174	BTFSS 0xFA4,SSP2IF,0
001DC4 D7FE       05860 	BRA   m174
                  05861 			;		SSP2IF = 0;
001DC6 9EA4       05862 	BCF   0xFA4,SSP2IF,0
                  05863 			;	}
001DC8 D7F3       05864 	BRA   m173
                  05865 			;	
                  05866 			;	//Bus freigeben
                  05867 			;	PEN2 = 1;
001DCA 846B       05868 m175	BSF   0xF6B,PEN2,0
                  05869 			;	while(!SSP2IF) ;
001DCC AEA4       05870 m176	BTFSS 0xFA4,SSP2IF,0
001DCE D7FE       05871 	BRA   m176
                  05872 			;	SSP2IF = 0;
001DD0 9EA4       05873 	BCF   0xFA4,SSP2IF,0
                  05874 			;}
001DD2 0012       05875 	RETURN
                  05876 			;
                  05877 			;void I2C_ReadBlock(const uns8 slaveaddr, uns8* buffer, const uns8 readaddr, const uns8 length)
                  05878 			;{
                  05879 I2C_ReadBlock
                  05880 			;	//Writebit in Slaveadresse setzen
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 99

ADDR   CODE       LINE  SOURCE

                  05881 			;	uns8 _slaveaddr;
                  05882 			;	_slaveaddr = slaveaddr & 0b11111110;
001DD4 0EFE       05883 	MOVLW 254
001DD6 147F       05884 	ANDWF slaveaddr_3,W,0
001DD8 6E7F       05885 	MOVWF _slaveaddr,0
                  05886 			;	uns8 _length = length;
001DDA CF7F FF7F  05887 	MOVFF length_5,_length_2
                  05888 			;	
                  05889 			;	//Bus übernehmen
                  05890 			;	SSP2IF = 0;
001DDE 9EA4       05891 	BCF   0xFA4,SSP2IF,0
                  05892 			;	SEN2 = 1;
001DE0 806B       05893 	BSF   0xF6B,SEN2,0
                  05894 			;	while(!SSP2IF) ;
001DE2 AEA4       05895 m177	BTFSS 0xFA4,SSP2IF,0
001DE4 D7FE       05896 	BRA   m177
                  05897 			;	SSP2IF = 0;
001DE6 9EA4       05898 	BCF   0xFA4,SSP2IF,0
                  05899 			;	
                  05900 			;	//Slave ansprechen
                  05901 			;	SSP2BUF = _slaveaddr;
001DE8 CF7F FF6F  05902 	MOVFF _slaveaddr,SSP2BUF
                  05903 			;	while(!SSP2IF) ;
001DEC AEA4       05904 m178	BTFSS 0xFA4,SSP2IF,0
001DEE D7FE       05905 	BRA   m178
                  05906 			;	SSP2IF = 0;
001DF0 9EA4       05907 	BCF   0xFA4,SSP2IF,0
                  05908 			;	
                  05909 			;	//Datenregisteradresse übertragen
                  05910 			;	SSP2BUF = readaddr;
001DF2 CF7F FF6F  05911 	MOVFF readaddr,SSP2BUF
                  05912 			;	while(!SSP2IF) ;
001DF6 AEA4       05913 m179	BTFSS 0xFA4,SSP2IF,0
001DF8 D7FE       05914 	BRA   m179
                  05915 			;	SSP2IF = 0;
001DFA 9EA4       05916 	BCF   0xFA4,SSP2IF,0
                  05917 			;	
                  05918 			;	//Bus freigeben
                  05919 			;	PEN2 = 1;
001DFC 846B       05920 	BSF   0xF6B,PEN2,0
                  05921 			;	while(!SSP2IF) ;
001DFE AEA4       05922 m180	BTFSS 0xFA4,SSP2IF,0
001E00 D7FE       05923 	BRA   m180
                  05924 			;	SSP2IF = 0;
001E02 9EA4       05925 	BCF   0xFA4,SSP2IF,0
                  05926 			;	
                  05927 			;	//Bus übernehmen
                  05928 			;	SSP2IF = 0;
001E04 9EA4       05929 	BCF   0xFA4,SSP2IF,0
                  05930 			;	SEN2 = 1;
001E06 806B       05931 	BSF   0xF6B,SEN2,0
                  05932 			;	while(!SSP2IF) ;
001E08 AEA4       05933 m181	BTFSS 0xFA4,SSP2IF,0
001E0A D7FE       05934 	BRA   m181
                  05935 			;	SSP2IF = 0;
001E0C 9EA4       05936 	BCF   0xFA4,SSP2IF,0
                  05937 			;	
                  05938 			;	//Readbit in Slaveadresse setzen
                  05939 			;	_slaveaddr = slaveaddr | 0b00000001;
001E0E 0E01       05940 	MOVLW 1
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 100

ADDR   CODE       LINE  SOURCE

001E10 107F       05941 	IORWF slaveaddr_3,W,0
001E12 6E7F       05942 	MOVWF _slaveaddr,0
                  05943 			;	//Slave ansprechen
                  05944 			;	SSP2BUF = _slaveaddr;
001E14 CF7F FF6F  05945 	MOVFF _slaveaddr,SSP2BUF
                  05946 			;	while(!SSP2IF) ;
001E18 AEA4       05947 m182	BTFSS 0xFA4,SSP2IF,0
001E1A D7FE       05948 	BRA   m182
                  05949 			;	SSP2IF = 0;
001E1C 9EA4       05950 	BCF   0xFA4,SSP2IF,0
                  05951 			;	
                  05952 			;	while (_length) {
001E1E 507F       05953 m183	MOVF  _length_2,W,0
001E20 B4D8       05954 	BTFSC 0xFD8,Zero_,0
001E22 D014       05955 	BRA   m186
                  05956 			;		//Pic auf Lesen umschalten
                  05957 			;		SSP2IF = 0;
001E24 9EA4       05958 	BCF   0xFA4,SSP2IF,0
                  05959 			;		RCEN2 = 1;
001E26 866B       05960 	BSF   0xF6B,RCEN2,0
                  05961 			;		while(!SSP2IF) ;
001E28 AEA4       05962 m184	BTFSS 0xFA4,SSP2IF,0
001E2A D7FE       05963 	BRA   m184
                  05964 			;		
                  05965 			;		*buffer = SSP2BUF;
001E2C CF7F FFE9  05966 	MOVFF buffer,FSR0
001E30 6AEA       05967 	CLRF  FSR0+1,0
001E32 CF6F FFEF  05968 	MOVFF SSP2BUF,INDF0
                  05969 			;		buffer++;
001E36 2A7F       05970 	INCF  buffer,1,0
                  05971 			;		_length--;
001E38 067F       05972 	DECF  _length_2,1,0
                  05973 			;		
                  05974 			;		//Send ACK if we have some bytes to read
                  05975 			;		if (_length) {
001E3A 507F       05976 	MOVF  _length_2,W,0
001E3C B4D8       05977 	BTFSC 0xFD8,Zero_,0
001E3E D7EF       05978 	BRA   m183
                  05979 			;			SSP2IF = 0;
001E40 9EA4       05980 	BCF   0xFA4,SSP2IF,0
                  05981 			;			ACKEN2 = 1;
001E42 886B       05982 	BSF   0xF6B,ACKEN2,0
                  05983 			;			ACKDT2 = 0;
001E44 9A6B       05984 	BCF   0xF6B,ACKDT2,0
                  05985 			;			while(!SSP2IF) ;
001E46 BEA4       05986 m185	BTFSC 0xFA4,SSP2IF,0
001E48 D7EA       05987 	BRA   m183
001E4A D7FD       05988 	BRA   m185
                  05989 			;		}
                  05990 			;		
                  05991 			;	}
                  05992 			;	
                  05993 			;	//Bus freigeben
                  05994 			;	PEN2 = 1;
001E4C 846B       05995 m186	BSF   0xF6B,PEN2,0
                  05996 			;	while(!SSP2IF) ;
001E4E AEA4       05997 m187	BTFSS 0xFA4,SSP2IF,0
001E50 D7FE       05998 	BRA   m187
                  05999 			;	SSP2IF = 0;
001E52 9EA4       06000 	BCF   0xFA4,SSP2IF,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 101

ADDR   CODE       LINE  SOURCE

                  06001 			;}
001E54 0012       06002 	RETURN
                  06003 			;
                  06004 			;uns8 I2C_Read(const uns8 slaveaddr, const uns8 readaddr)
                  06005 			;{
                  06006 I2C_Read
                  06007 			;	//Writebit in Slaveadresse setzen
                  06008 			;	uns8 _slaveaddr;
                  06009 			;	uns8 _data;
                  06010 			;	_slaveaddr = slaveaddr & 0b11111110;
001E56 0EFE       06011 	MOVLW 254
001E58 1412       06012 	ANDWF slaveaddr_4,W,0
001E5A 6E14       06013 	MOVWF _slaveaddr_2,0
                  06014 			;
                  06015 			;	//Bus übernehmen
                  06016 			;	SSP2IF = 0;
001E5C 9EA4       06017 	BCF   0xFA4,SSP2IF,0
                  06018 			;	SEN2 = 1;
001E5E 806B       06019 	BSF   0xF6B,SEN2,0
                  06020 			;	while(!SSP2IF) ;
001E60 AEA4       06021 m188	BTFSS 0xFA4,SSP2IF,0
001E62 D7FE       06022 	BRA   m188
                  06023 			;	SSP2IF = 0;
001E64 9EA4       06024 	BCF   0xFA4,SSP2IF,0
                  06025 			;
                  06026 			;	//Slave ansprechen
                  06027 			;	SSP2BUF = _slaveaddr;
001E66 C014 FF6F  06028 	MOVFF _slaveaddr_2,SSP2BUF
                  06029 			;	while(!SSP2IF) ;
001E6A AEA4       06030 m189	BTFSS 0xFA4,SSP2IF,0
001E6C D7FE       06031 	BRA   m189
                  06032 			;	SSP2IF = 0;
001E6E 9EA4       06033 	BCF   0xFA4,SSP2IF,0
                  06034 			;
                  06035 			;	//Datenregisteradresse übertragen
                  06036 			;	SSP2BUF = readaddr;
001E70 C013 FF6F  06037 	MOVFF readaddr_2,SSP2BUF
                  06038 			;	while(!SSP2IF) ;
001E74 AEA4       06039 m190	BTFSS 0xFA4,SSP2IF,0
001E76 D7FE       06040 	BRA   m190
                  06041 			;	SSP2IF = 0;
001E78 9EA4       06042 	BCF   0xFA4,SSP2IF,0
                  06043 			;
                  06044 			;	//Bus freigeben
                  06045 			;	PEN2 = 1;
001E7A 846B       06046 	BSF   0xF6B,PEN2,0
                  06047 			;	while(!SSP2IF) ;
001E7C AEA4       06048 m191	BTFSS 0xFA4,SSP2IF,0
001E7E D7FE       06049 	BRA   m191
                  06050 			;	SSP2IF = 0;
001E80 9EA4       06051 	BCF   0xFA4,SSP2IF,0
                  06052 			;
                  06053 			;	//Bus übernehmen
                  06054 			;	SSP2IF = 0;
001E82 9EA4       06055 	BCF   0xFA4,SSP2IF,0
                  06056 			;	RSEN2 = 1;
001E84 826B       06057 	BSF   0xF6B,RSEN2,0
                  06058 			;	while(!SSP2IF) ;
001E86 AEA4       06059 m192	BTFSS 0xFA4,SSP2IF,0
001E88 D7FE       06060 	BRA   m192
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 102

ADDR   CODE       LINE  SOURCE

                  06061 			;	SSP2IF = 0;
001E8A 9EA4       06062 	BCF   0xFA4,SSP2IF,0
                  06063 			;
                  06064 			;	//Readbit in Slaveadresse setzen
                  06065 			;	_slaveaddr |= 0b00000001;
001E8C 8014       06066 	BSF   _slaveaddr_2,0,0
                  06067 			;	//Slave ansprechen
                  06068 			;	SSP2BUF = _slaveaddr;
001E8E C014 FF6F  06069 	MOVFF _slaveaddr_2,SSP2BUF
                  06070 			;	while(!SSP2IF) ;
001E92 AEA4       06071 m193	BTFSS 0xFA4,SSP2IF,0
001E94 D7FE       06072 	BRA   m193
                  06073 			;	SSP2IF = 0;
001E96 9EA4       06074 	BCF   0xFA4,SSP2IF,0
                  06075 			;
                  06076 			;	//Pic auf Lesen umschalten
                  06077 			;	RCEN2 = 1;
001E98 866B       06078 	BSF   0xF6B,RCEN2,0
                  06079 			;	while(!SSP2IF) ;
001E9A AEA4       06080 m194	BTFSS 0xFA4,SSP2IF,0
001E9C D7FE       06081 	BRA   m194
                  06082 			;	SSP2IF = 0;
001E9E 9EA4       06083 	BCF   0xFA4,SSP2IF,0
                  06084 			;	ACKEN2 = 0;
001EA0 986B       06085 	BCF   0xF6B,ACKEN2,0
                  06086 			;	_data = SSP2BUF;
001EA2 CF6F F015  06087 	MOVFF SSP2BUF,_data
                  06088 			;
                  06089 			;
                  06090 			;	//Bus freigeben
                  06091 			;	PEN2 = 1;
001EA6 846B       06092 	BSF   0xF6B,PEN2,0
                  06093 			;	while(!SSP2IF) ;
001EA8 AEA4       06094 m195	BTFSS 0xFA4,SSP2IF,0
001EAA D7FE       06095 	BRA   m195
                  06096 			;	SSP2IF = 0;
001EAC 9EA4       06097 	BCF   0xFA4,SSP2IF,0
                  06098 			;	return _data;
001EAE 5015       06099 	MOVF  _data,W,0
001EB0 0012       06100 	RETURN
                  06101 			;}
                  06102 			;
                  06103 			;uns8 I2C_DetectSlave(const uns8 slaveaddr) {
                  06104 I2C_DetectSlave
                  06105 			;	//Bus übernehmen
                  06106 			;	SSP2IF = 0;
001EB2 9EA4       06107 	BCF   0xFA4,SSP2IF,0
                  06108 			;	SEN2 = 1;
001EB4 806B       06109 	BSF   0xF6B,SEN2,0
                  06110 			;	while(!SSP2IF) ;
001EB6 AEA4       06111 m196	BTFSS 0xFA4,SSP2IF,0
001EB8 D7FE       06112 	BRA   m196
                  06113 			;	SSP2IF = 0;
001EBA 9EA4       06114 	BCF   0xFA4,SSP2IF,0
                  06115 			;	
                  06116 			;	//Slave ansprechen
                  06117 			;	SSP2BUF = slaveaddr;
001EBC C007 FF6F  06118 	MOVFF slaveaddr_5,SSP2BUF
                  06119 			;	while(!SSP2IF) ;
001EC0 AEA4       06120 m197	BTFSS 0xFA4,SSP2IF,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 103

ADDR   CODE       LINE  SOURCE

001EC2 D7FE       06121 	BRA   m197
                  06122 			;	SSP2IF = 0;
001EC4 9EA4       06123 	BCF   0xFA4,SSP2IF,0
                  06124 			;	
                  06125 			;	//check ACKSTAT
                  06126 			;	uns8 returnValue = SSP2CON2 & 0b01000000;
001EC6 0E40       06127 	MOVLW 64
001EC8 146B       06128 	ANDWF SSP2CON2,W,0
001ECA 6E08       06129 	MOVWF returnValue,0
                  06130 			;	
                  06131 			;	//Bus freigeben
                  06132 			;	PEN2 = 1;
001ECC 846B       06133 	BSF   0xF6B,PEN2,0
                  06134 			;	while(!SSP2IF) ;
001ECE AEA4       06135 m198	BTFSS 0xFA4,SSP2IF,0
001ED0 D7FE       06136 	BRA   m198
                  06137 			;	SSP2IF = 0;
001ED2 9EA4       06138 	BCF   0xFA4,SSP2IF,0
                  06139 			;	
                  06140 			;	if (returnValue == 0) {
001ED4 5208       06141 	MOVF  returnValue,1,0
001ED6 B4D8       06142 	BTFSC 0xFD8,Zero_,0
                  06143 			;		return TRUE;
001ED8 0C01       06144 	RETLW 1
                  06145 			;	} else {
                  06146 			;		return FALSE;
001EDA 0C00       06147 	RETLW 0
                  06148 
                  06149   ; FILE ./firmware\ScriptCtrl.c
                  06150 			;/*
                  06151 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  06152 			;
                  06153 			; This file is part of Wifly_Light.
                  06154 			;
                  06155 			; Wifly_Light is free software: you can redistribute it and/or modify
                  06156 			; it under the terms of the GNU General Public License as published by
                  06157 			; the Free Software Foundation, either version 3 of the License, or
                  06158 			; (at your option) any later version.
                  06159 			;
                  06160 			; Wifly_Light is distributed in the hope that it will be useful,
                  06161 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  06162 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  06163 			; GNU General Public License for more details.
                  06164 			;
                  06165 			; You should have received a copy of the GNU General Public License
                  06166 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  06167 			;
                  06168 			;
                  06169 			;#ifdef cc3200
                  06170 			;#include "socket.h"
                  06171 			;#include <stdbool.h>
                  06172 			;
                  06173 			;#ifdef write
                  06174 			;#undef write
                  06175 			;#endif
                  06176 			;#endif
                  06177 			;
                  06178 			;#include "platform.h"
                  06179 			;
                  06180 			;
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 104

ADDR   CODE       LINE  SOURCE

                  06181 			;#include "ledstrip.h"
                  06182 			;#include "ScriptCtrl.h"
                  06183 			;#include "CommandIO.h"
                  06184 			;#include "eeprom.h"
                  06185 			;#include "error.h"
                  06186 			;#include "trace.h"
                  06187 			;
                  06188 			;/**************** private functions/ macros *****************/
                  06189 			;/**
                  06190 			; * Helper to calculate an eeprom address from a command pointer
                  06191 			; */
                  06192 			;#define ScriptBufAddr(x) ((uns16)EEPROM_SCRIPTBUF_BASE + ((uns16)(x) * (uns16)sizeof(struct led_cmd)))
                  06193 			;
                  06194 			;/**
                  06195 			; * Helper to increment a ScriptBuf pointer
                  06196 			; */
                  06197 			;#define ScriptBufInc(x) ((x + 1) & SCRIPTCTRL_NUM_CMD_MAX)
                  06198 			;
                  06199 			;/**
                  06200 			; * Setter for ScriptBuf.inLoop
                  06201 			; */
                  06202 			;#define ScriptBufSetInLoop(x) { \
                  06203 			;		Eeprom_Write(EEPROM_SCRIPTBUF_INLOOP, x); \
                  06204 			;		gScriptBuf.inLoop = x; \
                  06205 			;}
                  06206 			;
                  06207 			;/**
                  06208 			; * Setter for ScriptBuf.read
                  06209 			; */
                  06210 			;#define ScriptBufSetRead(x) { \
                  06211 			;		Eeprom_Write(EEPROM_SCRIPTBUF_READ, x); \
                  06212 			;		gScriptBuf.read = x; \
                  06213 			;}
                  06214 			;
                  06215 			;/**
                  06216 			; * Setter for ScriptBuf.write
                  06217 			; */
                  06218 			;#define ScriptBufSetWrite(x) { \
                  06219 			;		Eeprom_Write(EEPROM_SCRIPTBUF_WRITE, x); \
                  06220 			;		gScriptBuf.write = x; \
                  06221 			;}
                  06222 			;
                  06223 			;/**
                  06224 			; * Prototyp - Private function
                  06225 			; * save command to eeprom
                  06226 			; */
                  06227 			;uns8 ScriptCtrl_Write(const struct led_cmd *pCmd);
                  06228 			;
                  06229 			;/* private globals */
                  06230 			;struct ScriptBuf gScriptBuf;
                  06231 			;struct led_cmd nextCmd;
                  06232 			;
                  06233 			;uns8 ScriptCtrl_Add(struct led_cmd *pCmd)
                  06234 			;{
                  06235 ScriptCtrl_Add
                  06236 			;	/* We have to reject all commands until buffer was cleared completely */
                  06237 			;	if(gScriptBuf.isClearing) {
001EDC 0100       06238 	MOVLB 0
001EDE B36B       06239 	BTFSC gScriptBuf+11,1,1
                  06240 			;		return SCRIPTBUFFER_FULL;
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 105

ADDR   CODE       LINE  SOURCE

001EE0 0C01       06241 	RETLW 1
                  06242 			;	}
                  06243 			;
                  06244 			;	switch(pCmd->cmd)
001EE2 0E02       06245 	MOVLW 2
001EE4 6EEA       06246 	MOVWF FSR0+1,0
001EE6 C009 FFE9  06247 	MOVFF pCmd_3,FSR0
001EEA 50EF       06248 	MOVF  INDF0,W,0
001EEC 0AF8       06249 	XORLW 248
001EEE B4D8       06250 	BTFSC 0xFD8,Zero_,0
001EF0 D028       06251 	BRA   m199
001EF2 0A0F       06252 	XORLW 15
001EF4 B4D8       06253 	BTFSC 0xFD8,Zero_,0
001EF6 D028       06254 	BRA   m200
001EF8 0A01       06255 	XORLW 1
001EFA B4D8       06256 	BTFSC 0xFD8,Zero_,0
001EFC D032       06257 	BRA   m201
001EFE 0A08       06258 	XORLW 8
001F00 B4D8       06259 	BTFSC 0xFD8,Zero_,0
001F02 D05B       06260 	BRA   m202
001F04 0A0B       06261 	XORLW 11
001F06 B4D8       06262 	BTFSC 0xFD8,Zero_,0
001F08 D05D       06263 	BRA   m203
001F0A 0A06       06264 	XORLW 6
001F0C B4D8       06265 	BTFSC 0xFD8,Zero_,0
001F0E D06A       06266 	BRA   m204
001F10 0A07       06267 	XORLW 7
001F12 B4D8       06268 	BTFSC 0xFD8,Zero_,0
001F14 D068       06269 	BRA   m205
001F16 0A05       06270 	XORLW 5
001F18 B4D8       06271 	BTFSC 0xFD8,Zero_,0
001F1A D09B       06272 	BRA   m206
001F1C 0A01       06273 	XORLW 1
001F1E B4D8       06274 	BTFSC 0xFD8,Zero_,0
001F20 D09D       06275 	BRA   m207
001F22 0A1E       06276 	XORLW 30
001F24 B4D8       06277 	BTFSC 0xFD8,Zero_,0
001F26 D09B       06278 	BRA   m208
001F28 0A03       06279 	XORLW 3
001F2A B4D8       06280 	BTFSC 0xFD8,Zero_,0
001F2C D099       06281 	BRA   m209
001F2E 0A11       06282 	XORLW 17
001F30 B4D8       06283 	BTFSC 0xFD8,Zero_,0
001F32 D097       06284 	BRA   m210
001F34 0A05       06285 	XORLW 5
001F36 B4D8       06286 	BTFSC 0xFD8,Zero_,0
001F38 D099       06287 	BRA   m211
001F3A 0A12       06288 	XORLW 18
001F3C B4D8       06289 	BTFSC 0xFD8,Zero_,0
001F3E D09B       06290 	BRA   m212
001F40 D09B       06291 	BRA   m213
                  06292 			;	{
                  06293 			;	case CLEAR_SCRIPT:
                  06294 			;		//Trace_String("Clearing script buffer;");
                  06295 			;		gScriptBuf.isClearing = TRUE;
001F42 0100       06296 m199	MOVLB 0
001F44 836B       06297 	BSF   gScriptBuf+11,1,1
                  06298 			;		return OK;
001F46 0C00       06299 	RETLW 0
                  06300 			;	case LOOP_ON:
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 106

ADDR   CODE       LINE  SOURCE

                  06301 			;		gScriptBuf.loopStart[gScriptBuf.loopDepth] = gScriptBuf.write;
001F48 6AEA       06302 m200	CLRF  FSR0+1,0
001F4A 0E62       06303 	MOVLW 98
001F4C 0100       06304 	MOVLB 0
001F4E 2566       06305 	ADDWF gScriptBuf+6,W,1
001F50 6EE9       06306 	MOVWF FSR0,0
001F52 C069 FFEF  06307 	MOVFF gScriptBuf+9,INDF0
                  06308 			;		gScriptBuf.loopDepth++;
001F56 2B66       06309 	INCF  gScriptBuf+6,1,1
                  06310 			;		return ScriptCtrl_Write(pCmd);
001F58 0E02       06311 	MOVLW 2
001F5A 6E0E       06312 	MOVWF pCmd_4+1,0
001F5C C009 F00D  06313 	MOVFF pCmd_3,pCmd_4
001F60 D1BB       06314 	BRA   ScriptCtrl_Write
                  06315 			;	case LOOP_OFF:
                  06316 			;	{
                  06317 			;		gScriptBuf.loopDepth--;
001F62 0100       06318 m201	MOVLB 0
001F64 0766       06319 	DECF  gScriptBuf+6,1,1
                  06320 			;		uns8 loopStart = gScriptBuf.loopStart[gScriptBuf.loopDepth];
001F66 6AEA       06321 	CLRF  FSR0+1,0
001F68 0E62       06322 	MOVLW 98
001F6A 2566       06323 	ADDWF gScriptBuf+6,W,1
001F6C 6EE9       06324 	MOVWF FSR0,0
001F6E CFEF F00A  06325 	MOVFF INDF0,loopStart
                  06326 			;		pCmd->data.loopEnd.startIndex = ScriptBufInc(loopStart);
001F72 0E02       06327 	MOVLW 2
001F74 6EEA       06328 	MOVWF FSR0+1,0
001F76 2809       06329 	INCF  pCmd_3,W,0
001F78 6EE9       06330 	MOVWF FSR0,0
001F7A 280A       06331 	INCF  loopStart,W,0
001F7C 0B3F       06332 	ANDLW 63
001F7E 6EEF       06333 	MOVWF INDF0,0
                  06334 			;		pCmd->data.loopEnd.depth = gScriptBuf.loopDepth;
001F80 0E02       06335 	MOVLW 2
001F82 6EEA       06336 	MOVWF FSR0+1,0
001F84 0E04       06337 	MOVLW 4
001F86 2409       06338 	ADDWF pCmd_3,W,0
001F88 6EE9       06339 	MOVWF FSR0,0
001F8A C066 FFEF  06340 	MOVFF gScriptBuf+6,INDF0
                  06341 			;		uns8 numLoops = pCmd->data.loopEnd.numLoops;
001F8E 0E02       06342 	MOVLW 2
001F90 6EEA       06343 	MOVWF FSR0+1,0
001F92 0E03       06344 	MOVLW 3
001F94 2409       06345 	ADDWF pCmd_3,W,0
001F96 6EE9       06346 	MOVWF FSR0,0
001F98 CFEF F00B  06347 	MOVFF INDF0,numLoops
                  06348 			;		pCmd->data.loopEnd.counter = numLoops;
001F9C 0E02       06349 	MOVLW 2
001F9E 6EEA       06350 	MOVWF FSR0+1,0
001FA0 0E02       06351 	MOVLW 2
001FA2 2409       06352 	ADDWF pCmd_3,W,0
001FA4 6EE9       06353 	MOVWF FSR0,0
001FA6 C00B FFEF  06354 	MOVFF numLoops,INDF0
                  06355 			;		/*Trace_String("Add LOOP_OFF: ");
                  06356 			;		Trace_Hex(gScriptBuf.write);
                  06357 			;		Trace_Hex(pCmd->data.loopEnd.startIndex);
                  06358 			;		Trace_Hex(pCmd->data.loopEnd.depth);
                  06359 			;		Trace_Hex(pCmd->data.loopEnd.counter);
                  06360 			;		Trace_String(";");*/
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 107

ADDR   CODE       LINE  SOURCE

                  06361 			;		uns8 retVal = ScriptCtrl_Write(pCmd);
001FAA 0E02       06362 	MOVLW 2
001FAC 6E0E       06363 	MOVWF pCmd_4+1,0
001FAE C009 F00D  06364 	MOVFF pCmd_3,pCmd_4
001FB2 D992       06365 	RCALL ScriptCtrl_Write
001FB4 6E0C       06366 	MOVWF retVal,0
                  06367 			;#ifdef cc3200
                  06368 			;		Eeprom_Save(true);
                  06369 			;#endif
                  06370 			;		return retVal;
001FB6 500C       06371 	MOVF  retVal,W,0
001FB8 0012       06372 	RETURN
                  06373 			;	}
                  06374 			;	case WAIT:
                  06375 			;	{
                  06376 			;		return ScriptCtrl_Write(pCmd);
001FBA 0E02       06377 m202	MOVLW 2
001FBC 6E0E       06378 	MOVWF pCmd_4+1,0
001FBE C009 F00D  06379 	MOVFF pCmd_3,pCmd_4
001FC2 D18A       06380 	BRA   ScriptCtrl_Write
                  06381 			;	}
                  06382 			;#ifndef cc3200
                  06383 			;	case START_BL:
                  06384 			;	{
                  06385 			;		CommandIO_CreateResponse(&g_ResponseBuf, START_BL, OK);
001FC4 6A0A       06386 m203	CLRF  mFrame_2,0
001FC6 0E05       06387 	MOVLW 5
001FC8 6E0B       06388 	MOVWF mFrame_2+1,0
001FCA 0EF5       06389 	MOVLW 245
001FCC 6E0C       06390 	MOVWF cmd,0
001FCE 6A0D       06391 	CLRF  mState,0
001FD0 EC66 F00B  06392 	CALL  CommandIO_CreateResponse
                  06393 			;		CommandIO_SendResponse(&g_ResponseBuf);
001FD4 6A0A       06394 	CLRF  mFrame,0
001FD6 0E05       06395 	MOVLW 5
001FD8 6E0B       06396 	MOVWF mFrame+1,0
001FDA ECFE F00A  06397 	CALL  CommandIO_SendResponse
                  06398 			;		Platform_EnableBootloaderAutostart();
001FDE DC3B       06399 	RCALL Platform_EnableBootloaderAutostart
                  06400 			;		softReset();
001FE0 00FF       06401 	RESET
                  06402 			;		/* never reach this */
                  06403 			;		return OK;
001FE2 0C00       06404 	RETLW 0
                  06405 			;	}
                  06406 			;#endif /* cc3200 */
                  06407 			;#ifdef __CC8E__
                  06408 			;	case GET_RTC:
                  06409 			;	{
                  06410 			;		return OK;
001FE4 0C00       06411 m204	RETLW 0
                  06412 			;	}
                  06413 			;	case SET_RTC:
                  06414 			;	{
                  06415 			;		g_RtcTime.tm_year = pCmd->data.set_rtc.tm_year;
001FE6 0E02       06416 m205	MOVLW 2
001FE8 6EEA       06417 	MOVWF FSR0+1,0
001FEA 0E06       06418 	MOVLW 6
001FEC 2409       06419 	ADDWF pCmd_3,W,0
001FEE 6EE9       06420 	MOVWF FSR0,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 108

ADDR   CODE       LINE  SOURCE

001FF0 CFEF F029  06421 	MOVFF INDF0,g_RtcTime+5
                  06422 			;		g_RtcTime.tm_mon = pCmd->data.set_rtc.tm_mon;
001FF4 0E02       06423 	MOVLW 2
001FF6 6EEA       06424 	MOVWF FSR0+1,0
001FF8 0E05       06425 	MOVLW 5
001FFA 2409       06426 	ADDWF pCmd_3,W,0
001FFC 6EE9       06427 	MOVWF FSR0,0
001FFE CFEF F028  06428 	MOVFF INDF0,g_RtcTime+4
                  06429 			;		g_RtcTime.tm_mday = pCmd->data.set_rtc.tm_mday;
002002 0E02       06430 	MOVLW 2
002004 6EEA       06431 	MOVWF FSR0+1,0
002006 0E04       06432 	MOVLW 4
002008 2409       06433 	ADDWF pCmd_3,W,0
00200A 6EE9       06434 	MOVWF FSR0,0
00200C CFEF F027  06435 	MOVFF INDF0,g_RtcTime+3
                  06436 			;		g_RtcTime.tm_wday = pCmd->data.set_rtc.tm_wday;
002010 0E02       06437 	MOVLW 2
002012 6EEA       06438 	MOVWF FSR0+1,0
002014 0E07       06439 	MOVLW 7
002016 2409       06440 	ADDWF pCmd_3,W,0
002018 6EE9       06441 	MOVWF FSR0,0
00201A CFEF F02A  06442 	MOVFF INDF0,g_RtcTime+6
                  06443 			;		g_RtcTime.tm_hour = pCmd->data.set_rtc.tm_hour;
00201E 0E02       06444 	MOVLW 2
002020 6EEA       06445 	MOVWF FSR0+1,0
002022 0E03       06446 	MOVLW 3
002024 2409       06447 	ADDWF pCmd_3,W,0
002026 6EE9       06448 	MOVWF FSR0,0
002028 CFEF F026  06449 	MOVFF INDF0,g_RtcTime+2
                  06450 			;		g_RtcTime.tm_min = pCmd->data.set_rtc.tm_min;
00202C 0E02       06451 	MOVLW 2
00202E 6EEA       06452 	MOVWF FSR0+1,0
002030 0E02       06453 	MOVLW 2
002032 2409       06454 	ADDWF pCmd_3,W,0
002034 6EE9       06455 	MOVWF FSR0,0
002036 CFEF F025  06456 	MOVFF INDF0,g_RtcTime+1
                  06457 			;		g_RtcTime.tm_sec = pCmd->data.set_rtc.tm_sec;
00203A 0E02       06458 	MOVLW 2
00203C 6EEA       06459 	MOVWF FSR0+1,0
00203E 2809       06460 	INCF  pCmd_3,W,0
002040 6EE9       06461 	MOVWF FSR0,0
002042 CFEF F024  06462 	MOVFF INDF0,g_RtcTime
                  06463 			;		Rtc_Ctl(RTC_SET_TIME, &g_RtcTime);
002046 6A0E       06464 	CLRF  req,0
002048 0E24       06465 	MOVLW 36
00204A 6E0F       06466 	MOVWF pRtcTime,0
00204C 6A10       06467 	CLRF  pRtcTime+1,0
00204E DC9F       06468 	RCALL Rtc_Ctl
                  06469 			;		return OK;
002050 0C00       06470 	RETLW 0
                  06471 			;	}
                  06472 			;#endif /* #ifdef __CC8E__ */
                  06473 			;	case SET_COLOR_DIRECT:
                  06474 			;	{
                  06475 			;		Ledstrip_SetColorDirect((uns8 *)&pCmd->data.set_color_direct.ptr_led_array);
002052 2809       06476 m206	INCF  pCmd_3,W,0
002054 6E0A       06477 	MOVWF pValues,0
002056 EC71 F002  06478 	CALL  Ledstrip_SetColorDirect
                  06479 			;		return NO_RESPONSE;
00205A 0C05       06480 	RETLW 5
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 109

ADDR   CODE       LINE  SOURCE

                  06481 			;	}
                  06482 			;#ifdef __CC8E__
                  06483 			;	case GET_CYCLETIME:
                  06484 			;	{
                  06485 			;		return OK;
00205C 0C00       06486 m207	RETLW 0
                  06487 			;	}
                  06488 			;	case GET_TRACE:
                  06489 			;	{
                  06490 			;		return OK;
00205E 0C00       06491 m208	RETLW 0
                  06492 			;	}
                  06493 			;#endif /* #ifdef __CC8E__ */
                  06494 			;	case GET_FW_VERSION:
                  06495 			;	{
                  06496 			;		return OK;
002060 0C00       06497 m209	RETLW 0
                  06498 			;	}
                  06499 			;	case SET_FADE:
                  06500 			;	{
                  06501 			;		return ScriptCtrl_Write(pCmd);
002062 0E02       06502 m210	MOVLW 2
002064 6E0E       06503 	MOVWF pCmd_4+1,0
002066 C009 F00D  06504 	MOVFF pCmd_3,pCmd_4
00206A D136       06505 	BRA   ScriptCtrl_Write
                  06506 			;	}
                  06507 			;	case SET_GRADIENT:
                  06508 			;	{
                  06509 			;		return ScriptCtrl_Write(pCmd);
00206C 0E02       06510 m211	MOVLW 2
00206E 6E0E       06511 	MOVWF pCmd_4+1,0
002070 C009 F00D  06512 	MOVFF pCmd_3,pCmd_4
002074 D131       06513 	BRA   ScriptCtrl_Write
                  06514 			;	}
                  06515 			;	case GET_LED_TYP:
                  06516 			;	{
                  06517 			;		return OK;
002076 0C00       06518 m212	RETLW 0
                  06519 			;	}
                  06520 			;	default:
                  06521 			;	{
                  06522 			;		return BAD_COMMAND_CODE;
002078 0C04       06523 m213	RETLW 4
                  06524 			;	}
                  06525 			;	}
                  06526 			;
                  06527 			;}
                  06528 			;
                  06529 			;void ScriptCtrl_Clear(void)
                  06530 			;{
                  06531 ScriptCtrl_Clear
                  06532 			;	ScriptBufSetInLoop(FALSE);
00207A 0EFD       06533 	MOVLW 253
00207C 6E1A       06534 	MOVWF adress,0
00207E 0E03       06535 	MOVLW 3
002080 6E1B       06536 	MOVWF adress+1,0
002082 6A1C       06537 	CLRF  data_2,0
002084 EC71 F001  06538 	CALL  Eeprom_Write
002088 0100       06539 	MOVLB 0
00208A 6B6A       06540 	CLRF  gScriptBuf+10,1
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 110

ADDR   CODE       LINE  SOURCE

                  06541 			;	ScriptBufSetRead(EEPROM_SCRIPTBUF_BASE);
00208C 0EFB       06542 	MOVLW 251
00208E 6E1A       06543 	MOVWF adress,0
002090 0E03       06544 	MOVLW 3
002092 6E1B       06545 	MOVWF adress+1,0
002094 6A1C       06546 	CLRF  data_2,0
002096 EC71 F001  06547 	CALL  Eeprom_Write
00209A 6B68       06548 	CLRF  gScriptBuf+8,1
                  06549 			;	ScriptBufSetWrite(EEPROM_SCRIPTBUF_BASE);
00209C 0EF9       06550 	MOVLW 249
00209E 6E1A       06551 	MOVWF adress,0
0020A0 0E03       06552 	MOVLW 3
0020A2 6E1B       06553 	MOVWF adress+1,0
0020A4 6A1C       06554 	CLRF  data_2,0
0020A6 EC71 F001  06555 	CALL  Eeprom_Write
0020AA 6B69       06556 	CLRF  gScriptBuf+9,1
                  06557 			;	gScriptBuf.execute = gScriptBuf.read;
0020AC C068 F067  06558 	MOVFF gScriptBuf+8,gScriptBuf+7
                  06559 			;	gScriptBuf.waitValue = 0;
0020B0 6B60       06560 	CLRF  gScriptBuf,1
0020B2 6B61       06561 	CLRF  gScriptBuf+1,1
                  06562 			;	gScriptBuf.isClearing = FALSE;
0020B4 936B       06563 	BCF   gScriptBuf+11,1,1
                  06564 			;}
0020B6 0012       06565 	RETURN
                  06566 			;
                  06567 			;void ScriptCtrl_Init(void)
                  06568 			;{
                  06569 ScriptCtrl_Init
                  06570 			;	Eeprom_Init();
                  06571 			;	gScriptBuf.inLoop = Eeprom_Read(EEPROM_SCRIPTBUF_INLOOP);
0020B8 0EFD       06572 	MOVLW 253
0020BA 6E0F       06573 	MOVWF adress_2,0
0020BC 0E03       06574 	MOVLW 3
0020BE 6E10       06575 	MOVWF adress_2+1,0
0020C0 EC8B F001  06576 	CALL  Eeprom_Read
0020C4 0100       06577 	MOVLB 0
0020C6 6F6A       06578 	MOVWF gScriptBuf+10,1
                  06579 			;	gScriptBuf.read = Eeprom_Read(EEPROM_SCRIPTBUF_READ);
0020C8 0EFB       06580 	MOVLW 251
0020CA 6E0F       06581 	MOVWF adress_2,0
0020CC 0E03       06582 	MOVLW 3
0020CE 6E10       06583 	MOVWF adress_2+1,0
0020D0 EC8B F001  06584 	CALL  Eeprom_Read
0020D4 6F68       06585 	MOVWF gScriptBuf+8,1
                  06586 			;	gScriptBuf.write = Eeprom_Read(EEPROM_SCRIPTBUF_WRITE);
0020D6 0EF9       06587 	MOVLW 249
0020D8 6E0F       06588 	MOVWF adress_2,0
0020DA 0E03       06589 	MOVLW 3
0020DC 6E10       06590 	MOVWF adress_2+1,0
0020DE EC8B F001  06591 	CALL  Eeprom_Read
0020E2 6F69       06592 	MOVWF gScriptBuf+9,1
                  06593 			;	gScriptBuf.execute = gScriptBuf.read;
0020E4 C068 F067  06594 	MOVFF gScriptBuf+8,gScriptBuf+7
                  06595 			;	gScriptBuf.isRunning = TRUE;
0020E8 816B       06596 	BSF   gScriptBuf+11,0,1
                  06597 			;}
0020EA 0012       06598 	RETURN
                  06599 			;//TODO Add a Methode to test the Errorbits and there responses
                  06600 			;
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 111

ADDR   CODE       LINE  SOURCE

                  06601 			;void ScriptCtrl_Run(void)
                  06602 			;{
                  06603 ScriptCtrl_Run
                  06604 			;	/* delete command was triggered? */
                  06605 			;	if(gScriptBuf.isClearing) {
0020EC 0100       06606 	MOVLB 0
0020EE B36B       06607 	BTFSC gScriptBuf+11,1,1
                  06608 			;		ScriptCtrl_Clear();
0020F0 DFC4       06609 	RCALL ScriptCtrl_Clear
                  06610 			;	}
                  06611 			;
                  06612 			;	if(!gScriptBuf.isRunning) return;
0020F2 0100       06613 	MOVLB 0
0020F4 A16B       06614 	BTFSS gScriptBuf+11,0,1
0020F6 0012       06615 	RETURN
                  06616 			;
                  06617 			;	if(gScriptBuf.waitValue > 0) {
0020F8 0100       06618 	MOVLB 0
0020FA 5160       06619 	MOVF  gScriptBuf,W,1
0020FC 1161       06620 	IORWF gScriptBuf+1,W,1
0020FE A4D8       06621 	BTFSS 0xFD8,Zero_,0
                  06622 			;		return;
002100 0012       06623 	RETURN
                  06624 			;	}
                  06625 			;
                  06626 			;	/* cmd available? */
                  06627 			;	if(gScriptBuf.execute == gScriptBuf.write) {
002102 0100       06628 	MOVLB 0
002104 5167       06629 	MOVF  gScriptBuf+7,W,1
002106 6369       06630 	CPFSEQ gScriptBuf+9,1
002108 D001       06631 	BRA   m214
                  06632 			;		return;
00210A 0012       06633 	RETURN
                  06634 			;	}
                  06635 			;
                  06636 			;	/* read next cmd from buffer */
                  06637 			;	uns16 tempAddress = ScriptBufAddr(gScriptBuf.execute);
00210C C067 F01E  06638 m214	MOVFF gScriptBuf+7,arg1
002110 0E0B       06639 	MOVLW 11
002112 ECE0 F001  06640 	CALL  _mult8x8
002116 5020       06641 	MOVF  rval,W,0
002118 6E07       06642 	MOVWF tempAddress,0
00211A 5021       06643 	MOVF  rval+1,W,0
00211C 6E08       06644 	MOVWF tempAddress+1,0
                  06645 			;	Eeprom_ReadBlock((uns8 *)&nextCmd, tempAddress, sizeof(nextCmd));
00211E 0E77       06646 	MOVLW 119
002120 6E09       06647 	MOVWF array_2,0
002122 C007 F00A  06648 	MOVFF tempAddress,adress_4
002126 C008 F00B  06649 	MOVFF tempAddress+1,adress_4+1
00212A 0E0B       06650 	MOVLW 11
00212C 6E0C       06651 	MOVWF length_3,0
00212E ECB6 F001  06652 	CALL  Eeprom_ReadBlock
                  06653 			;
                  06654 			;	switch(nextCmd.cmd)
002132 0100       06655 	MOVLB 0
002134 5177       06656 	MOVF  nextCmd,W,1
002136 0AF7       06657 	XORLW 247
002138 B4D8       06658 	BTFSC 0xFD8,Zero_,0
00213A D00D       06659 	BRA   m215
00213C 0A01       06660 	XORLW 1
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 112

ADDR   CODE       LINE  SOURCE

00213E B4D8       06661 	BTFSC 0xFD8,Zero_,0
002140 D019       06662 	BRA   m216
002142 0A0A       06663 	XORLW 10
002144 B4D8       06664 	BTFSC 0xFD8,Zero_,0
002146 D065       06665 	BRA   m220
002148 0A05       06666 	XORLW 5
00214A B4D8       06667 	BTFSC 0xFD8,Zero_,0
00214C D086       06668 	BRA   m222
00214E 0A07       06669 	XORLW 7
002150 B4D8       06670 	BTFSC 0xFD8,Zero_,0
002152 D0A6       06671 	BRA   m224
002154 D0C0       06672 	BRA   m225
                  06673 			;	{
                  06674 			;	case LOOP_ON:
                  06675 			;	{
                  06676 			;		//Trace_String("LOOP_ON;");
                  06677 			;		/* move execute pointer to the next command */
                  06678 			;		gScriptBuf.execute = ScriptBufInc(gScriptBuf.execute);
002156 0100       06679 m215	MOVLB 0
002158 2967       06680 	INCF  gScriptBuf+7,W,1
00215A 0B3F       06681 	ANDLW 63
00215C 6F67       06682 	MOVWF gScriptBuf+7,1
                  06683 			;		ScriptBufSetInLoop(TRUE);
00215E 0EFD       06684 	MOVLW 253
002160 6E1A       06685 	MOVWF adress,0
002162 0E03       06686 	MOVLW 3
002164 6E1B       06687 	MOVWF adress+1,0
002166 0E01       06688 	MOVLW 1
002168 6E1C       06689 	MOVWF data_2,0
00216A EC71 F001  06690 	CALL  Eeprom_Write
00216E 0E01       06691 	MOVLW 1
002170 6F6A       06692 	MOVWF gScriptBuf+10,1
                  06693 			;		break;
002172 D0B1       06694 	BRA   m225
                  06695 			;	}
                  06696 			;	case LOOP_OFF:
                  06697 			;	{
                  06698 			;		if(LOOP_INFINITE == nextCmd.data.loopEnd.counter) {
002174 0100       06699 m216	MOVLB 0
002176 5379       06700 	MOVF  nextCmd+2,1,1
002178 A4D8       06701 	BTFSS 0xFD8,Zero_,0
00217A D003       06702 	BRA   m217
                  06703 			;			//Trace_String("End of infinite loop reached;");
                  06704 			;			/* move execute pointer to the top of this loop */
                  06705 			;			gScriptBuf.execute = nextCmd.data.loopEnd.startIndex;
00217C C078 F067  06706 	MOVFF nextCmd+1,gScriptBuf+7
                  06707 			;		} else if(nextCmd.data.loopEnd.counter > 1)   {
002180 D0AA       06708 	BRA   m225
002182 0E01       06709 m217	MOVLW 1
002184 0100       06710 	MOVLB 0
002186 6579       06711 	CPFSGT nextCmd+2,1
002188 D00F       06712 	BRA   m218
                  06713 			;			/*Trace_String("normal loop iteration");
                  06714 			;			//Trace_Hex(nextCmd.data.loopEnd.counter);
                  06715 			;			//Trace_Hex(nextCmd.data.loopEnd.depth);
                  06716 			;			Trace_String(";");*/
                  06717 			;			/* update counter and set execute pointer to start of the loop */
                  06718 			;			nextCmd.data.loopEnd.counter--;
00218A 0779       06719 	DECF  nextCmd+2,1,1
                  06720 			;			Eeprom_WriteBlock((uns8 *)&nextCmd, tempAddress, sizeof(struct led_cmd));
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 113

ADDR   CODE       LINE  SOURCE

00218C 0E77       06721 	MOVLW 119
00218E 6E12       06722 	MOVWF array,0
002190 6A13       06723 	CLRF  array+1,0
002192 C007 F014  06724 	MOVFF tempAddress,adress_3
002196 C008 F015  06725 	MOVFF tempAddress+1,adress_3+1
00219A 0E0B       06726 	MOVLW 11
00219C 6E16       06727 	MOVWF length_2,0
00219E EC96 F001  06728 	CALL  Eeprom_WriteBlock
                  06729 			;
                  06730 			;			/* move execute pointer to the top of this loop */
                  06731 			;			gScriptBuf.execute = nextCmd.data.loopEnd.startIndex;
0021A2 C078 F067  06732 	MOVFF nextCmd+1,gScriptBuf+7
                  06733 			;		} else {
0021A6 D097       06734 	BRA   m225
                  06735 			;			if(0 == nextCmd.data.loopEnd.depth) {
0021A8 0100       06736 m218	MOVLB 0
0021AA 537B       06737 	MOVF  nextCmd+4,1,1
0021AC A4D8       06738 	BTFSS 0xFD8,Zero_,0
0021AE D016       06739 	BRA   m219
                  06740 			;				//Trace_String("End of top loop reached;");
                  06741 			;				/* move execute pointer to the next command */
                  06742 			;				gScriptBuf.execute = ScriptBufInc(gScriptBuf.execute);
0021B0 2967       06743 	INCF  gScriptBuf+7,W,1
0021B2 0B3F       06744 	ANDLW 63
0021B4 6F67       06745 	MOVWF gScriptBuf+7,1
                  06746 			;
                  06747 			;				/* delete loop body from buffer */
                  06748 			;				ScriptBufSetRead(gScriptBuf.execute);
0021B6 0EFB       06749 	MOVLW 251
0021B8 6E1A       06750 	MOVWF adress,0
0021BA 0E03       06751 	MOVLW 3
0021BC 6E1B       06752 	MOVWF adress+1,0
0021BE C067 F01C  06753 	MOVFF gScriptBuf+7,data_2
0021C2 EC71 F001  06754 	CALL  Eeprom_Write
0021C6 C067 F068  06755 	MOVFF gScriptBuf+7,gScriptBuf+8
                  06756 			;				ScriptBufSetInLoop(FALSE);
0021CA 0EFD       06757 	MOVLW 253
0021CC 6E1A       06758 	MOVWF adress,0
0021CE 0E03       06759 	MOVLW 3
0021D0 6E1B       06760 	MOVWF adress+1,0
0021D2 6A1C       06761 	CLRF  data_2,0
0021D4 EC71 F001  06762 	CALL  Eeprom_Write
0021D8 6B6A       06763 	CLRF  gScriptBuf+10,1
                  06764 			;			} else {
0021DA D07D       06765 	BRA   m225
                  06766 			;				//Trace_String("End of inner loop reached;");
                  06767 			;				/* reinit counter for next iteration */
                  06768 			;				nextCmd.data.loopEnd.counter = nextCmd.data.loopEnd.numLoops;
0021DC C07A F079  06769 m219	MOVFF nextCmd+3,nextCmd+2
                  06770 			;				uns16 tempAddress = ScriptBufAddr(gScriptBuf.execute);
0021E0 C067 F01E  06771 	MOVFF gScriptBuf+7,arg1
0021E4 0E0B       06772 	MOVLW 11
0021E6 ECE0 F001  06773 	CALL  _mult8x8
0021EA 5020       06774 	MOVF  rval,W,0
0021EC 6E09       06775 	MOVWF tempAddress_2,0
0021EE 5021       06776 	MOVF  rval+1,W,0
0021F0 6E0A       06777 	MOVWF tempAddress_2+1,0
                  06778 			;				Eeprom_WriteBlock((uns8 *)&nextCmd, tempAddress, sizeof(struct led_cmd));
0021F2 0E77       06779 	MOVLW 119
0021F4 6E12       06780 	MOVWF array,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 114

ADDR   CODE       LINE  SOURCE

0021F6 6A13       06781 	CLRF  array+1,0
0021F8 C009 F014  06782 	MOVFF tempAddress_2,adress_3
0021FC C00A F015  06783 	MOVFF tempAddress_2+1,adress_3+1
002200 0E0B       06784 	MOVLW 11
002202 6E16       06785 	MOVWF length_2,0
002204 EC96 F001  06786 	CALL  Eeprom_WriteBlock
                  06787 			;
                  06788 			;				/* move execute pointer to the next command */
                  06789 			;				gScriptBuf.execute = ScriptBufInc(gScriptBuf.execute);
002208 0100       06790 	MOVLB 0
00220A 2967       06791 	INCF  gScriptBuf+7,W,1
00220C 0B3F       06792 	ANDLW 63
00220E 6F67       06793 	MOVWF gScriptBuf+7,1
                  06794 			;			}
                  06795 			;		}
                  06796 			;		break;
002210 D062       06797 	BRA   m225
                  06798 			;	}
                  06799 			;	case SET_FADE:
                  06800 			;	{
                  06801 			;		Ledstrip_SetFade(&nextCmd.data.set_fade);
002212 0E78       06802 m220	MOVLW 120
002214 6E09       06803 	MOVWF pCmd,0
002216 EC93 F003  06804 	CALL  Ledstrip_SetFade
                  06805 			;		if(nextCmd.data.set_fade.parallelFade == 0) {
00221A 0100       06806 	MOVLB 0
00221C 537F       06807 	MOVF  nextCmd+8,1,1
00221E A4D8       06808 	BTFSS 0xFD8,Zero_,0
002220 D00A       06809 	BRA   m221
                  06810 			;			gScriptBuf.waitValue = ntohs(nextCmd.data.set_fade.fadeTmms);
002222 C080 F01E  06811 	MOVFF nextCmd+9,networkShort
002226 C081 F01F  06812 	MOVFF nextCmd+10,networkShort+1
00222A EC37 F00C  06813 	CALL  ntohs
00222E C020 F060  06814 	MOVFF retval_2,gScriptBuf
002232 C021 F061  06815 	MOVFF retval_2+1,gScriptBuf+1
                  06816 			;		}
                  06817 			;
                  06818 			;		/* move execute pointer to the next command */
                  06819 			;		gScriptBuf.execute = ScriptBufInc(gScriptBuf.execute);
002236 0100       06820 m221	MOVLB 0
002238 2967       06821 	INCF  gScriptBuf+7,W,1
00223A 0B3F       06822 	ANDLW 63
00223C 6F67       06823 	MOVWF gScriptBuf+7,1
                  06824 			;		if(!gScriptBuf.inLoop) {
00223E 536A       06825 	MOVF  gScriptBuf+10,1,1
002240 A4D8       06826 	BTFSS 0xFD8,Zero_,0
002242 D049       06827 	BRA   m225
                  06828 			;			ScriptBufSetRead(gScriptBuf.execute);
002244 0EFB       06829 	MOVLW 251
002246 6E1A       06830 	MOVWF adress,0
002248 0E03       06831 	MOVLW 3
00224A 6E1B       06832 	MOVWF adress+1,0
00224C C067 F01C  06833 	MOVFF gScriptBuf+7,data_2
002250 EC71 F001  06834 	CALL  Eeprom_Write
002254 C067 F068  06835 	MOVFF gScriptBuf+7,gScriptBuf+8
                  06836 			;		}
                  06837 			;		break;
002258 D03E       06838 	BRA   m225
                  06839 			;	}
                  06840 			;	case SET_GRADIENT:
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 115

ADDR   CODE       LINE  SOURCE

                  06841 			;	{
                  06842 			;		Ledstrip_SetGradient(&nextCmd.data.set_gradient);
00225A 0E78       06843 m222	MOVLW 120
00225C 6E09       06844 	MOVWF pCmd_2,0
00225E EC42 F005  06845 	CALL  Ledstrip_SetGradient
                  06846 			;		if((nextCmd.data.set_gradient.parallelAndOffset & 0x80) == 0) {
002262 0100       06847 	MOVLB 0
002264 BF7E       06848 	BTFSC nextCmd+7,7,1
002266 D00A       06849 	BRA   m223
                  06850 			;			gScriptBuf.waitValue = ntohs(nextCmd.data.set_gradient.fadeTmms);
002268 C080 F01E  06851 	MOVFF nextCmd+9,networkShort
00226C C081 F01F  06852 	MOVFF nextCmd+10,networkShort+1
002270 EC37 F00C  06853 	CALL  ntohs
002274 C020 F060  06854 	MOVFF retval_2,gScriptBuf
002278 C021 F061  06855 	MOVFF retval_2+1,gScriptBuf+1
                  06856 			;		}
                  06857 			;
                  06858 			;		/* move execute pointer to the next command */
                  06859 			;		gScriptBuf.execute = ScriptBufInc(gScriptBuf.execute);
00227C 0100       06860 m223	MOVLB 0
00227E 2967       06861 	INCF  gScriptBuf+7,W,1
002280 0B3F       06862 	ANDLW 63
002282 6F67       06863 	MOVWF gScriptBuf+7,1
                  06864 			;		if(!gScriptBuf.inLoop) {
002284 536A       06865 	MOVF  gScriptBuf+10,1,1
002286 A4D8       06866 	BTFSS 0xFD8,Zero_,0
002288 D026       06867 	BRA   m225
                  06868 			;			ScriptBufSetRead(gScriptBuf.execute);
00228A 0EFB       06869 	MOVLW 251
00228C 6E1A       06870 	MOVWF adress,0
00228E 0E03       06871 	MOVLW 3
002290 6E1B       06872 	MOVWF adress+1,0
002292 C067 F01C  06873 	MOVFF gScriptBuf+7,data_2
002296 EC71 F001  06874 	CALL  Eeprom_Write
00229A C067 F068  06875 	MOVFF gScriptBuf+7,gScriptBuf+8
                  06876 			;		}
                  06877 			;		break;
00229E D01B       06878 	BRA   m225
                  06879 			;	}
                  06880 			;	case WAIT:
                  06881 			;	{
                  06882 			;		/* TODO we should disable interrupts while changing waitValue */
                  06883 			;		gScriptBuf.waitValue = ntohs(nextCmd.data.wait.waitTmms);
0022A0 C078 F01E  06884 m224	MOVFF nextCmd+1,networkShort
0022A4 C079 F01F  06885 	MOVFF nextCmd+2,networkShort+1
0022A8 EC37 F00C  06886 	CALL  ntohs
0022AC C020 F060  06887 	MOVFF retval_2,gScriptBuf
0022B0 C021 F061  06888 	MOVFF retval_2+1,gScriptBuf+1
                  06889 			;		/* move execute pointer to the next command */
                  06890 			;		gScriptBuf.execute = ScriptBufInc(gScriptBuf.execute);
0022B4 0100       06891 	MOVLB 0
0022B6 2967       06892 	INCF  gScriptBuf+7,W,1
0022B8 0B3F       06893 	ANDLW 63
0022BA 6F67       06894 	MOVWF gScriptBuf+7,1
                  06895 			;		if(!gScriptBuf.inLoop) {
0022BC 536A       06896 	MOVF  gScriptBuf+10,1,1
0022BE A4D8       06897 	BTFSS 0xFD8,Zero_,0
0022C0 D00A       06898 	BRA   m225
                  06899 			;			ScriptBufSetRead(gScriptBuf.execute);
0022C2 0EFB       06900 	MOVLW 251
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 116

ADDR   CODE       LINE  SOURCE

0022C4 6E1A       06901 	MOVWF adress,0
0022C6 0E03       06902 	MOVLW 3
0022C8 6E1B       06903 	MOVWF adress+1,0
0022CA C067 F01C  06904 	MOVFF gScriptBuf+7,data_2
0022CE EC71 F001  06905 	CALL  Eeprom_Write
0022D2 C067 F068  06906 	MOVFF gScriptBuf+7,gScriptBuf+8
                  06907 			;		}
                  06908 			;		break;
                  06909 			;	}
                  06910 			;	}
                  06911 			;}
0022D6 0012       06912 m225	RETURN
                  06913 			;
                  06914 			;uns8 ScriptCtrl_Write(const struct led_cmd *pCmd)
                  06915 			;{
                  06916 ScriptCtrl_Write
                  06917 			;	/* if we write a new command, we set the scriptCtrl to running
                  06918 			;	 * ATTENTION Check if this behaviour is acceptable when whe use an alarmCtrl */
                  06919 			;	if(!gScriptBuf.isRunning) gScriptBuf.isRunning = TRUE;
0022D8 0100       06920 	MOVLB 0
0022DA A16B       06921 	BTFSS gScriptBuf+11,0,1
0022DC 816B       06922 	BSF   gScriptBuf+11,0,1
                  06923 			;
                  06924 			;	uns8 writeNext = ScriptBufInc(gScriptBuf.write);
0022DE 0100       06925 	MOVLB 0
0022E0 2969       06926 	INCF  gScriptBuf+9,W,1
0022E2 0B3F       06927 	ANDLW 63
0022E4 6E0F       06928 	MOVWF writeNext_3,0
                  06929 			;	if(writeNext != gScriptBuf.read) {
0022E6 500F       06930 	MOVF  writeNext_3,W,0
0022E8 1968       06931 	XORWF gScriptBuf+8,W,1
0022EA B4D8       06932 	BTFSC 0xFD8,Zero_,0
0022EC D020       06933 	BRA   m226
                  06934 			;		uns16 tempAddress = ScriptBufAddr(gScriptBuf.write);
0022EE C069 F01E  06935 	MOVFF gScriptBuf+9,arg1
0022F2 0E0B       06936 	MOVLW 11
0022F4 ECE0 F001  06937 	CALL  _mult8x8
0022F8 5020       06938 	MOVF  rval,W,0
0022FA 6E10       06939 	MOVWF tempAddress_3,0
0022FC 5021       06940 	MOVF  rval+1,W,0
0022FE 6E11       06941 	MOVWF tempAddress_3+1,0
                  06942 			;		Eeprom_WriteBlock((const uns8 *)pCmd, tempAddress, sizeof(struct led_cmd));
002300 C00D F012  06943 	MOVFF pCmd_4,array
002304 C00E F013  06944 	MOVFF pCmd_4+1,array+1
002308 C010 F014  06945 	MOVFF tempAddress_3,adress_3
00230C C011 F015  06946 	MOVFF tempAddress_3+1,adress_3+1
002310 0E0B       06947 	MOVLW 11
002312 6E16       06948 	MOVWF length_2,0
002314 EC96 F001  06949 	CALL  Eeprom_WriteBlock
                  06950 			;		ScriptBufSetWrite(writeNext);
002318 0EF9       06951 	MOVLW 249
00231A 6E1A       06952 	MOVWF adress,0
00231C 0E03       06953 	MOVLW 3
00231E 6E1B       06954 	MOVWF adress+1,0
002320 C00F F01C  06955 	MOVFF writeNext_3,data_2
002324 EC71 F001  06956 	CALL  Eeprom_Write
002328 C00F F069  06957 	MOVFF writeNext_3,gScriptBuf+9
                  06958 			;		return OK;
00232C 0C00       06959 	RETLW 0
                  06960 			;	}
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 117

ADDR   CODE       LINE  SOURCE

                  06961 			;	return SCRIPTBUFFER_FULL;
00232E 0C01       06962 m226	RETLW 1
                  06963 			;}
                  06964 			;
                  06965 			;void ScriptCtrl_DecrementWaitValue(void)
                  06966 			;{
                  06967 ScriptCtrl_DecrementWaitValue
                  06968 			;	if(gScriptBuf.waitValue > 0) {
002330 0100       06969 	MOVLB 0
002332 5160       06970 	MOVF  gScriptBuf,W,1
002334 1161       06971 	IORWF gScriptBuf+1,W,1
002336 B4D8       06972 	BTFSC 0xFD8,Zero_,0
002338 D003       06973 	BRA   m227
                  06974 			;		gScriptBuf.waitValue = gScriptBuf.waitValue - 1;
00233A 0760       06975 	DECF  gScriptBuf,1,1
00233C 0E00       06976 	MOVLW 0
00233E 5B61       06977 	SUBWFB gScriptBuf+1,1,1
                  06978 			;	}
                  06979 			;}
002340 0012       06980 m227	RETURN
                  06981 			;
                  06982 			;void ScriptCtrl_CheckAndDecrementWaitValue(void)
                  06983 			;{
                  06984 ScriptCtrl_CheckAndDecrementWaitValue
                  06985 			;	if(gScriptBuf.waitValue < 8) {
002342 0100       06986 	MOVLB 0
002344 5161       06987 	MOVF  gScriptBuf+1,W,1
002346 A4D8       06988 	BTFSS 0xFD8,Zero_,0
002348 D005       06989 	BRA   m228
00234A 0E08       06990 	MOVLW 8
00234C 6160       06991 	CPFSLT gScriptBuf,1
00234E D002       06992 	BRA   m228
                  06993 			;		gScriptBuf.waitValue = 0;
002350 6B60       06994 	CLRF  gScriptBuf,1
002352 6B61       06995 	CLRF  gScriptBuf+1,1
                  06996 			;	}
                  06997 			;}
002354 0012       06998 m228	RETURN
                  06999 
                  07000   ; FILE ./firmware\trace.c
                  07001 			;/*
                  07002 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  07003 			;
                  07004 			; This file is part of Wifly_Light.
                  07005 			;
                  07006 			; Wifly_Light is free software: you can redistribute it and/or modify
                  07007 			; it under the terms of the GNU General Public License as published by
                  07008 			; the Free Software Foundation, either version 3 of the License, or
                  07009 			; (at your option) any later version.
                  07010 			;
                  07011 			; Wifly_Light is distributed in the hope that it will be useful,
                  07012 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  07013 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  07014 			; GNU General Public License for more details.
                  07015 			;
                  07016 			; You should have received a copy of the GNU General Public License
                  07017 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  07018 			;
                  07019 			;#include "trace.h"
                  07020 			;
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 118

ADDR   CODE       LINE  SOURCE

                  07021 			;#if defined(DEBUG) && defined(__CC8E__)
                  07022 			;struct RingBuffer g_TraceBuf;
                  07023 			;
                  07024 			;void Trace_Init(void)
                  07025 			;{
                  07026 Trace_Init
                  07027 			;	RingBuf_Init(&g_TraceBuf);
002356 0E83       07028 	MOVLW 131
002358 6E07       07029 	MOVWF pBuf,0
00235A 6A08       07030 	CLRF  pBuf+1,0
00235C EFC5 F009  07031 	GOTO  RingBuf_Init
                  07032 			;}
                  07033 			;
                  07034 			;void PutToBuf(const uns8 Byte)
                  07035 			;{
                  07036 PutToBuf
                  07037 			;	if(RingBuf_HasError(&g_TraceBuf)) return;
002360 0E83       07038 	MOVLW 131
002362 6E15       07039 	MOVWF pBuf_4,0
002364 6A16       07040 	CLRF  pBuf_4+1,0
002366 EC23 F00A  07041 	CALL  RingBuf_HasError
00236A B0D8       07042 	BTFSC 0xFD8,Carry,0
00236C 0012       07043 	RETURN
                  07044 			;	RingBuf_Put(&g_TraceBuf, Byte);
00236E 0E83       07045 	MOVLW 131
002370 6E15       07046 	MOVWF pBuf_3,0
002372 6A16       07047 	CLRF  pBuf_3+1,0
002374 C014 F017  07048 	MOVFF Byte,value
002378 EFF5 F009  07049 	GOTO  RingBuf_Put
                  07050 			;}
                  07051 			;
                  07052 			;void Trace_String(const char *string)
                  07053 			;{
                  07054 Trace_String
                  07055 			;	if(RingBuf_HasError(&g_TraceBuf)) return;
00237C 0E83       07056 	MOVLW 131
00237E 6E15       07057 	MOVWF pBuf_4,0
002380 6A16       07058 	CLRF  pBuf_4+1,0
002382 EC23 F00A  07059 	CALL  RingBuf_HasError
002386 B0D8       07060 	BTFSC 0xFD8,Carry,0
002388 0012       07061 	RETURN
                  07062 			;	uns8 ps;
                  07063 			;	ps = *string;
00238A 5012       07064 	MOVF  string,W,0
00238C DA2A       07065 	RCALL _const4
00238E 6E13       07066 	MOVWF ps,0
                  07067 			;	while(ps > 0)
002390 5213       07068 m229	MOVF  ps,1,0
002392 B4D8       07069 	BTFSC 0xFD8,Zero_,0
002394 D008       07070 	BRA   m230
                  07071 			;	{
                  07072 			;		string++;
002396 2A12       07073 	INCF  string,1,0
                  07074 			;		PutToBuf(ps);
002398 C013 F014  07075 	MOVFF ps,Byte
00239C DFE1       07076 	RCALL PutToBuf
                  07077 			;		ps = *string;
00239E 5012       07078 	MOVF  string,W,0
0023A0 DA20       07079 	RCALL _const4
0023A2 6E13       07080 	MOVWF ps,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 119

ADDR   CODE       LINE  SOURCE

                  07081 			;	}
0023A4 D7F5       07082 	BRA   m229
                  07083 			;}
0023A6 0012       07084 m230	RETURN
                  07085 			;
                  07086 			;void Trace_Char(const uns8 input)
                  07087 			;{
                  07088 Trace_Char
                  07089 			;		PutToBuf(input);
0023A8 CF7F F014  07090 	MOVFF input,Byte
0023AC D7D9       07091 	BRA   PutToBuf
                  07092 			;}
                  07093 			;
                  07094 			;void Trace_Number(uns8 input)
                  07095 			;{
                  07096 Trace_Number
0023AE 6E7F       07097 	MOVWF input_2,0
                  07098 			;	if(RingBuf_HasError(&g_TraceBuf)) return;
0023B0 0E83       07099 	MOVLW 131
0023B2 6E15       07100 	MOVWF pBuf_4,0
0023B4 6A16       07101 	CLRF  pBuf_4+1,0
0023B6 EC23 F00A  07102 	CALL  RingBuf_HasError
0023BA B0D8       07103 	BTFSC 0xFD8,Carry,0
0023BC 0012       07104 	RETURN
                  07105 			;	uns8 temp;
                  07106 			;	uns8 h,z,e;
                  07107 			;
                  07108 			;	h = 0;
0023BE 6A7F       07109 	CLRF  h,0
                  07110 			;	z = 0;
0023C0 6A7F       07111 	CLRF  z,0
                  07112 			;	e = 0;
0023C2 6A7F       07113 	CLRF  e,0
                  07114 			;
                  07115 			;	if(input > 99) {
0023C4 0E63       07116 	MOVLW 99
0023C6 647F       07117 	CPFSGT input_2,0
0023C8 D012       07118 	BRA   m231
                  07119 			;		h = input / 100;
0023CA CF7F F01E  07120 	MOVFF input_2,arg1_5
0023CE 6A1F       07121 	CLRF  arg1_5+1,0
0023D0 0E64       07122 	MOVLW 100
0023D2 ECEE F001  07123 	CALL  _divU16_8
0023D6 C01E FF7F  07124 	MOVFF arg1_5,h
                  07125 			;		temp = 0;
0023DA 6A7F       07126 	CLRF  temp_5,0
                  07127 			;		temp = 100 * h;
0023DC 0E64       07128 	MOVLW 100
0023DE 6E1E       07129 	MOVWF arg1,0
0023E0 507F       07130 	MOVF  h,W,0
0023E2 ECE0 F001  07131 	CALL  _mult8x8
0023E6 C020 FF7F  07132 	MOVFF rval,temp_5
                  07133 			;		input = input - temp;
0023EA 507F       07134 	MOVF  temp_5,W,0
0023EC 5E7F       07135 	SUBWF input_2,1,0
                  07136 			;	}
                  07137 			;
                  07138 			;	if(input > 9) {
0023EE 0E09       07139 m231	MOVLW 9
0023F0 647F       07140 	CPFSGT input_2,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 120

ADDR   CODE       LINE  SOURCE

0023F2 D012       07141 	BRA   m232
                  07142 			;		z = input / 10;
0023F4 CF7F F01E  07143 	MOVFF input_2,arg1_5
0023F8 6A1F       07144 	CLRF  arg1_5+1,0
0023FA 0E0A       07145 	MOVLW 10
0023FC ECEE F001  07146 	CALL  _divU16_8
002400 C01E FF7F  07147 	MOVFF arg1_5,z
                  07148 			;		temp = 0;
002404 6A7F       07149 	CLRF  temp_5,0
                  07150 			;		temp = z * 10;
002406 CF7F F01E  07151 	MOVFF z,arg1
00240A 0E0A       07152 	MOVLW 10
00240C ECE0 F001  07153 	CALL  _mult8x8
002410 C020 FF7F  07154 	MOVFF rval,temp_5
                  07155 			;		input = input - temp;
002414 507F       07156 	MOVF  temp_5,W,0
002416 5E7F       07157 	SUBWF input_2,1,0
                  07158 			;	}
                  07159 			;
                  07160 			;	if(input <= 9) {
002418 0E09       07161 m232	MOVLW 9
00241A 647F       07162 	CPFSGT input_2,0
                  07163 			;		e = input;
00241C CF7F FF7F  07164 	MOVFF input_2,e
                  07165 			;	}
                  07166 			;
                  07167 			;	if(h != 0) PutToBuf(h + 0x30);
002420 507F       07168 	MOVF  h,W,0
002422 B4D8       07169 	BTFSC 0xFD8,Zero_,0
002424 D004       07170 	BRA   m233
002426 0E30       07171 	MOVLW 48
002428 247F       07172 	ADDWF h,W,0
00242A 6E14       07173 	MOVWF Byte,0
00242C DF99       07174 	RCALL PutToBuf
                  07175 			;
                  07176 			;		PutToBuf(z + 0x30);
00242E 0E30       07177 m233	MOVLW 48
002430 247F       07178 	ADDWF z,W,0
002432 6E14       07179 	MOVWF Byte,0
002434 DF95       07180 	RCALL PutToBuf
                  07181 			;
                  07182 			;		PutToBuf(e + 0x30);
002436 0E30       07183 	MOVLW 48
002438 247F       07184 	ADDWF e,W,0
00243A 6E14       07185 	MOVWF Byte,0
00243C D791       07186 	BRA   PutToBuf
                  07187 			;}
                  07188 			;
                  07189 			;void Trace_Hex(const uns8 input)
                  07190 			;{
                  07191 Trace_Hex
                  07192 			;	if(RingBuf_HasError(&g_TraceBuf)) return;
00243E 0E83       07193 	MOVLW 131
002440 6E15       07194 	MOVWF pBuf_4,0
002442 6A16       07195 	CLRF  pBuf_4+1,0
002444 EC23 F00A  07196 	CALL  RingBuf_HasError
002448 B0D8       07197 	BTFSC 0xFD8,Carry,0
00244A 0012       07198 	RETURN
                  07199 			;
                  07200 			;	uns8 temp4 = input & 0xf0;
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 121

ADDR   CODE       LINE  SOURCE

00244C 0EF0       07201 	MOVLW 240
00244E 1408       07202 	ANDWF input_3,W,0
002450 6E09       07203 	MOVWF temp4,0
                  07204 			;	temp4 = temp4 >> 4;
002452 3809       07205 	SWAPF temp4,W,0
002454 0B0F       07206 	ANDLW 15
002456 6E09       07207 	MOVWF temp4,0
                  07208 			;	if(temp4 > 9) {
002458 0E09       07209 	MOVLW 9
00245A 6409       07210 	CPFSGT temp4,0
00245C D007       07211 	BRA   m234
                  07212 			;		temp4 -= 10;
00245E 0E0A       07213 	MOVLW 10
002460 5E09       07214 	SUBWF temp4,1,0
                  07215 			;		PutToBuf(temp4 + 'A');
002462 0E41       07216 	MOVLW 65
002464 2409       07217 	ADDWF temp4,W,0
002466 6E14       07218 	MOVWF Byte,0
002468 DF7B       07219 	RCALL PutToBuf
                  07220 			;	} else {
00246A D004       07221 	BRA   m235
                  07222 			;		PutToBuf(temp4 + '0');
00246C 0E30       07223 m234	MOVLW 48
00246E 2409       07224 	ADDWF temp4,W,0
002470 6E14       07225 	MOVWF Byte,0
002472 DF76       07226 	RCALL PutToBuf
                  07227 			;	}
                  07228 			;
                  07229 			;	temp4 = input & 0x0f;
002474 0E0F       07230 m235	MOVLW 15
002476 1408       07231 	ANDWF input_3,W,0
002478 6E09       07232 	MOVWF temp4,0
                  07233 			;	if(temp4 > 9) {
00247A 0E09       07234 	MOVLW 9
00247C 6409       07235 	CPFSGT temp4,0
00247E D007       07236 	BRA   m236
                  07237 			;		temp4 -= 10;
002480 0E0A       07238 	MOVLW 10
002482 5E09       07239 	SUBWF temp4,1,0
                  07240 			;		PutToBuf(temp4 + 'A');
002484 0E41       07241 	MOVLW 65
002486 2409       07242 	ADDWF temp4,W,0
002488 6E14       07243 	MOVWF Byte,0
00248A DF6A       07244 	RCALL PutToBuf
                  07245 			;	} else {
00248C D004       07246 	BRA   m237
                  07247 			;		PutToBuf(temp4 + '0');
00248E 0E30       07248 m236	MOVLW 48
002490 2409       07249 	ADDWF temp4,W,0
002492 6E14       07250 	MOVWF Byte,0
002494 D765       07251 	BRA   PutToBuf
                  07252 			;	}
                  07253 			;}
002496 0012       07254 m237	RETURN
                  07255 			;
                  07256 			;void Trace_Hex16(const uns16 input)
                  07257 			;{
                  07258 Trace_Hex16
                  07259 			;	Trace_Hex(input.high8);
002498 CF7F F008  07260 	MOVFF input_4+1,input_3
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 122

ADDR   CODE       LINE  SOURCE

00249C DFD0       07261 	RCALL Trace_Hex
                  07262 			;	Trace_Hex(input.low8);
00249E CF7F F008  07263 	MOVFF input_4,input_3
0024A2 D7CD       07264 	BRA   Trace_Hex
                  07265 			;}
                  07266 			;
                  07267 			;uns8 Trace_Print(uns8 *pArray, const uns16 arraySize)
                  07268 			;{
                  07269 Trace_Print
                  07270 			;	uns16 i = 0;
0024A4 6A13       07271 	CLRF  i_6,0
0024A6 6A14       07272 	CLRF  i_6+1,0
                  07273 			;	uns8 tempByte;
                  07274 			;	while(RingBuf_IsEmpty(&g_TraceBuf) == 0 && i < arraySize)
0024A8 0E83       07275 m238	MOVLW 131
0024AA 6E16       07276 	MOVWF pBuf_5,0
0024AC 6A17       07277 	CLRF  pBuf_5+1,0
0024AE EC2D F00A  07278 	CALL  RingBuf_IsEmpty
0024B2 B0D8       07279 	BTFSC 0xFD8,Carry,0
0024B4 D019       07280 	BRA   m239
0024B6 5011       07281 	MOVF  arraySize_2,W,0
0024B8 5C13       07282 	SUBWF i_6,W,0
0024BA 5012       07283 	MOVF  arraySize_2+1,W,0
0024BC 5814       07284 	SUBWFB i_6+1,W,0
0024BE B0D8       07285 	BTFSC 0xFD8,Carry,0
0024C0 D013       07286 	BRA   m239
                  07287 			;	{
                  07288 			;		tempByte = RingBuf_Get(&g_TraceBuf);
0024C2 0E83       07289 	MOVLW 131
0024C4 6E16       07290 	MOVWF pBuf_2,0
0024C6 6A17       07291 	CLRF  pBuf_2+1,0
0024C8 ECD8 F009  07292 	CALL  RingBuf_Get
0024CC 6E15       07293 	MOVWF tempByte_2,0
                  07294 			;		*pArray = tempByte;
0024CE C00F FFE9  07295 	MOVFF pArray_2,FSR0
0024D2 C010 FFEA  07296 	MOVFF pArray_2+1,FSR0+1
0024D6 C015 FFEF  07297 	MOVFF tempByte_2,INDF0
                  07298 			;		pArray++;
0024DA 2A0F       07299 	INCF  pArray_2,1,0
0024DC 0E00       07300 	MOVLW 0
0024DE 2210       07301 	ADDWFC pArray_2+1,1,0
                  07302 			;		i++;
0024E0 2A13       07303 	INCF  i_6,1,0
0024E2 0E00       07304 	MOVLW 0
0024E4 2214       07305 	ADDWFC i_6+1,1,0
                  07306 			;	}
0024E6 D7E0       07307 	BRA   m238
                  07308 			;	return i;
0024E8 5013       07309 m239	MOVF  i_6,W,0
0024EA 0012       07310 	RETURN
                  07311 
                  07312   ; FILE ./firmware\Flash.c
                  07313 			;/*
                  07314 			; Copyright (C) 2012, 2013 Nils Weiss, Patrick Bruenn.
                  07315 			;
                  07316 			; This file is part of Wifly_Light.
                  07317 			;
                  07318 			; Wifly_Light is free software: you can redistribute it and/or modify
                  07319 			; it under the terms of the GNU General Public License as published by
                  07320 			; the Free Software Foundation, either version 3 of the License, or
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 123

ADDR   CODE       LINE  SOURCE

                  07321 			; (at your option) any later version.
                  07322 			;
                  07323 			; Wifly_Light is distributed in the hope that it will be useful,
                  07324 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  07325 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  07326 			; GNU General Public License for more details.
                  07327 			;
                  07328 			; You should have received a copy of the GNU General Public License
                  07329 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  07330 			;
                  07331 			;
                  07332 			;#include "Flash.h"
                  07333 			;
                  07334 			;#ifdef __CC8E__
                  07335 			;
                  07336 			;uns8 AdressValid(const uns16 adress)
                  07337 			;{
                  07338 AdressValid
                  07339 			;	if(adress < 0xf000 && adress >= 0x5000)
0024EC 0EF0       07340 	MOVLW 240
0024EE 607F       07341 	CPFSLT adress_5+1,0
0024F0 D003       07342 	BRA   m240
0024F2 0E50       07343 	MOVLW 80
0024F4 607F       07344 	CPFSLT adress_5+1,0
                  07345 			;		return TRUE;
0024F6 0C01       07346 	RETLW 1
                  07347 			;	else {
                  07348 			;		return FALSE;
0024F8 0C00       07349 m240	RETLW 0
                  07350 			;	}
                  07351 			;}
                  07352 			;
                  07353 			;void Flash_ReadBlock(const uns8 upperAdress, const uns16 adress, uns8 *data, const uns16 length_bytes)
                  07354 			;{
                  07355 Flash_ReadBlock
                  07356 			;	TBLPTRU = upperAdress;
0024FA CF7F FFF8  07357 	MOVFF upperAdress,TBLPTRU
                  07358 			;	TBLPTRH = adress.high8;
0024FE CF7F FFF7  07359 	MOVFF adress_6+1,TBLPTRH
                  07360 			;	TBLPTRL = adress.low8;          // Adresse in Adressregister uebertragen
002502 CF7F FFF6  07361 	MOVFF adress_6,TBLPTRL
                  07362 			;
                  07363 			;	//length is in bytecount, so we have to divide by 2 to get the wordcount of length
                  07364 			;	uns16 i;
                  07365 			;	for(i = 0; i < length_bytes; i++) {
002506 6A7F       07366 	CLRF  i_7,0
002508 6A7F       07367 	CLRF  i_7+1,0
00250A 507F       07368 m241	MOVF  length_bytes,W,0
00250C 5C7F       07369 	SUBWF i_7,W,0
00250E 507F       07370 	MOVF  length_bytes+1,W,0
002510 587F       07371 	SUBWFB i_7+1,W,0
002512 B0D8       07372 	BTFSC 0xFD8,Carry,0
002514 D00E       07373 	BRA   m242
                  07374 			;#asm
                  07375 			;		tblrd *+
002516 0009       07376 	TBLRD *+
                  07377 			;#endasm
                  07378 			;		*data++ = TABLAT;
002518 CF7F FFE9  07379 	MOVFF data_7,FSR0
00251C CF7F FFEA  07380 	MOVFF data_7+1,FSR0+1
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 124

ADDR   CODE       LINE  SOURCE

002520 CFF5 FFEF  07381 	MOVFF TABLAT,INDF0
002524 2A7F       07382 	INCF  data_7,1,0
002526 0E00       07383 	MOVLW 0
002528 227F       07384 	ADDWFC data_7+1,1,0
                  07385 			;	}
00252A 2A7F       07386 	INCF  i_7,1,0
00252C 0E00       07387 	MOVLW 0
00252E 227F       07388 	ADDWFC i_7+1,1,0
002530 D7EC       07389 	BRA   m241
                  07390 			;}
002532 0012       07391 m242	RETURN
                  07392 			;
                  07393 			;uns16 Flash_Read(const uns8 upperAdress, const uns16 adress)
                  07394 			;{
                  07395 Flash_Read
                  07396 			;	uns16 buffer;
                  07397 			;		Flash_ReadBlock(upperAdress, adress, &buffer, sizeof(buffer));
002534 CF7F FF7F  07398 	MOVFF upperAdress_2,upperAdress
002538 CF7F FF7F  07399 	MOVFF adress_7,adress_6
00253C CF7F FF7F  07400 	MOVFF adress_7+1,adress_6+1
002540 0E7F       07401 	MOVLW 127
002542 6E7F       07402 	MOVWF data_7,0
002544 0E0F       07403 	MOVLW 15
002546 6E7F       07404 	MOVWF data_7+1,0
002548 0E02       07405 	MOVLW 2
00254A 6E7F       07406 	MOVWF length_bytes,0
00254C 6A7F       07407 	CLRF  length_bytes+1,0
00254E DFD5       07408 	RCALL Flash_ReadBlock
                  07409 			;	return buffer;
002550 507F       07410 	MOVF  buffer_2,W,0
002552 0012       07411 	RETURN
                  07412 			;}
                  07413 			;
                  07414 			;void Flash_WriteBlock(uns16 adress, const uns8 *data, const uns16 length_bytes)
                  07415 			;{
                  07416 Flash_WriteBlock
                  07417 			;	uns16 pageAdress, offset, endAdress, i;
                  07418 			;
                  07419 			;	/* check the memory range, abort if we want to write in the app oder bl memory */
                  07420 			;	endAdress = adress + length_bytes;
002554 507F       07421 	MOVF  length_bytes_2,W,0
002556 247F       07422 	ADDWF adress_8,W,0
002558 6E7F       07423 	MOVWF endAdress,0
00255A 507F       07424 	MOVF  length_bytes_2+1,W,0
00255C 207F       07425 	ADDWFC adress_8+1,W,0
00255E 6E7F       07426 	MOVWF endAdress+1,0
                  07427 			;	if(!AdressValid(endAdress)) return;
002560 CF7F FF7F  07428 	MOVFF endAdress,adress_5
002564 CF7F FF7F  07429 	MOVFF endAdress+1,adress_5+1
002568 DFC1       07430 	RCALL AdressValid
00256A 0A00       07431 	XORLW 0
00256C B4D8       07432 	BTFSC 0xFD8,Zero_,0
00256E 0012       07433 	RETURN
                  07434 			;	if(!AdressValid(adress)) return;
002570 CF7F FF7F  07435 	MOVFF adress_8,adress_5
002574 CF7F FF7F  07436 	MOVFF adress_8+1,adress_5+1
002578 DFB9       07437 	RCALL AdressValid
00257A 0A00       07438 	XORLW 0
00257C B4D8       07439 	BTFSC 0xFD8,Zero_,0
00257E 0012       07440 	RETURN
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 125

ADDR   CODE       LINE  SOURCE

                  07441 			;
                  07442 			;	while(endAdress > adress)
002580 507F       07443 m243	MOVF  endAdress,W,0
002582 5C7F       07444 	SUBWF adress_8,W,0
002584 507F       07445 	MOVF  endAdress+1,W,0
002586 587F       07446 	SUBWFB adress_8+1,W,0
002588 B0D8       07447 	BTFSC 0xFD8,Carry,0
00258A D078       07448 	BRA   m249
                  07449 			;	{
                  07450 			;		/* calculate the page adress for erase and write operation */
                  07451 			;		pageAdress = adress & 0xffc0;
00258C 507F       07452 	MOVF  adress_8+1,W,0
00258E 6E7F       07453 	MOVWF pageAdress+1,0
002590 0EC0       07454 	MOVLW 192
002592 147F       07455 	ANDWF adress_8,W,0
002594 6E7F       07456 	MOVWF pageAdress,0
                  07457 			;		/* calculate offset. Used as empty space befor the data block is written on a page */
                  07458 			;		offset = adress - pageAdress;
002596 507F       07459 	MOVF  pageAdress,W,0
002598 5C7F       07460 	SUBWF adress_8,W,0
00259A 6E7F       07461 	MOVWF offset_2,0
00259C 507F       07462 	MOVF  pageAdress+1,W,0
00259E 587F       07463 	SUBWFB adress_8+1,W,0
0025A0 6E7F       07464 	MOVWF offset_2+1,0
                  07465 			;
                  07466 			;		bank14 uns8 flashBuff[FLASH_BLOCKSIZE_BYTE];
                  07467 			;		/* get old data from current page */
                  07468 			;		Flash_ReadBlock(0, pageAdress, flashBuff, sizeof(flashBuff));
0025A2 6A7F       07469 	CLRF  upperAdress,0
0025A4 CF7F FF7F  07470 	MOVFF pageAdress,adress_6
0025A8 CF7F FF7F  07471 	MOVFF pageAdress+1,adress_6+1
0025AC 0E7F       07472 	MOVLW 127
0025AE 6E7F       07473 	MOVWF data_7,0
0025B0 0E0F       07474 	MOVLW 15
0025B2 6E7F       07475 	MOVWF data_7+1,0
0025B4 0E40       07476 	MOVLW 64
0025B6 6E7F       07477 	MOVWF length_bytes,0
0025B8 6A7F       07478 	CLRF  length_bytes+1,0
0025BA DF9F       07479 	RCALL Flash_ReadBlock
                  07480 			;		/* erase this page */
                  07481 			;		Flash_EraseBlock64(pageAdress);
0025BC CF7F FF7F  07482 	MOVFF pageAdress,adress_9
0025C0 CF7F FF7F  07483 	MOVFF pageAdress+1,adress_9+1
0025C4 D85C       07484 	RCALL Flash_EraseBlock64
                  07485 			;
                  07486 			;		for(i = 0; i < sizeof(flashBuff); i++) {
0025C6 6A7F       07487 	CLRF  i_8,0
0025C8 6A7F       07488 	CLRF  i_8+1,0
0025CA 507F       07489 m244	MOVF  i_8+1,W,0
0025CC A4D8       07490 	BTFSS 0xFD8,Zero_,0
0025CE D025       07491 	BRA   m246
0025D0 0E40       07492 	MOVLW 64
0025D2 607F       07493 	CPFSLT i_8,0
0025D4 D022       07494 	BRA   m246
                  07495 			;			/* if we are in the offset region, we don't modify the old data */
                  07496 			;			if(i < offset) continue;
0025D6 507F       07497 	MOVF  offset_2,W,0
0025D8 5C7F       07498 	SUBWF i_8,W,0
0025DA 507F       07499 	MOVF  offset_2+1,W,0
0025DC 587F       07500 	SUBWFB i_8+1,W,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 126

ADDR   CODE       LINE  SOURCE

0025DE A0D8       07501 	BTFSS 0xFD8,Carry,0
0025E0 D018       07502 	BRA   m245
                  07503 			;
                  07504 			;			/* calculate a temp adress that we know, when we reach the endadress */
                  07505 			;			uns16 tempAdress = pageAdress + i;
0025E2 507F       07506 	MOVF  i_8,W,0
0025E4 247F       07507 	ADDWF pageAdress,W,0
0025E6 6E7F       07508 	MOVWF tempAdress,0
0025E8 507F       07509 	MOVF  i_8+1,W,0
0025EA 207F       07510 	ADDWFC pageAdress+1,W,0
0025EC 6E7F       07511 	MOVWF tempAdress+1,0
                  07512 			;			if(tempAdress < endAdress) {
0025EE 507F       07513 	MOVF  endAdress,W,0
0025F0 5C7F       07514 	SUBWF tempAdress,W,0
0025F2 507F       07515 	MOVF  endAdress+1,W,0
0025F4 587F       07516 	SUBWFB tempAdress+1,W,0
0025F6 B0D8       07517 	BTFSC 0xFD8,Carry,0
0025F8 D00C       07518 	BRA   m245
                  07519 			;				/* insert new data to page in RAM */
                  07520 			;				uns8 temp = *data;
0025FA 507F       07521 	MOVF  data_8,W,0
0025FC D939       07522 	RCALL _const5
0025FE 6E7F       07523 	MOVWF temp_6,0
                  07524 			;				data++;
002600 2A7F       07525 	INCF  data_8,1,0
                  07526 			;				flashBuff[i] = temp;
002602 0E7F       07527 	MOVLW 127
002604 247F       07528 	ADDWF i_8,W,0
002606 6EE9       07529 	MOVWF FSR0,0
002608 0E0F       07530 	MOVLW 15
00260A 207F       07531 	ADDWFC i_8+1,W,0
00260C 6EEA       07532 	MOVWF FSR0+1,0
00260E CF7F FFEF  07533 	MOVFF temp_6,INDF0
                  07534 			;			}
                  07535 			;		}
002612 2A7F       07536 m245	INCF  i_8,1,0
002614 0E00       07537 	MOVLW 0
002616 227F       07538 	ADDWFC i_8+1,1,0
002618 D7D8       07539 	BRA   m244
                  07540 			;		/* transfer page from RAM to holding registers */
                  07541 			;		TBLPTRU = 0;
00261A 6AF8       07542 m246	CLRF  TBLPTRU,0
                  07543 			;		TBLPTRH = pageAdress.high8;
00261C CF7F FFF7  07544 	MOVFF pageAdress+1,TBLPTRH
                  07545 			;		TBLPTRL = pageAdress.low8;
002620 CF7F FFF6  07546 	MOVFF pageAdress,TBLPTRL
                  07547 			;		for(i = 0; i < sizeof(flashBuff); i++) {
002624 6A7F       07548 	CLRF  i_8,0
002626 6A7F       07549 	CLRF  i_8+1,0
002628 507F       07550 m247	MOVF  i_8+1,W,0
00262A A4D8       07551 	BTFSS 0xFD8,Zero_,0
00262C D010       07552 	BRA   m248
00262E 0E40       07553 	MOVLW 64
002630 607F       07554 	CPFSLT i_8,0
002632 D00D       07555 	BRA   m248
                  07556 			;			TABLAT = flashBuff[i];
002634 0E7F       07557 	MOVLW 127
002636 247F       07558 	ADDWF i_8,W,0
002638 6EE9       07559 	MOVWF FSR0,0
00263A 0E0F       07560 	MOVLW 15
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 127

ADDR   CODE       LINE  SOURCE

00263C 207F       07561 	ADDWFC i_8+1,W,0
00263E 6EEA       07562 	MOVWF FSR0+1,0
002640 CFEF FFF5  07563 	MOVFF INDF0,TABLAT
                  07564 			;#asm
                  07565 			;			tblwt *+
002644 000D       07566 	TBLWT *+
                  07567 			;#endasm
                  07568 			;		}
002646 2A7F       07569 	INCF  i_8,1,0
002648 0E00       07570 	MOVLW 0
00264A 227F       07571 	ADDWFC i_8+1,1,0
00264C D7ED       07572 	BRA   m247
                  07573 			;		/* write page to program memory */
                  07574 			;		TBLPTRU = 0;
00264E 6AF8       07575 m248	CLRF  TBLPTRU,0
                  07576 			;		TBLPTRH = pageAdress.high8;
002650 CF7F FFF7  07577 	MOVFF pageAdress+1,TBLPTRH
                  07578 			;		TBLPTRL = pageAdress.low8;
002654 CF7F FFF6  07579 	MOVFF pageAdress,TBLPTRL
                  07580 			;#asm
                  07581 			;		bsf EECON1, EEPGD
002658 8EA6       07582 	BSF   0xFA6,EEPGD,0
                  07583 			;		bcf EECON1, CFGS
00265A 9CA6       07584 	BCF   0xFA6,CFGS,0
                  07585 			;		bsf EECON1, WREN
00265C 84A6       07586 	BSF   0xFA6,WREN,0
                  07587 			;		bcf INTCON, GIE
00265E 9EF2       07588 	BCF   0xFF2,GIE,0
                  07589 			;		    movlw 0x55
002660 0E55       07590 	MOVLW 85
                  07591 			;		movwf EECON2
002662 6EA7       07592 	MOVWF EECON2,0
                  07593 			;		    movlw 0xaa
002664 0EAA       07594 	MOVLW 170
                  07595 			;		movwf EECON2
002666 6EA7       07596 	MOVWF EECON2,0
                  07597 			;		bsf EECON1, WR
002668 82A6       07598 	BSF   0xFA6,WR,0
                  07599 			;		bsf INTCON, GIE
00266A 8EF2       07600 	BSF   0xFF2,GIE,0
                  07601 			;		bcf EECON1, WREN
00266C 94A6       07602 	BCF   0xFA6,WREN,0
                  07603 			;#endasm
                  07604 			;		/* increment adress with the size of a page for the next run */
                  07605 			;		adress = pageAdress + FLASH_BLOCKSIZE_BYTE;
00266E 0E40       07606 	MOVLW 64
002670 247F       07607 	ADDWF pageAdress,W,0
002672 6E7F       07608 	MOVWF adress_8,0
002674 0E00       07609 	MOVLW 0
002676 207F       07610 	ADDWFC pageAdress+1,W,0
002678 6E7F       07611 	MOVWF adress_8+1,0
                  07612 			;	}
00267A D782       07613 	BRA   m243
                  07614 			;}
00267C 0012       07615 m249	RETURN
                  07616 			;
                  07617 			;void Flash_EraseBlock64(const uns16 adress)
                  07618 			;{
                  07619 Flash_EraseBlock64
                  07620 			;	uns16 pageAdress = adress & 0xffc0;
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 128

ADDR   CODE       LINE  SOURCE

00267E 507F       07621 	MOVF  adress_9+1,W,0
002680 6E7F       07622 	MOVWF pageAdress_2+1,0
002682 0EC0       07623 	MOVLW 192
002684 147F       07624 	ANDWF adress_9,W,0
002686 6E7F       07625 	MOVWF pageAdress_2,0
                  07626 			;	if(!AdressValid(pageAdress)) return;
002688 CF7F FF7F  07627 	MOVFF pageAdress_2,adress_5
00268C CF7F FF7F  07628 	MOVFF pageAdress_2+1,adress_5+1
002690 DF2D       07629 	RCALL AdressValid
002692 0A00       07630 	XORLW 0
002694 B4D8       07631 	BTFSC 0xFD8,Zero_,0
002696 0012       07632 	RETURN
                  07633 			;	TBLPTRU = 0;
002698 6AF8       07634 	CLRF  TBLPTRU,0
                  07635 			;	TBLPTRH = pageAdress.high8;
00269A CF7F FFF7  07636 	MOVFF pageAdress_2+1,TBLPTRH
                  07637 			;	TBLPTRL = pageAdress.low8;              // Adresse in Adressregister uebertragen
00269E CF7F FFF6  07638 	MOVFF pageAdress_2,TBLPTRL
                  07639 			;
                  07640 			;#asm
                  07641 			;	bsf EECON1, EEPGD
0026A2 8EA6       07642 	BSF   0xFA6,EEPGD,0
                  07643 			;	bcf EECON1, CFGS
0026A4 9CA6       07644 	BCF   0xFA6,CFGS,0
                  07645 			;	bsf EECON1, WREN
0026A6 84A6       07646 	BSF   0xFA6,WREN,0
                  07647 			;	bsf EECON1, FREE
0026A8 88A6       07648 	BSF   0xFA6,FREE,0
                  07649 			;	bcf INTCON, GIE
0026AA 9EF2       07650 	BCF   0xFF2,GIE,0
                  07651 			;	    movlw 0x55
0026AC 0E55       07652 	MOVLW 85
                  07653 			;	movwf EECON2
0026AE 6EA7       07654 	MOVWF EECON2,0
                  07655 			;	    movlw 0xaa
0026B0 0EAA       07656 	MOVLW 170
                  07657 			;	movwf EECON2
0026B2 6EA7       07658 	MOVWF EECON2,0
                  07659 			;	bsf EECON1, WR
0026B4 82A6       07660 	BSF   0xFA6,WR,0
                  07661 			;	bsf INTCON, GIE
0026B6 8EF2       07662 	BSF   0xFF2,GIE,0
                  07663 			;	    tblrd *-
0026B8 000A       07664 	TBLRD *-
                  07665 			;#endasm
                  07666 			;
                  07667 			;}
0026BA 0012       07668 	RETURN
                  07669 			;
                  07670 			;void Flash_EraseBlocks64(const uns16 adress, uns8 numBlocks)
                  07671 			;{
                  07672 Flash_EraseBlocks64
0026BC 6E7F       07673 	MOVWF numBlocks,0
                  07674 			;	uns16 pageAdress = adress & 0xffc0;
0026BE 507F       07675 	MOVF  adress_10+1,W,0
0026C0 6E7F       07676 	MOVWF pageAdress_3+1,0
0026C2 0EC0       07677 	MOVLW 192
0026C4 147F       07678 	ANDWF adress_10,W,0
0026C6 6E7F       07679 	MOVWF pageAdress_3,0
                  07680 			;	while(numBlocks)
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 129

ADDR   CODE       LINE  SOURCE

0026C8 507F       07681 m250	MOVF  numBlocks,W,0
0026CA B4D8       07682 	BTFSC 0xFD8,Zero_,0
0026CC D00B       07683 	BRA   m251
                  07684 			;	{
                  07685 			;		numBlocks--;
0026CE 067F       07686 	DECF  numBlocks,1,0
                  07687 			;		Flash_EraseBlock64(pageAdress);
0026D0 CF7F FF7F  07688 	MOVFF pageAdress_3,adress_9
0026D4 CF7F FF7F  07689 	MOVFF pageAdress_3+1,adress_9+1
0026D8 DFD2       07690 	RCALL Flash_EraseBlock64
                  07691 			;
                  07692 			;		pageAdress = pageAdress + FLASH_BLOCKSIZE_BYTE;
0026DA 0E40       07693 	MOVLW 64
0026DC 267F       07694 	ADDWF pageAdress_3,1,0
0026DE 0E00       07695 	MOVLW 0
0026E0 227F       07696 	ADDWFC pageAdress_3+1,1,0
                  07697 			;	}
0026E2 D7F2       07698 	BRA   m250
                  07699 			;}
0026E4 0012       07700 m251	RETURN
                  07701 
                  07702   ; FILE ./firmware\Version.c
                  07703 			;/*
                  07704 			; Copyright (C) 2013 Nils Weiss, Patrick Bruenn.
                  07705 			;
                  07706 			; This file is part of Wifly_Light.
                  07707 			;
                  07708 			; Wifly_Light is free software: you can redistribute it and/or modify
                  07709 			; it under the terms of the GNU General Public License as published by
                  07710 			; the Free Software Foundation, either version 3 of the License, or
                  07711 			; (at your option) any later version.
                  07712 			;
                  07713 			; Wifly_Light is distributed in the hope that it will be useful,
                  07714 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  07715 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  07716 			; GNU General Public License for more details.
                  07717 			;
                  07718 			; You should have received a copy of the GNU General Public License
                  07719 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  07720 			;
                  07721 			;#include "Version.h"
                  07722 			;#include "VersionFile.h"
                  07723 			;#include "platform.h"
                  07724 			;
                  07725 			;#ifdef cc3200
                  07726 			;#include "socket.h"
                  07727 			;#endif
                  07728 			;
                  07729 			;const uns16 versionInt = VERSION;
                  07730 			;
                  07731 			;uns16 Version_Print(void)
                  07732 			;{
                  07733 Version_Print
                  07734 			;	return htons(versionInt);
0026E6 0E5B       07735 	MOVLW 91
0026E8 D87C       07736 	RCALL _const4
0026EA 6E17       07737 	MOVWF hostShort,0
0026EC 000B       07738 	TBLRD +*
0026EE 50F5       07739 	MOVF  TABLAT,W,0
0026F0 6E18       07740 	MOVWF hostShort+1,0
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 130

ADDR   CODE       LINE  SOURCE

0026F2 EC31 F00C  07741 	CALL  htons
0026F6 C019 F010  07742 	MOVFF retval,C1tmp
0026FA C01A F011  07743 	MOVFF retval+1,C1tmp+1
0026FE 5010       07744 	MOVF  C1tmp,W,0
002700 0012       07745 	RETURN
                  07746 
                  07747   ; FILE ./firmware\external_eeprom.c
                  07748 			;/**
                  07749 			; Copyright (C) 2012 Nils Weiss, Patrick Bruenn.
                  07750 			;
                  07751 			; This file is part of Wifly_Light.
                  07752 			;
                  07753 			; Wifly_Light is free software: you can redistribute it and/or modify
                  07754 			; it under the terms of the GNU General Public License as published by
                  07755 			; the Free Software Foundation, either version 3 of the License, or
                  07756 			; (at your option) any later version.
                  07757 			;
                  07758 			; Wifly_Light is distributed in the hope that it will be useful,
                  07759 			; but WITHOUT ANY WARRANTY; without even the implied warranty of
                  07760 			; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  07761 			; GNU General Public License for more details.
                  07762 			;
                  07763 			; You should have received a copy of the GNU General Public License
                  07764 			; along with Wifly_Light.  If not, see <http://www.gnu.org/licenses/>. */
                  07765 			;
                  07766 			;#include "external_eeprom.h"
                  07767 			;#include "iic.h"
                  07768 			;#include "trace.h"
                  07769 			;
                  07770 			;static uns8 g_ExtEepromDetected;
                  07771 			;
                  07772 			;void ExtEeprom_Init(void) {
                  07773 ExtEeprom_Init
                  07774 			;	I2C_Init();
002702 ECA3 F00E  07775 	CALL  I2C_Init
                  07776 			;	if (I2C_DetectSlave(EEPROM_ADRESS)) {
002706 0EDE       07777 	MOVLW 222
002708 6E07       07778 	MOVWF slaveaddr_5,0
00270A EC59 F00F  07779 	CALL  I2C_DetectSlave
00270E 0A00       07780 	XORLW 0
002710 B4D8       07781 	BTFSC 0xFD8,Zero_,0
002712 D00A       07782 	BRA   m252
                  07783 			;		g_ExtEepromDetected = 1;
002714 0E01       07784 	MOVLW 1
002716 0100       07785 	MOVLB 0
002718 6F82       07786 	MOVWF g_ExtEepromDetected,1
                  07787 			;		I2C_Write(EEPROM_ADRESS, 0xff, 0x00);
00271A 0EDE       07788 	MOVLW 222
00271C 6E12       07789 	MOVWF slaveaddr,0
00271E 6813       07790 	SETF  dataaddr,0
002720 6A14       07791 	CLRF  data_5,0
002722 ECAC F00E  07792 	CALL  I2C_Write
                  07793 			;	} else {
002726 D002       07794 	BRA   m253
                  07795 			;		g_ExtEepromDetected = 0;
002728 0100       07796 m252	MOVLB 0
00272A 6B82       07797 	CLRF  g_ExtEepromDetected,1
                  07798 			;	}
                  07799 			;}
00272C 0012       07800 m253	RETURN
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 131

ADDR   CODE       LINE  SOURCE

                  07801 			;void ExtEeprom_Write(const uns8 adress, const uns8 data) {
                  07802 ExtEeprom_Write
                  07803 			;	if (adress <= EEPROM_MEMORY_END_ADRESS) {
00272E 0E80       07804 	MOVLW 128
002730 607F       07805 	CPFSLT adress_11,0
002732 D00D       07806 	BRA   m254
                  07807 			;		if (g_ExtEepromDetected) {
002734 0100       07808 	MOVLB 0
002736 5382       07809 	MOVF  g_ExtEepromDetected,1,1
002738 B4D8       07810 	BTFSC 0xFD8,Zero_,0
00273A D00C       07811 	BRA   m255
                  07812 			;			I2C_Write(EEPROM_ADRESS, adress, data);
00273C 0EDE       07813 	MOVLW 222
00273E 6E12       07814 	MOVWF slaveaddr,0
002740 CF7F F013  07815 	MOVFF adress_11,dataaddr
002744 CF7F F014  07816 	MOVFF data_9,data_5
002748 ECAC F00E  07817 	CALL  I2C_Write
                  07818 			;		}
                  07819 			;	} else {
00274C D003       07820 	BRA   m255
                  07821 			;		Trace_String("invalid ext eeprom adress");
00274E 0E5D       07822 m254	MOVLW 93
002750 6E12       07823 	MOVWF string,0
002752 D614       07824 	BRA   Trace_String
                  07825 			;	}
                  07826 			;}
002754 0012       07827 m255	RETURN
                  07828 			;uns8 ExtEeprom_Read(const uns8 adress) {
                  07829 ExtEeprom_Read
                  07830 			;	if (adress <= EEPROM_MEMORY_END_ADRESS) {
002756 0E80       07831 	MOVLW 128
002758 607F       07832 	CPFSLT adress_12,0
00275A D00A       07833 	BRA   m256
                  07834 			;		if (g_ExtEepromDetected) {
00275C 0100       07835 	MOVLB 0
00275E 5382       07836 	MOVF  g_ExtEepromDetected,1,1
002760 B4D8       07837 	BTFSC 0xFD8,Zero_,0
002762 D009       07838 	BRA   m257
                  07839 			;			return I2C_Read(EEPROM_ADRESS, adress);
002764 0EDE       07840 	MOVLW 222
002766 6E12       07841 	MOVWF slaveaddr_4,0
002768 CF7F F013  07842 	MOVFF adress_12,readaddr_2
00276C EF2B F00F  07843 	GOTO  I2C_Read
                  07844 			;		}
                  07845 			;	} else {
                  07846 			;		Trace_String("invalid ext eeprom adress");
002770 0E5D       07847 m256	MOVLW 93
002772 6E12       07848 	MOVWF string,0
002774 DE03       07849 	RCALL Trace_String
                  07850 			;	}
                  07851 			;	return 0;
002776 0C00       07852 m257	RETLW 0
                  07853 			;}
                  07854 			;void ExtEeprom_WriteBlock(const uns8 *array, const uns8 adress, const uns8 length) {
                  07855 ExtEeprom_WriteBlock
                  07856 			;	if (adress <= EEPROM_MEMORY_END_ADRESS) {
002778 0E80       07857 	MOVLW 128
00277A 607F       07858 	CPFSLT adress_13,0
00277C D00F       07859 	BRA   m258
                  07860 			;		if (g_ExtEepromDetected) {
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 132

ADDR   CODE       LINE  SOURCE

00277E 0100       07861 	MOVLB 0
002780 5382       07862 	MOVF  g_ExtEepromDetected,1,1
002782 B4D8       07863 	BTFSC 0xFD8,Zero_,0
002784 D00E       07864 	BRA   m259
                  07865 			;			I2C_WriteBlock(EEPROM_ADRESS, array, adress, length);
002786 0EDE       07866 	MOVLW 222
002788 6E7F       07867 	MOVWF slaveaddr_2,0
00278A CF7F FF7F  07868 	MOVFF array_4,data_6
00278E CF7F FF7F  07869 	MOVFF adress_13,dataaddr_2
002792 CF7F FF7F  07870 	MOVFF length_6,length_4
002796 ECC6 F00E  07871 	CALL  I2C_WriteBlock
                  07872 			;		}
                  07873 			;	} else {
00279A D003       07874 	BRA   m259
                  07875 			;		Trace_String("invalid ext eeprom adress");
00279C 0E5D       07876 m258	MOVLW 93
00279E 6E12       07877 	MOVWF string,0
0027A0 D5ED       07878 	BRA   Trace_String
                  07879 			;	}
                  07880 			;}
0027A2 0012       07881 m259	RETURN
                  07882 			;void ExtEeprom_ReadBlock(uns8 *array, const uns8 adress, const uns8 length) {
                  07883 ExtEeprom_ReadBlock
                  07884 			;	if (adress <= EEPROM_MEMORY_END_ADRESS) {
0027A4 0E80       07885 	MOVLW 128
0027A6 607F       07886 	CPFSLT adress_14,0
0027A8 D00F       07887 	BRA   m260
                  07888 			;		if (g_ExtEepromDetected) {
0027AA 0100       07889 	MOVLB 0
0027AC 5382       07890 	MOVF  g_ExtEepromDetected,1,1
0027AE B4D8       07891 	BTFSC 0xFD8,Zero_,0
0027B0 D00E       07892 	BRA   m261
                  07893 			;			I2C_ReadBlock(EEPROM_ADRESS, array, adress, length);
0027B2 0EDE       07894 	MOVLW 222
0027B4 6E7F       07895 	MOVWF slaveaddr_3,0
0027B6 CF7F FF7F  07896 	MOVFF array_5,buffer
0027BA CF7F FF7F  07897 	MOVFF adress_14,readaddr
0027BE CF7F FF7F  07898 	MOVFF length_7,length_5
0027C2 ECEA F00E  07899 	CALL  I2C_ReadBlock
                  07900 			;		}
                  07901 			;	} else {
0027C6 D003       07902 	BRA   m261
                  07903 			;		Trace_String("invalid ext eeprom adress");
0027C8 0E5D       07904 m260	MOVLW 93
0027CA 6E12       07905 	MOVWF string,0
0027CC D5D7       07906 	BRA   Trace_String
                  07907 
                  07908   ; FILE ./firmware/main.c
                  07909 			;
                  07910 			;#ifdef __CC8E__
                  07911 			;//#pragma codepage 1
                  07912 			;#include "crc.c"
                  07913 			;#include "eeprom.c"
                  07914 			;#include "error.c"
                  07915 			;#include "ledstrip.c"
                  07916 			;#include "spi.c"
                  07917 			;#include "timer.c"
                  07918 			;#include "RingBuf.c"
                  07919 			;#include "usart.c"
                  07920 			;#include "CommandIO.c"
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 133

ADDR   CODE       LINE  SOURCE

                  07921 			;#include "platform.c"
                  07922 			;#include "rtc.c"
                  07923 			;#include "iic.c"
                  07924 			;#include "ScriptCtrl.c"
                  07925 			;#include "trace.c"
                  07926 			;#include "Flash.c"
                  07927 			;#include "Version.c"
                  07928 			;#include "external_eeprom.c"
0027CE 0012       07929 m261	RETURN
                  07930 _const1
0027D0 0C00       07931 	RETLW 0
                  07932 _const2
0027D2 501A       07933 	MOVF  ci_2,W,0
0027D4 6EE9       07934 	MOVWF FSR0L,0
0027D6 501B       07935 	MOVF  ci_2+1,W,0
0027D8 6EEA       07936 	MOVWF FSR0+1,0
0027DA 50EF       07937 	MOVF  INDF0,W,0
0027DC 0012       07938 	RETURN
                  07939 _const3
0027DE 6E7F       07940 	MOVWF ci_3,0
0027E0 0C00       07941 	RETLW 0
                  07942 _const4
0027E2 6E14       07943 	MOVWF ci_4,0
0027E4 5014       07944 	MOVF  ci_4,W,0
0027E6 0FF8       07945 	ADDLW 248
0027E8 6EF6       07946 	MOVWF TBLPTR,0
0027EA 0E27       07947 	MOVLW 39
0027EC 6AF7       07948 	CLRF  TBLPTR+1,0
0027EE 22F7       07949 	ADDWFC TBLPTR+1,1,0
0027F0 6AF8       07950 	CLRF  TBLPTR+2,0
0027F2 0008       07951 	TBLRD *
0027F4 50F5       07952 	MOVF  TABLAT,W,0
0027F6 0012       07953 	RETURN
0027F8 4920       07954 	DW    0x4920
0027FA 696E       07955 	DW    0x696E
0027FC 2074       07956 	DW    0x2074
0027FE 6F44       07957 	DW    0x6F44
002800 656E       07958 	DW    0x656E
002802 0020       07959 	DW    0x20
002804 3A45       07960 	DW    0x3A45
002806 3130       07961 	DW    0x3130
002808 003B       07962 	DW    0x3B
00280A 3A45       07963 	DW    0x3A45
00280C 3230       07964 	DW    0x3230
00280E 003B       07965 	DW    0x3B
002810 3720       07966 	DW    0x3720
002812 3439       07967 	DW    0x3439
002814 3031       07968 	DW    0x3031
002816 6420       07969 	DW    0x6420
002818 7465       07970 	DW    0x7465
00281A 6365       07971 	DW    0x6365
00281C 6574       07972 	DW    0x6574
00281E 2064       07973 	DW    0x2064
002820 2000       07974 	DW    0x2000
002822 3538       07975 	DW    0x3538
002824 3436       07976 	DW    0x3436
002826 454A       07977 	DW    0x454A
002828 6420       07978 	DW    0x6420
00282A 7465       07979 	DW    0x7465
00282C 6365       07980 	DW    0x6365
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 134

ADDR   CODE       LINE  SOURCE

00282E 6574       07981 	DW    0x6574
002830 0064       07982 	DW    0x64
002832 4E20       07983 	DW    0x4E20
002834 204F       07984 	DW    0x204F
002836 5452       07985 	DW    0x5452
002838 2043       07986 	DW    0x2043
00283A 6564       07987 	DW    0x6564
00283C 6574       07988 	DW    0x6574
00283E 7463       07989 	DW    0x7463
002840 6465       07990 	DW    0x6465
002842 2000       07991 	DW    0x2000
002844 5452       07992 	DW    0x5452
002846 2043       07993 	DW    0x2043
002848 3330       07994 	DW    0x3330
00284A 003A       07995 	DW    0x3A
00284C 4F4E       07996 	DW    0x4F4E
00284E 5220       07997 	DW    0x5220
002850 4354       07998 	DW    0x4354
002852 1B00       07999 	DW    0x1B00
002854 6900       08000 	DW    0x6900
002856 766E       08001 	DW    0x766E
002858 6C61       08002 	DW    0x6C61
00285A 6469       08003 	DW    0x6469
00285C 6520       08004 	DW    0x6520
00285E 7478       08005 	DW    0x7478
002860 6520       08006 	DW    0x6520
002862 7065       08007 	DW    0x7065
002864 6F72       08008 	DW    0x6F72
002866 206D       08009 	DW    0x206D
002868 6461       08010 	DW    0x6461
00286A 6572       08011 	DW    0x6572
00286C 7373       08012 	DW    0x7373
00286E 0000       08013 	DW    0x0
                  08014 _const5
002870 6E7F       08015 	MOVWF ci_5,0
002872 0C00       08016 	RETLW 0
                  08017 
       0000       08018 	ORG 0x00E0
0000E0 001B       08019 	DATA 0x001B
                  08020 	END
                  08021 
                  08022 
                  08023 ; *** KEY INFO ***
                  08024 
                  08025 ; 0x00182A   12 word(s)  0 % : Platform_AllowInterrupts
                  08026 ; 0x001842    3 word(s)  0 % : Platform_EnableAllInterrupts
                  08027 ; 0x0017FC   23 word(s)  0 % : Platform_CheckInputs
                  08028 ; 0x001862    6 word(s)  0 % : htons
                  08029 ; 0x00186E    6 word(s)  0 % : ntohs
                  08030 ; 0x001848    7 word(s)  0 % : Platform_DisableBootloaderAutostart
                  08031 ; 0x001856    6 word(s)  0 % : Platform_EnableBootloaderAutostart
                  08032 ; 0x0026E6   14 word(s)  0 % : Version_Print
                  08033 ; 0x001446   10 word(s)  0 % : RingBuf_HasError
                  08034 ; 0x00145A   21 word(s)  0 % : RingBuf_IsEmpty
                  08035 ; 0x00138A   19 word(s)  0 % : RingBuf_Init
                  08036 ; 0x0013B0   29 word(s)  0 % : RingBuf_Get
                  08037 ; 0x0013EA   46 word(s)  0 % : RingBuf_Put
                  08038 ; 0x001484   15 word(s)  0 % : UART_Init
                  08039 ; 0x0014A2    5 word(s)  0 % : UART_Send
                  08040 ; 0x0018DC   89 word(s)  0 % : Rtc_Init
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 135

ADDR   CODE       LINE  SOURCE

                  08041 ; 0x00198E  476 word(s)  1 % : Rtc_Ctl
                  08042 ; 0x001232   26 word(s)  0 % : Timer_Init
                  08043 ; 0x001266   14 word(s)  0 % : Timer_StartStopwatch
                  08044 ; 0x001282   66 word(s)  0 % : Timer_StopStopwatch
                  08045 ; 0x001306   66 word(s)  0 % : Timer_PrintCycletime
                  08046 ; 0x00039E   17 word(s)  0 % : Error_Throw
                  08047 ; 0x001504    5 word(s)  0 % : CommandIO_Init
                  08048 ; 0x001528  106 word(s)  0 % : CommandIO_GetCommands
                  08049 ; 0x00150E   13 word(s)  0 % : CommandIO_Error
                  08050 ; 0x0015FC  104 word(s)  0 % : CommandIO_SendResponse
                  08051 ; 0x0016CC  152 word(s)  0 % : CommandIO_CreateResponse
                  08052 ; 0x00042A   92 word(s)  0 % : Ledstrip_Init
                  08053 ; 0x0004E2  108 word(s)  0 % : Ledstrip_SetColorDirect
                  08054 ; 0x000726  431 word(s)  1 % : Ledstrip_SetFade
                  08055 ; 0x000A84  941 word(s)  2 % : Ledstrip_SetGradient
                  08056 ; 0x0005BA  176 word(s)  0 % : Ledstrip_DoFade
                  08057 ; 0x00071A    6 word(s)  0 % : Ledstrip_UpdateLed
                  08058 ; 0x000402   20 word(s)  0 % : Ledstrip_FadeOffLeds
                  08059 ; 0x001EDC  207 word(s)  0 % : ScriptCtrl_Add
                  08060 ; 0x00207A   31 word(s)  0 % : ScriptCtrl_Clear
                  08061 ; 0x0020B8   26 word(s)  0 % : ScriptCtrl_Init
                  08062 ; 0x0020EC  246 word(s)  0 % : ScriptCtrl_Run
                  08063 ; 0x002330    9 word(s)  0 % : ScriptCtrl_DecrementWaitValue
                  08064 ; 0x002342   10 word(s)  0 % : ScriptCtrl_CheckAndDecrementWaitValue
                  08065 ; 0x002356    5 word(s)  0 % : Trace_Init
                  08066 ; 0x00237C   22 word(s)  0 % : Trace_String
                  08067 ; 0x0023AE   72 word(s)  0 % : Trace_Number
                  08068 ; 0x00243E   45 word(s)  0 % : Trace_Hex
                  08069 ; 0x002498    6 word(s)  0 % : Trace_Hex16
                  08070 ; 0x0023A8    3 word(s)  0 % : Trace_Char
                  08071 ; 0x0024A4   36 word(s)  0 % : Trace_Print
                  08072 ; 0x002534   16 word(s)  0 % : Flash_Read
                  08073 ; 0x0024FA   29 word(s)  0 % : Flash_ReadBlock
                  08074 ; 0x002554  149 word(s)  0 % : Flash_WriteBlock
                  08075 ; 0x00267E   31 word(s)  0 % : Flash_EraseBlock64
                  08076 ; 0x0026BC   21 word(s)  0 % : Flash_EraseBlocks64
                  08077 ; 0x002702   22 word(s)  0 % : ExtEeprom_Init
                  08078 ; 0x00272E   20 word(s)  0 % : ExtEeprom_Write
                  08079 ; 0x002756   17 word(s)  0 % : ExtEeprom_Read
                  08080 ; 0x002778   22 word(s)  0 % : ExtEeprom_WriteBlock
                  08081 ; 0x0027A4   22 word(s)  0 % : ExtEeprom_ReadBlock
                  08082 ; 0x00017A   65 word(s)  0 % : InitAll
                  08083 ; 0x000052   36 word(s)  0 % : HighPriorityInterruptFunction
                  08084 ; 0x000008    2 word(s)  0 % : HighPriorityInterrupt
                  08085 ; 0x000018   29 word(s)  0 % : LowPriorityInterrupt
                  08086 ; 0x0000E2   76 word(s)  0 % : main
                  08087 ; 0x0001FC   43 word(s)  0 % : Crc_AddCrc
                  08088 ; 0x000252    9 word(s)  0 % : Crc_AddCrc16
                  08089 ; 0x000264   44 word(s)  0 % : Crc_BuildCrc
                  08090 ; 0x0002BC   19 word(s)  0 % : Crc_NewCrc
                  08091 ; 0x0027D0    1 word(s)  0 % : _const1
                  08092 ; 0x0002E2   26 word(s)  0 % : Eeprom_Write
                  08093 ; 0x000316   11 word(s)  0 % : Eeprom_Read
                  08094 ; 0x00032C   32 word(s)  0 % : Eeprom_WriteBlock
                  08095 ; 0x00036C   25 word(s)  0 % : Eeprom_ReadBlock
                  08096 ; 0x0011DE   11 word(s)  0 % : SPI_Init
                  08097 ; 0x0011F4    7 word(s)  0 % : SPI_Send
                  08098 ; 0x001202   24 word(s)  0 % : SPI_SendLedBuffer
                  08099 ; 0x0003C0   14 word(s)  0 % : _mult8x8
                  08100 ; 0x0003DC   19 word(s)  0 % : _divU16_8
CC8E Version 1.3F,   File: ./firmware/main.c    1. Dec 2014  23:24   Page 136

ADDR   CODE       LINE  SOURCE

                  08101 ; 0x0027D2    6 word(s)  0 % : _const2
                  08102 ; 0x0014AC   25 word(s)  0 % : WriteByte
                  08103 ; 0x0014DE   12 word(s)  0 % : DeleteBuffer
                  08104 ; 0x0014F6    7 word(s)  0 % : CheckForFwIdentMessage
                  08105 ; 0x001D46    9 word(s)  0 % : I2C_Init
                  08106 ; 0x001D58   26 word(s)  0 % : I2C_Write
                  08107 ; 0x001E56   46 word(s)  0 % : I2C_Read
                  08108 ; 0x001EB2   21 word(s)  0 % : I2C_DetectSlave
                  08109 ; 0x001DD4   65 word(s)  0 % : I2C_ReadBlock
                  08110 ; 0x001D8C   36 word(s)  0 % : I2C_WriteBlock
                  08111 ; 0x00187A   18 word(s)  0 % : BcdToBin
                  08112 ; 0x00189E   31 word(s)  0 % : BinToBcd
                  08113 ; 0x0027DE    2 word(s)  0 % : _const3
                  08114 ; 0x0022D8   44 word(s)  0 % : ScriptCtrl_Write
                  08115 ; 0x002360   14 word(s)  0 % : PutToBuf
                  08116 ; 0x0027E2   71 word(s)  0 % : _const4
                  08117 ; 0x0024EC    7 word(s)  0 % : AdressValid
                  08118 ; 0x002870    2 word(s)  0 % : _const5
                  08119 
                  08120 ; RAM usage: 1708 bytes (36 local), 2188 bytes free
                  08121 ; Maximum call level: 7 (+2 for interrupt)
                  08122 ; Total of 5135 code words (15 %)
