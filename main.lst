CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 1

ADDR CODE  LINE SOURCE

           0001 
           0002 ; CC5X Version 3.4E, Copyright (c) B Knudsen Data
           0003 ; C compiler for the PICmicro family
           0004 ; ************  10. Jun 2012  15:01  *************
           0005 
           0006 	processor  16F1936
           0007 	radix  DEC
           0008 
     0000  0009 INDF0       EQU   0x00
     0004  0010 FSR0        EQU   0x04
     0004  0011 FSR0L       EQU   0x04
     0005  0012 FSR0H       EQU   0x05
     0000  0013 Carry       EQU   0
     0002  0014 Zero_       EQU   2
     000E  0015 PORTC       EQU   0x0E
     001B  0016 PR2         EQU   0x1B
     001C  0017 T2CON       EQU   0x1C
     008E  0018 TRISC       EQU   0x8E
     0099  0019 OSCCON      EQU   0x99
     0191  0020 EEADRL      EQU   0x191
     0192  0021 EEADRH      EQU   0x192
     0193  0022 EEDATL      EQU   0x193
     0194  0023 EEDATH      EQU   0x194
     0196  0024 EECON2      EQU   0x196
     0199  0025 RCREG       EQU   0x199
     019A  0026 TXREG       EQU   0x19A
     019B  0027 SPBRGL      EQU   0x19B
     019C  0028 SPBRGH      EQU   0x19C
     0211  0029 SSPBUF      EQU   0x211
     0006  0030 PEIE        EQU   6
     0007  0031 GIE         EQU   7
     0001  0032 TMR2IF      EQU   1
     0003  0033 SSPIF       EQU   3
     0004  0034 TXIF        EQU   4
     0005  0035 RCIF        EQU   5
     0001  0036 TMR2IE      EQU   1
     0005  0037 RCIE        EQU   5
     0000  0038 RD          EQU   0
     0001  0039 WR          EQU   1
     0002  0040 WREN        EQU   2
     0006  0041 CFGS        EQU   6
     0007  0042 EEPGD       EQU   7
     0003  0043 ADDEN       EQU   3
     0004  0044 CREN        EQU   4
     0006  0045 RX9         EQU   6
     0007  0046 SPEN        EQU   7
     0002  0047 BRGH        EQU   2
     0004  0048 SYNC        EQU   4
     0005  0049 TXEN        EQU   5
     0006  0050 TX9         EQU   6
     0003  0051 BRG16       EQU   3
     0006  0052 CKE         EQU   6
     0007  0053 SMP         EQU   7
     0001  0054 SSPM1       EQU   1
     0004  0055 CKP         EQU   4
     0005  0056 SSPEN       EQU   5
     0039  0057 gRingBuf    EQU   0x39
     004C  0058 gERROR      EQU   0x4C
     004D  0059 gCmdBuf     EQU   0x4D
     0061  0060 gLedBuf     EQU   0x61
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 2

ADDR CODE  LINE SOURCE

     0060  0061 gTimecounter EQU   0x60
     0020  0062 temp        EQU   0x20
     0025  0063 byte        EQU   0x25
     0026  0064 p_crcH      EQU   0x26
     0027  0065 p_crcL      EQU   0x27
     0028  0066 index       EQU   0x28
     0029  0067 crcH        EQU   0x29
     002A  0068 crcL        EQU   0x2A
     007F  0069 data        EQU   0x7F
     007F  0070 length      EQU   0x7F
     007F  0071 crcH_out    EQU   0x7F
     007F  0072 crcL_out    EQU   0x7F
     007F  0073 crcH_2      EQU   0x7F
     007F  0074 crcL_2      EQU   0x7F
     007F  0075 i           EQU   0x7F
     007F  0076 byte_2      EQU   0x7F
     0025  0077 p_crcH_2    EQU   0x25
     0026  0078 p_crcL_2    EQU   0x26
     0030  0079 adress      EQU   0x30
     0031  0080 data_2      EQU   0x31
     0000  0081 GIE_status  EQU   0
     0035  0082 adress_2    EQU   0x35
     0036  0083 data_3      EQU   0x36
     0028  0084 array       EQU   0x28
     0029  0085 adress_3    EQU   0x29
     002A  0086 length_2    EQU   0x2A
     002B  0087 i_2         EQU   0x2B
     0030  0088 array_2     EQU   0x30
     0031  0089 adress_4    EQU   0x31
     0032  0090 length_3    EQU   0x32
     0033  0091 i_3         EQU   0x33
     0034  0092 temp_2      EQU   0x34
     0022  0093 k           EQU   0x22
     002D  0094 pCmd        EQU   0x2D
     002E  0095 address     EQU   0x2E
     002F  0096 r           EQU   0x2F
     0030  0097 g           EQU   0x30
     0031  0098 b           EQU   0x31
     0032  0099 k_2         EQU   0x32
     0033  0100 mask        EQU   0x33
     002D  0101 pCmd_2      EQU   0x2D
     002E  0102 address_2   EQU   0x2E
     002F  0103 r_2         EQU   0x2F
     0030  0104 g_2         EQU   0x30
     0031  0105 b_2         EQU   0x31
     0032  0106 k_3         EQU   0x32
     0033  0107 mask_2      EQU   0x33
     0034  0108 temp_3      EQU   0x34
     007F  0109 destinationvalue EQU   0x7F
     007F  0110 currentvalue EQU   0x7F
     007F  0111 max_distance_2 EQU   0x7F
     007F  0112 temp_4      EQU   0x7F
     0000  0113 fade_finish EQU   0
     0022  0114 temp_current EQU   0x22
     0023  0115 temp_destination EQU   0x23
     0024  0116 i_4         EQU   0x24
     0025  0117 result      EQU   0x25
     0020  0118 value       EQU   0x20
     0021  0119 writeNext   EQU   0x21
     0038  0120 data_4      EQU   0x38
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 3

ADDR CODE  LINE SOURCE

     007F  0121 array_3     EQU   0x7F
     007F  0122 length_4    EQU   0x7F
     007F  0123 i_5         EQU   0x7F
     0034  0124 array_4     EQU   0x34
     0036  0125 end         EQU   0x36
     0036  0126 value_2     EQU   0x36
     0028  0127 ch          EQU   0x28
     0026  0128 string      EQU   0x26
     0027  0129 ps          EQU   0x27
     007F  0130 array_5     EQU   0x7F
     007F  0131 length_5    EQU   0x7F
     007F  0132 i_6         EQU   0x7F
     002D  0133 pDest       EQU   0x2D
     0000  0134 movePtr     EQU   0
     002E  0135 nextCmd     EQU   0x2E
     0025  0136 pSrc        EQU   0x25
     0026  0137 length_6    EQU   0x26
     0027  0138 nextCmd_2   EQU   0x27
     0022  0139 new_byte    EQU   0x22
     0023  0140 temp_5      EQU   0x23
     0024  0141 j           EQU   0x24
     0022  0142 nextCmd_3   EQU   0x22
     002C  0143 result_2    EQU   0x2C
     0028  0144 ci          EQU   0x28
           0145 
0000 2860  0146 	GOTO main
           0147 
           0148   ; FILE main.c
           0149 			;//Nils Weiß 
           0150 			;//05.09.2011
           0151 			;//Compiler CC5x/
           0152 			;
           0153 			;#define NO_CRC
           0154 			;#pragma sharedAllocation
           0155 			;
           0156 			;//*********************** INCLUDEDATEIEN *********************************************
           0157 			;#include "platform.h"
           0158 			;#include "RingBuf.h"		//clean
           0159 			;#include "usart.h"			//clean
           0160 			;#include "eeprom.h"       	//clean 
           0161 			;#include "crc.h"			//clean
           0162 			;#include "commandstorage.h" //under construction
           0163 			;#include "ledstrip.h"		//clean
           0164 			;#include "spi.h"			//clean
           0165 			;#include "timer.h"			//under construction
           0166 			;
           0167 			;//*********************** GLOBAL VARIABLES *******************************************
           0168 			;struct CommandBuffer gCmdBuf;
           0169 			;struct LedBuffer gLedBuf;
           0170 			;struct ErrorBits gERROR;
           0171 			;char gTimecounter;
           0172 			;
           0173 			;#ifdef X86
           0174 			;void* gl_start(void* unused);
           0175 			;void* InterruptRoutine(void* unused)
           0176 			;{
           0177 			;
           0178 			;	char dummyData[] = {
           0179 			;		STX, (uns8)sizeof(struct cmd_set_color) + 2,
           0180 			;		SET_COLOR,
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 4

ADDR CODE  LINE SOURCE

           0181 			;		0xff, 0xff, 0xff, 0xff,
           0182 			;		0, 128, 0,
           0183 			;		0, 0,
           0184 			;		0xDE, 0xAD};
           0185 			;
           0186 			;	uns8 i = 0;
           0187 			;	for(;;)
           0188 			;	{
           0189 			;		if(!RingBufHasError)
           0190 			;		{
           0191 			;			RingBufPut(dummyData[i]);
           0192 			;		}
           0193 			;	
           0194 			;		i++;
           0195 			;		if(i == sizeof(dummyData))
           0196 			;		{
           0197 			;			i = 0;
           0198 			;			char temp = dummyData[7];
           0199 			;			dummyData[7] = dummyData[8];
           0200 			;			dummyData[8] = dummyData[9];
           0201 			;			dummyData[9] = temp;
           0202 			;			sleep(1);//sleep a second
           0203 			;		}
           0204 			;	}
           0205 			;}
           0206 			;#else
           0207 			;//*********************** INTERRUPTSERVICEROUTINE ************************************
           0208 			;#pragma origin 4					//Adresse des Interrupts	
     0000  0209 	ORG 0x0004
           0210 			;interrupt InterruptRoutine(void)
           0211 			;{
           0212 InterruptRoutine
           0213 			;	if(RCIF)
0004 0020  0214 	MOVLB 0
0005 1E91  0215 	BTFSS 0x11,RCIF
0006 2811  0216 	GOTO  m002
           0217 			;	{
           0218 			;		if(!RingBufHasError) RingBufPut(RCREG);
0007 184B  0219 	BTFSC gRingBuf+18,0
0008 280D  0220 	GOTO  m001
0009 0023  0221 	MOVLB 3
000A 0819  0222 	MOVF  RCREG,W
000B 22E4  0223 	CALL  RingBufPut
           0224 			;		else 
000C 2811  0225 	GOTO  m002
           0226 			;		{
           0227 			;			//Register lesen um Schnittstellen Fehler zu vermeiden
           0228 			;			char temp = RCREG;
000D 0023  0229 m001	MOVLB 3
000E 0819  0230 	MOVF  RCREG,W
000F 0020  0231 	MOVLB 0
0010 00A0  0232 	MOVWF temp
           0233 			;		}
           0234 			;	}
           0235 			;	if(TMR2IF)
0011 0020  0236 m002	MOVLB 0
0012 1C91  0237 	BTFSS 0x11,TMR2IF
0013 2816  0238 	GOTO  m003
           0239 			;	{
           0240 			;		Timerinterrupt();
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 5

ADDR CODE  LINE SOURCE

0014 1091  0241 	BCF   0x11,TMR2IF
0015 0AE0  0242 	INCF  gTimecounter,1
           0243 			;	}
           0244 			;}
0016 0009  0245 m003	RETFIE
           0246 			;#endif /* #ifdef X86 */
           0247 			;
           0248 			;//*********************** FUNKTIONSPROTOTYPEN ****************************************
           0249 			;void init_all();
           0250 			;
           0251 			;//*********************** HAUPTPROGRAMM **********************************************
           0252 			;void main(void)
           0253 			;{
           0254 _const1
0017 0020  0255 	MOVLB 0
0018 00A8  0256 	MOVWF ci
0019 3000  0257 	MOVLW 0
001A 0023  0258 	MOVLB 3
001B 0092  0259 	MOVWF EEADRH
001C 0020  0260 	MOVLB 0
001D 0C28  0261 	RRF   ci,W
001E 397F  0262 	ANDLW 127
001F 3E34  0263 	ADDLW 52
0020 0023  0264 	MOVLB 3
0021 0091  0265 	MOVWF EEADRL
0022 1803  0266 	BTFSC 0x03,Carry
0023 0A92  0267 	INCF  EEADRH,1
0024 0023  0268 	MOVLB 3
0025 1795  0269 	BSF   0x195,EEPGD
0026 1415  0270 	BSF   0x195,RD
0027 0000  0271 	NOP  
0028 0000  0272 	NOP  
0029 0020  0273 	MOVLB 0
002A 1828  0274 	BTFSC ci,0
002B 2830  0275 	GOTO  m004
002C 0023  0276 	MOVLB 3
002D 0813  0277 	MOVF  EEDATL,W
002E 397F  0278 	ANDLW 127
002F 0008  0279 	RETURN
0030 0023  0280 m004	MOVLB 3
0031 0D13  0281 	RLF   EEDATL,W
0032 0D14  0282 	RLF   EEDATH,W
0033 0008  0283 	RETURN
0034 22A0  0284 	DW    0x22A0
0035 2952  0285 	DW    0x2952
0036 294F  0286 	DW    0x294F
0037 103A  0287 	DW    0x103A
0038 32D2  0288 	DW    0x32D2
0039 32E3  0289 	DW    0x32E3
003A 3B69  0290 	DW    0x3B69
003B 3165  0291 	DW    0x3165
003C 3375  0292 	DW    0x3375
003D 32E6  0293 	DW    0x32E6
003E 1072  0294 	DW    0x1072
003F 3AE6  0295 	DW    0x3AE6
0040 366C  0296 	DW    0x366C
0041 1000  0297 	DW    0x1000
0042 2945  0298 	DW    0x2945
0043 27D2  0299 	DW    0x27D2
0044 1D52  0300 	DW    0x1D52
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 6

ADDR CODE  LINE SOURCE

0045 21A0  0301 	DW    0x21A0
0046 21D2  0302 	DW    0x21D2
0047 21AD  0303 	DW    0x21AD
0048 32E8  0304 	DW    0x32E8
0049 35E3  0305 	DW    0x35E3
004A 3320  0306 	DW    0x3320
004B 34E1  0307 	DW    0x34E1
004C 32EC  0308 	DW    0x32EC
004D 0064  0309 	DW    0x64
004E 22A0  0310 	DW    0x22A0
004F 2952  0311 	DW    0x2952
0050 294F  0312 	DW    0x294F
0051 103A  0313 	DW    0x103A
0052 22C5  0314 	DW    0x22C5
0053 2950  0315 	DW    0x2950
0054 26CF  0316 	DW    0x26CF
0055 34A0  0317 	DW    0x34A0
0056 1073  0318 	DW    0x1073
0057 3AE6  0319 	DW    0x3AE6
0058 366C  0320 	DW    0x366C
0059 1000  0321 	DW    0x1000
005A 30E6  0322 	DW    0x30E6
005B 32E4  0323 	DW    0x32E4
005C 3320  0324 	DW    0x3320
005D 3769  0325 	DW    0x3769
005E 39E9  0326 	DW    0x39E9
005F 0068  0327 	DW    0x68
           0328 main
           0329 			;	init_all();
0060 206D  0330 	CALL  init_all
           0331 			;
           0332 			;#ifdef X86
           0333 			;	#include <pthread.h>
           0334 			;	pthread_t isrThread;
           0335 			;	pthread_t glThread;
           0336 			;	
           0337 			;	pthread_create(&isrThread, 0, InterruptRoutine, 0);
           0338 			;	pthread_create(&glThread, 0, gl_start, 0);
           0339 			;#endif /* #ifdef X86 */
           0340 			;    
           0341 			;	while(1)
           0342 			;	{
           0343 			;		throw_errors();
0061 2153  0344 m005	CALL  throw_errors
           0345 			;		commandstorage_get_commands();
0062 23CC  0346 	CALL  commandstorage_get_commands
           0347 			;		commandstorage_execute_commands();
0063 2449  0348 	CALL  commandstorage_execute_commands
           0349 			;		if(gTimecounter == 0)
0064 0020  0350 	MOVLB 0
0065 08E0  0351 	MOVF  gTimecounter,1
0066 1D03  0352 	BTFSS 0x03,Zero_
0067 2861  0353 	GOTO  m005
           0354 			;		{
           0355 			;			if(gLedBuf.led_fade_operation)
0068 0023  0356 	MOVLB 3
0069 1C31  0357 	BTFSS gLedBuf+336,0
006A 2861  0358 	GOTO  m005
           0359 			;				ledstrip_do_fade();
006B 2285  0360 	CALL  ledstrip_do_fade
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 7

ADDR CODE  LINE SOURCE

           0361 			;		}	
           0362 			;	}
006C 2861  0363 	GOTO  m005
           0364 			;}
           0365 			;//*********************** UNTERPROGRAMME **********************************************
           0366 			;
           0367 			;void init_all()
           0368 			;{
           0369 init_all
           0370 			;	OsciInit();
006D 3072  0371 	MOVLW 114
006E 0021  0372 	MOVLB 1
006F 0099  0373 	MOVWF OSCCON
           0374 			;	RingBufInit();
0070 22D3  0375 	CALL  RingBufInit
           0376 			;	USARTinit();
0071 234C  0377 	CALL  USARTinit
           0378 			;	spi_init();
0072 22F9  0379 	CALL  spi_init
           0380 			;	ledstrip_init();
0073 216F  0381 	CALL  ledstrip_init
           0382 			;	commandstorage_init();
0074 2468  0383 	CALL  commandstorage_init
           0384 			;	timer_init();
0075 2341  0385 	CALL  timer_init
           0386 			;	InitFET();
0076 0021  0387 	MOVLB 1
0077 100E  0388 	BCF   TRISC,0
           0389 			;	PowerOnLEDs();
0078 0020  0390 	MOVLB 0
0079 100E  0391 	BCF   PORTC,0
           0392 			;    
           0393 			;	ErrorInit();
007A 104C  0394 	BCF   gERROR,0
007B 10CC  0395 	BCF   gERROR,1
           0396 			;	ClearCmdBuf();	
007C 01CD  0397 	CLRF  gCmdBuf
007D 01CE  0398 	CLRF  gCmdBuf+1
           0399 			;	AllowInterrupts();
007E 0021  0400 	MOVLB 1
007F 1691  0401 	BSF   0x91,RCIE
0080 170B  0402 	BSF   0x0B,PEIE
0081 178B  0403 	BSF   0x0B,GIE
           0404 			;	
           0405 			;	// *** send ready after init
           0406 			;	USARTsend('R');
0082 3052  0407 	MOVLW 82
0083 235F  0408 	CALL  USARTsend
           0409 			;	USARTsend('D');
0084 3044  0410 	MOVLW 68
0085 235F  0411 	CALL  USARTsend
           0412 			;	USARTsend('Y');
0086 3059  0413 	MOVLW 89
0087 2B5F  0414 	GOTO  USARTsend
           0415 			;}
           0416 
           0417   ; FILE crc.c
           0418 			; // Include-Datei zum Erstellen von CRC Prüfsummen
           0419 			; //
           0420 			; //
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 8

ADDR CODE  LINE SOURCE

           0421 			; // Nils Weiß
           0422 			; // 14.04.2012
           0423 			; // Compiler CC5x
           0424 			;
           0425 			;// 16-bit CCIT CRC
           0426 			;
           0427 			;void addCRC(char byte, char* p_crcH, char* p_crcL)
           0428 			;{
           0429 addCRC
           0430 			;	char index;
           0431 			;	char crcH,crcL;
           0432 			;	crcH = *p_crcH;
0088 0185  0433 	CLRF  FSR0H
0089 0020  0434 	MOVLB 0
008A 0826  0435 	MOVF  p_crcH,W
008B 0084  0436 	MOVWF FSR0L
008C 0800  0437 	MOVF  INDF0,W
008D 00A9  0438 	MOVWF crcH
           0439 			;	crcL = *p_crcL;
008E 0185  0440 	CLRF  FSR0H
008F 0827  0441 	MOVF  p_crcL,W
0090 0084  0442 	MOVWF FSR0L
0091 0800  0443 	MOVF  INDF0,W
0092 00AA  0444 	MOVWF crcL
           0445 			;
           0446 			;	MOVF(byte,0);
0093 0825  0447 	MOVF  byte,W
           0448 			;	
           0449 			;	XORWF(crcH,0);
0094 0629  0450 	XORWF crcH,W
           0451 			;	MOVWF(index);
0095 00A8  0452 	MOVWF index
           0453 			;	ANDLW(0xf0);
0096 39F0  0454 	ANDLW 240
           0455 			;	SWAPF(index,1);
0097 0EA8  0456 	SWAPF index,1
           0457 			;	XORWF(index,1);
0098 06A8  0458 	XORWF index,1
           0459 			;	
           0460 			;	MOVF(index,0);
0099 0828  0461 	MOVF  index,W
           0462 			;	ANDLW(0xf0);
009A 39F0  0463 	ANDLW 240
           0464 			;	XORWF(crcL,0);
009B 062A  0465 	XORWF crcL,W
           0466 			;	MOVWF(crcH);
009C 00A9  0467 	MOVWF crcH
           0468 			;	
           0469 			;	RLF(index,0);
009D 0D28  0470 	RLF   index,W
           0471 			;	RLF(index,0);
009E 0D28  0472 	RLF   index,W
           0473 			;	XORWF(crcH,1);
009F 06A9  0474 	XORWF crcH,1
           0475 			;	ANDLW(0xe0);
00A0 39E0  0476 	ANDLW 224
           0477 			;	XORWF(crcH,1);
00A1 06A9  0478 	XORWF crcH,1
           0479 			;		
           0480 			;	SWAPF(index,1);
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 9

ADDR CODE  LINE SOURCE

00A2 0EA8  0481 	SWAPF index,1
           0482 			;	XORWF(index,0);
00A3 0628  0483 	XORWF index,W
           0484 			;	MOVWF(crcL);
00A4 00AA  0485 	MOVWF crcL
           0486 			;
           0487 			;	*p_crcH = crcH;
00A5 0185  0488 	CLRF  FSR0H
00A6 0826  0489 	MOVF  p_crcH,W
00A7 0084  0490 	MOVWF FSR0L
00A8 0829  0491 	MOVF  crcH,W
00A9 0080  0492 	MOVWF INDF0
           0493 			;	*p_crcL = crcL;
00AA 0185  0494 	CLRF  FSR0H
00AB 0827  0495 	MOVF  p_crcL,W
00AC 0084  0496 	MOVWF FSR0L
00AD 082A  0497 	MOVF  crcL,W
00AE 0080  0498 	MOVWF INDF0
           0499 			;
           0500 			;}
00AF 0008  0501 	RETURN
           0502 			;
           0503 			;void CRC(char *data, char length, char* crcH_out, char* crcL_out)
           0504 			;{
           0505 CRC
           0506 			;	if(!crcH_out)return;
00B0 08FF  0507 	MOVF  crcH_out,1
00B1 1903  0508 	BTFSC 0x03,Zero_
00B2 0008  0509 	RETURN
           0510 			;	if(!crcL_out)return;
00B3 08FF  0511 	MOVF  crcL_out,1
00B4 1903  0512 	BTFSC 0x03,Zero_
00B5 0008  0513 	RETURN
           0514 			;	if(!data)return;
00B6 08FF  0515 	MOVF  data,1
00B7 1903  0516 	BTFSC 0x03,Zero_
00B8 0008  0517 	RETURN
           0518 			;	char crcH,crcL,i,byte;
           0519 			;	crcH=0xff;
00B9 30FF  0520 	MOVLW 255
00BA 00FF  0521 	MOVWF crcH_2
           0522 			;	crcL=0xff;
00BB 30FF  0523 	MOVLW 255
00BC 00FF  0524 	MOVWF crcL_2
           0525 			;
           0526 			;	for(i=0;i<length;i++)
00BD 01FF  0527 	CLRF  i
00BE 087F  0528 m006	MOVF  length,W
00BF 027F  0529 	SUBWF i,W
00C0 1803  0530 	BTFSC 0x03,Carry
00C1 28D2  0531 	GOTO  m007
           0532 			;	{
           0533 			;		byte = data[i];
00C2 087F  0534 	MOVF  i,W
00C3 077F  0535 	ADDWF data,W
00C4 0084  0536 	MOVWF FSR0L
00C5 0185  0537 	CLRF  FSR0H
00C6 0800  0538 	MOVF  INDF0,W
00C7 00FF  0539 	MOVWF byte_2
           0540 			;		addCRC(byte,&crcH,&crcL);
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 10

ADDR CODE  LINE SOURCE

00C8 087F  0541 	MOVF  byte_2,W
00C9 0020  0542 	MOVLB 0
00CA 00A5  0543 	MOVWF byte
00CB 307F  0544 	MOVLW 127
00CC 00A6  0545 	MOVWF p_crcH
00CD 307F  0546 	MOVLW 127
00CE 00A7  0547 	MOVWF p_crcL
00CF 2088  0548 	CALL  addCRC
           0549 			;	}
00D0 0AFF  0550 	INCF  i,1
00D1 28BE  0551 	GOTO  m006
           0552 			;	
           0553 			;	*crcH_out = crcH;
00D2 0185  0554 m007	CLRF  FSR0H
00D3 087F  0555 	MOVF  crcH_out,W
00D4 0084  0556 	MOVWF FSR0L
00D5 087F  0557 	MOVF  crcH_2,W
00D6 0080  0558 	MOVWF INDF0
           0559 			;	*crcL_out = crcL;
00D7 0185  0560 	CLRF  FSR0H
00D8 087F  0561 	MOVF  crcL_out,W
00D9 0084  0562 	MOVWF FSR0L
00DA 087F  0563 	MOVF  crcL_2,W
00DB 0080  0564 	MOVWF INDF0
           0565 			;}
00DC 0008  0566 	RETURN
           0567 			;
           0568 			;void newCRC(char* p_crcH, char* p_crcL)
           0569 			;{
           0570 newCRC
           0571 			;    if(!p_crcH) return;
00DD 0020  0572 	MOVLB 0
00DE 08A5  0573 	MOVF  p_crcH_2,1
00DF 1903  0574 	BTFSC 0x03,Zero_
00E0 0008  0575 	RETURN
           0576 			;    if(!p_crcL) return;
00E1 0020  0577 	MOVLB 0
00E2 08A6  0578 	MOVF  p_crcL_2,1
00E3 1903  0579 	BTFSC 0x03,Zero_
00E4 0008  0580 	RETURN
           0581 			;    *p_crcH = 0xff;
00E5 0185  0582 	CLRF  FSR0H
00E6 0020  0583 	MOVLB 0
00E7 0825  0584 	MOVF  p_crcH_2,W
00E8 0084  0585 	MOVWF FSR0L
00E9 30FF  0586 	MOVLW 255
00EA 0080  0587 	MOVWF INDF0
           0588 			;    *p_crcL = 0xff;
00EB 0185  0589 	CLRF  FSR0H
00EC 0826  0590 	MOVF  p_crcL_2,W
00ED 0084  0591 	MOVWF FSR0L
00EE 30FF  0592 	MOVLW 255
00EF 0080  0593 	MOVWF INDF0
           0594 			;}
00F0 0008  0595 	RETURN
           0596 
           0597   ; FILE eeprom.c
           0598 			;//Funktionen für EEPROM-Zugriffe
           0599 			;
           0600 			;//Nils Weiß 
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 11

ADDR CODE  LINE SOURCE

           0601 			;//05.09.2011
           0602 			;//Compiler CC5x
           0603 			;
           0604 			;#ifndef X86
           0605 			;//*********************** EEPROM BYTE SCHREIBEN  **********************************************
           0606 			;
           0607 			;void EEPROM_WR(char adress, char data)
           0608 			;{
           0609 EEPROM_WR
00F1 0020  0610 	MOVLB 0
00F2 00B1  0611 	MOVWF data_2
           0612 			;	bit GIE_status; 
           0613 			;	//EEADRH = (char)(adress<<8);
           0614 			;    EEADRL = (char)adress;        // Adresse in Adressregister übertragen
00F3 0830  0615 	MOVF  adress,W
00F4 0023  0616 	MOVLB 3
00F5 0091  0617 	MOVWF EEADRL
           0618 			;	EEDATL = data;          // Daten in Datenregister übertragen
00F6 0020  0619 	MOVLB 0
00F7 0831  0620 	MOVF  data_2,W
00F8 0023  0621 	MOVLB 3
00F9 0093  0622 	MOVWF EEDATL
           0623 			;    CFGS = 0;
00FA 1315  0624 	BCF   0x195,CFGS
           0625 			;	EEPGD = 0;                // Auswahl: Programmspeicher lesen oder EEPROM
00FB 1395  0626 	BCF   0x195,EEPGD
           0627 			;    WREN = 1;                 // Schreiben ins EEPROM erlauben
00FC 1515  0628 	BSF   0x195,WREN
           0629 			;	GIE_status=GIE;			
00FD 0020  0630 	MOVLB 0
00FE 1032  0631 	BCF   0x32,GIE_status
00FF 1B8B  0632 	BTFSC 0x0B,GIE
0100 1432  0633 	BSF   0x32,GIE_status
           0634 			;    GIE=0;                  // Interrups verbieten
0101 138B  0635 	BCF   0x0B,GIE
           0636 			;    EECON2 = 0x55;
0102 3055  0637 	MOVLW 85
0103 0023  0638 	MOVLB 3
0104 0096  0639 	MOVWF EECON2
           0640 			;    EECON2 = 0xAA;
0105 30AA  0641 	MOVLW 170
0106 0096  0642 	MOVWF EECON2
           0643 			;	WR=1; 					// Starten des Schreibens
0107 1495  0644 	BSF   0x195,WR
           0645 			;    GIE=GIE_status;                  // Interrups erlauben
0108 0020  0646 	MOVLB 0
0109 1C32  0647 	BTFSS 0x32,GIE_status
010A 138B  0648 	BCF   0x0B,GIE
010B 1832  0649 	BTFSC 0x32,GIE_status
010C 178B  0650 	BSF   0x0B,GIE
           0651 			;	WREN=0;
010D 0023  0652 	MOVLB 3
010E 1115  0653 	BCF   0x195,WREN
           0654 			;	while(WR);
010F 0023  0655 m008	MOVLB 3
0110 1895  0656 	BTFSC 0x195,WR
0111 290F  0657 	GOTO  m008
           0658 			;}
0112 0008  0659 	RETURN
           0660 			;
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 12

ADDR CODE  LINE SOURCE

           0661 			;//*********************** EEPROM BYTE LESEN  **********************************************
           0662 			;
           0663 			;char EEPROM_RD(char adress)
           0664 			;{
           0665 EEPROM_RD
0113 0020  0666 	MOVLB 0
0114 00B5  0667 	MOVWF adress_2
           0668 			;    char data;
           0669 			;    //EEADRH = (char)(adress<<8);        // Adresse in Adressregister übertragen
           0670 			;    EEADRL = (char)(adress);
0115 0835  0671 	MOVF  adress_2,W
0116 0023  0672 	MOVLB 3
0117 0091  0673 	MOVWF EEADRL
           0674 			;	CFGS=0;
0118 1315  0675 	BCF   0x195,CFGS
           0676 			;	EEPGD=0;                // Auswahl: Programmspeicher lesen oder EEPROM
0119 1395  0677 	BCF   0x195,EEPGD
           0678 			;    RD=1;                   // Starten des Lesesn
011A 1415  0679 	BSF   0x195,RD
           0680 			;    data = EEDATL;       // Daten aus Datenregister auslesen
011B 0813  0681 	MOVF  EEDATL,W
011C 0020  0682 	MOVLB 0
011D 00B6  0683 	MOVWF data_3
           0684 			;    return data;
011E 0836  0685 	MOVF  data_3,W
011F 0008  0686 	RETURN
           0687 			;}
           0688 			;#endif /* #ifndef X86 */
           0689 			;
           0690 			;//*********************** EEPROM BYTEARRAY SCHREIBEN  **************************************
           0691 			;
           0692 			;void EEPROM_WR_BLK(char *array, char adress, char length)			//Zum Ausführen eines beliebigen Befehls durch den Programmcode
           0693 			;{
           0694 EEPROM_WR_BLK
0120 0020  0695 	MOVLB 0
0121 00AA  0696 	MOVWF length_2
           0697 			;	if(!array) return;
0122 08A8  0698 	MOVF  array,1
0123 1903  0699 	BTFSC 0x03,Zero_
0124 0008  0700 	RETURN
           0701 			;	char i;
           0702 			;	for(i=0;i<length;i++)
0125 0020  0703 	MOVLB 0
0126 01AB  0704 	CLRF  i_2
0127 0020  0705 m009	MOVLB 0
0128 082A  0706 	MOVF  length_2,W
0129 022B  0707 	SUBWF i_2,W
012A 1803  0708 	BTFSC 0x03,Carry
012B 2938  0709 	GOTO  m010
           0710 			;	{
           0711 			;		EEPROM_WR(adress,*array);
012C 0829  0712 	MOVF  adress_3,W
012D 00B0  0713 	MOVWF adress
012E 0185  0714 	CLRF  FSR0H
012F 0828  0715 	MOVF  array,W
0130 0084  0716 	MOVWF FSR0L
0131 0800  0717 	MOVF  INDF0,W
0132 20F1  0718 	CALL  EEPROM_WR
           0719 			;		adress++;
0133 0020  0720 	MOVLB 0
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 13

ADDR CODE  LINE SOURCE

0134 0AA9  0721 	INCF  adress_3,1
           0722 			;		array++;
0135 0AA8  0723 	INCF  array,1
           0724 			;	}
0136 0AAB  0725 	INCF  i_2,1
0137 2927  0726 	GOTO  m009
           0727 			;}
0138 0008  0728 m010	RETURN
           0729 			;
           0730 			;//*********************** EEPROM BYTEARRAY LESEN  **************************************
           0731 			;
           0732 			;void EEPROM_RD_BLK(char *array, char adress, char length)			//Zum Ausführen eines beliebigen Befehls durch den Programmcode
           0733 			;{
           0734 EEPROM_RD_BLK
0139 0020  0735 	MOVLB 0
013A 00B2  0736 	MOVWF length_3
           0737 			;	if(!array) return;
013B 08B0  0738 	MOVF  array_2,1
013C 1903  0739 	BTFSC 0x03,Zero_
013D 0008  0740 	RETURN
           0741 			;	char i, temp;
           0742 			;	for(i=0;i<length;i++)
013E 0020  0743 	MOVLB 0
013F 01B3  0744 	CLRF  i_3
0140 0020  0745 m011	MOVLB 0
0141 0832  0746 	MOVF  length_3,W
0142 0233  0747 	SUBWF i_3,W
0143 1803  0748 	BTFSC 0x03,Carry
0144 2952  0749 	GOTO  m012
           0750 			;	{
           0751 			;		temp = EEPROM_RD(adress);
0145 0831  0752 	MOVF  adress_4,W
0146 2113  0753 	CALL  EEPROM_RD
0147 0020  0754 	MOVLB 0
0148 00B4  0755 	MOVWF temp_2
           0756 			;		array[i] = temp;
0149 0833  0757 	MOVF  i_3,W
014A 0730  0758 	ADDWF array_2,W
014B 0084  0759 	MOVWF FSR0L
014C 0185  0760 	CLRF  FSR0H
014D 0834  0761 	MOVF  temp_2,W
014E 0080  0762 	MOVWF INDF0
           0763 			;		adress++;
014F 0AB1  0764 	INCF  adress_4,1
           0765 			;	}
0150 0AB3  0766 	INCF  i_3,1
0151 2940  0767 	GOTO  m011
           0768 			;}
0152 0008  0769 m012	RETURN
           0770 
           0771   ; FILE error.c
           0772 			;
           0773 			;#include "commandstorage.h"
           0774 			;#include "error.h"
           0775 			;#include "RingBuf.h"
           0776 			;#include "usart.h"
           0777 			;
           0778 			;void throw_errors()
           0779 			;{
           0780 throw_errors
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 14

ADDR CODE  LINE SOURCE

           0781 			;	if(RingBufHasError) 
0153 0020  0782 	MOVLB 0
0154 1C4B  0783 	BTFSS gRingBuf+18,0
0155 295E  0784 	GOTO  m013
           0785 			;	{
           0786 			;		// *** if a RingBufError occure, I have to throw away the current command,
           0787 			;		// *** because the last byte was not saved. Commandstring is inconsistent
           0788 			;		ClearCmdBuf();
0156 01CD  0789 	CLRF  gCmdBuf
0157 01CE  0790 	CLRF  gCmdBuf+1
           0791 			;USARTsend('x');
0158 3078  0792 	MOVLW 120
0159 235F  0793 	CALL  USARTsend
           0794 			;		USARTsend_str(" ERROR: Receivebuffer full");
015A 0020  0795 	MOVLB 0
015B 01A6  0796 	CLRF  string
015C 2369  0797 	CALL  USARTsend_str
           0798 			;		// *** Re-init the Ringbuffer to get a consistent commandstring and reset error
           0799 			;		RingBufInit();
015D 22D3  0800 	CALL  RingBufInit
           0801 			;	}
           0802 			;	if(gERROR.crc_failure)
015E 0020  0803 m013	MOVLB 0
015F 1C4C  0804 	BTFSS gERROR,0
0160 2966  0805 	GOTO  m014
           0806 			;	{
           0807 			;		USARTsend_str(" ERROR: CRC-Check failed");
0161 301B  0808 	MOVLW 27
0162 00A6  0809 	MOVWF string
0163 2369  0810 	CALL  USARTsend_str
           0811 			;		gERROR.crc_failure = 0;
0164 0020  0812 	MOVLB 0
0165 104C  0813 	BCF   gERROR,0
           0814 			;	}
           0815 			;	if(gERROR.eeprom_failure)
0166 0020  0816 m014	MOVLB 0
0167 1CCC  0817 	BTFSS gERROR,1
0168 296E  0818 	GOTO  m015
           0819 			;	{
           0820 			;		USARTsend_str(" ERROR: EEPROM is full");
0169 3034  0821 	MOVLW 52
016A 00A6  0822 	MOVWF string
016B 2369  0823 	CALL  USARTsend_str
           0824 			;		gERROR.eeprom_failure = 0;
016C 0020  0825 	MOVLB 0
016D 10CC  0826 	BCF   gERROR,1
           0827 			;	}
           0828 			;}
016E 0008  0829 m015	RETURN
           0830 
           0831   ; FILE MATH16.H
           0832 			;// SIZE
           0833 			;
           0834 			;#pragma library 1
           0835 			;/*
           0836 			;uns16 operator* _mult8x8( uns8 arg1, uns8 arg2);
           0837 			;int16 operator* _multS8x8( int8 arg1, int8 arg2);
           0838 			;uns16 operator* _multU16x8( uns16 arg1, uns8 arg2);
           0839 			;uns16 operator* _mult16x16( uns16 arg1, uns16 arg2);
           0840 			;uns16 operator/ _divU16_8( uns16 arg1, uns8 arg2);
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 15

ADDR CODE  LINE SOURCE

           0841 			;uns16 operator/ _divU16_16( uns16 arg1, uns16 arg2);
           0842 			;int16 operator/ _divS16_8( int16 arg1, int8 arg2);
           0843 			;int16 operator/ _divS16_16( int16 arg1, int16 arg2);
           0844 			;uns8 operator% _remU16_8( uns16 arg1, uns8 arg2);
           0845 			;uns16 operator% _remU16_16( uns16 arg1, uns16 arg2);
           0846 			;int8 operator% _remS16_8( int16 arg1, int8 arg2);
           0847 			;int16 operator% _remS16_16( int16 arg1, int16 arg2);
           0848 			;*/
           0849 			;
           0850 			;#if __CoreSet__ < 1410
           0851 			; #define genAdd(r,a) W=a; btsc(Carry); W=incsz(a); r+=W
           0852 			; #define genSub(r,a) W=a; btss(Carry); W=incsz(a); r-=W
           0853 			; #define genAddW(r,a) W=a; btsc(Carry); W=incsz(a); W=r+W
           0854 			; #define genSubW(r,a) W=a; btss(Carry); W=incsz(a); W=r-W
           0855 			;#else
           0856 			; #define genAdd(r,a) W=a; r=addWFC(r)
           0857 			; #define genSub(r,a) W=a; r=subWFB(r)
           0858 			; #define genAddW(r,a) W=a; W=addWFC(r)
           0859 			; #define genSubW(r,a) W=a; W=subWFB(r)
           0860 			;#endif
           0861 			;
           0862 			;
           0863 			;int8 operator*( int8 arg1, int8 arg2)  @
           0864 			;
           0865 			;uns16 operator* _mult8x8( uns8 arg1, uns8 arg2)
           0866 			;{
           0867 _mult8x8
           0868 			;    uns16 rval;
           0869 			;    char counter = sizeof(arg2)*8;
           0870 			;    rval.high8 = 0;
           0871 			;    W = arg1;
           0872 			;    do  {
           0873 			;        arg2 = rr( arg2);
           0874 			;        if (Carry)
           0875 			;            rval.high8 += W;
           0876 			;        rval = rr( rval);
           0877 			;        counter = decsz(counter);
           0878 			;    } while (1);
           0879 			;    return rval;
           0880 			;}
           0881 			;
           0882 			;
           0883 			;int16 operator* _multS8x8( int8 arg1, int8 arg2)
           0884 			;{
           0885 _multS8x8
           0886 			;    uns16 rval;
           0887 			;    char counter = sizeof(arg2)*8;
           0888 			;    int8 tmpArg2 = arg2;
           0889 			;    rval.high8 = 0;
           0890 			;    W = arg1;
           0891 			;    do  {
           0892 			;        tmpArg2 = rr( tmpArg2);
           0893 			;        if (Carry)
           0894 			;            rval.high8 += W;
           0895 			;        rval = rr( rval);
           0896 			;        counter = decsz(counter);
           0897 			;    } while (1);
           0898 			;    W = arg2;
           0899 			;    if (arg1 < 0)
           0900 			;        rval.high8 -= W;
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 16

ADDR CODE  LINE SOURCE

           0901 			;    W = arg1;
           0902 			;    if (arg2 < 0)
           0903 			;        rval.high8 -= W;
           0904 			;    return rval;
           0905 			;}
           0906 			;
           0907 			;
           0908 			;uns16 operator*( uns8 arg1, uns16 arg2) exchangeArgs @
           0909 			;
           0910 			;uns16 operator* _multU16x8( uns16 arg1, uns8 arg2)
           0911 			;{
           0912 _multU16x8
           0913 			;    uns16 rval;
           0914 			;    uns8 rvalH = 0;
           0915 			;    char counter = sizeof(arg1)*8;
           0916 			;    W = arg2;
           0917 			;    do  {
           0918 			;        arg1 = rr( arg1);
           0919 			;        if (Carry)
           0920 			;            rvalH += W;
           0921 			;        rvalH = rr(rvalH);
           0922 			;        rval = rr(rval);
           0923 			;        counter = decsz(counter);
           0924 			;    } while (1);
           0925 			;    return rval;
           0926 			;}
           0927 			;
           0928 			;
           0929 			;int16 operator*( int16 arg1, int16 arg2) @
           0930 			;
           0931 			;uns16 operator* _mult16x16( uns16 arg1, uns16 arg2)
           0932 			;{
           0933 _mult16x16
           0934 			;    uns16 rval;
           0935 			;    char counter = sizeof(arg1)*8;
           0936 			;    do  {
           0937 			;        Carry = 0;
           0938 			;        rval = rl( rval);
           0939 			;        arg1 = rl( arg1);
           0940 			;        if (Carry)
           0941 			;            rval += arg2;
           0942 			;        counter = decsz(counter);
           0943 			;    } while (1);
           0944 			;    return rval;
           0945 			;}
           0946 			;
           0947 			;
           0948 			;
           0949 			;uns16 operator/ _divU16_8( uns16 arg1, uns8 arg2)
           0950 			;{
           0951 _divU16_8
           0952 			;    uns8 rm = 0;
           0953 			;    char counter = sizeof(arg1)*8+1;
           0954 			;    goto ENTRY_ML;
           0955 			;    do  {
           0956 			;        rm = rl( rm);
           0957 			;        uns8 tmp = rl( tmp);
           0958 			;        W = rm - arg2;
           0959 			;        if (tmp&1)
           0960 			;            Carry = 1;
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 17

ADDR CODE  LINE SOURCE

           0961 			;        if (Carry)
           0962 			;            rm = W;
           0963 			;       ENTRY_ML:
           0964 			;        arg1 = rl( arg1);
           0965 			;        counter = decsz(counter);
           0966 			;    } while (1);
           0967 			;    return arg1;
           0968 			;}
           0969 			;
           0970 			;
           0971 			;uns16 operator/ _divU16_16( uns16 arg1, uns16 arg2)
           0972 			;{
           0973 _divU16_16
           0974 			;    uns16 rm = 0;
           0975 			;    char counter = sizeof(arg1)*8+1;
           0976 			;    goto ENTRY_ML;
           0977 			;    do  {
           0978 			;        rm = rl( rm);
           0979 			;        W = rm.low8 - arg2.low8;
           0980 			;        genSubW( rm.high8, arg2.high8);
           0981 			;        if (!Carry)
           0982 			;            goto ENTRY_ML;
           0983 			;        rm.high8 = W;
           0984 			;        rm.low8 -= arg2.low8;
           0985 			;        Carry = 1;
           0986 			;       ENTRY_ML:
           0987 			;        arg1 = rl( arg1);
           0988 			;        counter = decsz(counter);
           0989 			;    } while (1);
           0990 			;    return arg1;
           0991 			;}
           0992 			;
           0993 			;
           0994 			;int8  operator/ (int8 arg1, int8 arg2) @
           0995 			;
           0996 			;int16 operator/ _divS16_8( int16 arg1, int8 arg2)
           0997 			;{
           0998 _divS16_8
           0999 			;    uns8 rm = 0;
           1000 			;    char counter = 16+1;
           1001 			;    char sign = arg1.high8 ^ arg2.high8;
           1002 			;    if (arg1 < 0)  {
           1003 			;       INVERT_ML:
           1004 			;        arg1 = -arg1;
           1005 			;        if (!counter)
           1006 			;            return arg1;
           1007 			;    }
           1008 			;    if (arg2 < 0)
           1009 			;        arg2 = -arg2;
           1010 			;    goto ENTRY_ML;
           1011 			;    do  {
           1012 			;        rm = rl( rm);
           1013 			;        W = rm - arg2;
           1014 			;        if (Carry)
           1015 			;            rm = W;
           1016 			;       ENTRY_ML:
           1017 			;        arg1 = rl( arg1);
           1018 			;        counter = decsz(counter);
           1019 			;    } while (1);
           1020 			;    if (sign & 0x80)
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 18

ADDR CODE  LINE SOURCE

           1021 			;        goto INVERT_ML;
           1022 			;    return arg1;
           1023 			;}
           1024 			;
           1025 			;
           1026 			;int16 operator/ _divS16_16( int16 arg1, int16 arg2)
           1027 			;{
           1028 _divS16_16
           1029 			;    uns16 rm = 0;
           1030 			;    char counter = sizeof(arg1)*8+1;
           1031 			;    char sign = arg1.high8 ^ arg2.high8;
           1032 			;    if (arg1 < 0)  {
           1033 			;       INVERT_ML:
           1034 			;        arg1 = -arg1;
           1035 			;        if (!counter)
           1036 			;            return arg1;
           1037 			;    }
           1038 			;    if (arg2 < 0)
           1039 			;        arg2 = -arg2;
           1040 			;    goto ENTRY_ML;
           1041 			;    do  {
           1042 			;        rm = rl( rm);
           1043 			;        W = rm.low8 - arg2.low8;
           1044 			;        genSubW( rm.high8, arg2.high8);
           1045 			;        if (!Carry)
           1046 			;            goto ENTRY_ML;
           1047 			;        rm.high8 = W;
           1048 			;        rm.low8 -= arg2.low8;
           1049 			;        Carry = 1;
           1050 			;       ENTRY_ML:
           1051 			;        arg1 = rl( arg1);
           1052 			;        counter = decsz(counter);
           1053 			;    } while (1);
           1054 			;    if (sign & 0x80)
           1055 			;        goto INVERT_ML;
           1056 			;    return arg1;
           1057 			;}
           1058 			;
           1059 			;
           1060 			;uns8 operator% _remU16_8( uns16 arg1, uns8 arg2)
           1061 			;{
           1062 _remU16_8
           1063 			;    uns8 rm = 0;
           1064 			;    char counter = sizeof(arg1)*8;
           1065 			;    do  {
           1066 			;        arg1 = rl( arg1);
           1067 			;        rm = rl( rm);
           1068 			;        uns8 tmp = rl( tmp);
           1069 			;        W = rm - arg2;
           1070 			;        if (tmp&1)
           1071 			;            Carry = 1;
           1072 			;        if (Carry)
           1073 			;            rm = W;
           1074 			;        counter = decsz(counter);
           1075 			;    } while (1);
           1076 			;    return rm;
           1077 			;}
           1078 			;
           1079 			;
           1080 			;uns16 operator% _remU16_16( uns16 arg1, uns16 arg2)
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 19

ADDR CODE  LINE SOURCE

           1081 			;{
           1082 _remU16_16
           1083 			;    uns16 rm = 0;
           1084 			;    char counter = sizeof(arg1)*8;
           1085 			;    do  {
           1086 			;        arg1 = rl( arg1);
           1087 			;        rm = rl( rm);
           1088 			;        W = rm.low8 - arg2.low8;
           1089 			;        genSubW( rm.high8, arg2.high8);
           1090 			;        if (!Carry)
           1091 			;            goto NOSUB;
           1092 			;        rm.high8 = W;
           1093 			;        rm.low8 -= arg2.low8;
           1094 			;      NOSUB:
           1095 			;        counter = decsz(counter);
           1096 			;    } while (1);
           1097 			;    return rm;
           1098 			;}
           1099 			;
           1100 			;
           1101 			;int8 operator% (int8 arg1, int8 arg2) @
           1102 			;
           1103 			;int8 operator% _remS16_8( int16 arg1, int8 arg2)
           1104 			;{
           1105 _remS16_8
           1106 			;    int8 rm = 0;
           1107 			;    char counter = 16;
           1108 			;    char sign = arg1.high8;
           1109 			;    if (arg1 < 0)
           1110 			;        arg1 = -arg1;
           1111 			;    if (arg2 < 0)
           1112 			;        arg2 = -arg2;
           1113 			;    do  {
           1114 			;        arg1 = rl( arg1);
           1115 			;        rm = rl( rm);
           1116 			;        W = rm - arg2;
           1117 			;        if (Carry)
           1118 			;            rm = W;
           1119 			;        counter = decsz(counter);
           1120 			;    } while (1);
           1121 			;    if (sign & 0x80)
           1122 			;        rm = -rm;
           1123 			;    return rm;
           1124 			;}
           1125 			;
           1126 			;
           1127 			;int16 operator% _remS16_16( int16 arg1, int16 arg2)
           1128 			;{
           1129 _remS16_16
           1130 			;    int16 rm = 0;
           1131 			;    char counter = sizeof(arg1)*8;
           1132 			;    char sign = arg1.high8;
           1133 			;    if (arg1 < 0)
           1134 			;        arg1 = -arg1;
           1135 			;    if (arg2 < 0)
           1136 			;        arg2 = -arg2;
           1137 			;    do  {
           1138 			;        arg1 = rl( arg1);
           1139 			;        rm = rl( rm);
           1140 			;        W = rm.low8 - arg2.low8;
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 20

ADDR CODE  LINE SOURCE

           1141 			;        genSubW( rm.high8, arg2.high8);
           1142 			;        if (!Carry)
           1143 			;            goto NOSUB;
           1144 			;        rm.high8 = W;
           1145 			;        rm.low8 -= arg2.low8;
           1146 			;      NOSUB:
           1147 			;        counter = decsz(counter);
           1148 			;    } while (1);
           1149 			;    if (sign & 0x80)
           1150 			;        rm = -rm;
           1151 			;    return rm;
           1152 
           1153   ; FILE ledstrip.c
           1154 			;//Nils Weiß 
           1155 			;//20.04.2012
           1156 			;//Compiler CC5x 
           1157 			;
           1158 			;#include "ledstrip.h"
           1159 			;#include "MATH16.H"
           1160 			;//private function
           1161 			;void ledstrip_get_distance(char destinationvalue, char currentvalue,char* max_distance);
           1162 			;
           1163 			;void ledstrip_init(void)
           1164 			;{
           1165 ledstrip_init
           1166 			;	char k;
           1167 			;	for(k = 0;k < (NUM_OF_LED * 3); k++)
016F 0020  1168 	MOVLB 0
0170 01A2  1169 	CLRF  k
0171 3060  1170 m016	MOVLW 96
0172 0020  1171 	MOVLB 0
0173 0222  1172 	SUBWF k,W
0174 1803  1173 	BTFSC 0x03,Carry
0175 2980  1174 	GOTO  m017
           1175 			;	{	
           1176 			;		gLedBuf.led_array[k] = 0;
0176 3020  1177 	MOVLW 32
0177 0085  1178 	MOVWF FSR0+1
0178 3041  1179 	MOVLW 65
0179 0722  1180 	ADDWF k,W
017A 0084  1181 	MOVWF FSR0
017B 1803  1182 	BTFSC 0x03,Carry
017C 0A85  1183 	INCF  FSR0+1,1
017D 0180  1184 	CLRF  INDF0
           1185 			;	}
017E 0AA2  1186 	INCF  k,1
017F 2971  1187 	GOTO  m016
           1188 			;}
0180 0008  1189 m017	RETURN
           1190 			;
           1191 			;/***
           1192 			;*** This funktion sets the values of the global LedBuffer
           1193 			;*** only Led's where the address bit is 1 will be set to the new color
           1194 			;***/
           1195 			;void ledstrip_set_color(struct cmd_set_color *pCmd)
           1196 			;{	
           1197 ledstrip_set_color
           1198 			;	char *address = pCmd->addr;
0181 0020  1199 	MOVLB 0
0182 082D  1200 	MOVF  pCmd,W
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 21

ADDR CODE  LINE SOURCE

0183 00AE  1201 	MOVWF address
           1202 			;	char r = pCmd->red;
0184 3004  1203 	MOVLW 4
0185 072D  1204 	ADDWF pCmd,W
0186 0084  1205 	MOVWF FSR0L
0187 0185  1206 	CLRF  FSR0H
0188 0800  1207 	MOVF  INDF0,W
0189 00AF  1208 	MOVWF r
           1209 			;	char g = pCmd->green;
018A 3005  1210 	MOVLW 5
018B 072D  1211 	ADDWF pCmd,W
018C 0084  1212 	MOVWF FSR0L
018D 0185  1213 	CLRF  FSR0H
018E 0800  1214 	MOVF  INDF0,W
018F 00B0  1215 	MOVWF g
           1216 			;	char b = pCmd->blue;
0190 3006  1217 	MOVLW 6
0191 072D  1218 	ADDWF pCmd,W
0192 0084  1219 	MOVWF FSR0L
0193 0185  1220 	CLRF  FSR0H
0194 0800  1221 	MOVF  INDF0,W
0195 00B1  1222 	MOVWF b
           1223 			;	
           1224 			;	char k,mask;
           1225 			;	mask = 0b00000001;
0196 3001  1226 	MOVLW 1
0197 00B3  1227 	MOVWF mask
           1228 			;	for(k = 0; k < (NUM_OF_LED * 3); k++)
0198 01B2  1229 	CLRF  k_2
0199 3060  1230 m018	MOVLW 96
019A 0020  1231 	MOVLB 0
019B 0232  1232 	SUBWF k_2,W
019C 1803  1233 	BTFSC 0x03,Carry
019D 29ED  1234 	GOTO  m022
           1235 			;	{	
           1236 			;		if(0 != (*address & mask))
019E 0185  1237 	CLRF  FSR0H
019F 082E  1238 	MOVF  address,W
01A0 0084  1239 	MOVWF FSR0L
01A1 0833  1240 	MOVF  mask,W
01A2 0500  1241 	ANDWF INDF0,W
01A3 1903  1242 	BTFSC 0x03,Zero_
01A4 29DE  1243 	GOTO  m019
           1244 			;		{
           1245 			;			gLedBuf.led_array[k] = b;
01A5 3020  1246 	MOVLW 32
01A6 0085  1247 	MOVWF FSR0+1
01A7 3041  1248 	MOVLW 65
01A8 0732  1249 	ADDWF k_2,W
01A9 0084  1250 	MOVWF FSR0
01AA 1803  1251 	BTFSC 0x03,Carry
01AB 0A85  1252 	INCF  FSR0+1,1
01AC 0831  1253 	MOVF  b,W
01AD 0080  1254 	MOVWF INDF0
           1255 			;			gLedBuf.led_destination[k] = b;
01AE 3020  1256 	MOVLW 32
01AF 0085  1257 	MOVWF FSR0+1
01B0 30A1  1258 	MOVLW 161
01B1 0732  1259 	ADDWF k_2,W
01B2 0084  1260 	MOVWF FSR0
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 22

ADDR CODE  LINE SOURCE

01B3 1803  1261 	BTFSC 0x03,Carry
01B4 0A85  1262 	INCF  FSR0+1,1
01B5 0831  1263 	MOVF  b,W
01B6 0080  1264 	MOVWF INDF0
           1265 			;			k++;
01B7 0AB2  1266 	INCF  k_2,1
           1267 			;			gLedBuf.led_array[k] = g;
01B8 3020  1268 	MOVLW 32
01B9 0085  1269 	MOVWF FSR0+1
01BA 3041  1270 	MOVLW 65
01BB 0732  1271 	ADDWF k_2,W
01BC 0084  1272 	MOVWF FSR0
01BD 1803  1273 	BTFSC 0x03,Carry
01BE 0A85  1274 	INCF  FSR0+1,1
01BF 0830  1275 	MOVF  g,W
01C0 0080  1276 	MOVWF INDF0
           1277 			;			gLedBuf.led_destination[k] = g;
01C1 3020  1278 	MOVLW 32
01C2 0085  1279 	MOVWF FSR0+1
01C3 30A1  1280 	MOVLW 161
01C4 0732  1281 	ADDWF k_2,W
01C5 0084  1282 	MOVWF FSR0
01C6 1803  1283 	BTFSC 0x03,Carry
01C7 0A85  1284 	INCF  FSR0+1,1
01C8 0830  1285 	MOVF  g,W
01C9 0080  1286 	MOVWF INDF0
           1287 			;			k++;
01CA 0AB2  1288 	INCF  k_2,1
           1289 			;			gLedBuf.led_array[k] = r;
01CB 3020  1290 	MOVLW 32
01CC 0085  1291 	MOVWF FSR0+1
01CD 3041  1292 	MOVLW 65
01CE 0732  1293 	ADDWF k_2,W
01CF 0084  1294 	MOVWF FSR0
01D0 1803  1295 	BTFSC 0x03,Carry
01D1 0A85  1296 	INCF  FSR0+1,1
01D2 082F  1297 	MOVF  r,W
01D3 0080  1298 	MOVWF INDF0
           1299 			;			gLedBuf.led_destination[k] = r;
01D4 3020  1300 	MOVLW 32
01D5 0085  1301 	MOVWF FSR0+1
01D6 30A1  1302 	MOVLW 161
01D7 0732  1303 	ADDWF k_2,W
01D8 0084  1304 	MOVWF FSR0
01D9 1803  1305 	BTFSC 0x03,Carry
01DA 0A85  1306 	INCF  FSR0+1,1
01DB 082F  1307 	MOVF  r,W
01DC 0080  1308 	MOVWF INDF0
           1309 			;		}
           1310 			;		else 
01DD 29E1  1311 	GOTO  m020
           1312 			;		{
           1313 			;			k++;
01DE 0020  1314 m019	MOVLB 0
01DF 0AB2  1315 	INCF  k_2,1
           1316 			;			k++;
01E0 0AB2  1317 	INCF  k_2,1
           1318 			;		}
           1319 			;		mask = mask << 1;
01E1 1003  1320 m020	BCF   0x03,Carry
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 23

ADDR CODE  LINE SOURCE

01E2 0020  1321 	MOVLB 0
01E3 0DB3  1322 	RLF   mask,1
           1323 			;		if(0 == mask)
01E4 08B3  1324 	MOVF  mask,1
01E5 1D03  1325 	BTFSS 0x03,Zero_
01E6 29EA  1326 	GOTO  m021
           1327 			;		{
           1328 			;			address++;
01E7 0AAE  1329 	INCF  address,1
           1330 			;			mask= 0b00000001;
01E8 3001  1331 	MOVLW 1
01E9 00B3  1332 	MOVWF mask
           1333 			;		}
           1334 			;	}
01EA 0020  1335 m021	MOVLB 0
01EB 0AB2  1336 	INCF  k_2,1
01EC 2999  1337 	GOTO  m018
           1338 			;	spi_send_ledbuf(&gLedBuf.led_array[0]);
01ED 3041  1339 m022	MOVLW 65
01EE 0020  1340 	MOVLB 0
01EF 00B4  1341 	MOVWF array_4
01F0 3020  1342 	MOVLW 32
01F1 00B5  1343 	MOVWF array_4+1
01F2 2321  1344 	CALL  spi_send_ledbuf
           1345 			;	// Laufende Operationen ausschalten
           1346 			;	gLedBuf.led_fade_operation = 0;
01F3 0023  1347 	MOVLB 3
01F4 1031  1348 	BCF   gLedBuf+336,0
           1349 			;	gLedBuf.led_run_operation = 0;
01F5 10B1  1350 	BCF   gLedBuf+336,1
           1351 			;}
01F6 0008  1352 	RETURN
           1353 			;/***
           1354 			;* This funktion sets the destination color configurates
           1355 			;* the timer 1. If the settings are done, the bit led_fade_operation is 1.
           1356 			;* To configurate the Timer the funktion calculates the maximal distance between
           1357 			;* two values to calculate the time to fade by the maximal changens of one LED
           1358 			;**/
           1359 			;void ledstrip_set_fade(struct cmd_set_fade *pCmd)
           1360 			;{
           1361 ledstrip_set_fade
           1362 			;	char *address = pCmd->addr;
01F7 0020  1363 	MOVLB 0
01F8 082D  1364 	MOVF  pCmd_2,W
01F9 00AE  1365 	MOVWF address_2
           1366 			;	char r = pCmd->red;
01FA 3004  1367 	MOVLW 4
01FB 072D  1368 	ADDWF pCmd_2,W
01FC 0084  1369 	MOVWF FSR0L
01FD 0185  1370 	CLRF  FSR0H
01FE 0800  1371 	MOVF  INDF0,W
01FF 00AF  1372 	MOVWF r_2
           1373 			;	char g = pCmd->green;
0200 3005  1374 	MOVLW 5
0201 072D  1375 	ADDWF pCmd_2,W
0202 0084  1376 	MOVWF FSR0L
0203 0185  1377 	CLRF  FSR0H
0204 0800  1378 	MOVF  INDF0,W
0205 00B0  1379 	MOVWF g_2
           1380 			;	char b = pCmd->blue;
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 24

ADDR CODE  LINE SOURCE

0206 3006  1381 	MOVLW 6
0207 072D  1382 	ADDWF pCmd_2,W
0208 0084  1383 	MOVWF FSR0L
0209 0185  1384 	CLRF  FSR0H
020A 0800  1385 	MOVF  INDF0,W
020B 00B1  1386 	MOVWF b_2
           1387 			;	
           1388 			;	char k,mask,temp,max_distance;
           1389 			;	//max_distance = 0;
           1390 			;	mask = 0b00000001;
020C 3001  1391 	MOVLW 1
020D 00B3  1392 	MOVWF mask_2
           1393 			;	
           1394 			;	for(k = 0; k < (NUM_OF_LED * 3); k++)
020E 01B2  1395 	CLRF  k_3
020F 3060  1396 m023	MOVLW 96
0210 0020  1397 	MOVLB 0
0211 0232  1398 	SUBWF k_3,W
0212 1803  1399 	BTFSC 0x03,Carry
0213 2A63  1400 	GOTO  m027
           1401 			;	{	
           1402 			;		if(0 != (*address & mask))
0214 0185  1403 	CLRF  FSR0H
0215 082E  1404 	MOVF  address_2,W
0216 0084  1405 	MOVWF FSR0L
0217 0833  1406 	MOVF  mask_2,W
0218 0500  1407 	ANDWF INDF0,W
0219 1903  1408 	BTFSC 0x03,Zero_
021A 2A54  1409 	GOTO  m024
           1410 			;		{
           1411 			;			temp = gLedBuf.led_array[k];
021B 3020  1412 	MOVLW 32
021C 0085  1413 	MOVWF FSR0+1
021D 3041  1414 	MOVLW 65
021E 0732  1415 	ADDWF k_3,W
021F 0084  1416 	MOVWF FSR0
0220 1803  1417 	BTFSC 0x03,Carry
0221 0A85  1418 	INCF  FSR0+1,1
0222 0800  1419 	MOVF  INDF0,W
0223 00B4  1420 	MOVWF temp_3
           1421 			;			gLedBuf.led_destination[k] = b;
0224 3020  1422 	MOVLW 32
0225 0085  1423 	MOVWF FSR0+1
0226 30A1  1424 	MOVLW 161
0227 0732  1425 	ADDWF k_3,W
0228 0084  1426 	MOVWF FSR0
0229 1803  1427 	BTFSC 0x03,Carry
022A 0A85  1428 	INCF  FSR0+1,1
022B 0831  1429 	MOVF  b_2,W
022C 0080  1430 	MOVWF INDF0
           1431 			;			//ledstrip_get_distance(b,temp,&max_distance);
           1432 			;			k++;
022D 0AB2  1433 	INCF  k_3,1
           1434 			;			temp = gLedBuf.led_array[k];
022E 3020  1435 	MOVLW 32
022F 0085  1436 	MOVWF FSR0+1
0230 3041  1437 	MOVLW 65
0231 0732  1438 	ADDWF k_3,W
0232 0084  1439 	MOVWF FSR0
0233 1803  1440 	BTFSC 0x03,Carry
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 25

ADDR CODE  LINE SOURCE

0234 0A85  1441 	INCF  FSR0+1,1
0235 0800  1442 	MOVF  INDF0,W
0236 00B4  1443 	MOVWF temp_3
           1444 			;			gLedBuf.led_destination[k] = g;
0237 3020  1445 	MOVLW 32
0238 0085  1446 	MOVWF FSR0+1
0239 30A1  1447 	MOVLW 161
023A 0732  1448 	ADDWF k_3,W
023B 0084  1449 	MOVWF FSR0
023C 1803  1450 	BTFSC 0x03,Carry
023D 0A85  1451 	INCF  FSR0+1,1
023E 0830  1452 	MOVF  g_2,W
023F 0080  1453 	MOVWF INDF0
           1454 			;			//ledstrip_get_distance(g,temp,&max_distance);
           1455 			;			k++;
0240 0AB2  1456 	INCF  k_3,1
           1457 			;			temp = gLedBuf.led_array[k];
0241 3020  1458 	MOVLW 32
0242 0085  1459 	MOVWF FSR0+1
0243 3041  1460 	MOVLW 65
0244 0732  1461 	ADDWF k_3,W
0245 0084  1462 	MOVWF FSR0
0246 1803  1463 	BTFSC 0x03,Carry
0247 0A85  1464 	INCF  FSR0+1,1
0248 0800  1465 	MOVF  INDF0,W
0249 00B4  1466 	MOVWF temp_3
           1467 			;			gLedBuf.led_destination[k] = r;
024A 3020  1468 	MOVLW 32
024B 0085  1469 	MOVWF FSR0+1
024C 30A1  1470 	MOVLW 161
024D 0732  1471 	ADDWF k_3,W
024E 0084  1472 	MOVWF FSR0
024F 1803  1473 	BTFSC 0x03,Carry
0250 0A85  1474 	INCF  FSR0+1,1
0251 082F  1475 	MOVF  r_2,W
0252 0080  1476 	MOVWF INDF0
           1477 			;			//ledstrip_get_distance(g,temp,&max_distance);
           1478 			;		}
           1479 			;		else 
0253 2A57  1480 	GOTO  m025
           1481 			;		{ 
           1482 			;			k++;
0254 0020  1483 m024	MOVLB 0
0255 0AB2  1484 	INCF  k_3,1
           1485 			;			k++;
0256 0AB2  1486 	INCF  k_3,1
           1487 			;		}
           1488 			;		mask = mask << 1;
0257 1003  1489 m025	BCF   0x03,Carry
0258 0020  1490 	MOVLB 0
0259 0DB3  1491 	RLF   mask_2,1
           1492 			;		if(0 == mask)
025A 08B3  1493 	MOVF  mask_2,1
025B 1D03  1494 	BTFSS 0x03,Zero_
025C 2A60  1495 	GOTO  m026
           1496 			;		{
           1497 			;			address++;
025D 0AAE  1498 	INCF  address_2,1
           1499 			;			mask= 0b00000001;
025E 3001  1500 	MOVLW 1
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 26

ADDR CODE  LINE SOURCE

025F 00B3  1501 	MOVWF mask_2
           1502 			;		}
           1503 			;	}
0260 0020  1504 m026	MOVLB 0
0261 0AB2  1505 	INCF  k_3,1
0262 2A0F  1506 	GOTO  m023
           1507 			;#ifdef DEBUG
           1508 			;	USARTsend_str("timevalue:");
           1509 			;	USARTsend_num(pCmd->timevalue,'#');
           1510 			;#endif
           1511 			;	timer_set_for_fade(pCmd->timevalue);
0263 3007  1512 m027	MOVLW 7
0264 0020  1513 	MOVLB 0
0265 072D  1514 	ADDWF pCmd_2,W
0266 0084  1515 	MOVWF FSR0L
0267 0185  1516 	CLRF  FSR0H
0268 0800  1517 	MOVF  INDF0,W
0269 2347  1518 	CALL  timer_set_for_fade
           1519 			;	gLedBuf.led_fade_operation = 1;
026A 0023  1520 	MOVLB 3
026B 1431  1521 	BSF   gLedBuf+336,0
           1522 			;}
026C 0008  1523 	RETURN
           1524 			;
           1525 			;//This funktion calculates the distance between the current value of a Led and the 
           1526 			;//destination value of a Led. Distance meens the steps to change. After calculation, 
           1527 			;//check if there is a new maximal_value
           1528 			;void ledstrip_get_distance(char destinationvalue, char currentvalue,char* max_distance)
           1529 			;{
           1530 ledstrip_get_distance
           1531 			;	char temp;
           1532 			;	if(destinationvalue > currentvalue)
026D 087F  1533 	MOVF  destinationvalue,W
026E 027F  1534 	SUBWF currentvalue,W
026F 1803  1535 	BTFSC 0x03,Carry
0270 2A75  1536 	GOTO  m028
           1537 			;		temp = destinationvalue - currentvalue;
0271 087F  1538 	MOVF  currentvalue,W
0272 027F  1539 	SUBWF destinationvalue,W
0273 00FF  1540 	MOVWF temp_4
           1541 			;	else
0274 2A78  1542 	GOTO  m029
           1543 			;		temp = currentvalue - destinationvalue;
0275 087F  1544 m028	MOVF  destinationvalue,W
0276 027F  1545 	SUBWF currentvalue,W
0277 00FF  1546 	MOVWF temp_4
           1547 			;		
           1548 			;	if(temp > *max_distance) *max_distance = temp;
0278 0185  1549 m029	CLRF  FSR0H
0279 087F  1550 	MOVF  max_distance_2,W
027A 0084  1551 	MOVWF FSR0L
027B 087F  1552 	MOVF  temp_4,W
027C 0200  1553 	SUBWF INDF0,W
027D 1803  1554 	BTFSC 0x03,Carry
027E 2A84  1555 	GOTO  m030
027F 0185  1556 	CLRF  FSR0H
0280 087F  1557 	MOVF  max_distance_2,W
0281 0084  1558 	MOVWF FSR0L
0282 087F  1559 	MOVF  temp_4,W
0283 0080  1560 	MOVWF INDF0
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 27

ADDR CODE  LINE SOURCE

           1561 			;}
0284 0008  1562 m030	RETURN
           1563 			;
           1564 			;void ledstrip_do_fade()
           1565 			;{
           1566 ledstrip_do_fade
           1567 			;	char fade_finish:1;
           1568 			;	fade_finish = 1;
0285 0020  1569 	MOVLB 0
0286 1425  1570 	BSF   0x25,fade_finish
           1571 			;	char temp_current,temp_destination;
           1572 			;	
           1573 			;	char i;
           1574 			;	for(i = 0; i < (NUM_OF_LED*3);i++)
0287 01A4  1575 	CLRF  i_4
0288 3060  1576 m031	MOVLW 96
0289 0020  1577 	MOVLB 0
028A 0224  1578 	SUBWF i_4,W
028B 1803  1579 	BTFSC 0x03,Carry
028C 2AC2  1580 	GOTO  m034
           1581 			;	{
           1582 			;		temp_current = gLedBuf.led_array[i];
028D 3020  1583 	MOVLW 32
028E 0085  1584 	MOVWF FSR0+1
028F 3041  1585 	MOVLW 65
0290 0724  1586 	ADDWF i_4,W
0291 0084  1587 	MOVWF FSR0
0292 1803  1588 	BTFSC 0x03,Carry
0293 0A85  1589 	INCF  FSR0+1,1
0294 0800  1590 	MOVF  INDF0,W
0295 00A2  1591 	MOVWF temp_current
           1592 			;		temp_destination = gLedBuf.led_destination[i];
0296 3020  1593 	MOVLW 32
0297 0085  1594 	MOVWF FSR0+1
0298 30A1  1595 	MOVLW 161
0299 0724  1596 	ADDWF i_4,W
029A 0084  1597 	MOVWF FSR0
029B 1803  1598 	BTFSC 0x03,Carry
029C 0A85  1599 	INCF  FSR0+1,1
029D 0800  1600 	MOVF  INDF0,W
029E 00A3  1601 	MOVWF temp_destination
           1602 			;		if(temp_current > temp_destination)
029F 0822  1603 	MOVF  temp_current,W
02A0 0223  1604 	SUBWF temp_destination,W
02A1 1803  1605 	BTFSC 0x03,Carry
02A2 2AAF  1606 	GOTO  m032
           1607 			;		{
           1608 			;			gLedBuf.led_array[i] = --temp_current;
02A3 03A2  1609 	DECF  temp_current,1
02A4 3020  1610 	MOVLW 32
02A5 0085  1611 	MOVWF FSR0+1
02A6 3041  1612 	MOVLW 65
02A7 0724  1613 	ADDWF i_4,W
02A8 0084  1614 	MOVWF FSR0
02A9 1803  1615 	BTFSC 0x03,Carry
02AA 0A85  1616 	INCF  FSR0+1,1
02AB 0822  1617 	MOVF  temp_current,W
02AC 0080  1618 	MOVWF INDF0
           1619 			;			fade_finish = 0;
02AD 1025  1620 	BCF   0x25,fade_finish
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 28

ADDR CODE  LINE SOURCE

           1621 			;		}
           1622 			;		else if(temp_current < temp_destination)	
02AE 2ABF  1623 	GOTO  m033
02AF 0020  1624 m032	MOVLB 0
02B0 0823  1625 	MOVF  temp_destination,W
02B1 0222  1626 	SUBWF temp_current,W
02B2 1803  1627 	BTFSC 0x03,Carry
02B3 2ABF  1628 	GOTO  m033
           1629 			;		{
           1630 			;			gLedBuf.led_array[i] = ++temp_current;
02B4 0AA2  1631 	INCF  temp_current,1
02B5 3020  1632 	MOVLW 32
02B6 0085  1633 	MOVWF FSR0+1
02B7 3041  1634 	MOVLW 65
02B8 0724  1635 	ADDWF i_4,W
02B9 0084  1636 	MOVWF FSR0
02BA 1803  1637 	BTFSC 0x03,Carry
02BB 0A85  1638 	INCF  FSR0+1,1
02BC 0822  1639 	MOVF  temp_current,W
02BD 0080  1640 	MOVWF INDF0
           1641 			;			fade_finish = 0;
02BE 1025  1642 	BCF   0x25,fade_finish
           1643 			;		}		
           1644 			;	}	
02BF 0020  1645 m033	MOVLB 0
02C0 0AA4  1646 	INCF  i_4,1
02C1 2A88  1647 	GOTO  m031
           1648 			;	if(fade_finish) 
02C2 0020  1649 m034	MOVLB 0
02C3 1C25  1650 	BTFSS 0x25,fade_finish
02C4 2ACC  1651 	GOTO  m035
           1652 			;	{
           1653 			;		gLedBuf.led_fade_operation = 0;
02C5 0023  1654 	MOVLB 3
02C6 1031  1655 	BCF   gLedBuf+336,0
           1656 			;		USARTsend_str(" fade finish");
02C7 304B  1657 	MOVLW 75
02C8 0020  1658 	MOVLB 0
02C9 00A6  1659 	MOVWF string
02CA 2369  1660 	CALL  USARTsend_str
           1661 			;	}
           1662 			;	else 
02CB 2AD2  1663 	GOTO  m036
           1664 			;		spi_send_ledbuf(&gLedBuf.led_array[0]);
02CC 3041  1665 m035	MOVLW 65
02CD 0020  1666 	MOVLB 0
02CE 00B4  1667 	MOVWF array_4
02CF 3020  1668 	MOVLW 32
02D0 00B5  1669 	MOVWF array_4+1
02D1 2B21  1670 	GOTO  spi_send_ledbuf
           1671 			;}
02D2 0008  1672 m036	RETURN
           1673 
           1674   ; FILE RingBuf.c
           1675 			;
           1676 			;#include "RingBuf.h"
           1677 			;
           1678 			;#ifndef X86
           1679 			;#message Global variables are defined in RingBuf.c
           1680 			;#endif /* #ifndef X86 */
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 29

ADDR CODE  LINE SOURCE

           1681 			;struct RingBuffer gRingBuf;
           1682 			;
           1683 			;void RingBufInit(void)
           1684 			;{
           1685 RingBufInit
           1686 			;	gRingBuf.read = 0;
02D3 0020  1687 	MOVLB 0
02D4 01C9  1688 	CLRF  gRingBuf+16
           1689 			;	gRingBuf.write = 0;
02D5 01CA  1690 	CLRF  gRingBuf+17
           1691 			;	gRingBuf.error_full = 0;
02D6 104B  1692 	BCF   gRingBuf+18,0
           1693 			;}
02D7 0008  1694 	RETURN
           1695 			;
           1696 			;char RingBufGet(void)
           1697 			;{
           1698 RingBufGet
           1699 			;	char result = gRingBuf.data[gRingBuf.read];
02D8 3039  1700 	MOVLW 57
02D9 0020  1701 	MOVLB 0
02DA 0749  1702 	ADDWF gRingBuf+16,W
02DB 0084  1703 	MOVWF FSR0L
02DC 0185  1704 	CLRF  FSR0H
02DD 0800  1705 	MOVF  INDF0,W
02DE 00A5  1706 	MOVWF result
           1707 			;	gRingBuf.read = RingBufInc(gRingBuf.read);
02DF 0A49  1708 	INCF  gRingBuf+16,W
02E0 390F  1709 	ANDLW 15
02E1 00C9  1710 	MOVWF gRingBuf+16
           1711 			;	return result;
02E2 0825  1712 	MOVF  result,W
02E3 0008  1713 	RETURN
           1714 			;}
           1715 			;
           1716 			;void RingBufPut(char value)
           1717 			;{
           1718 RingBufPut
02E4 0020  1719 	MOVLB 0
02E5 00A0  1720 	MOVWF value
           1721 			;	char writeNext = RingBufInc(gRingBuf.write);
02E6 0A4A  1722 	INCF  gRingBuf+17,W
02E7 390F  1723 	ANDLW 15
02E8 00A1  1724 	MOVWF writeNext
           1725 			;	if(writeNext != gRingBuf.read)
02E9 0821  1726 	MOVF  writeNext,W
02EA 0649  1727 	XORWF gRingBuf+16,W
02EB 1903  1728 	BTFSC 0x03,Zero_
02EC 2AF6  1729 	GOTO  m037
           1730 			;	{
           1731 			;		gRingBuf.data[gRingBuf.write] = value;
02ED 3039  1732 	MOVLW 57
02EE 074A  1733 	ADDWF gRingBuf+17,W
02EF 0084  1734 	MOVWF FSR0L
02F0 0185  1735 	CLRF  FSR0H
02F1 0820  1736 	MOVF  value,W
02F2 0080  1737 	MOVWF INDF0
           1738 			;		gRingBuf.write = writeNext;
02F3 0821  1739 	MOVF  writeNext,W
02F4 00CA  1740 	MOVWF gRingBuf+17
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 30

ADDR CODE  LINE SOURCE

           1741 			;	}
           1742 			;	else gRingBuf.error_full = 1;
02F5 2AF8  1743 	GOTO  m038
02F6 0020  1744 m037	MOVLB 0
02F7 144B  1745 	BSF   gRingBuf+18,0
           1746 			;}
02F8 0008  1747 m038	RETURN
           1748 
           1749   ; FILE spi.c
           1750 			;//Nils Weiß 
           1751 			;//20.04.2012
           1752 			;//Compiler CC5x
           1753 			;
           1754 			;#include "ledstrip.h"
           1755 			;
           1756 			;#ifndef X86
           1757 			;void spi_init()
           1758 			;{
           1759 spi_init
           1760 			;	TRISC.3 = 0;        // Make port RC3 an output(SPI Clock)
02F9 0021  1761 	MOVLB 1
02FA 118E  1762 	BCF   TRISC,3
           1763 			;    TRISC.4 = 1;        // Make port RC4 an input(SPI Data In)
02FB 160E  1764 	BSF   TRISC,4
           1765 			;    TRISC.5 = 0;        // Make port RC5 an output(SPI Data Out)
02FC 128E  1766 	BCF   TRISC,5
           1767 			;	SSPM1 = 0;
02FD 0024  1768 	MOVLB 4
02FE 1095  1769 	BCF   0x215,SSPM1
           1770 			;	SMP = 1;
02FF 1794  1771 	BSF   0x214,SMP
           1772 			;	CKP = 0;
0300 1215  1773 	BCF   0x215,CKP
           1774 			;	CKE = 1;
0301 1714  1775 	BSF   0x214,CKE
           1776 			;	SSPEN = 1;
0302 1695  1777 	BSF   0x215,SSPEN
           1778 			;}
0303 0008  1779 	RETURN
           1780 			;
           1781 			;char spi_send(char data)
           1782 			;{
           1783 spi_send
0304 0020  1784 	MOVLB 0
0305 00B8  1785 	MOVWF data_4
           1786 			;	SSPBUF = data;	
0306 0838  1787 	MOVF  data_4,W
0307 0024  1788 	MOVLB 4
0308 0091  1789 	MOVWF SSPBUF
           1790 			;	while(SSPIF == 0);
0309 0020  1791 m039	MOVLB 0
030A 1D91  1792 	BTFSS 0x11,SSPIF
030B 2B09  1793 	GOTO  m039
           1794 			;	return SSPBUF;
030C 0024  1795 	MOVLB 4
030D 0811  1796 	MOVF  SSPBUF,W
030E 0008  1797 	RETURN
           1798 			;}
           1799 			;#endif /* #ifndef X86 */
           1800 			;
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 31

ADDR CODE  LINE SOURCE

           1801 			;/***
           1802 			;**	This function sends the array to the LED controller(WS2801)
           1803 			;**  it starts with the last byte to get a correct output
           1804 			;***/
           1805 			;void spi_send_arr(char *array, char length)
           1806 			;{
           1807 spi_send_arr
030F 00FF  1808 	MOVWF length_4
           1809 			;	if(array == 0) return;
0310 08FF  1810 	MOVF  array_3,1
0311 1903  1811 	BTFSC 0x03,Zero_
0312 0008  1812 	RETURN
           1813 			;	char i;
           1814 			;	for(i = length; i == 0; i-- )
0313 087F  1815 	MOVF  length_4,W
0314 00FF  1816 	MOVWF i_5
0315 08FF  1817 m040	MOVF  i_5,1
0316 1D03  1818 	BTFSS 0x03,Zero_
0317 2B20  1819 	GOTO  m041
           1820 			;	{
           1821 			;		spi_send(array[i]);
0318 087F  1822 	MOVF  i_5,W
0319 077F  1823 	ADDWF array_3,W
031A 0084  1824 	MOVWF FSR0L
031B 0185  1825 	CLRF  FSR0H
031C 0800  1826 	MOVF  INDF0,W
031D 2304  1827 	CALL  spi_send
           1828 			;	} 
031E 03FF  1829 	DECF  i_5,1
031F 2B15  1830 	GOTO  m040
           1831 			;}
0320 0008  1832 m041	RETURN
           1833 			;
           1834 			;void spi_send_ledbuf(char *array)//!!! CHECK if GIE=0 during the sendroutine improves the result
           1835 			;{
           1836 spi_send_ledbuf
           1837 			;	//array must be the address of the first byte
           1838 			;	char* end;
           1839 			;	//calculate where the end is
           1840 			;	end = array + (NUM_OF_LED * 3);
0321 0020  1841 	MOVLB 0
0322 0835  1842 	MOVF  array_4+1,W
0323 00B7  1843 	MOVWF end+1
0324 3060  1844 	MOVLW 96
0325 0734  1845 	ADDWF array_4,W
0326 00B6  1846 	MOVWF end
0327 1803  1847 	BTFSC 0x03,Carry
0328 0AB7  1848 	INCF  end+1,1
           1849 			;	//send all
           1850 			;	for(; array < end; array++)
0329 0020  1851 m042	MOVLB 0
032A 0837  1852 	MOVF  end+1,W
032B 0235  1853 	SUBWF array_4+1,W
032C 1C03  1854 	BTFSS 0x03,Carry
032D 2B34  1855 	GOTO  m043
032E 1D03  1856 	BTFSS 0x03,Zero_
032F 2B40  1857 	GOTO  m044
0330 0836  1858 	MOVF  end,W
0331 0234  1859 	SUBWF array_4,W
0332 1803  1860 	BTFSC 0x03,Carry
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 32

ADDR CODE  LINE SOURCE

0333 2B40  1861 	GOTO  m044
           1862 			;	{
           1863 			;		spi_send(*array);
0334 0020  1864 m043	MOVLB 0
0335 0835  1865 	MOVF  array_4+1,W
0336 0085  1866 	MOVWF FSR0H
0337 0834  1867 	MOVF  array_4,W
0338 0084  1868 	MOVWF FSR0L
0339 0800  1869 	MOVF  INDF0,W
033A 2304  1870 	CALL  spi_send
           1871 			;	}
033B 0020  1872 	MOVLB 0
033C 0AB4  1873 	INCF  array_4,1
033D 1903  1874 	BTFSC 0x03,Zero_
033E 0AB5  1875 	INCF  array_4+1,1
033F 2B29  1876 	GOTO  m042
           1877 			;}
0340 0008  1878 m044	RETURN
           1879 
           1880   ; FILE timer.c
           1881 			;//Nils Weiß 
           1882 			;//08.05.2012
           1883 			;//Compiler CC5x 
           1884 			;
           1885 			;void timer_init()
           1886 			;{
           1887 timer_init
           1888 			;	T2CON = 0b01111101;
0341 307D  1889 	MOVLW 125
0342 0020  1890 	MOVLB 0
0343 009C  1891 	MOVWF T2CON
           1892 			;	TMR2IE = 1;
0344 0021  1893 	MOVLB 1
0345 1491  1894 	BSF   0x91,TMR2IE
           1895 			;}
0346 0008  1896 	RETURN
           1897 			;
           1898 			;void timer_set_for_fade(char value)
           1899 			;{
           1900 timer_set_for_fade
0347 0020  1901 	MOVLB 0
0348 00B6  1902 	MOVWF value_2
           1903 			;	PR2 = value;
0349 0836  1904 	MOVF  value_2,W
034A 009B  1905 	MOVWF PR2
           1906 			;}
034B 0008  1907 	RETURN
           1908 
           1909   ; FILE usart.c
           1910 			;// Include-Datei für Serielle Kommunikation über Hardwaremodul des Pic
           1911 			; //
           1912 			; //
           1913 			; // Nils Weiß
           1914 			; // 29.11.2010
           1915 			; // Compiler CC5x
           1916 			;
           1917 			;#ifndef X86
           1918 			;//*******  Initialisierungs-Funktion  *************************************************
           1919 			;void USARTinit()
           1920 			;{
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 33

ADDR CODE  LINE SOURCE

           1921 USARTinit
           1922 			;	//USART TX Pin als Ausgang
           1923 			;	TRISC.6 = 0;
034C 0021  1924 	MOVLB 1
034D 130E  1925 	BCF   TRISC,6
           1926 			;
           1927 			;    BRGH=1;					// High Baudrate activated
034E 0023  1928 	MOVLB 3
034F 151E  1929 	BSF   0x19E,BRGH
           1930 			;	BRG16=0;
0350 119F  1931 	BCF   0x19F,BRG16
           1932 			;	SPBRGL=25;				// 19200 Bps @ 8 MHz Clock
0351 3019  1933 	MOVLW 25
0352 009B  1934 	MOVWF SPBRGL
           1935 			;	SPBRGH=0;
0353 019C  1936 	CLRF  SPBRGH
           1937 			;    SPEN = 1;               // Set_Serial_Pins;
0354 179D  1938 	BSF   0x19D,SPEN
           1939 			;    SYNC = 0;               // Set_Async_Mode;
0355 121E  1940 	BCF   0x19E,SYNC
           1941 			;    TX9 = 0;                // Set_8bit_Tx;
0356 131E  1942 	BCF   0x19E,TX9
           1943 			;    RX9 = 0;                // Set_8bit_Rx;
0357 131D  1944 	BCF   0x19D,RX9
           1945 			;    CREN = 1;               // Enable_Rx;
0358 161D  1946 	BSF   0x19D,CREN
           1947 			;    TXEN = 1;               // Enable_Tx;
0359 169E  1948 	BSF   0x19E,TXEN
           1949 			;    RCIE=1;                 // Rx Interrupt aus
035A 0021  1950 	MOVLB 1
035B 1691  1951 	BSF   0x91,RCIE
           1952 			;	ADDEN=0;				// Disable Adressdetection
035C 0023  1953 	MOVLB 3
035D 119D  1954 	BCF   0x19D,ADDEN
           1955 			;}
035E 0008  1956 	RETURN
           1957 			;
           1958 			;//*******  Sende-char-Funktion  *************************************************
           1959 			;void USARTsend(unsigned char ch)
           1960 			;{
           1961 USARTsend
035F 0020  1962 	MOVLB 0
0360 00A8  1963 	MOVWF ch
           1964 			;	while(!TXIF);
0361 0020  1965 m045	MOVLB 0
0362 1E11  1966 	BTFSS 0x11,TXIF
0363 2B61  1967 	GOTO  m045
           1968 			;	TXREG=ch;
0364 0020  1969 	MOVLB 0
0365 0828  1970 	MOVF  ch,W
0366 0023  1971 	MOVLB 3
0367 009A  1972 	MOVWF TXREG
           1973 			;}
0368 0008  1974 	RETURN
           1975 			;#endif /* #ifndef X86 */
           1976 			;
           1977 			;//*******  Sende-String-Funktion  *************************************************
           1978 			;void USARTsend_str(const char *string)
           1979 			;{
           1980 USARTsend_str
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 34

ADDR CODE  LINE SOURCE

           1981 			; char ps;
           1982 			; ps = *string;
0369 0020  1983 	MOVLB 0
036A 0826  1984 	MOVF  string,W
036B 2017  1985 	CALL  _const1
036C 0020  1986 	MOVLB 0
036D 00A7  1987 	MOVWF ps
           1988 			; while(ps > 0)
036E 0020  1989 m046	MOVLB 0
036F 08A7  1990 	MOVF  ps,1
0370 1903  1991 	BTFSC 0x03,Zero_
0371 2B7B  1992 	GOTO  m047
           1993 			;   {
           1994 			;    string++;
0372 0AA6  1995 	INCF  string,1
           1996 			;   	USARTsend(ps);
0373 0827  1997 	MOVF  ps,W
0374 235F  1998 	CALL  USARTsend
           1999 			;    ps = *string;
0375 0020  2000 	MOVLB 0
0376 0826  2001 	MOVF  string,W
0377 2017  2002 	CALL  _const1
0378 0020  2003 	MOVLB 0
0379 00A7  2004 	MOVWF ps
           2005 			;   }
037A 2B6E  2006 	GOTO  m046
           2007 			;}
037B 0008  2008 m047	RETURN
           2009 			;
           2010 			;//*******  Sende-Array-Funktion  *************************************************
           2011 			;void USARTsend_arr(char *array, char length)
           2012 			;{
           2013 USARTsend_arr
037C 00FF  2014 	MOVWF length_5
           2015 			;	if(array == 0) return;
037D 08FF  2016 	MOVF  array_5,1
037E 1903  2017 	BTFSC 0x03,Zero_
037F 0008  2018 	RETURN
           2019 			;	char i;
           2020 			;	for(i=0;i<length;i++)
0380 01FF  2021 	CLRF  i_6
0381 087F  2022 m048	MOVF  length_5,W
0382 027F  2023 	SUBWF i_6,W
0383 1803  2024 	BTFSC 0x03,Carry
0384 2B8D  2025 	GOTO  m049
           2026 			;	{
           2027 			;		USARTsend(*array);
0385 0185  2028 	CLRF  FSR0H
0386 087F  2029 	MOVF  array_5,W
0387 0084  2030 	MOVWF FSR0L
0388 0800  2031 	MOVF  INDF0,W
0389 235F  2032 	CALL  USARTsend
           2033 			;		array++;
038A 0AFF  2034 	INCF  array_5,1
           2035 			;	}
038B 0AFF  2036 	INCF  i_6,1
038C 2B81  2037 	GOTO  m048
           2038 			;}
038D 0008  2039 m049	RETURN
           2040 
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 35

ADDR CODE  LINE SOURCE

           2041   ; FILE commandstorage.c
           2042 			;#include "platform.h"
           2043 			;#include "commandstorage.h"
           2044 			;
           2045 			;struct led_cmd* commandstorage_read(struct led_cmd *pDest, bit movePtr)
           2046 			;{
           2047 commandstorage_read
           2048 			;	//check parameter
           2049 			;	if(0 == pDest) return 0;
038E 0020  2050 	MOVLB 0
038F 08AD  2051 	MOVF  pDest,1
0390 1903  2052 	BTFSC 0x03,Zero_
0391 3400  2053 	RETLW 0
           2054 			;
           2055 			;	//commands available in eeprom?
           2056 			;	char nextCmd = EEPROM_RD(CmdPointerAddr);
0392 30FF  2057 	MOVLW 255
0393 2113  2058 	CALL  EEPROM_RD
0394 0020  2059 	MOVLB 0
0395 00AE  2060 	MOVWF nextCmd
           2061 			;	if(0 == nextCmd) return 0;
0396 08AE  2062 	MOVF  nextCmd,1
0397 1903  2063 	BTFSC 0x03,Zero_
0398 3400  2064 	RETLW 0
           2065 			;
           2066 			;	//read command from eeprom
           2067 			;	EEPROM_RD_BLK((char*)pDest, (nextCmd - CmdWidth), CmdWidth);
0399 0020  2068 	MOVLB 0
039A 082D  2069 	MOVF  pDest,W
039B 00B0  2070 	MOVWF array_2
039C 300A  2071 	MOVLW 10
039D 022E  2072 	SUBWF nextCmd,W
039E 00B1  2073 	MOVWF adress_4
039F 300A  2074 	MOVLW 10
03A0 2139  2075 	CALL  EEPROM_RD_BLK
           2076 			;
           2077 			;	//do we have to update the CmdPointer?
           2078 			;	if(movePtr)
03A1 0020  2079 	MOVLB 0
03A2 1C2F  2080 	BTFSS 0x2F,movePtr
03A3 2BA9  2081 	GOTO  m050
           2082 			;	{		
           2083 			;		EEPROM_WR(CmdPointerAddr, nextCmd - CmdWidth);
03A4 30FF  2084 	MOVLW 255
03A5 00B0  2085 	MOVWF adress
03A6 300A  2086 	MOVLW 10
03A7 022E  2087 	SUBWF nextCmd,W
03A8 20F1  2088 	CALL  EEPROM_WR
           2089 			;	}
           2090 			;	return pDest;
03A9 0020  2091 m050	MOVLB 0
03AA 082D  2092 	MOVF  pDest,W
03AB 0008  2093 	RETURN
           2094 			;}
           2095 			;
           2096 			;bit commandstorage_write(char *pSrc, char length)
           2097 			;{
           2098 commandstorage_write
03AC 0020  2099 	MOVLB 0
03AD 00A6  2100 	MOVWF length_6
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 36

ADDR CODE  LINE SOURCE

           2101 			;	//check parameter
           2102 			;	if(0 == pSrc) return FALSE;
03AE 08A5  2103 	MOVF  pSrc,1
03AF 1D03  2104 	BTFSS 0x03,Zero_
03B0 2BB3  2105 	GOTO  m051
03B1 1003  2106 	BCF   0x03,Carry
03B2 0008  2107 	RETURN
           2108 			;	
           2109 			;	//enought free space in eeprom?
           2110 			;	char nextCmd = EEPROM_RD(CmdPointerAddr);
03B3 30FF  2111 m051	MOVLW 255
03B4 2113  2112 	CALL  EEPROM_RD
03B5 0020  2113 	MOVLB 0
03B6 00A7  2114 	MOVWF nextCmd_2
           2115 			;	if(nextCmd >= (CmdPointerAddr - CmdWidth)) return FALSE;
03B7 30F5  2116 	MOVLW 245
03B8 0227  2117 	SUBWF nextCmd_2,W
03B9 1C03  2118 	BTFSS 0x03,Carry
03BA 2BBD  2119 	GOTO  m052
03BB 1003  2120 	BCF   0x03,Carry
03BC 0008  2121 	RETURN
           2122 			;
           2123 			;	//increase the command pointer in eeprom
           2124 			;	EEPROM_WR(CmdPointerAddr,(nextCmd + CmdWidth));
03BD 30FF  2125 m052	MOVLW 255
03BE 0020  2126 	MOVLB 0
03BF 00B0  2127 	MOVWF adress
03C0 300A  2128 	MOVLW 10
03C1 0727  2129 	ADDWF nextCmd_2,W
03C2 20F1  2130 	CALL  EEPROM_WR
           2131 			;		
           2132 			;	//write data to eeprom
           2133 			;	EEPROM_WR_BLK(pSrc, nextCmd, length);
03C3 0020  2134 	MOVLB 0
03C4 0825  2135 	MOVF  pSrc,W
03C5 00A8  2136 	MOVWF array
03C6 0827  2137 	MOVF  nextCmd_2,W
03C7 00A9  2138 	MOVWF adress_3
03C8 0826  2139 	MOVF  length_6,W
03C9 2120  2140 	CALL  EEPROM_WR_BLK
           2141 			;		
           2142 			;	return TRUE;
03CA 1403  2143 	BSF   0x03,Carry
03CB 0008  2144 	RETURN
           2145 			;}
           2146 			;
           2147 			;void commandstorage_get_commands()
           2148 			;{	
           2149 commandstorage_get_commands
           2150 			;	if(RingBufHasError)
03CC 0020  2151 	MOVLB 0
03CD 1C4B  2152 	BTFSS gRingBuf+18,0
03CE 2BD1  2153 	GOTO  m053
           2154 			;	{
           2155 			;		// *** if a RingBufError occure, I have to throw away the current command,
           2156 			;		// *** because the last byte was not saved. Commandstring is inconsistent
           2157 			;		ClearCmdBuf();
03CF 01CD  2158 	CLRF  gCmdBuf
03D0 01CE  2159 	CLRF  gCmdBuf+1
           2160 			;	}
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 37

ADDR CODE  LINE SOURCE

           2161 			;
           2162 			;	if(RingBufIsNotEmpty)
03D1 0020  2163 m053	MOVLB 0
03D2 084A  2164 	MOVF  gRingBuf+17,W
03D3 0649  2165 	XORWF gRingBuf+16,W
03D4 1903  2166 	BTFSC 0x03,Zero_
03D5 2C48  2167 	GOTO  m062
           2168 			;	{
           2169 			;		// *** preload variables and 
           2170 			;		// *** get new_byte from ringbuffer
           2171 			;		char new_byte, temp, j;
           2172 			;		temp = 0;
03D6 01A3  2173 	CLRF  temp_5
           2174 			;		j = 0;
03D7 01A4  2175 	CLRF  j
           2176 			;		// *** get new byte
           2177 			;		new_byte = RingBufGet();	
03D8 22D8  2178 	CALL  RingBufGet
03D9 0020  2179 	MOVLB 0
03DA 00A2  2180 	MOVWF new_byte
           2181 			;		// *** do I wait for databytes?
           2182 			;		if(gCmdBuf.frame_counter == 0)
03DB 08CE  2183 	MOVF  gCmdBuf+1,1
03DC 1D03  2184 	BTFSS 0x03,Zero_
03DD 2C09  2185 	GOTO  m055
           2186 			;		{
           2187 			;			// *** I don't wait for databytes
           2188 			;			// *** Do I receive a Start_of_Text sign
           2189 			;			if((uns8)new_byte == STX)
03DE 0F22  2190 	INCFSZ new_byte,W
03DF 2BF2  2191 	GOTO  m054
           2192 			;			{
           2193 			;				// *** increse the cmd_counter
           2194 			;				gCmdBuf.cmd_counter = 1;
03E0 3001  2195 	MOVLW 1
03E1 00CD  2196 	MOVWF gCmdBuf
           2197 			;				// *** Write the startsign at the begin of the buffer
           2198 			;				gCmdBuf.cmd_buf[0] = new_byte;
03E2 0822  2199 	MOVF  new_byte,W
03E3 00CF  2200 	MOVWF gCmdBuf+2
           2201 			;                // *** Reset crc Variables
           2202 			;                newCRC(&gCmdBuf.crcH, &gCmdBuf.crcL);
03E4 305E  2203 	MOVLW 94
03E5 00A5  2204 	MOVWF p_crcH_2
03E6 305F  2205 	MOVLW 95
03E7 00A6  2206 	MOVWF p_crcL_2
03E8 20DD  2207 	CALL  newCRC
           2208 			;                // *** add new_byte to crc checksum
           2209 			;                addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
03E9 0020  2210 	MOVLB 0
03EA 0822  2211 	MOVF  new_byte,W
03EB 00A5  2212 	MOVWF byte
03EC 305E  2213 	MOVLW 94
03ED 00A6  2214 	MOVWF p_crcH
03EE 305F  2215 	MOVLW 95
03EF 00A7  2216 	MOVWF p_crcL
03F0 2088  2217 	CALL  addCRC
           2218 			;			}
           2219 			;			else
03F1 2C48  2220 	GOTO  m062
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 38

ADDR CODE  LINE SOURCE

           2221 			;			{	
           2222 			;				// *** to avoid arrayoverflow
           2223 			;				temp = FRAMELENGTH - 2;
03F2 300D  2224 m054	MOVLW 13
03F3 0020  2225 	MOVLB 0
03F4 00A3  2226 	MOVWF temp_5
           2227 			;				// *** check if I get the framelength byte
           2228 			;				if((new_byte < temp) && (gCmdBuf.cmd_counter == 1))
03F5 0823  2229 	MOVF  temp_5,W
03F6 0222  2230 	SUBWF new_byte,W
03F7 1803  2231 	BTFSC 0x03,Carry
03F8 2C48  2232 	GOTO  m062
03F9 0B4D  2233 	DECFSZ gCmdBuf,W
03FA 2C48  2234 	GOTO  m062
           2235 			;				{
           2236 			;					gCmdBuf.frame_counter = new_byte;
03FB 0822  2237 	MOVF  new_byte,W
03FC 00CE  2238 	MOVWF gCmdBuf+1
           2239 			;					gCmdBuf.cmd_buf[1] = new_byte;
03FD 0822  2240 	MOVF  new_byte,W
03FE 00D0  2241 	MOVWF gCmdBuf+3
           2242 			;					gCmdBuf.cmd_counter = 2;
03FF 3002  2243 	MOVLW 2
0400 00CD  2244 	MOVWF gCmdBuf
           2245 			;                    // *** add new_byte to crc checksum
           2246 			;                    addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
0401 0822  2247 	MOVF  new_byte,W
0402 00A5  2248 	MOVWF byte
0403 305E  2249 	MOVLW 94
0404 00A6  2250 	MOVWF p_crcH
0405 305F  2251 	MOVLW 95
0406 00A7  2252 	MOVWF p_crcL
0407 2088  2253 	CALL  addCRC
           2254 			;				}
           2255 			;			}
           2256 			;		}
           2257 			;		else
0408 2C48  2258 	GOTO  m062
           2259 			;		{
           2260 			;			// *** I wait for Databytes, so I save all bytes 
           2261 			;			// *** that I get until my framecounter is > 0
           2262 			;			gCmdBuf.cmd_buf[gCmdBuf.cmd_counter] = new_byte;
0409 304F  2263 m055	MOVLW 79
040A 0020  2264 	MOVLB 0
040B 074D  2265 	ADDWF gCmdBuf,W
040C 0084  2266 	MOVWF FSR0L
040D 0185  2267 	CLRF  FSR0H
040E 0822  2268 	MOVF  new_byte,W
040F 0080  2269 	MOVWF INDF0
           2270 			;			gCmdBuf.cmd_counter++;
0410 0ACD  2271 	INCF  gCmdBuf,1
           2272 			;			
           2273 			;            // *** add new_byte to crc checksum
           2274 			;			if(gCmdBuf.frame_counter > 2)
0411 3003  2275 	MOVLW 3
0412 024E  2276 	SUBWF gCmdBuf+1,W
0413 1C03  2277 	BTFSS 0x03,Carry
0414 2C1C  2278 	GOTO  m056
           2279 			;            addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
0415 0822  2280 	MOVF  new_byte,W
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 39

ADDR CODE  LINE SOURCE

0416 00A5  2281 	MOVWF byte
0417 305E  2282 	MOVLW 94
0418 00A6  2283 	MOVWF p_crcH
0419 305F  2284 	MOVLW 95
041A 00A7  2285 	MOVWF p_crcL
041B 2088  2286 	CALL  addCRC
           2287 			;			gCmdBuf.frame_counter--;
041C 0020  2288 m056	MOVLB 0
041D 0BCE  2289 	DECFSZ gCmdBuf+1,1
           2290 			;			// *** now I have to check if my framecounter is null.
           2291 			;			// *** If it's null my string is complete 
           2292 			;			// *** and I can give the string to the crc check function.
           2293 			;			if(gCmdBuf.frame_counter == 0)
041E 2C48  2294 	GOTO  m062
           2295 			;			{
           2296 			;#ifdef NO_CRC
           2297 			;				if(1==1)
           2298 			;#else
           2299 			;                // *** verify crc checksum
           2300 			;                if( (gCmdBuf.crcL == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 1]) &&
           2301 			;                    (gCmdBuf.crcH == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 2]) )
           2302 			;#endif
           2303 			;                {
           2304 			;					// *** Execute the simple Commands
           2305 			;					switch(gCmdBuf.cmd_buf[2])
041F 0851  2306 	MOVF  gCmdBuf+4,W
0420 3AF8  2307 	XORLW 248
0421 1903  2308 	BTFSC 0x03,Zero_
0422 2C2A  2309 	GOTO  m057
0423 3A02  2310 	XORLW 2
0424 1903  2311 	BTFSC 0x03,Zero_
0425 2C2F  2312 	GOTO  m058
0426 3A03  2313 	XORLW 3
0427 1903  2314 	BTFSC 0x03,Zero_
0428 2C32  2315 	GOTO  m059
0429 2C35  2316 	GOTO  m060
           2317 			;					{
           2318 			;						case DELETE: 
           2319 			;							{
           2320 			;								EEPROM_WR(CmdPointerAddr,0);
042A 30FF  2321 m057	MOVLW 255
042B 0020  2322 	MOVLB 0
042C 00B0  2323 	MOVWF adress
042D 3000  2324 	MOVLW 0
042E 28F1  2325 	GOTO  EEPROM_WR
           2326 			;								return;
           2327 			;							}
           2328 			;						case SET_ON: 
           2329 			;							{
           2330 			;								PowerOnLEDs();
042F 0020  2331 m058	MOVLB 0
0430 100E  2332 	BCF   PORTC,0
           2333 			;								return;
0431 0008  2334 	RETURN
           2335 			;								}
           2336 			;						case SET_OFF: 
           2337 			;							{
           2338 			;								PowerOffLEDs();
0432 0020  2339 m059	MOVLB 0
0433 140E  2340 	BSF   PORTC,0
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 40

ADDR CODE  LINE SOURCE

           2341 			;								return;
0434 0008  2342 	RETURN
           2343 			;							}
           2344 			;					}			
           2345 			;					if( commandstorage_write(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4)))
0435 3051  2346 m060	MOVLW 81
0436 0020  2347 	MOVLB 0
0437 00A5  2348 	MOVWF pSrc
0438 3004  2349 	MOVLW 4
0439 024D  2350 	SUBWF gCmdBuf,W
043A 23AC  2351 	CALL  commandstorage_write
043B 1C03  2352 	BTFSS 0x03,Carry
043C 2C42  2353 	GOTO  m061
           2354 			;					{
           2355 			;						USARTsend('G');
043D 3047  2356 	MOVLW 71
043E 235F  2357 	CALL  USARTsend
           2358 			;						USARTsend('C');
043F 3043  2359 	MOVLW 67
0440 235F  2360 	CALL  USARTsend
           2361 			;					}
           2362 			;					else 
0441 2C48  2363 	GOTO  m062
           2364 			;						gERROR.eeprom_failure = 1;
0442 0020  2365 m061	MOVLB 0
0443 14CC  2366 	BSF   gERROR,1
           2367 			;#ifdef TEST
           2368 			;					USARTsend_arr(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4));
           2369 			;#endif
           2370 			;                }
           2371 			;                else
0444 2C48  2372 	GOTO  m062
           2373 			;                {
           2374 			;                    // *** Do some error handling in case of an CRC failure here
           2375 			;					gERROR.crc_failure = 1;
0445 0020  2376 	MOVLB 0
0446 144C  2377 	BSF   gERROR,0
           2378 			;                    return;
0447 0008  2379 	RETURN
           2380 			;                }
           2381 			;			}
           2382 			;		}
           2383 			;	}
           2384 			;}
0448 0008  2385 m062	RETURN
           2386 			;
           2387 			;void commandstorage_execute_commands()
           2388 			;{
           2389 commandstorage_execute_commands
           2390 			;	// *** get the pointer to commands in the EEPROM
           2391 			;	struct led_cmd nextCmd;
           2392 			;
           2393 			;	// read next command from eeprom and move command pointer in eeprom to the next command (TRUE)
           2394 			;	struct led_cmd *result = commandstorage_read(&nextCmd, TRUE);
0449 3022  2395 	MOVLW 34
044A 0020  2396 	MOVLB 0
044B 00AD  2397 	MOVWF pDest
044C 142F  2398 	BSF   0x2F,movePtr
044D 238E  2399 	CALL  commandstorage_read
044E 0020  2400 	MOVLB 0
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 41

ADDR CODE  LINE SOURCE

044F 00AC  2401 	MOVWF result_2
           2402 			;	if(0 != result)
0450 08AC  2403 	MOVF  result_2,1
0451 1903  2404 	BTFSC 0x03,Zero_
0452 2C67  2405 	GOTO  m065
           2406 			;	{
           2407 			;		// *** commands available, check what to do
           2408 			;		switch(nextCmd.cmd) 
0453 0822  2409 	MOVF  nextCmd_3,W
0454 3AFD  2410 	XORLW 253
0455 1903  2411 	BTFSC 0x03,Zero_
0456 2C5E  2412 	GOTO  m063
0457 3A01  2413 	XORLW 1
0458 1903  2414 	BTFSC 0x03,Zero_
0459 2C63  2415 	GOTO  m064
045A 3A07  2416 	XORLW 7
045B 1903  2417 	BTFSC 0x03,Zero_
045C 2C67  2418 	GOTO  m065
045D 2C67  2419 	GOTO  m065
           2420 			;		{	
           2421 			;			case SET_COLOR: 
           2422 			;			{
           2423 			;				ledstrip_set_color(&nextCmd.data.set_color);
045E 3023  2424 m063	MOVLW 35
045F 0020  2425 	MOVLB 0
0460 00AD  2426 	MOVWF pCmd
0461 2181  2427 	CALL  ledstrip_set_color
           2428 			;				break;
0462 2C67  2429 	GOTO  m065
           2430 			;			}
           2431 			;			case SET_FADE:
           2432 			;			{
           2433 			;#ifdef DEBUG
           2434 			;				USARTsend_num(nextCmd.data.set_fade.addr[0],'#');
           2435 			;				USARTsend_num(nextCmd.data.set_fade.addr[1],'#');
           2436 			;				USARTsend_num(nextCmd.data.set_fade.addr[2],'#');
           2437 			;				USARTsend_num(nextCmd.data.set_fade.addr[3],'#');
           2438 			;				USARTsend_num(nextCmd.data.set_fade.red,'r');
           2439 			;#endif
           2440 			;				ledstrip_set_fade(&nextCmd.data.set_fade);
0463 3023  2441 m064	MOVLW 35
0464 0020  2442 	MOVLB 0
0465 00AD  2443 	MOVWF pCmd_2
0466 21F7  2444 	CALL  ledstrip_set_fade
           2445 			;				break;
           2446 			;			}
           2447 			;			case SET_RUN: {break;}
           2448 			;		}
           2449 			;	}
           2450 			;}
0467 0008  2451 m065	RETURN
           2452 			;
           2453 			;void commandstorage_init()
           2454 			;{
           2455 commandstorage_init
           2456 			;	/** EEPROM contains FF in every cell after inital start,
           2457 			;	*** so I have to delete the pointer address
           2458 			;	*** otherwise the PIC thinks he has the EEPROM full with commands
           2459 			;	**/
           2460 			;	if (EEPROM_RD(CmdPointerAddr) == 0xff)
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 42

ADDR CODE  LINE SOURCE

0468 30FF  2461 	MOVLW 255
0469 2113  2462 	CALL  EEPROM_RD
046A 3AFF  2463 	XORLW 255
046B 1D03  2464 	BTFSS 0x03,Zero_
046C 2C72  2465 	GOTO  m066
           2466 			;		EEPROM_WR(CmdPointerAddr, 0);
046D 30FF  2467 	MOVLW 255
046E 0020  2468 	MOVLB 0
046F 00B0  2469 	MOVWF adress
0470 3000  2470 	MOVLW 0
0471 20F1  2471 	CALL  EEPROM_WR
           2472 			;
           2473 			;	// set loop pointer address to start
           2474 			;	EEPROM_WR(CmdLoopPointerAddr, 0);
0472 30FD  2475 m066	MOVLW 253
0473 0020  2476 	MOVLB 0
0474 00B0  2477 	MOVWF adress
0475 3000  2478 	MOVLW 0
0476 28F1  2479 	GOTO  EEPROM_WR
           2480 			;}
           2481 
           2482 	END
           2483 
           2484 
           2485 ; *** KEY INFO ***
           2486 
           2487 ; 0x02D3 P0    5 word(s)  0 % : RingBufInit
           2488 ; 0x02D8 P0   12 word(s)  0 % : RingBufGet
           2489 ; 0x02E4 P0   21 word(s)  1 % : RingBufPut
           2490 ; 0x034C P0   19 word(s)  0 % : USARTinit
           2491 ; 0x035F P0   10 word(s)  0 % : USARTsend
           2492 ; 0x0369 P0   19 word(s)  0 % : USARTsend_str
           2493 ; 0x037C P0   18 word(s)  0 % : USARTsend_arr
           2494 ; 0x00F1 P0   34 word(s)  1 % : EEPROM_WR
           2495 ; 0x0113 P0   13 word(s)  0 % : EEPROM_RD
           2496 ; 0x0120 P0   25 word(s)  1 % : EEPROM_WR_BLK
           2497 ; 0x0139 P0   26 word(s)  1 % : EEPROM_RD_BLK
           2498 ; 0x0088 P0   40 word(s)  1 % : addCRC
           2499 ; 0x00B0 P0   45 word(s)  2 % : CRC
           2500 ; 0x00DD P0   20 word(s)  0 % : newCRC
           2501 ; 0x0153 P0   28 word(s)  1 % : throw_errors
           2502 ; 0x038E P0   30 word(s)  1 % : commandstorage_read
           2503 ; 0x03AC P0   32 word(s)  1 % : commandstorage_write
           2504 ; 0x03CC P0  125 word(s)  6 % : commandstorage_get_commands
           2505 ; 0x0449 P0   31 word(s)  1 % : commandstorage_execute_commands
           2506 ; 0x0468 P0   15 word(s)  0 % : commandstorage_init
           2507 ; 0x02F9 P0   11 word(s)  0 % : spi_init
           2508 ; 0x0304 P0   11 word(s)  0 % : spi_send
           2509 ; 0x030F P0   18 word(s)  0 % : spi_send_arr
           2510 ; 0x0321 P0   32 word(s)  1 % : spi_send_ledbuf
           2511 ; 0x016F P0   18 word(s)  0 % : ledstrip_init
           2512 ; 0x0181 P0  118 word(s)  5 % : ledstrip_set_color
           2513 ; 0x01F7 P0  118 word(s)  5 % : ledstrip_set_fade
           2514 ; 0x0285 P0   78 word(s)  3 % : ledstrip_do_fade
           2515 ; 0x0341 P0    6 word(s)  0 % : timer_init
           2516 ; 0x0347 P0    5 word(s)  0 % : timer_set_for_fade
           2517 ; 0x0004 P0   19 word(s)  0 % : InterruptRoutine
           2518 ; 0x006D P0   27 word(s)  1 % : init_all
           2519 ; 0x0060 P0   13 word(s)  0 % : main
           2520 ; 0x026D P0   24 word(s)  1 % : ledstrip_get_distance
CC5X Version 3.4E,   File: main.c              10. Jun 2012  15:01   Page 43

ADDR CODE  LINE SOURCE

           2521 ; 0x0017 P0   73 word(s)  3 % : _const1
           2522 
           2523 ; RAM usage: 258 bytes (25 local), 254 bytes free
           2524 ; Maximum call level: 4 (+2 for interrupt)
           2525 ;  Codepage 0 has 1140 word(s) :  55 %
           2526 ;  Codepage 1 has    0 word(s) :   0 %
           2527 ;  Codepage 2 has    0 word(s) :   0 %
           2528 ;  Codepage 3 has    0 word(s) :   0 %
           2529 ; Total of 1140 code words (13 %)
