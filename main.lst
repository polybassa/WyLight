CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 1

ADDR CODE  LINE SOURCE

           0001 
           0002 ; CC5X Version 3.4H, Copyright (c) B Knudsen Data
           0003 ; C compiler for the PICmicro family
           0004 ; ************  17. May 2012  10:30  *************
           0005 
           0006 	processor  16F1936
           0007 	radix  DEC
           0008 
     0000  0009 INDF0       EQU   0x00
     0004  0010 FSR0        EQU   0x04
     0004  0011 FSR0L       EQU   0x04
     0005  0012 FSR0H       EQU   0x05
     0000  0013 Carry       EQU   0
     0002  0014 Zero_       EQU   2
     000E  0015 PORTC       EQU   0x0E
     008E  0016 TRISC       EQU   0x8E
     0099  0017 OSCCON      EQU   0x99
     0191  0018 EEADRL      EQU   0x191
     0192  0019 EEADRH      EQU   0x192
     0193  0020 EEDATL      EQU   0x193
     0194  0021 EEDATH      EQU   0x194
     0196  0022 EECON2      EQU   0x196
     0199  0023 RCREG       EQU   0x199
     019A  0024 TXREG       EQU   0x19A
     019B  0025 SPBRGL      EQU   0x19B
     019C  0026 SPBRGH      EQU   0x19C
     0211  0027 SSPBUF      EQU   0x211
     0006  0028 PEIE        EQU   6
     0007  0029 GIE         EQU   7
     0003  0030 SSPIF       EQU   3
     0004  0031 TXIF        EQU   4
     0005  0032 RCIF        EQU   5
     0005  0033 RCIE        EQU   5
     0000  0034 RD          EQU   0
     0001  0035 WR          EQU   1
     0002  0036 WREN        EQU   2
     0006  0037 CFGS        EQU   6
     0007  0038 EEPGD       EQU   7
     0003  0039 ADDEN       EQU   3
     0004  0040 CREN        EQU   4
     0006  0041 RX9         EQU   6
     0007  0042 SPEN        EQU   7
     0002  0043 BRGH        EQU   2
     0004  0044 SYNC        EQU   4
     0005  0045 TXEN        EQU   5
     0006  0046 TX9         EQU   6
     0003  0047 BRG16       EQU   3
     0006  0048 CKE         EQU   6
     0007  0049 SMP         EQU   7
     0001  0050 SSPM1       EQU   1
     0004  0051 CKP         EQU   4
     0005  0052 SSPEN       EQU   5
     0039  0053 gRingBuf    EQU   0x39
     004C  0054 gERROR      EQU   0x4C
     004D  0055 gCmdBuf     EQU   0x4D
     0020  0056 temp        EQU   0x20
     0025  0057 byte        EQU   0x25
     0026  0058 p_crcH      EQU   0x26
     0027  0059 p_crcL      EQU   0x27
     0028  0060 index       EQU   0x28
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 2

ADDR CODE  LINE SOURCE

     0029  0061 crcH        EQU   0x29
     002A  0062 crcL        EQU   0x2A
     007F  0063 data        EQU   0x7F
     007F  0064 length      EQU   0x7F
     007F  0065 crcH_out    EQU   0x7F
     007F  0066 crcL_out    EQU   0x7F
     007F  0067 crcH_2      EQU   0x7F
     007F  0068 crcL_2      EQU   0x7F
     007F  0069 i           EQU   0x7F
     007F  0070 byte_2      EQU   0x7F
     0025  0071 p_crcH_2    EQU   0x25
     0026  0072 p_crcL_2    EQU   0x26
     0030  0073 adress      EQU   0x30
     0031  0074 data_2      EQU   0x31
     0000  0075 GIE_status  EQU   0
     0035  0076 adress_2    EQU   0x35
     0036  0077 data_3      EQU   0x36
     0028  0078 array       EQU   0x28
     0029  0079 adress_3    EQU   0x29
     002A  0080 length_2    EQU   0x2A
     002B  0081 i_2         EQU   0x2B
     0030  0082 array_2     EQU   0x30
     0031  0083 adress_4    EQU   0x31
     0032  0084 length_3    EQU   0x32
     0033  0085 i_3         EQU   0x33
     0034  0086 temp_2      EQU   0x34
     0022  0087 k           EQU   0x22
     002D  0088 pCmd        EQU   0x2D
     002E  0089 address     EQU   0x2E
     002F  0090 r           EQU   0x2F
     0030  0091 g           EQU   0x30
     0031  0092 b           EQU   0x31
     0032  0093 k_2         EQU   0x32
     0033  0094 mask        EQU   0x33
     0025  0095 result      EQU   0x25
     0020  0096 value       EQU   0x20
     0021  0097 writeNext   EQU   0x21
     0038  0098 data_4      EQU   0x38
     007F  0099 array_3     EQU   0x7F
     007F  0100 length_4    EQU   0x7F
     007F  0101 i_4         EQU   0x7F
     0034  0102 array_4     EQU   0x34
     0036  0103 end         EQU   0x36
     0025  0104 ch          EQU   0x25
     0022  0105 string      EQU   0x22
     0023  0106 ps          EQU   0x23
     007F  0107 array_5     EQU   0x7F
     007F  0108 length_5    EQU   0x7F
     007F  0109 i_5         EQU   0x7F
     002D  0110 pDest       EQU   0x2D
     0000  0111 movePtr     EQU   0
     002E  0112 nextCmd     EQU   0x2E
     0025  0113 pSrc        EQU   0x25
     0026  0114 length_6    EQU   0x26
     0027  0115 nextCmd_2   EQU   0x27
     0022  0116 new_byte    EQU   0x22
     0023  0117 temp_3      EQU   0x23
     0024  0118 j           EQU   0x24
     0022  0119 nextCmd_3   EQU   0x22
     002C  0120 result_2    EQU   0x2C
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 3

ADDR CODE  LINE SOURCE

     0024  0121 ci          EQU   0x24
           0122 
0000 2855  0123 	GOTO main
           0124 
           0125   ; FILE main.c
           0126 			;//Nils Weiß 
           0127 			;//05.09.2011
           0128 			;//Compiler CC5x/
           0129 			;
           0130 			;#define NO_CRC
           0131 			;
           0132 			;#include "platform.h"
           0133 			;#pragma sharedAllocation
           0134 			;
           0135 			;//*********************** INCLUDEDATEIEN *********************************************
           0136 			;#include "RingBuf.h"		//clean
           0137 			;#include "usart.h"			//clean
           0138 			;#include "eeprom.h"       	//clean 
           0139 			;#include "crc.h"			//clean
           0140 			;#include "commandstorage.h"
           0141 			;#include "ledstrip.h"		//clean
           0142 			;#include "spi.h"			//clean
           0143 			;#include "timer.h"
           0144 			;
           0145 			;//*********************** GLOBAL VARIABLES *******************************************
           0146 			;struct CommandBuffer gCmdBuf;
           0147 			;struct LedBuffer gLedBuf;
           0148 			;struct ErrorBits gERROR;
           0149 			;
           0150 			;#ifndef X86
           0151 			;//*********************** INTERRUPTSERVICEROUTINE ************************************
           0152 			;#pragma origin 4					//Adresse des Interrupts	
     0000  0153 	ORG 0x0004
           0154 			;interrupt InterruptRoutine(void)
           0155 			;{
           0156 InterruptRoutine
           0157 			;	if (RCIF)
0004 0020  0158 	MOVLB 0
0005 1E91  0159 	BTFSS 0x11,RCIF
0006 2811  0160 	GOTO  m002
           0161 			;	{
           0162 			;		if(!RingBufHasError) RingBufPut(RCREG);
0007 184B  0163 	BTFSC gRingBuf+18,0
0008 280D  0164 	GOTO  m001
0009 0023  0165 	MOVLB 3
000A 0819  0166 	MOVF  RCREG,W
000B 21D0  0167 	CALL  RingBufPut
           0168 			;		else 
000C 2811  0169 	GOTO  m002
           0170 			;		{
           0171 			;			//Register lesen um Schnittstellen Fehler zu vermeiden
           0172 			;			char temp = RCREG;
000D 0023  0173 m001	MOVLB 3
000E 0819  0174 	MOVF  RCREG,W
000F 0020  0175 	MOVLB 0
0010 00A0  0176 	MOVWF temp
           0177 			;		}
           0178 			;	}
           0179 			;}
0011 0009  0180 m002	RETFIE
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 4

ADDR CODE  LINE SOURCE

           0181 			;#endif /* #ifndef X86 */
           0182 			;
           0183 			;//*********************** FUNKTIONSPROTOTYPEN ****************************************
           0184 			;void init_all();
           0185 			;
           0186 			;//*********************** HAUPTPROGRAMM **********************************************
           0187 			;void main(void)
           0188 			;{
           0189 _const1
0012 0020  0190 	MOVLB 0
0013 00A4  0191 	MOVWF ci
0014 3000  0192 	MOVLW 0
0015 0023  0193 	MOVLB 3
0016 0092  0194 	MOVWF EEADRH
0017 0020  0195 	MOVLB 0
0018 0C24  0196 	RRF   ci,W
0019 397F  0197 	ANDLW 127
001A 3E2F  0198 	ADDLW 47
001B 0023  0199 	MOVLB 3
001C 0091  0200 	MOVWF EEADRL
001D 1803  0201 	BTFSC 0x03,Carry
001E 0A92  0202 	INCF  EEADRH,1
001F 0023  0203 	MOVLB 3
0020 1795  0204 	BSF   0x195,EEPGD
0021 1415  0205 	BSF   0x195,RD
0022 0000  0206 	NOP  
0023 0000  0207 	NOP  
0024 0020  0208 	MOVLB 0
0025 1824  0209 	BTFSC ci,0
0026 282B  0210 	GOTO  m003
0027 0023  0211 	MOVLB 3
0028 0813  0212 	MOVF  EEDATL,W
0029 397F  0213 	ANDLW 127
002A 0008  0214 	RETURN
002B 0023  0215 m003	MOVLB 3
002C 0D13  0216 	RLF   EEDATL,W
002D 0D14  0217 	RLF   EEDATH,W
002E 0008  0218 	RETURN
002F 22A0  0219 	DW    0x22A0
0030 2952  0220 	DW    0x2952
0031 294F  0221 	DW    0x294F
0032 103A  0222 	DW    0x103A
0033 32D2  0223 	DW    0x32D2
0034 32E3  0224 	DW    0x32E3
0035 3B69  0225 	DW    0x3B69
0036 3165  0226 	DW    0x3165
0037 3375  0227 	DW    0x3375
0038 32E6  0228 	DW    0x32E6
0039 1072  0229 	DW    0x1072
003A 3AE6  0230 	DW    0x3AE6
003B 366C  0231 	DW    0x366C
003C 1000  0232 	DW    0x1000
003D 2945  0233 	DW    0x2945
003E 27D2  0234 	DW    0x27D2
003F 1D52  0235 	DW    0x1D52
0040 21A0  0236 	DW    0x21A0
0041 21D2  0237 	DW    0x21D2
0042 21AD  0238 	DW    0x21AD
0043 32E8  0239 	DW    0x32E8
0044 35E3  0240 	DW    0x35E3
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 5

ADDR CODE  LINE SOURCE

0045 3320  0241 	DW    0x3320
0046 34E1  0242 	DW    0x34E1
0047 32EC  0243 	DW    0x32EC
0048 0064  0244 	DW    0x64
0049 22A0  0245 	DW    0x22A0
004A 2952  0246 	DW    0x2952
004B 294F  0247 	DW    0x294F
004C 103A  0248 	DW    0x103A
004D 22C5  0249 	DW    0x22C5
004E 2950  0250 	DW    0x2950
004F 26CF  0251 	DW    0x26CF
0050 34A0  0252 	DW    0x34A0
0051 1073  0253 	DW    0x1073
0052 3AE6  0254 	DW    0x3AE6
0053 366C  0255 	DW    0x366C
0054 0000  0256 	DW    0x0
           0257 main
           0258 			;	init_all();
0055 205A  0259 	CALL  init_all
           0260 			;	while(1)
           0261 			;	{
           0262 			;		throw_errors();
0056 213F  0263 m004	CALL  throw_errors
           0264 			;		commandstorage_get_commands();
0057 22AD  0265 	CALL  commandstorage_get_commands
           0266 			;		commandstorage_execute_commands();
0058 232A  0267 	CALL  commandstorage_execute_commands
           0268 			;	}
0059 2856  0269 	GOTO  m004
           0270 			;}
           0271 			;//*********************** UNTERPROGRAMME **********************************************
           0272 			;
           0273 			;void init_all()
           0274 			;{
           0275 init_all
           0276 			;	OsciInit();
005A 3072  0277 	MOVLW 114
005B 0021  0278 	MOVLB 1
005C 0099  0279 	MOVWF OSCCON
           0280 			;	RingBufInit();
005D 21BF  0281 	CALL  RingBufInit
           0282 			;	USARTinit();
005E 222D  0283 	CALL  USARTinit
           0284 			;	spi_init();
005F 21E5  0285 	CALL  spi_init
           0286 			;	ledstrip_init();
0060 2158  0287 	CALL  ledstrip_init
           0288 			;	commandstorage_init();
0061 2344  0289 	CALL  commandstorage_init
           0290 			;	InitFET();
0062 0021  0291 	MOVLB 1
0063 100E  0292 	BCF   TRISC,0
           0293 			;	PowerOnLEDs();
0064 0020  0294 	MOVLB 0
0065 100E  0295 	BCF   PORTC,0
           0296 			;	//FactoryRestoreWLAN();
           0297 			;    
           0298 			;	ErrorInit();
0066 104C  0299 	BCF   gERROR,0
0067 10CC  0300 	BCF   gERROR,1
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 6

ADDR CODE  LINE SOURCE

           0301 			;	ClearCmdBuf();	
0068 01CD  0302 	CLRF  gCmdBuf
0069 01CE  0303 	CLRF  gCmdBuf+1
           0304 			;	AllowInterrupts();
006A 0021  0305 	MOVLB 1
006B 1691  0306 	BSF   0x91,RCIE
006C 170B  0307 	BSF   0x0B,PEIE
006D 178B  0308 	BSF   0x0B,GIE
           0309 			;	
           0310 			;	// *** send ready after init
           0311 			;	USARTsend('R');
006E 3052  0312 	MOVLW 82
006F 2240  0313 	CALL  USARTsend
           0314 			;	USARTsend('D');
0070 3044  0315 	MOVLW 68
0071 2240  0316 	CALL  USARTsend
           0317 			;	USARTsend('Y');
0072 3059  0318 	MOVLW 89
0073 2A40  0319 	GOTO  USARTsend
           0320 			;}
           0321 
           0322   ; FILE crc.c
           0323 			; // Include-Datei zum Erstellen von CRC Prüfsummen
           0324 			; //
           0325 			; //
           0326 			; // Nils Weiß
           0327 			; // 14.04.2012
           0328 			; // Compiler CC5x
           0329 			;
           0330 			;// 16-bit CCIT CRC
           0331 			;
           0332 			;void addCRC(char byte, char* p_crcH, char* p_crcL)
           0333 			;{
           0334 addCRC
           0335 			;	char index;
           0336 			;	char crcH,crcL;
           0337 			;	crcH = *p_crcH;
0074 0185  0338 	CLRF  FSR0H
0075 0020  0339 	MOVLB 0
0076 0826  0340 	MOVF  p_crcH,W
0077 0084  0341 	MOVWF FSR0L
0078 0800  0342 	MOVF  INDF0,W
0079 00A9  0343 	MOVWF crcH
           0344 			;	crcL = *p_crcL;
007A 0185  0345 	CLRF  FSR0H
007B 0827  0346 	MOVF  p_crcL,W
007C 0084  0347 	MOVWF FSR0L
007D 0800  0348 	MOVF  INDF0,W
007E 00AA  0349 	MOVWF crcL
           0350 			;
           0351 			;	MOVF(byte,0);
007F 0825  0352 	MOVF  byte,W
           0353 			;	
           0354 			;	XORWF(crcH,0);
0080 0629  0355 	XORWF crcH,W
           0356 			;	MOVWF(index);
0081 00A8  0357 	MOVWF index
           0358 			;	ANDLW(0xf0);
0082 39F0  0359 	ANDLW 240
           0360 			;	SWAPF(index,1);
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 7

ADDR CODE  LINE SOURCE

0083 0EA8  0361 	SWAPF index,1
           0362 			;	XORWF(index,1);
0084 06A8  0363 	XORWF index,1
           0364 			;	
           0365 			;	MOVF(index,0);
0085 0828  0366 	MOVF  index,W
           0367 			;	ANDLW(0xf0);
0086 39F0  0368 	ANDLW 240
           0369 			;	XORWF(crcL,0);
0087 062A  0370 	XORWF crcL,W
           0371 			;	MOVWF(crcH);
0088 00A9  0372 	MOVWF crcH
           0373 			;	
           0374 			;	RLF(index,0);
0089 0D28  0375 	RLF   index,W
           0376 			;	RLF(index,0);
008A 0D28  0377 	RLF   index,W
           0378 			;	XORWF(crcH,1);
008B 06A9  0379 	XORWF crcH,1
           0380 			;	ANDLW(0xe0);
008C 39E0  0381 	ANDLW 224
           0382 			;	XORWF(crcH,1);
008D 06A9  0383 	XORWF crcH,1
           0384 			;		
           0385 			;	SWAPF(index,1);
008E 0EA8  0386 	SWAPF index,1
           0387 			;	XORWF(index,0);
008F 0628  0388 	XORWF index,W
           0389 			;	MOVWF(crcL);
0090 00AA  0390 	MOVWF crcL
           0391 			;
           0392 			;	*p_crcH = crcH;
0091 0185  0393 	CLRF  FSR0H
0092 0826  0394 	MOVF  p_crcH,W
0093 0084  0395 	MOVWF FSR0L
0094 0829  0396 	MOVF  crcH,W
0095 0080  0397 	MOVWF INDF0
           0398 			;	*p_crcL = crcL;
0096 0185  0399 	CLRF  FSR0H
0097 0827  0400 	MOVF  p_crcL,W
0098 0084  0401 	MOVWF FSR0L
0099 082A  0402 	MOVF  crcL,W
009A 0080  0403 	MOVWF INDF0
           0404 			;
           0405 			;}
009B 0008  0406 	RETURN
           0407 			;
           0408 			;void CRC(char *data, char length, char* crcH_out, char* crcL_out)
           0409 			;{
           0410 CRC
           0411 			;	if(!crcH_out)return;
009C 08FF  0412 	MOVF  crcH_out,1
009D 1903  0413 	BTFSC 0x03,Zero_
009E 0008  0414 	RETURN
           0415 			;	if(!crcL_out)return;
009F 08FF  0416 	MOVF  crcL_out,1
00A0 1903  0417 	BTFSC 0x03,Zero_
00A1 0008  0418 	RETURN
           0419 			;	if(!data)return;
00A2 08FF  0420 	MOVF  data,1
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 8

ADDR CODE  LINE SOURCE

00A3 1903  0421 	BTFSC 0x03,Zero_
00A4 0008  0422 	RETURN
           0423 			;	char crcH,crcL,i,byte;
           0424 			;	crcH=0xff;
00A5 30FF  0425 	MOVLW 255
00A6 00FF  0426 	MOVWF crcH_2
           0427 			;	crcL=0xff;
00A7 30FF  0428 	MOVLW 255
00A8 00FF  0429 	MOVWF crcL_2
           0430 			;
           0431 			;	for(i=0;i<length;i++)
00A9 01FF  0432 	CLRF  i
00AA 087F  0433 m005	MOVF  length,W
00AB 027F  0434 	SUBWF i,W
00AC 1803  0435 	BTFSC 0x03,Carry
00AD 28BE  0436 	GOTO  m006
           0437 			;	{
           0438 			;		byte = data[i];
00AE 087F  0439 	MOVF  i,W
00AF 077F  0440 	ADDWF data,W
00B0 0084  0441 	MOVWF FSR0L
00B1 0185  0442 	CLRF  FSR0H
00B2 0800  0443 	MOVF  INDF0,W
00B3 00FF  0444 	MOVWF byte_2
           0445 			;		addCRC(byte,&crcH,&crcL);
00B4 087F  0446 	MOVF  byte_2,W
00B5 0020  0447 	MOVLB 0
00B6 00A5  0448 	MOVWF byte
00B7 307F  0449 	MOVLW 127
00B8 00A6  0450 	MOVWF p_crcH
00B9 307F  0451 	MOVLW 127
00BA 00A7  0452 	MOVWF p_crcL
00BB 2074  0453 	CALL  addCRC
           0454 			;	}
00BC 0AFF  0455 	INCF  i,1
00BD 28AA  0456 	GOTO  m005
           0457 			;	
           0458 			;	*crcH_out = crcH;
00BE 0185  0459 m006	CLRF  FSR0H
00BF 087F  0460 	MOVF  crcH_out,W
00C0 0084  0461 	MOVWF FSR0L
00C1 087F  0462 	MOVF  crcH_2,W
00C2 0080  0463 	MOVWF INDF0
           0464 			;	*crcL_out = crcL;
00C3 0185  0465 	CLRF  FSR0H
00C4 087F  0466 	MOVF  crcL_out,W
00C5 0084  0467 	MOVWF FSR0L
00C6 087F  0468 	MOVF  crcL_2,W
00C7 0080  0469 	MOVWF INDF0
           0470 			;}
00C8 0008  0471 	RETURN
           0472 			;
           0473 			;void newCRC(char* p_crcH, char* p_crcL)
           0474 			;{
           0475 newCRC
           0476 			;    if(!p_crcH) return;
00C9 0020  0477 	MOVLB 0
00CA 08A5  0478 	MOVF  p_crcH_2,1
00CB 1903  0479 	BTFSC 0x03,Zero_
00CC 0008  0480 	RETURN
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 9

ADDR CODE  LINE SOURCE

           0481 			;    if(!p_crcL) return;
00CD 0020  0482 	MOVLB 0
00CE 08A6  0483 	MOVF  p_crcL_2,1
00CF 1903  0484 	BTFSC 0x03,Zero_
00D0 0008  0485 	RETURN
           0486 			;    *p_crcH = 0xff;
00D1 0185  0487 	CLRF  FSR0H
00D2 0020  0488 	MOVLB 0
00D3 0825  0489 	MOVF  p_crcH_2,W
00D4 0084  0490 	MOVWF FSR0L
00D5 30FF  0491 	MOVLW 255
00D6 0080  0492 	MOVWF INDF0
           0493 			;    *p_crcL = 0xff;
00D7 0185  0494 	CLRF  FSR0H
00D8 0826  0495 	MOVF  p_crcL_2,W
00D9 0084  0496 	MOVWF FSR0L
00DA 30FF  0497 	MOVLW 255
00DB 0080  0498 	MOVWF INDF0
           0499 			;}
00DC 0008  0500 	RETURN
           0501 
           0502   ; FILE eeprom.c
           0503 			;//Funktionen für EEPROM-Zugriffe
           0504 			;
           0505 			;//Nils Weiß 
           0506 			;//05.09.2011
           0507 			;//Compiler CC5x
           0508 			;
           0509 			;#ifndef X86
           0510 			;//*********************** EEPROM BYTE SCHREIBEN  **********************************************
           0511 			;
           0512 			;void EEPROM_WR(char adress, char data)
           0513 			;{
           0514 EEPROM_WR
00DD 0020  0515 	MOVLB 0
00DE 00B1  0516 	MOVWF data_2
           0517 			;	bit GIE_status; 
           0518 			;	//EEADRH = (char)(adress<<8);
           0519 			;    EEADRL = (char)adress;        // Adresse in Adressregister übertragen
00DF 0830  0520 	MOVF  adress,W
00E0 0023  0521 	MOVLB 3
00E1 0091  0522 	MOVWF EEADRL
           0523 			;	EEDATL = data;          // Daten in Datenregister übertragen
00E2 0020  0524 	MOVLB 0
00E3 0831  0525 	MOVF  data_2,W
00E4 0023  0526 	MOVLB 3
00E5 0093  0527 	MOVWF EEDATL
           0528 			;    CFGS = 0;
00E6 1315  0529 	BCF   0x195,CFGS
           0530 			;	EEPGD = 0;                // Auswahl: Programmspeicher lesen oder EEPROM
00E7 1395  0531 	BCF   0x195,EEPGD
           0532 			;    WREN = 1;                 // Schreiben ins EEPROM erlauben
00E8 1515  0533 	BSF   0x195,WREN
           0534 			;	GIE_status=GIE;			
00E9 0020  0535 	MOVLB 0
00EA 1032  0536 	BCF   0x32,GIE_status
00EB 1B8B  0537 	BTFSC 0x0B,GIE
00EC 1432  0538 	BSF   0x32,GIE_status
           0539 			;    GIE=0;                  // Interrups verbieten
00ED 138B  0540 	BCF   0x0B,GIE
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 10

ADDR CODE  LINE SOURCE

           0541 			;    EECON2 = 0x55;
00EE 3055  0542 	MOVLW 85
00EF 0023  0543 	MOVLB 3
00F0 0096  0544 	MOVWF EECON2
           0545 			;    EECON2 = 0xAA;
00F1 30AA  0546 	MOVLW 170
00F2 0096  0547 	MOVWF EECON2
           0548 			;	WR=1; 					// Starten des Schreibens
00F3 1495  0549 	BSF   0x195,WR
           0550 			;    GIE=GIE_status;                  // Interrups erlauben
00F4 0020  0551 	MOVLB 0
00F5 1C32  0552 	BTFSS 0x32,GIE_status
00F6 138B  0553 	BCF   0x0B,GIE
00F7 1832  0554 	BTFSC 0x32,GIE_status
00F8 178B  0555 	BSF   0x0B,GIE
           0556 			;	WREN=0;
00F9 0023  0557 	MOVLB 3
00FA 1115  0558 	BCF   0x195,WREN
           0559 			;	while(WR);
00FB 0023  0560 m007	MOVLB 3
00FC 1895  0561 	BTFSC 0x195,WR
00FD 28FB  0562 	GOTO  m007
           0563 			;}
00FE 0008  0564 	RETURN
           0565 			;
           0566 			;//*********************** EEPROM BYTE LESEN  **********************************************
           0567 			;
           0568 			;char EEPROM_RD(char adress)
           0569 			;{
           0570 EEPROM_RD
00FF 0020  0571 	MOVLB 0
0100 00B5  0572 	MOVWF adress_2
           0573 			;    char data;
           0574 			;    //EEADRH = (char)(adress<<8);        // Adresse in Adressregister übertragen
           0575 			;    EEADRL = (char)(adress);
0101 0835  0576 	MOVF  adress_2,W
0102 0023  0577 	MOVLB 3
0103 0091  0578 	MOVWF EEADRL
           0579 			;	CFGS=0;
0104 1315  0580 	BCF   0x195,CFGS
           0581 			;	EEPGD=0;                // Auswahl: Programmspeicher lesen oder EEPROM
0105 1395  0582 	BCF   0x195,EEPGD
           0583 			;    RD=1;                   // Starten des Lesesn
0106 1415  0584 	BSF   0x195,RD
           0585 			;    data = EEDATL;       // Daten aus Datenregister auslesen
0107 0813  0586 	MOVF  EEDATL,W
0108 0020  0587 	MOVLB 0
0109 00B6  0588 	MOVWF data_3
           0589 			;    return data;
010A 0836  0590 	MOVF  data_3,W
010B 0008  0591 	RETURN
           0592 			;}
           0593 			;#endif /* #ifndef X86 */
           0594 			;
           0595 			;//*********************** EEPROM BYTEARRAY SCHREIBEN  **************************************
           0596 			;
           0597 			;void EEPROM_WR_BLK(char *array, char adress, char length)			//Zum Ausführen eines beliebigen Befehls durch den Programmcode
           0598 			;{
           0599 EEPROM_WR_BLK
010C 0020  0600 	MOVLB 0
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 11

ADDR CODE  LINE SOURCE

010D 00AA  0601 	MOVWF length_2
           0602 			;	if(!array) return;
010E 08A8  0603 	MOVF  array,1
010F 1903  0604 	BTFSC 0x03,Zero_
0110 0008  0605 	RETURN
           0606 			;	char i;
           0607 			;	for(i=0;i<length;i++)
0111 0020  0608 	MOVLB 0
0112 01AB  0609 	CLRF  i_2
0113 0020  0610 m008	MOVLB 0
0114 082A  0611 	MOVF  length_2,W
0115 022B  0612 	SUBWF i_2,W
0116 1803  0613 	BTFSC 0x03,Carry
0117 2924  0614 	GOTO  m009
           0615 			;	{
           0616 			;		EEPROM_WR(adress,*array);
0118 0829  0617 	MOVF  adress_3,W
0119 00B0  0618 	MOVWF adress
011A 0185  0619 	CLRF  FSR0H
011B 0828  0620 	MOVF  array,W
011C 0084  0621 	MOVWF FSR0L
011D 0800  0622 	MOVF  INDF0,W
011E 20DD  0623 	CALL  EEPROM_WR
           0624 			;		adress++;
011F 0020  0625 	MOVLB 0
0120 0AA9  0626 	INCF  adress_3,1
           0627 			;		array++;
0121 0AA8  0628 	INCF  array,1
           0629 			;	}
0122 0AAB  0630 	INCF  i_2,1
0123 2913  0631 	GOTO  m008
           0632 			;}
0124 0008  0633 m009	RETURN
           0634 			;
           0635 			;//*********************** EEPROM BYTEARRAY LESEN  **************************************
           0636 			;
           0637 			;void EEPROM_RD_BLK(char *array, char adress, char length)			//Zum Ausführen eines beliebigen Befehls durch den Programmcode
           0638 			;{
           0639 EEPROM_RD_BLK
0125 0020  0640 	MOVLB 0
0126 00B2  0641 	MOVWF length_3
           0642 			;	if(!array) return;
0127 08B0  0643 	MOVF  array_2,1
0128 1903  0644 	BTFSC 0x03,Zero_
0129 0008  0645 	RETURN
           0646 			;	char i, temp;
           0647 			;	for(i=0;i<length;i++)
012A 0020  0648 	MOVLB 0
012B 01B3  0649 	CLRF  i_3
012C 0020  0650 m010	MOVLB 0
012D 0832  0651 	MOVF  length_3,W
012E 0233  0652 	SUBWF i_3,W
012F 1803  0653 	BTFSC 0x03,Carry
0130 293E  0654 	GOTO  m011
           0655 			;	{
           0656 			;		temp = EEPROM_RD(adress);
0131 0831  0657 	MOVF  adress_4,W
0132 20FF  0658 	CALL  EEPROM_RD
0133 0020  0659 	MOVLB 0
0134 00B4  0660 	MOVWF temp_2
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 12

ADDR CODE  LINE SOURCE

           0661 			;		array[i] = temp;
0135 0833  0662 	MOVF  i_3,W
0136 0730  0663 	ADDWF array_2,W
0137 0084  0664 	MOVWF FSR0L
0138 0185  0665 	CLRF  FSR0H
0139 0834  0666 	MOVF  temp_2,W
013A 0080  0667 	MOVWF INDF0
           0668 			;		adress++;
013B 0AB1  0669 	INCF  adress_4,1
           0670 			;	}
013C 0AB3  0671 	INCF  i_3,1
013D 292C  0672 	GOTO  m010
           0673 			;}
013E 0008  0674 m011	RETURN
           0675 
           0676   ; FILE error.c
           0677 			;
           0678 			;#include "commandstorage.h"
           0679 			;#include "error.h"
           0680 			;#include "RingBuf.h"
           0681 			;#include "usart.h"
           0682 			;
           0683 			;void throw_errors()
           0684 			;{
           0685 throw_errors
           0686 			;	if(RingBufHasError) 
013F 0020  0687 	MOVLB 0
0140 1C4B  0688 	BTFSS gRingBuf+18,0
0141 2947  0689 	GOTO  m012
           0690 			;	{
           0691 			;		// *** if a RingBufError occure, I have to throw away the current command,
           0692 			;		// *** because the last byte was not saved. Commandstring is inconsistent
           0693 			;		ClearCmdBuf();
0142 01CD  0694 	CLRF  gCmdBuf
0143 01CE  0695 	CLRF  gCmdBuf+1
           0696 			;		USARTsend_str(" ERROR: Receivebuffer full");
0144 01A2  0697 	CLRF  string
0145 224A  0698 	CALL  USARTsend_str
           0699 			;		// *** Re-init the Ringbuffer to get a consistent commandstring and reset error
           0700 			;		RingBufInit();
0146 21BF  0701 	CALL  RingBufInit
           0702 			;	}
           0703 			;	if(gERROR.crc_failure)
0147 0020  0704 m012	MOVLB 0
0148 1C4C  0705 	BTFSS gERROR,0
0149 294F  0706 	GOTO  m013
           0707 			;	{
           0708 			;		USARTsend_str(" ERROR: CRC-Check failed");
014A 301B  0709 	MOVLW 27
014B 00A2  0710 	MOVWF string
014C 224A  0711 	CALL  USARTsend_str
           0712 			;		gERROR.crc_failure = 0;
014D 0020  0713 	MOVLB 0
014E 104C  0714 	BCF   gERROR,0
           0715 			;	}
           0716 			;	if(gERROR.eeprom_failure)
014F 0020  0717 m013	MOVLB 0
0150 1CCC  0718 	BTFSS gERROR,1
0151 2957  0719 	GOTO  m014
           0720 			;	{
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 13

ADDR CODE  LINE SOURCE

           0721 			;		USARTsend_str(" ERROR: EEPROM is full");
0152 3034  0722 	MOVLW 52
0153 00A2  0723 	MOVWF string
0154 224A  0724 	CALL  USARTsend_str
           0725 			;		gERROR.eeprom_failure = 0;
0155 0020  0726 	MOVLB 0
0156 10CC  0727 	BCF   gERROR,1
           0728 			;	}
           0729 			;}
0157 0008  0730 m014	RETURN
           0731 
           0732   ; FILE ledstrip.c
           0733 			;//Nils Weiß 
           0734 			;//20.04.2012
           0735 			;//Compiler CC5x 
           0736 			;
           0737 			;#include "ledstrip.h"
           0738 			;
           0739 			;void ledstrip_init(void)
           0740 			;{
           0741 ledstrip_init
           0742 			;	char k;
           0743 			;	for(k = 0;k < (NUM_OF_LED * 3); k++)
0158 0020  0744 	MOVLB 0
0159 01A2  0745 	CLRF  k
015A 3060  0746 m015	MOVLW 96
015B 0020  0747 	MOVLB 0
015C 0222  0748 	SUBWF k,W
015D 1803  0749 	BTFSC 0x03,Carry
015E 2969  0750 	GOTO  m016
           0751 			;	{	
           0752 			;		gLedBuf.led_array[k] = 0;
015F 3020  0753 	MOVLW 32
0160 0085  0754 	MOVWF FSR0+1
0161 3040  0755 	MOVLW 64
0162 0722  0756 	ADDWF k,W
0163 0084  0757 	MOVWF FSR0
0164 1803  0758 	BTFSC 0x03,Carry
0165 0A85  0759 	INCF  FSR0+1,1
0166 0180  0760 	CLRF  INDF0
           0761 			;	}
0167 0AA2  0762 	INCF  k,1
0168 295A  0763 	GOTO  m015
           0764 			;}
0169 0008  0765 m016	RETURN
           0766 			;
           0767 			;/***
           0768 			;*** This funktion sets the values of the global LedBuffer
           0769 			;*** only Led's where the address bit is 1 will be set to the new color
           0770 			;***/
           0771 			;void ledstrip_set_color(struct cmd_set_color *pCmd)
           0772 			;{	
           0773 ledstrip_set_color
           0774 			;	char *address = pCmd->addr;
016A 0020  0775 	MOVLB 0
016B 082D  0776 	MOVF  pCmd,W
016C 00AE  0777 	MOVWF address
           0778 			;	char r = pCmd->red;
016D 3004  0779 	MOVLW 4
016E 072D  0780 	ADDWF pCmd,W
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 14

ADDR CODE  LINE SOURCE

016F 0084  0781 	MOVWF FSR0L
0170 0185  0782 	CLRF  FSR0H
0171 0800  0783 	MOVF  INDF0,W
0172 00AF  0784 	MOVWF r
           0785 			;	char g = pCmd->green;
0173 3005  0786 	MOVLW 5
0174 072D  0787 	ADDWF pCmd,W
0175 0084  0788 	MOVWF FSR0L
0176 0185  0789 	CLRF  FSR0H
0177 0800  0790 	MOVF  INDF0,W
0178 00B0  0791 	MOVWF g
           0792 			;	char b = pCmd->blue;
0179 3006  0793 	MOVLW 6
017A 072D  0794 	ADDWF pCmd,W
017B 0084  0795 	MOVWF FSR0L
017C 0185  0796 	CLRF  FSR0H
017D 0800  0797 	MOVF  INDF0,W
017E 00B1  0798 	MOVWF b
           0799 			;	
           0800 			;	char k,mask;
           0801 			;	mask = 0b00000001;
017F 3001  0802 	MOVLW 1
0180 00B3  0803 	MOVWF mask
           0804 			;	for(k = 0; k < (NUM_OF_LED * 3); k++)
0181 01B2  0805 	CLRF  k_2
0182 3060  0806 m017	MOVLW 96
0183 0020  0807 	MOVLB 0
0184 0232  0808 	SUBWF k_2,W
0185 1803  0809 	BTFSC 0x03,Carry
0186 29B9  0810 	GOTO  m021
           0811 			;	{	
           0812 			;		if(0 != (*address & mask))
0187 0185  0813 	CLRF  FSR0H
0188 082E  0814 	MOVF  address,W
0189 0084  0815 	MOVWF FSR0L
018A 0833  0816 	MOVF  mask,W
018B 0500  0817 	ANDWF INDF0,W
018C 1903  0818 	BTFSC 0x03,Zero_
018D 29AC  0819 	GOTO  m018
           0820 			;		{
           0821 			;			gLedBuf.led_array[k] = b;
018E 3020  0822 	MOVLW 32
018F 0085  0823 	MOVWF FSR0+1
0190 3040  0824 	MOVLW 64
0191 0732  0825 	ADDWF k_2,W
0192 0084  0826 	MOVWF FSR0
0193 1803  0827 	BTFSC 0x03,Carry
0194 0A85  0828 	INCF  FSR0+1,1
0195 0831  0829 	MOVF  b,W
0196 0080  0830 	MOVWF INDF0
           0831 			;			k++;
0197 0AB2  0832 	INCF  k_2,1
           0833 			;			gLedBuf.led_array[k] = g;
0198 3020  0834 	MOVLW 32
0199 0085  0835 	MOVWF FSR0+1
019A 3040  0836 	MOVLW 64
019B 0732  0837 	ADDWF k_2,W
019C 0084  0838 	MOVWF FSR0
019D 1803  0839 	BTFSC 0x03,Carry
019E 0A85  0840 	INCF  FSR0+1,1
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 15

ADDR CODE  LINE SOURCE

019F 0830  0841 	MOVF  g,W
01A0 0080  0842 	MOVWF INDF0
           0843 			;			k++;
01A1 0AB2  0844 	INCF  k_2,1
           0845 			;			gLedBuf.led_array[k] = r;
01A2 3020  0846 	MOVLW 32
01A3 0085  0847 	MOVWF FSR0+1
01A4 3040  0848 	MOVLW 64
01A5 0732  0849 	ADDWF k_2,W
01A6 0084  0850 	MOVWF FSR0
01A7 1803  0851 	BTFSC 0x03,Carry
01A8 0A85  0852 	INCF  FSR0+1,1
01A9 082F  0853 	MOVF  r,W
01AA 0080  0854 	MOVWF INDF0
           0855 			;		}
           0856 			;		else 
01AB 29AF  0857 	GOTO  m019
           0858 			;		{
           0859 			;			k++;
01AC 0020  0860 m018	MOVLB 0
01AD 0AB2  0861 	INCF  k_2,1
           0862 			;			k++;
01AE 0AB2  0863 	INCF  k_2,1
           0864 			;		}
           0865 			;#ifdef X86
           0866 			;		mask = mask << 1;
           0867 			;		if(0 == mask)
           0868 			;#else
           0869 			;		RLF(mask,1);
01AF 0020  0870 m019	MOVLB 0
01B0 0DB3  0871 	RLF   mask,1
           0872 			;		if(Carry == 1) 
01B1 1C03  0873 	BTFSS 0x03,Carry
01B2 29B6  0874 	GOTO  m020
           0875 			;#endif
           0876 			;		{
           0877 			;			address++;
01B3 0AAE  0878 	INCF  address,1
           0879 			;			mask= 0b00000001;
01B4 3001  0880 	MOVLW 1
01B5 00B3  0881 	MOVWF mask
           0882 			;		}
           0883 			;	}
01B6 0020  0884 m020	MOVLB 0
01B7 0AB2  0885 	INCF  k_2,1
01B8 2982  0886 	GOTO  m017
           0887 			;	spi_send_ledbuf(&gLedBuf.led_array[0]);
01B9 3040  0888 m021	MOVLW 64
01BA 0020  0889 	MOVLB 0
01BB 00B4  0890 	MOVWF array_4
01BC 3020  0891 	MOVLW 32
01BD 00B5  0892 	MOVWF array_4+1
01BE 2A0D  0893 	GOTO  spi_send_ledbuf
           0894 
           0895   ; FILE main.c
           0896 			;
           0897 			;// cc5xfree is a bit stupid so we include the other implementation files here
           0898 			;#ifndef X86
           0899 			;#include "crc.c"
           0900 			;#include "eeprom.c"
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 16

ADDR CODE  LINE SOURCE

           0901 			;#include "error.c"
           0902 			;#include "ledstrip.c"
           0903 
           0904   ; FILE RingBuf.c
           0905 			;
           0906 			;#include "RingBuf.h"
           0907 			;
           0908 			;#ifndef X86
           0909 			;#message Global variables are defined in RingBuf.c
           0910 			;#endif /* #ifndef X86 */
           0911 			;struct RingBuffer gRingBuf;
           0912 			;
           0913 			;void RingBufInit(void)
           0914 			;{
           0915 RingBufInit
           0916 			;	gRingBuf.read = 0;
01BF 0020  0917 	MOVLB 0
01C0 01C9  0918 	CLRF  gRingBuf+16
           0919 			;	gRingBuf.write = 0;
01C1 01CA  0920 	CLRF  gRingBuf+17
           0921 			;	gRingBuf.error_full = 0;
01C2 104B  0922 	BCF   gRingBuf+18,0
           0923 			;}
01C3 0008  0924 	RETURN
           0925 			;
           0926 			;char RingBufGet(void)
           0927 			;{
           0928 RingBufGet
           0929 			;	char result = gRingBuf.data[gRingBuf.read];
01C4 3039  0930 	MOVLW 57
01C5 0020  0931 	MOVLB 0
01C6 0749  0932 	ADDWF gRingBuf+16,W
01C7 0084  0933 	MOVWF FSR0L
01C8 0185  0934 	CLRF  FSR0H
01C9 0800  0935 	MOVF  INDF0,W
01CA 00A5  0936 	MOVWF result
           0937 			;	gRingBuf.read = RingBufInc(gRingBuf.read);
01CB 0A49  0938 	INCF  gRingBuf+16,W
01CC 390F  0939 	ANDLW 15
01CD 00C9  0940 	MOVWF gRingBuf+16
           0941 			;	return result;
01CE 0825  0942 	MOVF  result,W
01CF 0008  0943 	RETURN
           0944 			;}
           0945 			;
           0946 			;void RingBufPut(char value)
           0947 			;{
           0948 RingBufPut
01D0 0020  0949 	MOVLB 0
01D1 00A0  0950 	MOVWF value
           0951 			;	char writeNext = RingBufInc(gRingBuf.write);
01D2 0A4A  0952 	INCF  gRingBuf+17,W
01D3 390F  0953 	ANDLW 15
01D4 00A1  0954 	MOVWF writeNext
           0955 			;	if(writeNext != gRingBuf.read)
01D5 0821  0956 	MOVF  writeNext,W
01D6 0649  0957 	XORWF gRingBuf+16,W
01D7 1903  0958 	BTFSC 0x03,Zero_
01D8 29E2  0959 	GOTO  m022
           0960 			;	{
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 17

ADDR CODE  LINE SOURCE

           0961 			;		gRingBuf.data[gRingBuf.write] = value;
01D9 3039  0962 	MOVLW 57
01DA 074A  0963 	ADDWF gRingBuf+17,W
01DB 0084  0964 	MOVWF FSR0L
01DC 0185  0965 	CLRF  FSR0H
01DD 0820  0966 	MOVF  value,W
01DE 0080  0967 	MOVWF INDF0
           0968 			;		gRingBuf.write = writeNext;
01DF 0821  0969 	MOVF  writeNext,W
01E0 00CA  0970 	MOVWF gRingBuf+17
           0971 			;	}
           0972 			;	else gRingBuf.error_full = 1;
01E1 29E4  0973 	GOTO  m023
01E2 0020  0974 m022	MOVLB 0
01E3 144B  0975 	BSF   gRingBuf+18,0
           0976 			;}
01E4 0008  0977 m023	RETURN
           0978 
           0979   ; FILE spi.c
           0980 			;//Nils Weiß 
           0981 			;//20.04.2012
           0982 			;//Compiler CC5x
           0983 			;
           0984 			;#include "ledstrip.h"
           0985 			;
           0986 			;#ifndef X86
           0987 			;void spi_init()
           0988 			;{
           0989 spi_init
           0990 			;	TRISC.3 = 0;        // Make port RC3 an output(SPI Clock)
01E5 0021  0991 	MOVLB 1
01E6 118E  0992 	BCF   TRISC,3
           0993 			;    TRISC.4 = 1;        // Make port RC4 an input(SPI Data In)
01E7 160E  0994 	BSF   TRISC,4
           0995 			;    TRISC.5 = 0;        // Make port RC5 an output(SPI Data Out)
01E8 128E  0996 	BCF   TRISC,5
           0997 			;	SSPM1 = 0;
01E9 0024  0998 	MOVLB 4
01EA 1095  0999 	BCF   0x215,SSPM1
           1000 			;	SMP = 0;
01EB 1394  1001 	BCF   0x214,SMP
           1002 			;	CKP = 1;
01EC 1615  1003 	BSF   0x215,CKP
           1004 			;	CKE = 0;
01ED 1314  1005 	BCF   0x214,CKE
           1006 			;	SSPEN = 1;
01EE 1695  1007 	BSF   0x215,SSPEN
           1008 			;}
01EF 0008  1009 	RETURN
           1010 			;
           1011 			;char spi_send(char data)
           1012 			;{
           1013 spi_send
01F0 0020  1014 	MOVLB 0
01F1 00B8  1015 	MOVWF data_4
           1016 			;	SSPBUF = data;	
01F2 0838  1017 	MOVF  data_4,W
01F3 0024  1018 	MOVLB 4
01F4 0091  1019 	MOVWF SSPBUF
           1020 			;	while(SSPIF == 0);
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 18

ADDR CODE  LINE SOURCE

01F5 0020  1021 m024	MOVLB 0
01F6 1D91  1022 	BTFSS 0x11,SSPIF
01F7 29F5  1023 	GOTO  m024
           1024 			;	return SSPBUF;
01F8 0024  1025 	MOVLB 4
01F9 0811  1026 	MOVF  SSPBUF,W
01FA 0008  1027 	RETURN
           1028 			;}
           1029 			;#endif /* #ifndef X86 */
           1030 			;
           1031 			;/***
           1032 			;**	This function sends the array to the LED controller(WS2801)
           1033 			;**  it starts with the last byte to get a correct output
           1034 			;***/
           1035 			;void spi_send_arr(char *array, char length)
           1036 			;{
           1037 spi_send_arr
01FB 00FF  1038 	MOVWF length_4
           1039 			;	if(array == 0) return;
01FC 08FF  1040 	MOVF  array_3,1
01FD 1903  1041 	BTFSC 0x03,Zero_
01FE 0008  1042 	RETURN
           1043 			;	char i;
           1044 			;	for(i = length; i == 0; i-- )
01FF 087F  1045 	MOVF  length_4,W
0200 00FF  1046 	MOVWF i_4
0201 08FF  1047 m025	MOVF  i_4,1
0202 1D03  1048 	BTFSS 0x03,Zero_
0203 2A0C  1049 	GOTO  m026
           1050 			;	{
           1051 			;		spi_send(array[i]);
0204 087F  1052 	MOVF  i_4,W
0205 077F  1053 	ADDWF array_3,W
0206 0084  1054 	MOVWF FSR0L
0207 0185  1055 	CLRF  FSR0H
0208 0800  1056 	MOVF  INDF0,W
0209 21F0  1057 	CALL  spi_send
           1058 			;	} 
020A 03FF  1059 	DECF  i_4,1
020B 2A01  1060 	GOTO  m025
           1061 			;}
020C 0008  1062 m026	RETURN
           1063 			;
           1064 			;void spi_send_ledbuf(char *array)//!!! CHECK if GIE=0 during the sendroutine improves the result
           1065 			;{
           1066 spi_send_ledbuf
           1067 			;	//array must be the address of the first byte
           1068 			;	char* end;
           1069 			;	//calculate where the end is
           1070 			;	end = array + (NUM_OF_LED * 3);
020D 0020  1071 	MOVLB 0
020E 0835  1072 	MOVF  array_4+1,W
020F 00B7  1073 	MOVWF end+1
0210 3060  1074 	MOVLW 96
0211 0734  1075 	ADDWF array_4,W
0212 00B6  1076 	MOVWF end
0213 1803  1077 	BTFSC 0x03,Carry
0214 0AB7  1078 	INCF  end+1,1
           1079 			;	//send all
           1080 			;	for(; array < end; array++)
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 19

ADDR CODE  LINE SOURCE

0215 0020  1081 m027	MOVLB 0
0216 0837  1082 	MOVF  end+1,W
0217 0235  1083 	SUBWF array_4+1,W
0218 1C03  1084 	BTFSS 0x03,Carry
0219 2A20  1085 	GOTO  m028
021A 1D03  1086 	BTFSS 0x03,Zero_
021B 2A2C  1087 	GOTO  m029
021C 0836  1088 	MOVF  end,W
021D 0234  1089 	SUBWF array_4,W
021E 1803  1090 	BTFSC 0x03,Carry
021F 2A2C  1091 	GOTO  m029
           1092 			;	{
           1093 			;		spi_send(*array);
0220 0020  1094 m028	MOVLB 0
0221 0835  1095 	MOVF  array_4+1,W
0222 0085  1096 	MOVWF FSR0H
0223 0834  1097 	MOVF  array_4,W
0224 0084  1098 	MOVWF FSR0L
0225 0800  1099 	MOVF  INDF0,W
0226 21F0  1100 	CALL  spi_send
           1101 			;	}
0227 0020  1102 	MOVLB 0
0228 0AB4  1103 	INCF  array_4,1
0229 1903  1104 	BTFSC 0x03,Zero_
022A 0AB5  1105 	INCF  array_4+1,1
022B 2A15  1106 	GOTO  m027
           1107 			;}
022C 0008  1108 m029	RETURN
           1109 
           1110   ; FILE usart.c
           1111 			;// Include-Datei für Serielle Kommunikation über Hardwaremodul des Pic
           1112 			; //
           1113 			; //
           1114 			; // Nils Weiß
           1115 			; // 29.11.2010
           1116 			; // Compiler CC5x
           1117 			;
           1118 			;#ifndef X86
           1119 			;//*******  Initialisierungs-Funktion  *************************************************
           1120 			;void USARTinit()
           1121 			;{
           1122 USARTinit
           1123 			;	//USART TX Pin als Ausgang
           1124 			;	TRISC.6 = 0;
022D 0021  1125 	MOVLB 1
022E 130E  1126 	BCF   TRISC,6
           1127 			;
           1128 			;    BRGH=1;					// High Baudrate activated
022F 0023  1129 	MOVLB 3
0230 151E  1130 	BSF   0x19E,BRGH
           1131 			;	BRG16=0;
0231 119F  1132 	BCF   0x19F,BRG16
           1133 			;	SPBRGL=25;				// 19200 Bps @ 8 MHz Clock
0232 3019  1134 	MOVLW 25
0233 009B  1135 	MOVWF SPBRGL
           1136 			;	SPBRGH=0;
0234 019C  1137 	CLRF  SPBRGH
           1138 			;    SPEN = 1;               // Set_Serial_Pins;
0235 179D  1139 	BSF   0x19D,SPEN
           1140 			;    SYNC = 0;               // Set_Async_Mode;
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 20

ADDR CODE  LINE SOURCE

0236 121E  1141 	BCF   0x19E,SYNC
           1142 			;    TX9 = 0;                // Set_8bit_Tx;
0237 131E  1143 	BCF   0x19E,TX9
           1144 			;    RX9 = 0;                // Set_8bit_Rx;
0238 131D  1145 	BCF   0x19D,RX9
           1146 			;    CREN = 1;               // Enable_Rx;
0239 161D  1147 	BSF   0x19D,CREN
           1148 			;    TXEN = 1;               // Enable_Tx;
023A 169E  1149 	BSF   0x19E,TXEN
           1150 			;    RCIE=1;                 // Rx Interrupt aus
023B 0021  1151 	MOVLB 1
023C 1691  1152 	BSF   0x91,RCIE
           1153 			;	ADDEN=0;				// Disable Adressdetection
023D 0023  1154 	MOVLB 3
023E 119D  1155 	BCF   0x19D,ADDEN
           1156 			;}
023F 0008  1157 	RETURN
           1158 			;
           1159 			;//*******  Sende-char-Funktion  *************************************************
           1160 			;void USARTsend(unsigned char ch)
           1161 			;{
           1162 USARTsend
0240 0020  1163 	MOVLB 0
0241 00A5  1164 	MOVWF ch
           1165 			;	while(!TXIF);
0242 0020  1166 m030	MOVLB 0
0243 1E11  1167 	BTFSS 0x11,TXIF
0244 2A42  1168 	GOTO  m030
           1169 			;	TXREG=ch;
0245 0020  1170 	MOVLB 0
0246 0825  1171 	MOVF  ch,W
0247 0023  1172 	MOVLB 3
0248 009A  1173 	MOVWF TXREG
           1174 			;}
0249 0008  1175 	RETURN
           1176 			;#endif /* #ifndef X86 */
           1177 			;
           1178 			;//*******  Sende-String-Funktion  *************************************************
           1179 			;void USARTsend_str(const char *string)
           1180 			;{
           1181 USARTsend_str
           1182 			; char ps;
           1183 			; ps = *string;
024A 0020  1184 	MOVLB 0
024B 0822  1185 	MOVF  string,W
024C 2012  1186 	CALL  _const1
024D 0020  1187 	MOVLB 0
024E 00A3  1188 	MOVWF ps
           1189 			; while(ps > 0)
024F 0020  1190 m031	MOVLB 0
0250 08A3  1191 	MOVF  ps,1
0251 1903  1192 	BTFSC 0x03,Zero_
0252 2A5C  1193 	GOTO  m032
           1194 			;   {
           1195 			;    string++;
0253 0AA2  1196 	INCF  string,1
           1197 			;   	USARTsend(ps);
0254 0823  1198 	MOVF  ps,W
0255 2240  1199 	CALL  USARTsend
           1200 			;    ps = *string;
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 21

ADDR CODE  LINE SOURCE

0256 0020  1201 	MOVLB 0
0257 0822  1202 	MOVF  string,W
0258 2012  1203 	CALL  _const1
0259 0020  1204 	MOVLB 0
025A 00A3  1205 	MOVWF ps
           1206 			;   }
025B 2A4F  1207 	GOTO  m031
           1208 			;}
025C 0008  1209 m032	RETURN
           1210 			;
           1211 			;//*******  Sende-Array-Funktion  *************************************************
           1212 			;void USARTsend_arr(char *array, char length)
           1213 			;{
           1214 USARTsend_arr
025D 00FF  1215 	MOVWF length_5
           1216 			;	if(array == 0) return;
025E 08FF  1217 	MOVF  array_5,1
025F 1903  1218 	BTFSC 0x03,Zero_
0260 0008  1219 	RETURN
           1220 			;	char i;
           1221 			;	for(i=0;i<length;i++)
0261 01FF  1222 	CLRF  i_5
0262 087F  1223 m033	MOVF  length_5,W
0263 027F  1224 	SUBWF i_5,W
0264 1803  1225 	BTFSC 0x03,Carry
0265 2A6E  1226 	GOTO  m034
           1227 			;	{
           1228 			;		USARTsend(*array);
0266 0185  1229 	CLRF  FSR0H
0267 087F  1230 	MOVF  array_5,W
0268 0084  1231 	MOVWF FSR0L
0269 0800  1232 	MOVF  INDF0,W
026A 2240  1233 	CALL  USARTsend
           1234 			;		array++;
026B 0AFF  1235 	INCF  array_5,1
           1236 			;	}
026C 0AFF  1237 	INCF  i_5,1
026D 2A62  1238 	GOTO  m033
           1239 			;}
026E 0008  1240 m034	RETURN
           1241 
           1242   ; FILE commandstorage.c
           1243 			;/** Changelog
           1244 			; * 2012-05-08 pb:
           1245 			; * - refactor functions to access and manage a buffer for led commands, which is stored in the eeprom
           1246 			;**/
           1247 			;
           1248 			;#include "platform.h"
           1249 			;#include "commandstorage.h"
           1250 			;
           1251 			;struct led_cmd* commandstorage_read(struct led_cmd *pDest, bit movePtr)
           1252 			;{
           1253 commandstorage_read
           1254 			;	//check parameter
           1255 			;	if(0 == pDest) return 0;
026F 0020  1256 	MOVLB 0
0270 08AD  1257 	MOVF  pDest,1
0271 1903  1258 	BTFSC 0x03,Zero_
0272 3400  1259 	RETLW 0
           1260 			;
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 22

ADDR CODE  LINE SOURCE

           1261 			;	//commands available in eeprom?
           1262 			;	char nextCmd = EEPROM_RD(CmdPointerAddr);
0273 30FF  1263 	MOVLW 255
0274 20FF  1264 	CALL  EEPROM_RD
0275 0020  1265 	MOVLB 0
0276 00AE  1266 	MOVWF nextCmd
           1267 			;	if(0 == nextCmd) return 0;
0277 08AE  1268 	MOVF  nextCmd,1
0278 1903  1269 	BTFSC 0x03,Zero_
0279 3400  1270 	RETLW 0
           1271 			;
           1272 			;	//read command from eeprom
           1273 			;	EEPROM_RD_BLK((char*)pDest, (nextCmd - CmdWidth), CmdWidth);
027A 0020  1274 	MOVLB 0
027B 082D  1275 	MOVF  pDest,W
027C 00B0  1276 	MOVWF array_2
027D 300A  1277 	MOVLW 10
027E 022E  1278 	SUBWF nextCmd,W
027F 00B1  1279 	MOVWF adress_4
0280 300A  1280 	MOVLW 10
0281 2125  1281 	CALL  EEPROM_RD_BLK
           1282 			;
           1283 			;	//do we have to update the CmdPointer?
           1284 			;	if(movePtr)
0282 0020  1285 	MOVLB 0
0283 1C2F  1286 	BTFSS 0x2F,movePtr
0284 2A8A  1287 	GOTO  m035
           1288 			;	{		
           1289 			;		EEPROM_WR(CmdPointerAddr, nextCmd - CmdWidth);
0285 30FF  1290 	MOVLW 255
0286 00B0  1291 	MOVWF adress
0287 300A  1292 	MOVLW 10
0288 022E  1293 	SUBWF nextCmd,W
0289 20DD  1294 	CALL  EEPROM_WR
           1295 			;	}
           1296 			;	return pDest;
028A 0020  1297 m035	MOVLB 0
028B 082D  1298 	MOVF  pDest,W
028C 0008  1299 	RETURN
           1300 			;}
           1301 			;
           1302 			;bit commandstorage_write(char *pSrc, char length)
           1303 			;{
           1304 commandstorage_write
028D 0020  1305 	MOVLB 0
028E 00A6  1306 	MOVWF length_6
           1307 			;	//check parameter
           1308 			;	if(0 == pSrc) return FALSE;
028F 08A5  1309 	MOVF  pSrc,1
0290 1D03  1310 	BTFSS 0x03,Zero_
0291 2A94  1311 	GOTO  m036
0292 1003  1312 	BCF   0x03,Carry
0293 0008  1313 	RETURN
           1314 			;	
           1315 			;	//enought free space in eeprom?
           1316 			;	char nextCmd = EEPROM_RD(CmdPointerAddr);
0294 30FF  1317 m036	MOVLW 255
0295 20FF  1318 	CALL  EEPROM_RD
0296 0020  1319 	MOVLB 0
0297 00A7  1320 	MOVWF nextCmd_2
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 23

ADDR CODE  LINE SOURCE

           1321 			;	if(nextCmd >= (CmdPointerAddr - CmdWidth)) return FALSE;
0298 30F5  1322 	MOVLW 245
0299 0227  1323 	SUBWF nextCmd_2,W
029A 1C03  1324 	BTFSS 0x03,Carry
029B 2A9E  1325 	GOTO  m037
029C 1003  1326 	BCF   0x03,Carry
029D 0008  1327 	RETURN
           1328 			;
           1329 			;	//increase the command pointer in eeprom
           1330 			;	EEPROM_WR(CmdPointerAddr,(nextCmd + CmdWidth));
029E 30FF  1331 m037	MOVLW 255
029F 0020  1332 	MOVLB 0
02A0 00B0  1333 	MOVWF adress
02A1 300A  1334 	MOVLW 10
02A2 0727  1335 	ADDWF nextCmd_2,W
02A3 20DD  1336 	CALL  EEPROM_WR
           1337 			;		
           1338 			;	//write data to eeprom
           1339 			;	EEPROM_WR_BLK(pSrc, nextCmd, length);
02A4 0020  1340 	MOVLB 0
02A5 0825  1341 	MOVF  pSrc,W
02A6 00A8  1342 	MOVWF array
02A7 0827  1343 	MOVF  nextCmd_2,W
02A8 00A9  1344 	MOVWF adress_3
02A9 0826  1345 	MOVF  length_6,W
02AA 210C  1346 	CALL  EEPROM_WR_BLK
           1347 			;		
           1348 			;	return TRUE;
02AB 1403  1349 	BSF   0x03,Carry
02AC 0008  1350 	RETURN
           1351 			;}
           1352 			;
           1353 			;void commandstorage_get_commands()
           1354 			;{	
           1355 commandstorage_get_commands
           1356 			;	if(RingBufHasError)
02AD 0020  1357 	MOVLB 0
02AE 1C4B  1358 	BTFSS gRingBuf+18,0
02AF 2AB2  1359 	GOTO  m038
           1360 			;	{
           1361 			;		// *** if a RingBufError occure, I have to throw away the current command,
           1362 			;		// *** because the last byte was not saved. Commandstring is inconsistent
           1363 			;		ClearCmdBuf();
02B0 01CD  1364 	CLRF  gCmdBuf
02B1 01CE  1365 	CLRF  gCmdBuf+1
           1366 			;	}
           1367 			;
           1368 			;	if(RingBufIsNotEmpty)
02B2 0020  1369 m038	MOVLB 0
02B3 084A  1370 	MOVF  gRingBuf+17,W
02B4 0649  1371 	XORWF gRingBuf+16,W
02B5 1903  1372 	BTFSC 0x03,Zero_
02B6 2B29  1373 	GOTO  m047
           1374 			;	{
           1375 			;		// *** preload variables and 
           1376 			;		// *** get new_byte from ringbuffer
           1377 			;		char new_byte, temp, j;
           1378 			;		temp = 0;
02B7 01A3  1379 	CLRF  temp_3
           1380 			;		j = 0;
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 24

ADDR CODE  LINE SOURCE

02B8 01A4  1381 	CLRF  j
           1382 			;		// *** get new byte
           1383 			;		new_byte = RingBufGet();	
02B9 21C4  1384 	CALL  RingBufGet
02BA 0020  1385 	MOVLB 0
02BB 00A2  1386 	MOVWF new_byte
           1387 			;		// *** do I wait for databytes?
           1388 			;		if(gCmdBuf.frame_counter == 0)
02BC 08CE  1389 	MOVF  gCmdBuf+1,1
02BD 1D03  1390 	BTFSS 0x03,Zero_
02BE 2AEA  1391 	GOTO  m040
           1392 			;		{
           1393 			;			// *** I don't wait for databytes
           1394 			;			// *** Do I receive a Start_of_Text sign
           1395 			;			if(new_byte == STX)
02BF 0F22  1396 	INCFSZ new_byte,W
02C0 2AD3  1397 	GOTO  m039
           1398 			;			{
           1399 			;				// *** increse the cmd_counter
           1400 			;				gCmdBuf.cmd_counter = 1;
02C1 3001  1401 	MOVLW 1
02C2 00CD  1402 	MOVWF gCmdBuf
           1403 			;				// *** Write the startsign at the begin of the buffer
           1404 			;				gCmdBuf.cmd_buf[0] = new_byte;
02C3 0822  1405 	MOVF  new_byte,W
02C4 00CF  1406 	MOVWF gCmdBuf+2
           1407 			;                // *** Reset crc Variables
           1408 			;                newCRC(&gCmdBuf.crcH, &gCmdBuf.crcL);
02C5 305E  1409 	MOVLW 94
02C6 00A5  1410 	MOVWF p_crcH_2
02C7 305F  1411 	MOVLW 95
02C8 00A6  1412 	MOVWF p_crcL_2
02C9 20C9  1413 	CALL  newCRC
           1414 			;                // *** add new_byte to crc checksum
           1415 			;                addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
02CA 0020  1416 	MOVLB 0
02CB 0822  1417 	MOVF  new_byte,W
02CC 00A5  1418 	MOVWF byte
02CD 305E  1419 	MOVLW 94
02CE 00A6  1420 	MOVWF p_crcH
02CF 305F  1421 	MOVLW 95
02D0 00A7  1422 	MOVWF p_crcL
02D1 2074  1423 	CALL  addCRC
           1424 			;			}
           1425 			;			else
02D2 2B29  1426 	GOTO  m047
           1427 			;			{	
           1428 			;				// *** to avoid arrayoverflow
           1429 			;				temp = FRAMELENGTH - 2;
02D3 300D  1430 m039	MOVLW 13
02D4 0020  1431 	MOVLB 0
02D5 00A3  1432 	MOVWF temp_3
           1433 			;				// *** check if I get the framelength byte
           1434 			;				if((new_byte < temp) && (gCmdBuf.cmd_counter == 1))
02D6 0823  1435 	MOVF  temp_3,W
02D7 0222  1436 	SUBWF new_byte,W
02D8 1803  1437 	BTFSC 0x03,Carry
02D9 2B29  1438 	GOTO  m047
02DA 0B4D  1439 	DECFSZ gCmdBuf,W
02DB 2B29  1440 	GOTO  m047
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 25

ADDR CODE  LINE SOURCE

           1441 			;				{
           1442 			;					gCmdBuf.frame_counter = new_byte;
02DC 0822  1443 	MOVF  new_byte,W
02DD 00CE  1444 	MOVWF gCmdBuf+1
           1445 			;					gCmdBuf.cmd_buf[1] = new_byte;
02DE 0822  1446 	MOVF  new_byte,W
02DF 00D0  1447 	MOVWF gCmdBuf+3
           1448 			;					gCmdBuf.cmd_counter = 2;
02E0 3002  1449 	MOVLW 2
02E1 00CD  1450 	MOVWF gCmdBuf
           1451 			;                    // *** add new_byte to crc checksum
           1452 			;                    addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
02E2 0822  1453 	MOVF  new_byte,W
02E3 00A5  1454 	MOVWF byte
02E4 305E  1455 	MOVLW 94
02E5 00A6  1456 	MOVWF p_crcH
02E6 305F  1457 	MOVLW 95
02E7 00A7  1458 	MOVWF p_crcL
02E8 2074  1459 	CALL  addCRC
           1460 			;				}
           1461 			;			}
           1462 			;		}
           1463 			;		else
02E9 2B29  1464 	GOTO  m047
           1465 			;		{
           1466 			;			// *** I wait for Databytes, so I save all bytes 
           1467 			;			// *** that I get until my framecounter is > 0
           1468 			;			gCmdBuf.cmd_buf[gCmdBuf.cmd_counter] = new_byte;
02EA 304F  1469 m040	MOVLW 79
02EB 0020  1470 	MOVLB 0
02EC 074D  1471 	ADDWF gCmdBuf,W
02ED 0084  1472 	MOVWF FSR0L
02EE 0185  1473 	CLRF  FSR0H
02EF 0822  1474 	MOVF  new_byte,W
02F0 0080  1475 	MOVWF INDF0
           1476 			;			gCmdBuf.cmd_counter++;
02F1 0ACD  1477 	INCF  gCmdBuf,1
           1478 			;			
           1479 			;            // *** add new_byte to crc checksum
           1480 			;			if(gCmdBuf.frame_counter > 2)
02F2 3003  1481 	MOVLW 3
02F3 024E  1482 	SUBWF gCmdBuf+1,W
02F4 1C03  1483 	BTFSS 0x03,Carry
02F5 2AFD  1484 	GOTO  m041
           1485 			;            addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
02F6 0822  1486 	MOVF  new_byte,W
02F7 00A5  1487 	MOVWF byte
02F8 305E  1488 	MOVLW 94
02F9 00A6  1489 	MOVWF p_crcH
02FA 305F  1490 	MOVLW 95
02FB 00A7  1491 	MOVWF p_crcL
02FC 2074  1492 	CALL  addCRC
           1493 			;			gCmdBuf.frame_counter--;
02FD 0020  1494 m041	MOVLB 0
02FE 0BCE  1495 	DECFSZ gCmdBuf+1,1
           1496 			;			// *** now I have to check if my framecounter is null.
           1497 			;			// *** If it's null my string is complete 
           1498 			;			// *** and I can give the string to the crc check function.
           1499 			;			if(gCmdBuf.frame_counter == 0)
02FF 2B29  1500 	GOTO  m047
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 26

ADDR CODE  LINE SOURCE

           1501 			;			{
           1502 			;#ifdef NO_CRC
           1503 			;				if(1==1)
           1504 			;#else
           1505 			;                // *** verify crc checksum
           1506 			;                if( (gCmdBuf.crcL == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 1]) &&
           1507 			;                    (gCmdBuf.crcH == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 2]) )
           1508 			;#endif
           1509 			;                {
           1510 			;					// *** Execute the simple Commands
           1511 			;					switch(gCmdBuf.cmd_buf[2])
0300 0851  1512 	MOVF  gCmdBuf+4,W
0301 3AF8  1513 	XORLW 248
0302 1903  1514 	BTFSC 0x03,Zero_
0303 2B0B  1515 	GOTO  m042
0304 3A02  1516 	XORLW 2
0305 1903  1517 	BTFSC 0x03,Zero_
0306 2B10  1518 	GOTO  m043
0307 3A03  1519 	XORLW 3
0308 1903  1520 	BTFSC 0x03,Zero_
0309 2B13  1521 	GOTO  m044
030A 2B16  1522 	GOTO  m045
           1523 			;					{
           1524 			;						case DELETE: 
           1525 			;							{
           1526 			;								EEPROM_WR(CmdPointerAddr,0);
030B 30FF  1527 m042	MOVLW 255
030C 0020  1528 	MOVLB 0
030D 00B0  1529 	MOVWF adress
030E 3000  1530 	MOVLW 0
030F 28DD  1531 	GOTO  EEPROM_WR
           1532 			;								return;
           1533 			;							}
           1534 			;#ifndef X86
           1535 			;						case SET_ON: 
           1536 			;							{
           1537 			;								PowerOnLEDs();
0310 0020  1538 m043	MOVLB 0
0311 100E  1539 	BCF   PORTC,0
           1540 			;								return;
0312 0008  1541 	RETURN
           1542 			;								}
           1543 			;						case SET_OFF: 
           1544 			;							{
           1545 			;								PowerOffLEDs();
0313 0020  1546 m044	MOVLB 0
0314 140E  1547 	BSF   PORTC,0
           1548 			;								return;
0315 0008  1549 	RETURN
           1550 			;							}
           1551 			;#endif /* #ifndef X86 */
           1552 			;					}			
           1553 			;					if( commandstorage_write(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4)))
0316 3051  1554 m045	MOVLW 81
0317 0020  1555 	MOVLB 0
0318 00A5  1556 	MOVWF pSrc
0319 3004  1557 	MOVLW 4
031A 024D  1558 	SUBWF gCmdBuf,W
031B 228D  1559 	CALL  commandstorage_write
031C 1C03  1560 	BTFSS 0x03,Carry
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 27

ADDR CODE  LINE SOURCE

031D 2B23  1561 	GOTO  m046
           1562 			;					{
           1563 			;						USARTsend('G');
031E 3047  1564 	MOVLW 71
031F 2240  1565 	CALL  USARTsend
           1566 			;						USARTsend('C');
0320 3043  1567 	MOVLW 67
0321 2240  1568 	CALL  USARTsend
           1569 			;					}
           1570 			;					else 
0322 2B29  1571 	GOTO  m047
           1572 			;						gERROR.eeprom_failure = 1;
0323 0020  1573 m046	MOVLB 0
0324 14CC  1574 	BSF   gERROR,1
           1575 			;#ifdef TEST
           1576 			;					USARTsend_arr(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4));
           1577 			;#endif
           1578 			;                }
           1579 			;                else
0325 2B29  1580 	GOTO  m047
           1581 			;                {
           1582 			;                    // *** Do some error handling in case of an CRC failure here
           1583 			;					gERROR.crc_failure = 1;
0326 0020  1584 	MOVLB 0
0327 144C  1585 	BSF   gERROR,0
           1586 			;                    return;
0328 0008  1587 	RETURN
           1588 			;                }
           1589 			;			}
           1590 			;		}
           1591 			;	}
           1592 			;}
0329 0008  1593 m047	RETURN
           1594 			;
           1595 			;void commandstorage_execute_commands()
           1596 			;{
           1597 commandstorage_execute_commands
           1598 			;	// *** get the pointer to commands in the EEPROM
           1599 			;	struct led_cmd nextCmd;
           1600 			;
           1601 			;	// read next command from eeprom and move command pointer in eeprom to the next command (TRUE)
           1602 			;	struct led_cmd *result = commandstorage_read(&nextCmd, TRUE);
032A 3022  1603 	MOVLW 34
032B 0020  1604 	MOVLB 0
032C 00AD  1605 	MOVWF pDest
032D 142F  1606 	BSF   0x2F,movePtr
032E 226F  1607 	CALL  commandstorage_read
032F 0020  1608 	MOVLB 0
0330 00AC  1609 	MOVWF result_2
           1610 			;	if(0 != result)
0331 08AC  1611 	MOVF  result_2,1
0332 1903  1612 	BTFSC 0x03,Zero_
0333 2B43  1613 	GOTO  m049
           1614 			;	{
           1615 			;		// *** commands available, check what to do
           1616 			;		switch(nextCmd.cmd) 
0334 0822  1617 	MOVF  nextCmd_3,W
0335 3AFD  1618 	XORLW 253
0336 1903  1619 	BTFSC 0x03,Zero_
0337 2B3F  1620 	GOTO  m048
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 28

ADDR CODE  LINE SOURCE

0338 3A01  1621 	XORLW 1
0339 1903  1622 	BTFSC 0x03,Zero_
033A 2B43  1623 	GOTO  m049
033B 3A07  1624 	XORLW 7
033C 1903  1625 	BTFSC 0x03,Zero_
033D 2B43  1626 	GOTO  m049
033E 2B43  1627 	GOTO  m049
           1628 			;		{	
           1629 			;			case SET_COLOR: 
           1630 			;			{
           1631 			;				ledstrip_set_color(&nextCmd.data.set_color);
033F 3023  1632 m048	MOVLW 35
0340 0020  1633 	MOVLB 0
0341 00AD  1634 	MOVWF pCmd
0342 216A  1635 	CALL  ledstrip_set_color
           1636 			;				break;
           1637 			;			}
           1638 			;			case SET_FADE: {break;}
           1639 			;			case SET_RUN: {break;}
           1640 			;		}
           1641 			;	}
           1642 			;}
0343 0008  1643 m049	RETURN
           1644 			;
           1645 			;void commandstorage_init()
           1646 			;{
           1647 commandstorage_init
           1648 			;	/** EEPROM contains FF in every cell after inital start,
           1649 			;	*** so I have to delete the pointer address
           1650 			;	*** otherwise the PIC thinks he has the EEPROM full with commands
           1651 			;	**/
           1652 			;	if (EEPROM_RD(CmdPointerAddr) == 0xff)
0344 30FF  1653 	MOVLW 255
0345 20FF  1654 	CALL  EEPROM_RD
0346 3AFF  1655 	XORLW 255
0347 1D03  1656 	BTFSS 0x03,Zero_
0348 2B4E  1657 	GOTO  m050
           1658 			;		EEPROM_WR(CmdPointerAddr, 0);
0349 30FF  1659 	MOVLW 255
034A 0020  1660 	MOVLB 0
034B 00B0  1661 	MOVWF adress
034C 3000  1662 	MOVLW 0
034D 20DD  1663 	CALL  EEPROM_WR
           1664 			;
           1665 			;	// set loop pointer address to start
           1666 			;	EEPROM_WR(CmdLoopPointerAddr, 0);
034E 30FD  1667 m050	MOVLW 253
034F 0020  1668 	MOVLB 0
0350 00B0  1669 	MOVWF adress
0351 3000  1670 	MOVLW 0
0352 28DD  1671 	GOTO  EEPROM_WR
           1672 			;}
           1673 
           1674 	END
           1675 
           1676 
           1677 ; *** KEY INFO ***
           1678 
           1679 ; 0x01BF P0    5 word(s)  0 % : RingBufInit
           1680 ; 0x01C4 P0   12 word(s)  0 % : RingBufGet
CC5X Version 3.4H,   File: main.c              17. May 2012  10:30   Page 29

ADDR CODE  LINE SOURCE

           1681 ; 0x01D0 P0   21 word(s)  1 % : RingBufPut
           1682 ; 0x022D P0   19 word(s)  0 % : USARTinit
           1683 ; 0x0240 P0   10 word(s)  0 % : USARTsend
           1684 ; 0x024A P0   19 word(s)  0 % : USARTsend_str
           1685 ; 0x025D P0   18 word(s)  0 % : USARTsend_arr
           1686 ; 0x00DD P0   34 word(s)  1 % : EEPROM_WR
           1687 ; 0x00FF P0   13 word(s)  0 % : EEPROM_RD
           1688 ; 0x010C P0   25 word(s)  1 % : EEPROM_WR_BLK
           1689 ; 0x0125 P0   26 word(s)  1 % : EEPROM_RD_BLK
           1690 ; 0x0074 P0   40 word(s)  1 % : addCRC
           1691 ; 0x009C P0   45 word(s)  2 % : CRC
           1692 ; 0x00C9 P0   20 word(s)  0 % : newCRC
           1693 ; 0x013F P0   25 word(s)  1 % : throw_errors
           1694 ; 0x026F P0   30 word(s)  1 % : commandstorage_read
           1695 ; 0x028D P0   32 word(s)  1 % : commandstorage_write
           1696 ; 0x02AD P0  125 word(s)  6 % : commandstorage_get_commands
           1697 ; 0x032A P0   26 word(s)  1 % : commandstorage_execute_commands
           1698 ; 0x0344 P0   15 word(s)  0 % : commandstorage_init
           1699 ; 0x01E5 P0   11 word(s)  0 % : spi_init
           1700 ; 0x01F0 P0   11 word(s)  0 % : spi_send
           1701 ; 0x01FB P0   18 word(s)  0 % : spi_send_arr
           1702 ; 0x020D P0   32 word(s)  1 % : spi_send_ledbuf
           1703 ; 0x0158 P0   18 word(s)  0 % : ledstrip_init
           1704 ; 0x016A P0   85 word(s)  4 % : ledstrip_set_color
           1705 ; 0x0004 P0   14 word(s)  0 % : InterruptRoutine
           1706 ; 0x005A P0   26 word(s)  1 % : init_all
           1707 ; 0x0055 P0    5 word(s)  0 % : main
           1708 ; 0x0012 P0   67 word(s)  3 % : _const1
           1709 
           1710 ; RAM usage: 160 bytes (25 local), 352 bytes free
           1711 ; Maximum call level: 4 (+2 for interrupt)
           1712 ;  Codepage 0 has  848 word(s) :  41 %
           1713 ;  Codepage 1 has    0 word(s) :   0 %
           1714 ;  Codepage 2 has    0 word(s) :   0 %
           1715 ;  Codepage 3 has    0 word(s) :   0 %
           1716 ; Total of 848 code words (10 %)
