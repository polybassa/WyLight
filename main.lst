CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 1

ADDR CODE  LINE SOURCE

           0001 
           0002 ; CC5X Version 3.4E, Copyright (c) B Knudsen Data
           0003 ; C compiler for the PICmicro family
           0004 ; ************  11. May 2012  20:18  *************
           0005 
           0006 	processor  16F1936
           0007 	radix  DEC
           0008 
     0000  0009 INDF0       EQU   0x00
     0004  0010 FSR0        EQU   0x04
     0004  0011 FSR0L       EQU   0x04
     0005  0012 FSR0H       EQU   0x05
     0000  0013 Carry       EQU   0
     0002  0014 Zero_       EQU   2
     000E  0015 PORTC       EQU   0x0E
     008E  0016 TRISC       EQU   0x8E
     0099  0017 OSCCON      EQU   0x99
     0191  0018 EEADRL      EQU   0x191
     0192  0019 EEADRH      EQU   0x192
     0193  0020 EEDATL      EQU   0x193
     0194  0021 EEDATH      EQU   0x194
     0196  0022 EECON2      EQU   0x196
     0199  0023 RCREG       EQU   0x199
     019A  0024 TXREG       EQU   0x19A
     019B  0025 SPBRGL      EQU   0x19B
     019C  0026 SPBRGH      EQU   0x19C
     0211  0027 SSPBUF      EQU   0x211
     0006  0028 PEIE        EQU   6
     0007  0029 GIE         EQU   7
     0003  0030 SSPIF       EQU   3
     0004  0031 TXIF        EQU   4
     0005  0032 RCIF        EQU   5
     0005  0033 RCIE        EQU   5
     0000  0034 RD          EQU   0
     0001  0035 WR          EQU   1
     0002  0036 WREN        EQU   2
     0006  0037 CFGS        EQU   6
     0007  0038 EEPGD       EQU   7
     0003  0039 ADDEN       EQU   3
     0004  0040 CREN        EQU   4
     0006  0041 RX9         EQU   6
     0007  0042 SPEN        EQU   7
     0002  0043 BRGH        EQU   2
     0004  0044 SYNC        EQU   4
     0005  0045 TXEN        EQU   5
     0006  0046 TX9         EQU   6
     0003  0047 BRG16       EQU   3
     0006  0048 CKE         EQU   6
     0007  0049 SMP         EQU   7
     0001  0050 SSPM1       EQU   1
     0004  0051 CKP         EQU   4
     0005  0052 SSPEN       EQU   5
     0039  0053 gRingBuf    EQU   0x39
     004C  0054 gCmdBuf     EQU   0x4C
     0060  0055 gERROR      EQU   0x60
     0061  0056 gComState   EQU   0x61
     0020  0057 temp        EQU   0x20
     0022  0058 i           EQU   0x22
     0022  0059 new_byte    EQU   0x22
     0023  0060 temp_2      EQU   0x23
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 2

ADDR CODE  LINE SOURCE

     0024  0061 j           EQU   0x24
     0025  0062 CmdPointer  EQU   0x25
     0022  0063 pointer     EQU   0x22
     0025  0064 byte        EQU   0x25
     0026  0065 p_crcH      EQU   0x26
     0027  0066 p_crcL      EQU   0x27
     0028  0067 index       EQU   0x28
     0029  0068 crcH        EQU   0x29
     002A  0069 crcL        EQU   0x2A
     007F  0070 data        EQU   0x7F
     007F  0071 length      EQU   0x7F
     007F  0072 crcH_out    EQU   0x7F
     007F  0073 crcL_out    EQU   0x7F
     007F  0074 crcH_2      EQU   0x7F
     007F  0075 crcL_2      EQU   0x7F
     007F  0076 i_2         EQU   0x7F
     007F  0077 byte_2      EQU   0x7F
     0025  0078 p_crcH_2    EQU   0x25
     0026  0079 p_crcL_2    EQU   0x26
     002A  0080 adress      EQU   0x2A
     002B  0081 data_2      EQU   0x2B
     0000  0082 GIE_status  EQU   0
     002E  0083 adress_2    EQU   0x2E
     002F  0084 data_3      EQU   0x2F
     0026  0085 array       EQU   0x26
     0027  0086 adress_3    EQU   0x27
     0028  0087 length_2    EQU   0x28
     0029  0088 i_3         EQU   0x29
     007F  0089 array_2     EQU   0x7F
     007F  0090 adress_4    EQU   0x7F
     007F  0091 length_3    EQU   0x7F
     007F  0092 i_4         EQU   0x7F
     007F  0093 temp_3      EQU   0x7F
     0023  0094 k           EQU   0x23
     002E  0095 address     EQU   0x2E
     002F  0096 r           EQU   0x2F
     0030  0097 g           EQU   0x30
     0031  0098 b           EQU   0x31
     0032  0099 k_2         EQU   0x32
     0033  0100 mask        EQU   0x33
     0023  0101 cmdPointer  EQU   0x23
     0024  0102 r_2         EQU   0x24
     0025  0103 g_2         EQU   0x25
     0026  0104 b_2         EQU   0x26
     0027  0105 i_5         EQU   0x27
     0028  0106 temp_4      EQU   0x28
     0029  0107 temp1       EQU   0x29
     0025  0108 result      EQU   0x25
     0020  0109 value       EQU   0x20
     0021  0110 writeNext   EQU   0x21
     0038  0111 data_4      EQU   0x38
     007F  0112 array_3     EQU   0x7F
     007F  0113 length_4    EQU   0x7F
     007F  0114 i_6         EQU   0x7F
     0034  0115 array_4     EQU   0x34
     0036  0116 end         EQU   0x36
     0026  0117 ch          EQU   0x26
     0022  0118 string      EQU   0x22
     0023  0119 ps          EQU   0x23
     007F  0120 array_5     EQU   0x7F
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 3

ADDR CODE  LINE SOURCE

     007F  0121 length_5    EQU   0x7F
     007F  0122 i_7         EQU   0x7F
     0024  0123 ci          EQU   0x24
           0124 
0000 2855  0125 	GOTO main
           0126 
           0127   ; FILE main.c
           0128 			;//Nils Weiß 
           0129 			;//05.09.2011
           0130 			;//Compiler CC5x/
           0131 			;#define OLD_ROUTINE
           0132 			;//#define TEST
           0133 			;#define NO_CRC
           0134 			;#define MPLAB_IDE
           0135 			;
           0136 			;#include "platform.h"
           0137 			;#pragma sharedAllocation
           0138 			;
           0139 			;//*********************** ENUMERATIONS *********************************************
           0140 			;#define TRUE  1
           0141 			;#define FALSE 0
           0142 			;
           0143 			;#define STX 0xFF
           0144 			;#define SET_COLOR 0xFD
           0145 			;#define SET_FADE 0xFC
           0146 			;#define SET_RUN 0xFB
           0147 			;#define WAIT 0xFE
           0148 			;#define SET_ON 0xFA
           0149 			;#define SET_OFF 0xF9
           0150 			;#define DELETE 0xF8
           0151 			;
           0152 			;#define CmdPointerAddr 0xff		// *** Address at EERPOM. Commandpointer indicates the nummer of commands
           0153 			;#define CmdLoopPointerAddr 0xfd // *** Address at EEPROM. CommandLoopPointer indicates the next command. Used in Loop-Mode
           0154 			;
           0155 			;//*********************** INCLUDEDATEIEN *********************************************
           0156 			;#pragma codepage 1
     0000  0157 	ORG 0x0800
           0158 
           0159   ; FILE main.c
           0160 			;#include "RingBuf.h"		//clean
           0161 			;#include "usart.h"			//clean
           0162 			;#include "eeprom.h"       	//clean 
           0163 			;#include "crc.h"			//clean
           0164 			;#include "ledstrip.h"		//under construction
           0165 			;#include "spi.h"			//clean
           0166 			;#include "timer.h"
           0167 			;//*********************** GLOBAL VARIABLES *******************************************
           0168 			;#define FRAMELENGTH 16			// *** max length of one commandframe
           0169 			;struct CommandBuffer{
           0170 			;    char cmd_counter;
           0171 			;    char frame_counter;
           0172 			;    char cmd_buf[FRAMELENGTH];
           0173 			;    char crcH;
           0174 			;    char crcL;
           0175 			;};
           0176 			;static struct CommandBuffer gCmdBuf;
           0177 			;
           0178 			;// *** ERRORBITS
           0179 			;static struct {
           0180 			;		char crc_failure:1;
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 4

ADDR CODE  LINE SOURCE

           0181 			;		char eeprom_failure:1;
           0182 			;}gERROR;
           0183 			;static char gComState;
           0184 			;
           0185 			;#ifndef X86
           0186 			;//*********************** INTERRUPTSERVICEROUTINE ************************************
           0187 			;#pragma origin 4					//Adresse des Interrupts	
     0000  0188 	ORG 0x0004
           0189 			;interrupt InterruptRoutine(void)
           0190 			;{
           0191 InterruptRoutine
           0192 			;	if (RCIF)
0004 0020  0193 	MOVLB 0
0005 1E91  0194 	BTFSS 0x11,RCIF
0006 2811  0195 	GOTO  m002
           0196 			;	{
           0197 			;		if(!RingBufHasError) RingBufPut(RCREG);
0007 184B  0198 	BTFSC gRingBuf+18,0
0008 280D  0199 	GOTO  m001
0009 0023  0200 	MOVLB 3
000A 0819  0201 	MOVF  RCREG,W
000B 22B6  0202 	CALL  RingBufPut
           0203 			;		else 
000C 2811  0204 	GOTO  m002
           0205 			;		{
           0206 			;			//Register lesen um Schnittstellen Fehler zu vermeiden
           0207 			;			char temp = RCREG;
000D 0023  0208 m001	MOVLB 3
000E 0819  0209 	MOVF  RCREG,W
000F 0020  0210 	MOVLB 0
0010 00A0  0211 	MOVWF temp
           0212 			;		}
           0213 			;	}
           0214 			;}
0011 0009  0215 m002	RETFIE
           0216 			;#endif /* #ifndef X86 */
           0217 			;
           0218 			;//*********************** FUNKTIONSPROTOTYPEN ****************************************
           0219 			;void init_all();
           0220 			;void throw_errors();
           0221 			;void get_commands();
           0222 			;void execute_commands();
           0223 			;
           0224 			;//*********************** HAUPTPROGRAMM **********************************************
           0225 			;void main(void)
           0226 			;{
           0227 _const1
0012 0020  0228 	MOVLB 0
0013 00A4  0229 	MOVWF ci
0014 3000  0230 	MOVLW 0
0015 0023  0231 	MOVLB 3
0016 0092  0232 	MOVWF EEADRH
0017 0020  0233 	MOVLB 0
0018 0C24  0234 	RRF   ci,W
0019 397F  0235 	ANDLW 127
001A 3E2F  0236 	ADDLW 47
001B 0023  0237 	MOVLB 3
001C 0091  0238 	MOVWF EEADRL
001D 1803  0239 	BTFSC 0x03,Carry
001E 0A92  0240 	INCF  EEADRH,1
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 5

ADDR CODE  LINE SOURCE

001F 0023  0241 	MOVLB 3
0020 1795  0242 	BSF   0x195,EEPGD
0021 1415  0243 	BSF   0x195,RD
0022 0000  0244 	NOP  
0023 0000  0245 	NOP  
0024 0020  0246 	MOVLB 0
0025 1824  0247 	BTFSC ci,0
0026 282B  0248 	GOTO  m003
0027 0023  0249 	MOVLB 3
0028 0813  0250 	MOVF  EEDATL,W
0029 397F  0251 	ANDLW 127
002A 0008  0252 	RETURN
002B 0023  0253 m003	MOVLB 3
002C 0D13  0254 	RLF   EEDATL,W
002D 0D14  0255 	RLF   EEDATH,W
002E 0008  0256 	RETURN
002F 22A0  0257 	DW    0x22A0
0030 2952  0258 	DW    0x2952
0031 294F  0259 	DW    0x294F
0032 103A  0260 	DW    0x103A
0033 32D2  0261 	DW    0x32D2
0034 32E3  0262 	DW    0x32E3
0035 3B69  0263 	DW    0x3B69
0036 3165  0264 	DW    0x3165
0037 3375  0265 	DW    0x3375
0038 32E6  0266 	DW    0x32E6
0039 1072  0267 	DW    0x1072
003A 3AE6  0268 	DW    0x3AE6
003B 366C  0269 	DW    0x366C
003C 1000  0270 	DW    0x1000
003D 2945  0271 	DW    0x2945
003E 27D2  0272 	DW    0x27D2
003F 1D52  0273 	DW    0x1D52
0040 21A0  0274 	DW    0x21A0
0041 21D2  0275 	DW    0x21D2
0042 21AD  0276 	DW    0x21AD
0043 32E8  0277 	DW    0x32E8
0044 35E3  0278 	DW    0x35E3
0045 3320  0279 	DW    0x3320
0046 34E1  0280 	DW    0x34E1
0047 32EC  0281 	DW    0x32EC
0048 0064  0282 	DW    0x64
0049 22A0  0283 	DW    0x22A0
004A 2952  0284 	DW    0x2952
004B 294F  0285 	DW    0x294F
004C 103A  0286 	DW    0x103A
004D 22C5  0287 	DW    0x22C5
004E 2950  0288 	DW    0x2950
004F 26CF  0289 	DW    0x26CF
0050 34A0  0290 	DW    0x34A0
0051 1073  0291 	DW    0x1073
0052 3AE6  0292 	DW    0x3AE6
0053 366C  0293 	DW    0x366C
0054 0000  0294 	DW    0x0
           0295 main
           0296 			;	init_all();
0055 205A  0297 	CALL  init_all
           0298 			;    while(1)
           0299 			;    {	
           0300 			;        throw_errors();
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 6

ADDR CODE  LINE SOURCE

0056 2090  0301 m004	CALL  throw_errors
           0302 			;		get_commands();
0057 20A8  0303 	CALL  get_commands
           0304 			;		execute_commands();
0058 212E  0305 	CALL  execute_commands
           0306 			;    }
0059 2856  0307 	GOTO  m004
           0308 			;}
           0309 			;//*********************** UNTERPROGRAMME **********************************************
           0310 			;
           0311 			;void init_all()
           0312 			;{
           0313 init_all
           0314 			;#ifndef X86
           0315 			;	//OSZILLATOR initialisieren: 4xPLL deactivated;INTOSC 16MHz
           0316 			;	OSCCON = 0b01110010;
005A 3072  0317 	MOVLW 114
005B 0021  0318 	MOVLB 1
005C 0099  0319 	MOVWF OSCCON
           0320 			;#endif /* #ifndef X86 */
           0321 			;	RingBufInit();
005D 22A5  0322 	CALL  RingBufInit
           0323 			;	//initialise UART interface
           0324 			;	USARTinit();
005E 2313  0325 	CALL  USARTinit
           0326 			;	spi_init();
005F 22CB  0327 	CALL  spi_init
           0328 			;	ledstrip_init();
0060 2214  0329 	CALL  ledstrip_init
           0330 			;
           0331 			;/** EEPROM contains FF in every cell after inital start,
           0332 			;*** so I have to delet the pointer address
           0333 			;*** otherwise the PIC thinks he has the EEPROM full with commands
           0334 			;**/
           0335 			;	if (EEPROM_RD(CmdPointerAddr) == 0xff)
0061 30FF  0336 	MOVLW 255
0062 21D8  0337 	CALL  EEPROM_RD
0063 3AFF  0338 	XORLW 255
0064 1D03  0339 	BTFSS 0x03,Zero_
0065 286B  0340 	GOTO  m005
           0341 			;	EEPROM_WR(CmdPointerAddr, 0);
0066 30FF  0342 	MOVLW 255
0067 0020  0343 	MOVLB 0
0068 00AA  0344 	MOVWF adress
0069 3000  0345 	MOVLW 0
006A 21B6  0346 	CALL  EEPROM_WR
           0347 			;	EEPROM_WR(CmdLoopPointerAddr, 0);
006B 30FD  0348 m005	MOVLW 253
006C 0020  0349 	MOVLB 0
006D 00AA  0350 	MOVWF adress
006E 3000  0351 	MOVLW 0
006F 21B6  0352 	CALL  EEPROM_WR
           0353 			;	
           0354 			;#ifndef X86
           0355 			;	//Ausgang für FET initalisieren
           0356 			;	TRISC.0 = 0;
0070 0021  0357 	MOVLB 1
0071 100E  0358 	BCF   TRISC,0
           0359 			;	//Spannungsversorgung für LED's einschalten
           0360 			;	PORTC.0 = 0;
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 7

ADDR CODE  LINE SOURCE

0072 0020  0361 	MOVLB 0
0073 100E  0362 	BCF   PORTC,0
           0363 			;#endif /* #ifndef X86 */
           0364 			;
           0365 			;	//To Factory Restore WLAN Modul
           0366 			;	//TRISA.0 = 0;
           0367 			;	//PORTA.0 = 1;
           0368 			;    
           0369 			;    // *** load globals variables
           0370 			;    gERROR.crc_failure = 0;
0074 1060  0371 	BCF   gERROR,0
           0372 			;    gERROR.eeprom_failure = 0;
0075 10E0  0373 	BCF   gERROR,1
           0374 			;    gCmdBuf.cmd_counter = 0;
0076 01CC  0375 	CLRF  gCmdBuf
           0376 			;    gCmdBuf.frame_counter = 0;
0077 01CD  0377 	CLRF  gCmdBuf+1
           0378 			;	gComState = 0;
0078 01E1  0379 	CLRF  gComState
           0380 			;	
           0381 			;	char i;
           0382 			;	for(i=0;i<FRAMELENGTH;i++)
0079 01A2  0383 	CLRF  i
007A 3010  0384 m006	MOVLW 16
007B 0020  0385 	MOVLB 0
007C 0222  0386 	SUBWF i,W
007D 1803  0387 	BTFSC 0x03,Carry
007E 2886  0388 	GOTO  m007
           0389 			;	{
           0390 			;        gCmdBuf.cmd_buf[i] = 0;
007F 304E  0391 	MOVLW 78
0080 0722  0392 	ADDWF i,W
0081 0084  0393 	MOVWF FSR0L
0082 0185  0394 	CLRF  FSR0H
0083 0180  0395 	CLRF  INDF0
           0396 			;	}
0084 0AA2  0397 	INCF  i,1
0085 287A  0398 	GOTO  m006
           0399 			;
           0400 			;#ifndef X86
           0401 			;	// *** allow interrupts
           0402 			;	RCIE=1;
0086 0021  0403 m007	MOVLB 1
0087 1691  0404 	BSF   0x91,RCIE
           0405 			;	PEIE=1;
0088 170B  0406 	BSF   0x0B,PEIE
           0407 			;	GIE=1;
0089 178B  0408 	BSF   0x0B,GIE
           0409 			;#endif /* #ifndef X86 */
           0410 			;	// *** send ready after init
           0411 			;	USARTsend('R');
008A 3052  0412 	MOVLW 82
008B 2326  0413 	CALL  USARTsend
           0414 			;	USARTsend('D');
008C 3044  0415 	MOVLW 68
008D 2326  0416 	CALL  USARTsend
           0417 			;	USARTsend('Y');
008E 3059  0418 	MOVLW 89
008F 2B26  0419 	GOTO  USARTsend
           0420 			;
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 8

ADDR CODE  LINE SOURCE

           0421 			;	
           0422 			;}
           0423 			;
           0424 			;void throw_errors()
           0425 			;{
           0426 throw_errors
           0427 			;	if(RingBufHasError) 
0090 0020  0428 	MOVLB 0
0091 1C4B  0429 	BTFSS gRingBuf+18,0
0092 2897  0430 	GOTO  m008
           0431 			;	{
           0432 			;		USARTsend_str(" ERROR: Receivebuffer full");
0093 01A2  0433 	CLRF  string
0094 2330  0434 	CALL  USARTsend_str
           0435 			;		RingBufClearError;
0095 0020  0436 	MOVLB 0
0096 104B  0437 	BCF   gRingBuf+18,0
           0438 			;	}
           0439 			;	if(gERROR.crc_failure)
0097 0020  0440 m008	MOVLB 0
0098 1C60  0441 	BTFSS gERROR,0
0099 289F  0442 	GOTO  m009
           0443 			;	{
           0444 			;		USARTsend_str(" ERROR: CRC-Check failed");
009A 301B  0445 	MOVLW 27
009B 00A2  0446 	MOVWF string
009C 2330  0447 	CALL  USARTsend_str
           0448 			;		gERROR.crc_failure = 0;
009D 0020  0449 	MOVLB 0
009E 1060  0450 	BCF   gERROR,0
           0451 			;	}
           0452 			;	if(gERROR.eeprom_failure)
009F 0020  0453 m009	MOVLB 0
00A0 1CE0  0454 	BTFSS gERROR,1
00A1 28A7  0455 	GOTO  m010
           0456 			;	{
           0457 			;		USARTsend_str(" ERROR: EEPROM is full");
00A2 3034  0458 	MOVLW 52
00A3 00A2  0459 	MOVWF string
00A4 2330  0460 	CALL  USARTsend_str
           0461 			;		gERROR.eeprom_failure = 0;
00A5 0020  0462 	MOVLB 0
00A6 10E0  0463 	BCF   gERROR,1
           0464 			;	}
           0465 			;}
00A7 0008  0466 m010	RETURN
           0467 			;#ifdef OLD_ROUTINE
           0468 			;/** This function reads one byte from the ringbuffer and check
           0469 			;*** for framestart, framelength, or databyte 
           0470 			;*** if a frame is complete, the function save the frame as a new
           0471 			;*** command in the internal EEPROM and calculate the Pointer for the next Command
           0472 			;**/
           0473 			;void get_commands()
           0474 			;{	
           0475 get_commands
           0476 			;	if(RingBufIsNotEmpty)
00A8 0020  0477 	MOVLB 0
00A9 084A  0478 	MOVF  gRingBuf+17,W
00AA 0649  0479 	XORWF gRingBuf+16,W
00AB 1903  0480 	BTFSC 0x03,Zero_
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 9

ADDR CODE  LINE SOURCE

00AC 292D  0481 	GOTO  m020
           0482 			;	{
           0483 			;		// *** preload variables and 
           0484 			;		// *** get new_byte from ringbuffer
           0485 			;		char new_byte, temp, j;
           0486 			;		temp = 0;
00AD 01A3  0487 	CLRF  temp_2
           0488 			;		j = 0;
00AE 01A4  0489 	CLRF  j
           0490 			;		// *** get new byte
           0491 			;		new_byte = RingBufGet();	
00AF 22AA  0492 	CALL  RingBufGet
00B0 0020  0493 	MOVLB 0
00B1 00A2  0494 	MOVWF new_byte
           0495 			;		// *** do I wait for databytes?
           0496 			;		if(gCmdBuf.frame_counter == 0)
00B2 08CD  0497 	MOVF  gCmdBuf+1,1
00B3 1D03  0498 	BTFSS 0x03,Zero_
00B4 28E0  0499 	GOTO  m012
           0500 			;		{
           0501 			;			// *** I don't wait for databytes
           0502 			;			// *** Do I receive a Start_of_Text sign
           0503 			;			if(new_byte == STX)
00B5 0F22  0504 	INCFSZ new_byte,W
00B6 28C9  0505 	GOTO  m011
           0506 			;			{
           0507 			;				// *** increse the cmd_counter
           0508 			;				gCmdBuf.cmd_counter = 1;
00B7 3001  0509 	MOVLW 1
00B8 00CC  0510 	MOVWF gCmdBuf
           0511 			;				// *** Write the startsign at the begin of the buffer
           0512 			;				gCmdBuf.cmd_buf[0] = new_byte;
00B9 0822  0513 	MOVF  new_byte,W
00BA 00CE  0514 	MOVWF gCmdBuf+2
           0515 			;                // *** Reset crc Variables
           0516 			;                newCRC(&gCmdBuf.crcH, &gCmdBuf.crcL);
00BB 305E  0517 	MOVLW 94
00BC 00A5  0518 	MOVWF p_crcH_2
00BD 305F  0519 	MOVLW 95
00BE 00A6  0520 	MOVWF p_crcL_2
00BF 21A2  0521 	CALL  newCRC
           0522 			;                // *** add new_byte to crc checksum
           0523 			;                addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
00C0 0020  0524 	MOVLB 0
00C1 0822  0525 	MOVF  new_byte,W
00C2 00A5  0526 	MOVWF byte
00C3 305E  0527 	MOVLW 94
00C4 00A6  0528 	MOVWF p_crcH
00C5 305F  0529 	MOVLW 95
00C6 00A7  0530 	MOVWF p_crcL
00C7 214D  0531 	CALL  addCRC
           0532 			;			}
           0533 			;			else
00C8 292D  0534 	GOTO  m020
           0535 			;			{	
           0536 			;				// *** to avoid arrayoverflow
           0537 			;				temp = FRAMELENGTH - 2;
00C9 300E  0538 m011	MOVLW 14
00CA 0020  0539 	MOVLB 0
00CB 00A3  0540 	MOVWF temp_2
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 10

ADDR CODE  LINE SOURCE

           0541 			;				// *** check if I get the framelength byte
           0542 			;				if((new_byte < temp) && (gCmdBuf.cmd_counter == 1))
00CC 0823  0543 	MOVF  temp_2,W
00CD 0222  0544 	SUBWF new_byte,W
00CE 1803  0545 	BTFSC 0x03,Carry
00CF 292D  0546 	GOTO  m020
00D0 0B4C  0547 	DECFSZ gCmdBuf,W
00D1 292D  0548 	GOTO  m020
           0549 			;				{
           0550 			;					gCmdBuf.frame_counter = new_byte;
00D2 0822  0551 	MOVF  new_byte,W
00D3 00CD  0552 	MOVWF gCmdBuf+1
           0553 			;					gCmdBuf.cmd_buf[1] = new_byte;
00D4 0822  0554 	MOVF  new_byte,W
00D5 00CF  0555 	MOVWF gCmdBuf+3
           0556 			;					gCmdBuf.cmd_counter = 2;
00D6 3002  0557 	MOVLW 2
00D7 00CC  0558 	MOVWF gCmdBuf
           0559 			;                    // *** add new_byte to crc checksum
           0560 			;                    addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
00D8 0822  0561 	MOVF  new_byte,W
00D9 00A5  0562 	MOVWF byte
00DA 305E  0563 	MOVLW 94
00DB 00A6  0564 	MOVWF p_crcH
00DC 305F  0565 	MOVLW 95
00DD 00A7  0566 	MOVWF p_crcL
00DE 214D  0567 	CALL  addCRC
           0568 			;				}
           0569 			;			}
           0570 			;		}
           0571 			;		else
00DF 292D  0572 	GOTO  m020
           0573 			;		{
           0574 			;			// *** I wait for Databytes, so I save all bytes 
           0575 			;			// *** that I get until my framecounter is > 0
           0576 			;			gCmdBuf.cmd_buf[gCmdBuf.cmd_counter] = new_byte;
00E0 304E  0577 m012	MOVLW 78
00E1 0020  0578 	MOVLB 0
00E2 074C  0579 	ADDWF gCmdBuf,W
00E3 0084  0580 	MOVWF FSR0L
00E4 0185  0581 	CLRF  FSR0H
00E5 0822  0582 	MOVF  new_byte,W
00E6 0080  0583 	MOVWF INDF0
           0584 			;			gCmdBuf.cmd_counter++;
00E7 0ACC  0585 	INCF  gCmdBuf,1
           0586 			;			
           0587 			;            // *** add new_byte to crc checksum
           0588 			;			if(gCmdBuf.frame_counter > 2)
00E8 3003  0589 	MOVLW 3
00E9 024D  0590 	SUBWF gCmdBuf+1,W
00EA 1C03  0591 	BTFSS 0x03,Carry
00EB 28F3  0592 	GOTO  m013
           0593 			;            addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
00EC 0822  0594 	MOVF  new_byte,W
00ED 00A5  0595 	MOVWF byte
00EE 305E  0596 	MOVLW 94
00EF 00A6  0597 	MOVWF p_crcH
00F0 305F  0598 	MOVLW 95
00F1 00A7  0599 	MOVWF p_crcL
00F2 214D  0600 	CALL  addCRC
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 11

ADDR CODE  LINE SOURCE

           0601 			;			gCmdBuf.frame_counter--;
00F3 0020  0602 m013	MOVLB 0
00F4 0BCD  0603 	DECFSZ gCmdBuf+1,1
           0604 			;			// *** now I have to check if my framecounter is null.
           0605 			;			// *** If it's null my string is complete 
           0606 			;			// *** and I can give the string to the crc check function.
           0607 			;			if(gCmdBuf.frame_counter == 0)
00F5 292D  0608 	GOTO  m020
           0609 			;			{
           0610 			;#ifdef NO_CRC
           0611 			;				if(1==1)
           0612 			;#else
           0613 			;                // *** verify crc checksum
           0614 			;                if( (gCmdBuf.crcL == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 1]) &&
           0615 			;                    (gCmdBuf.crcH == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 2]) )
           0616 			;#endif
           0617 			;                {
           0618 			;					// *** Execute the simple Commands
           0619 			;					switch(gCmdBuf.cmd_buf[2])
00F6 0850  0620 	MOVF  gCmdBuf+4,W
00F7 3AF8  0621 	XORLW 248
00F8 1903  0622 	BTFSC 0x03,Zero_
00F9 2901  0623 	GOTO  m014
00FA 3A02  0624 	XORLW 2
00FB 1903  0625 	BTFSC 0x03,Zero_
00FC 2906  0626 	GOTO  m015
00FD 3A03  0627 	XORLW 3
00FE 1903  0628 	BTFSC 0x03,Zero_
00FF 2909  0629 	GOTO  m016
0100 290C  0630 	GOTO  m017
           0631 			;					{
           0632 			;						case DELETE: 
           0633 			;							{
           0634 			;								EEPROM_WR(CmdPointerAddr,0);
0101 30FF  0635 m014	MOVLW 255
0102 0020  0636 	MOVLB 0
0103 00AA  0637 	MOVWF adress
0104 3000  0638 	MOVLW 0
0105 29B6  0639 	GOTO  EEPROM_WR
           0640 			;								return;
           0641 			;							}
           0642 			;#ifndef X86
           0643 			;						case SET_ON: 
           0644 			;							{
           0645 			;								BCF(PORTC.0); 
0106 0020  0646 m015	MOVLB 0
0107 100E  0647 	BCF   PORTC,0
           0648 			;								return;
0108 0008  0649 	RETURN
           0650 			;								}
           0651 			;						case SET_OFF: 
           0652 			;							{
           0653 			;								BSF(PORTC.0); 
0109 0020  0654 m016	MOVLB 0
010A 140E  0655 	BSF   PORTC,0
           0656 			;								return;
010B 0008  0657 	RETURN
           0658 			;							}
           0659 			;#endif /* #ifndef X86 */
           0660 			;					}
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 12

ADDR CODE  LINE SOURCE

           0661 			;                    char CmdPointer = EEPROM_RD(CmdPointerAddr);
010C 30FF  0662 m017	MOVLW 255
010D 21D8  0663 	CALL  EEPROM_RD
010E 0020  0664 	MOVLB 0
010F 00A5  0665 	MOVWF CmdPointer
           0666 			;					// *** check if there is enough space in the EEPROM for the next command
           0667 			;                    if(CmdPointer < (CmdPointerAddr - CmdWidth))
0110 30F5  0668 	MOVLW 245
0111 0225  0669 	SUBWF CmdPointer,W
0112 1803  0670 	BTFSC 0x03,Carry
0113 291A  0671 	GOTO  m018
           0672 			;                    {
           0673 			;                        // *** calculate the next address for EEPROM write
           0674 			;                        EEPROM_WR(CmdPointerAddr,(CmdPointer + CmdWidth));
0114 30FF  0675 	MOVLW 255
0115 00AA  0676 	MOVWF adress
0116 300A  0677 	MOVLW 10
0117 0725  0678 	ADDWF CmdPointer,W
0118 21B6  0679 	CALL  EEPROM_WR
           0680 			;                    }
           0681 			;                    else 
0119 291D  0682 	GOTO  m019
           0683 			;                    {
           0684 			;                        // *** EEPROM is full with commands
           0685 			;                        // *** Some errorhandling should be here
           0686 			;						gERROR.eeprom_failure = 1;
011A 0020  0687 m018	MOVLB 0
011B 14E0  0688 	BSF   gERROR,1
           0689 			;                        return;
011C 0008  0690 	RETURN
           0691 			;                    } 
           0692 			;					// *** Write the new command without STX and CRC
           0693 			;					EEPROM_WR_BLK(&gCmdBuf.cmd_buf[2], CmdPointer, (gCmdBuf.cmd_counter -4));
011D 3050  0694 m019	MOVLW 80
011E 0020  0695 	MOVLB 0
011F 00A6  0696 	MOVWF array
0120 0825  0697 	MOVF  CmdPointer,W
0121 00A7  0698 	MOVWF adress_3
0122 3004  0699 	MOVLW 4
0123 024C  0700 	SUBWF gCmdBuf,W
0124 21E5  0701 	CALL  EEPROM_WR_BLK
           0702 			;					// *** Send a Message('G'et 'C'ommand) when a new Command is received successfull
           0703 			;					USARTsend('G');
0125 3047  0704 	MOVLW 71
0126 2326  0705 	CALL  USARTsend
           0706 			;					USARTsend('C');
0127 3043  0707 	MOVLW 67
0128 2326  0708 	CALL  USARTsend
           0709 			;#ifdef TEST
           0710 			;					USARTsend_arr(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4));
           0711 			;#endif
           0712 			;                }
           0713 			;                else
0129 292D  0714 	GOTO  m020
           0715 			;                {
           0716 			;                    // *** Do some error handling in case of an CRC failure here
           0717 			;					gERROR.crc_failure = 1;
012A 0020  0718 	MOVLB 0
012B 1460  0719 	BSF   gERROR,0
           0720 			;                    return;
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 13

ADDR CODE  LINE SOURCE

012C 0008  0721 	RETURN
           0722 			;                }
           0723 			;			}
           0724 			;		}
           0725 			;	}
           0726 			;}
012D 0008  0727 m020	RETURN
           0728 			;#else
           0729 			;
           0730 			;/** This function reads one byte from the ringbuffer and check
           0731 			;*** for framestart, framelength, or databyte 
           0732 			;*** if a frame is complete, the function save the frame as a new
           0733 			;*** command in the internal EEPROM and calculate the Pointer for the next Command
           0734 			;**/
           0735 			;//--------- Enumeration for statemachine ------------
           0736 			;#define WAIT_FOR_STX 0
           0737 			;#define WAIT_FOR_FRL 1
           0738 			;#define WAIT_FOR_DATA 2
           0739 			;#define DO_CRC_CHECK 3
           0740 			;#define WRITE_COMMAND 4
           0741 			;
           0742 			;void get_commands()
           0743 			;{
           0744 			;	if(RingBufIsNotEmpty)
           0745 			;	{
           0746 			;	// *** Get next byte from Buffer
           0747 			;	char new_byte = RingBufGet();
           0748 			;#ifdef TEST
           0749 			;	USARTsend_num(gComState,'§');
           0750 			;#endif
           0751 			;	switch(gComState)
           0752 			;	{
           0753 			;		case WAIT_FOR_STX:			//-----------------WAIT_FOR_STX-----------------
           0754 			;		{
           0755 			;			// *** Do I receive a Start_of_Text sign
           0756 			;			if(new_byte == STX)
           0757 			;			{
           0758 			;				// *** increse the cmd_counter
           0759 			;				gCmdBuf.cmd_counter = 1;
           0760 			;				// *** Write the startsign at the begin of the buffer
           0761 			;				gCmdBuf.cmd_buf[0] = new_byte;
           0762 			;                // *** Reset crc Variables
           0763 			;                newCRC(&gCmdBuf.crcH, &gCmdBuf.crcL);
           0764 			;                // *** add new_byte to crc checksum
           0765 			;                addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
           0766 			;				// *** change STATE
           0767 			;				gComState = WAIT_FOR_FRL;
           0768 			;			}
           0769 			;			else
           0770 			;			{
           0771 			;				// *** Do some cleaning, maybe ist not necessary
           0772 			;				// *** 2DO !!! CHECK if necessary
           0773 			;				gCmdBuf.cmd_counter = 0;
           0774 			;				gCmdBuf.frame_counter = 0;
           0775 			;				gComState = WAIT_FOR_STX;
           0776 			;			}
           0777 			;		}break;
           0778 			;		case WAIT_FOR_FRL:			//-----------------WAIT_FOR_FRL-----------------
           0779 			;		{
           0780 			;			// *** check if I get the framelength byte
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 14

ADDR CODE  LINE SOURCE

           0781 			;			// *** check the length, because frame should not be longer as the array
           0782 			;			char temp = FRAMELENGTH-1;
           0783 			;			if(new_byte < temp)
           0784 			;			{
           0785 			;				gCmdBuf.frame_counter = new_byte;
           0786 			;				gCmdBuf.cmd_buf[1] = new_byte;
           0787 			;				gCmdBuf.cmd_counter = 2;
           0788 			;				// *** add new_byte to crc checksum
           0789 			;				addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
           0790 			;				// *** change STATE
           0791 			;				gComState = WAIT_FOR_DATA;
           0792 			;			}
           0793 			;			else gComState = WAIT_FOR_STX;
           0794 			;		}break;
           0795 			;		case WAIT_FOR_DATA:			//-----------------WAIT_FOR_DATA-----------------
           0796 			;		{
           0797 			;			// *** I wait for Databytes, so I save all bytes 
           0798 			;			// *** that I get until my framecounter is > 0
           0799 			;			gCmdBuf.cmd_buf[gCmdBuf.cmd_counter] = new_byte;
           0800 			;			gCmdBuf.cmd_counter++;			
           0801 			;			// *** add new_byte to crc checksum
           0802 			;			if(gCmdBuf.frame_counter > 2)
           0803 			;				addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
           0804 			;			gCmdBuf.frame_counter--;
           0805 			;			// *** now I have to check if my framecounter is zero.
           0806 			;			// *** If it's zero my string is complete 
           0807 			;			// *** and I can give the string to the crc check function.
           0808 			;			if(gCmdBuf.frame_counter == 0)
           0809 			;				// *** change STATE
           0810 			;#ifdef NO_CRC
           0811 			;				gComState = WRITE_COMMAND;
           0812 			;#else
           0813 			;				gComState = DO_CRC_CHECK;
           0814 			;#endif
           0815 			;			else 
           0816 			;				gComState = WAIT_FOR_DATA;
           0817 			;		}break;
           0818 			;		case DO_CRC_CHECK:			//-----------------DO_CRC_CHECK-----------------
           0819 			;		{
           0820 			;			// *** verify crc checksum
           0821 			;			if( (gCmdBuf.crcL == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 1]) &&
           0822 			;				(gCmdBuf.crcH == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 2]) )
           0823 			;				gComState = WRITE_COMMAND;
           0824 			;			else
           0825 			;			{
           0826 			;				// *** Do some error handling in case of an CRC failure here
           0827 			;				gERROR.crc_failure = 1;
           0828 			;				gComState = WAIT_FOR_STX;
           0829 			;				return;
           0830 			;            }
           0831 			;		}break;
           0832 			;		case WRITE_COMMAND:			//-----------------WRITE_COMMAND-----------------
           0833 			;		{
           0834 			;			// *** Execute the simple Commands
           0835 			;			switch(gCmdBuf.cmd_buf[2])
           0836 			;			{
           0837 			;				case DELETE: 
           0838 			;				{
           0839 			;					EEPROM_WR(CmdPointerAddr,0);
           0840 			;					gComState = WAIT_FOR_STX;
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 15

ADDR CODE  LINE SOURCE

           0841 			;					return;
           0842 			;				}
           0843 			;#ifndef X86
           0844 			;				case SET_ON: 
           0845 			;				{
           0846 			;					BCF(PORTC.0);
           0847 			;					gComState = WAIT_FOR_STX;
           0848 			;					return;
           0849 			;				}	
           0850 			;				case SET_OFF: 
           0851 			;				{
           0852 			;					BSF(PORTC.0);
           0853 			;					gComState = WAIT_FOR_STX;
           0854 			;					return;
           0855 			;				}
           0856 			;#endif /* #ifndef X86 */
           0857 			;			}
           0858 			;			char CmdPointer = EEPROM_RD(CmdPointerAddr);
           0859 			;			// *** check if there is enough space in the EEPROM for the next command
           0860 			;            if(CmdPointer < (CmdPointerAddr - CmdWidth))
           0861 			;            {
           0862 			;                // *** calculate the next address for EEPROM write
           0863 			;                EEPROM_WR(CmdPointerAddr,(CmdPointer + CmdWidth));
           0864 			;            }
           0865 			;            else 
           0866 			;            {
           0867 			;                // *** EEPROM is full with commands
           0868 			;                // *** Some errorhandling should be here
           0869 			;				gERROR.eeprom_failure = 1;
           0870 			;				gComState = WAIT_FOR_STX;
           0871 			;                return;
           0872 			;            } 
           0873 			;			// *** Write the new command without STX and CRC
           0874 			;			EEPROM_WR_BLK(&gCmdBuf.cmd_buf[2], CmdPointer, (gCmdBuf.cmd_counter -4));
           0875 			;			// *** Send a Message('G'et 'C'ommand) when a new Command is received successfull
           0876 			;			USARTsend('G');
           0877 			;			USARTsend('C');
           0878 			;			gComState = WAIT_FOR_STX;
           0879 			;#ifdef TEST
           0880 			;			USARTsend_arr(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4));
           0881 			;#endif
           0882 			;		}break;
           0883 			;		default: gComState = WAIT_FOR_STX;
           0884 			;	}
           0885 			;}}
           0886 			;
           0887 			;#endif /*old routine*/
           0888 			;/** This function reads the pointer for commands in the EEPROM from a defined address 
           0889 			;*** in the EEPROM. After this one by one command is executed by this function. 
           0890 			;**/ 
           0891 			;void execute_commands()
           0892 			;{
           0893 execute_commands
           0894 			;	// *** get the pointer to commands in the EEPROM
           0895 			;	char pointer = EEPROM_RD(CmdPointerAddr);
012E 30FF  0896 	MOVLW 255
012F 21D8  0897 	CALL  EEPROM_RD
0130 0020  0898 	MOVLB 0
0131 00A2  0899 	MOVWF pointer
           0900 			;	// *** are there commands to execute?
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 16

ADDR CODE  LINE SOURCE

           0901 			;	if(pointer != 0)
0132 08A2  0902 	MOVF  pointer,1
0133 1903  0903 	BTFSC 0x03,Zero_
0134 294C  0904 	GOTO  m023
           0905 			;	{
           0906 			;		// *** commands available, check what to do
           0907 			;		switch(EEPROM_RD(pointer - CmdWidth)) 
0135 300A  0908 	MOVLW 10
0136 0222  0909 	SUBWF pointer,W
0137 21D8  0910 	CALL  EEPROM_RD
0138 3AFD  0911 	XORLW 253
0139 1903  0912 	BTFSC 0x03,Zero_
013A 2942  0913 	GOTO  m021
013B 3A01  0914 	XORLW 1
013C 1903  0915 	BTFSC 0x03,Zero_
013D 2946  0916 	GOTO  m022
013E 3A07  0917 	XORLW 7
013F 1903  0918 	BTFSC 0x03,Zero_
0140 2946  0919 	GOTO  m022
0141 2946  0920 	GOTO  m022
           0921 			;		{	
           0922 			;			case SET_COLOR: 
           0923 			;			{
           0924 			;				sub_func_set_color(&pointer);
0142 3022  0925 m021	MOVLW 34
0143 0020  0926 	MOVLB 0
0144 00A3  0927 	MOVWF cmdPointer
0145 2268  0928 	CALL  sub_func_set_color
           0929 			;				break;
           0930 			;			}
           0931 			;			case SET_FADE: {break;}
           0932 			;			case SET_RUN: {break;}
           0933 			;		}
           0934 			;		// *** set commandpointer to the next command
           0935 			;		EEPROM_WR(CmdPointerAddr, (pointer - CmdWidth));
0146 30FF  0936 m022	MOVLW 255
0147 0020  0937 	MOVLB 0
0148 00AA  0938 	MOVWF adress
0149 300A  0939 	MOVLW 10
014A 0222  0940 	SUBWF pointer,W
014B 29B6  0941 	GOTO  EEPROM_WR
           0942 			;	}
           0943 			;}
014C 0008  0944 m023	RETURN
           0945 
           0946   ; FILE crc.c
           0947 			; // Include-Datei zum Erstellen von CRC Prüfsummen
           0948 			; //
           0949 			; //
           0950 			; // Nils Weiß
           0951 			; // 14.04.2012
           0952 			; // Compiler CC5x
           0953 			;
           0954 			;// 16-bit CCIT CRC
           0955 			;
           0956 			;void addCRC(char byte, char* p_crcH, char* p_crcL)
           0957 			;{
           0958 addCRC
           0959 			;	char index;
           0960 			;	char crcH,crcL;
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 17

ADDR CODE  LINE SOURCE

           0961 			;	crcH = *p_crcH;
014D 0185  0962 	CLRF  FSR0H
014E 0020  0963 	MOVLB 0
014F 0826  0964 	MOVF  p_crcH,W
0150 0084  0965 	MOVWF FSR0L
0151 0800  0966 	MOVF  INDF0,W
0152 00A9  0967 	MOVWF crcH
           0968 			;	crcL = *p_crcL;
0153 0185  0969 	CLRF  FSR0H
0154 0827  0970 	MOVF  p_crcL,W
0155 0084  0971 	MOVWF FSR0L
0156 0800  0972 	MOVF  INDF0,W
0157 00AA  0973 	MOVWF crcL
           0974 			;
           0975 			;	MOVF(byte,0);
0158 0825  0976 	MOVF  byte,W
           0977 			;	
           0978 			;	XORWF(crcH,0);
0159 0629  0979 	XORWF crcH,W
           0980 			;	MOVWF(index);
015A 00A8  0981 	MOVWF index
           0982 			;	ANDLW(0xf0);
015B 39F0  0983 	ANDLW 240
           0984 			;	SWAPF(index,1);
015C 0EA8  0985 	SWAPF index,1
           0986 			;	XORWF(index,1);
015D 06A8  0987 	XORWF index,1
           0988 			;	
           0989 			;	MOVF(index,0);
015E 0828  0990 	MOVF  index,W
           0991 			;	ANDLW(0xf0);
015F 39F0  0992 	ANDLW 240
           0993 			;	XORWF(crcL,0);
0160 062A  0994 	XORWF crcL,W
           0995 			;	MOVWF(crcH);
0161 00A9  0996 	MOVWF crcH
           0997 			;	
           0998 			;	RLF(index,0);
0162 0D28  0999 	RLF   index,W
           1000 			;	RLF(index,0);
0163 0D28  1001 	RLF   index,W
           1002 			;	XORWF(crcH,1);
0164 06A9  1003 	XORWF crcH,1
           1004 			;	ANDLW(0xe0);
0165 39E0  1005 	ANDLW 224
           1006 			;	XORWF(crcH,1);
0166 06A9  1007 	XORWF crcH,1
           1008 			;		
           1009 			;	SWAPF(index,1);
0167 0EA8  1010 	SWAPF index,1
           1011 			;	XORWF(index,0);
0168 0628  1012 	XORWF index,W
           1013 			;	MOVWF(crcL);
0169 00AA  1014 	MOVWF crcL
           1015 			;
           1016 			;	*p_crcH = crcH;
016A 0185  1017 	CLRF  FSR0H
016B 0826  1018 	MOVF  p_crcH,W
016C 0084  1019 	MOVWF FSR0L
016D 0829  1020 	MOVF  crcH,W
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 18

ADDR CODE  LINE SOURCE

016E 0080  1021 	MOVWF INDF0
           1022 			;	*p_crcL = crcL;
016F 0185  1023 	CLRF  FSR0H
0170 0827  1024 	MOVF  p_crcL,W
0171 0084  1025 	MOVWF FSR0L
0172 082A  1026 	MOVF  crcL,W
0173 0080  1027 	MOVWF INDF0
           1028 			;
           1029 			;}
0174 0008  1030 	RETURN
           1031 			;
           1032 			;void CRC(char *data, char length, char* crcH_out, char* crcL_out)
           1033 			;{
           1034 CRC
           1035 			;	if(!crcH_out)return;
0175 08FF  1036 	MOVF  crcH_out,1
0176 1903  1037 	BTFSC 0x03,Zero_
0177 0008  1038 	RETURN
           1039 			;	if(!crcL_out)return;
0178 08FF  1040 	MOVF  crcL_out,1
0179 1903  1041 	BTFSC 0x03,Zero_
017A 0008  1042 	RETURN
           1043 			;	if(!data)return;
017B 08FF  1044 	MOVF  data,1
017C 1903  1045 	BTFSC 0x03,Zero_
017D 0008  1046 	RETURN
           1047 			;	char crcH,crcL,i,byte;
           1048 			;	crcH=0xff;
017E 30FF  1049 	MOVLW 255
017F 00FF  1050 	MOVWF crcH_2
           1051 			;	crcL=0xff;
0180 30FF  1052 	MOVLW 255
0181 00FF  1053 	MOVWF crcL_2
           1054 			;
           1055 			;	for(i=0;i<length;i++)
0182 01FF  1056 	CLRF  i_2
0183 087F  1057 m024	MOVF  length,W
0184 027F  1058 	SUBWF i_2,W
0185 1803  1059 	BTFSC 0x03,Carry
0186 2997  1060 	GOTO  m025
           1061 			;	{
           1062 			;		byte = data[i];
0187 087F  1063 	MOVF  i_2,W
0188 077F  1064 	ADDWF data,W
0189 0084  1065 	MOVWF FSR0L
018A 0185  1066 	CLRF  FSR0H
018B 0800  1067 	MOVF  INDF0,W
018C 00FF  1068 	MOVWF byte_2
           1069 			;		addCRC(byte,&crcH,&crcL);
018D 087F  1070 	MOVF  byte_2,W
018E 0020  1071 	MOVLB 0
018F 00A5  1072 	MOVWF byte
0190 307F  1073 	MOVLW 127
0191 00A6  1074 	MOVWF p_crcH
0192 307F  1075 	MOVLW 127
0193 00A7  1076 	MOVWF p_crcL
0194 214D  1077 	CALL  addCRC
           1078 			;	}
0195 0AFF  1079 	INCF  i_2,1
0196 2983  1080 	GOTO  m024
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 19

ADDR CODE  LINE SOURCE

           1081 			;	
           1082 			;	*crcH_out = crcH;
0197 0185  1083 m025	CLRF  FSR0H
0198 087F  1084 	MOVF  crcH_out,W
0199 0084  1085 	MOVWF FSR0L
019A 087F  1086 	MOVF  crcH_2,W
019B 0080  1087 	MOVWF INDF0
           1088 			;	*crcL_out = crcL;
019C 0185  1089 	CLRF  FSR0H
019D 087F  1090 	MOVF  crcL_out,W
019E 0084  1091 	MOVWF FSR0L
019F 087F  1092 	MOVF  crcL_2,W
01A0 0080  1093 	MOVWF INDF0
           1094 			;}
01A1 0008  1095 	RETURN
           1096 			;
           1097 			;void newCRC(char* p_crcH, char* p_crcL)
           1098 			;{
           1099 newCRC
           1100 			;    if(!p_crcH) return;
01A2 0020  1101 	MOVLB 0
01A3 08A5  1102 	MOVF  p_crcH_2,1
01A4 1903  1103 	BTFSC 0x03,Zero_
01A5 0008  1104 	RETURN
           1105 			;    if(!p_crcL) return;
01A6 0020  1106 	MOVLB 0
01A7 08A6  1107 	MOVF  p_crcL_2,1
01A8 1903  1108 	BTFSC 0x03,Zero_
01A9 0008  1109 	RETURN
           1110 			;    *p_crcH = 0xff;
01AA 0185  1111 	CLRF  FSR0H
01AB 0020  1112 	MOVLB 0
01AC 0825  1113 	MOVF  p_crcH_2,W
01AD 0084  1114 	MOVWF FSR0L
01AE 30FF  1115 	MOVLW 255
01AF 0080  1116 	MOVWF INDF0
           1117 			;    *p_crcL = 0xff;
01B0 0185  1118 	CLRF  FSR0H
01B1 0826  1119 	MOVF  p_crcL_2,W
01B2 0084  1120 	MOVWF FSR0L
01B3 30FF  1121 	MOVLW 255
01B4 0080  1122 	MOVWF INDF0
           1123 			;}
01B5 0008  1124 	RETURN
           1125 
           1126   ; FILE eeprom.c
           1127 			;//Funktionen für EEPROM-Zugriffe
           1128 			;
           1129 			;//Nils Weiß 
           1130 			;//05.09.2011
           1131 			;//Compiler CC5x
           1132 			;
           1133 			;#ifndef X86
           1134 			;//*********************** EEPROM BYTE SCHREIBEN  **********************************************
           1135 			;
           1136 			;void EEPROM_WR(char adress, char data)
           1137 			;{
           1138 EEPROM_WR
01B6 0020  1139 	MOVLB 0
01B7 00AB  1140 	MOVWF data_2
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 20

ADDR CODE  LINE SOURCE

           1141 			;	bit GIE_status; 
           1142 			;	//EEADRH = (char)(adress<<8);
           1143 			;    EEADRL = (char)adress;        // Adresse in Adressregister übertragen
01B8 082A  1144 	MOVF  adress,W
01B9 0023  1145 	MOVLB 3
01BA 0091  1146 	MOVWF EEADRL
           1147 			;	EEDATL = data;          // Daten in Datenregister übertragen
01BB 0020  1148 	MOVLB 0
01BC 082B  1149 	MOVF  data_2,W
01BD 0023  1150 	MOVLB 3
01BE 0093  1151 	MOVWF EEDATL
           1152 			;    CFGS = 0;
01BF 1315  1153 	BCF   0x195,CFGS
           1154 			;	EEPGD = 0;                // Auswahl: Programmspeicher lesen oder EEPROM
01C0 1395  1155 	BCF   0x195,EEPGD
           1156 			;    WREN = 1;                 // Schreiben ins EEPROM erlauben
01C1 1515  1157 	BSF   0x195,WREN
           1158 			;	GIE_status=GIE;			
01C2 0020  1159 	MOVLB 0
01C3 102C  1160 	BCF   0x2C,GIE_status
01C4 1B8B  1161 	BTFSC 0x0B,GIE
01C5 142C  1162 	BSF   0x2C,GIE_status
           1163 			;    GIE=0;                  // Interrups verbieten
01C6 138B  1164 	BCF   0x0B,GIE
           1165 			;    EECON2 = 0x55;
01C7 3055  1166 	MOVLW 85
01C8 0023  1167 	MOVLB 3
01C9 0096  1168 	MOVWF EECON2
           1169 			;    EECON2 = 0xAA;
01CA 30AA  1170 	MOVLW 170
01CB 0096  1171 	MOVWF EECON2
           1172 			;	WR=1; 					// Starten des Schreibens
01CC 1495  1173 	BSF   0x195,WR
           1174 			;    GIE=GIE_status;                  // Interrups erlauben
01CD 0020  1175 	MOVLB 0
01CE 1C2C  1176 	BTFSS 0x2C,GIE_status
01CF 138B  1177 	BCF   0x0B,GIE
01D0 182C  1178 	BTFSC 0x2C,GIE_status
01D1 178B  1179 	BSF   0x0B,GIE
           1180 			;	WREN=0;
01D2 0023  1181 	MOVLB 3
01D3 1115  1182 	BCF   0x195,WREN
           1183 			;	while(WR);
01D4 0023  1184 m026	MOVLB 3
01D5 1895  1185 	BTFSC 0x195,WR
01D6 29D4  1186 	GOTO  m026
           1187 			;}
01D7 0008  1188 	RETURN
           1189 			;
           1190 			;//*********************** EEPROM BYTE LESEN  **********************************************
           1191 			;
           1192 			;char EEPROM_RD(char adress)
           1193 			;{
           1194 EEPROM_RD
01D8 0020  1195 	MOVLB 0
01D9 00AE  1196 	MOVWF adress_2
           1197 			;    char data;
           1198 			;    //EEADRH = (char)(adress<<8);        // Adresse in Adressregister übertragen
           1199 			;    EEADRL = (char)(adress);
01DA 082E  1200 	MOVF  adress_2,W
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 21

ADDR CODE  LINE SOURCE

01DB 0023  1201 	MOVLB 3
01DC 0091  1202 	MOVWF EEADRL
           1203 			;	CFGS=0;
01DD 1315  1204 	BCF   0x195,CFGS
           1205 			;	EEPGD=0;                // Auswahl: Programmspeicher lesen oder EEPROM
01DE 1395  1206 	BCF   0x195,EEPGD
           1207 			;    RD=1;                   // Starten des Lesesn
01DF 1415  1208 	BSF   0x195,RD
           1209 			;    data = EEDATL;       // Daten aus Datenregister auslesen
01E0 0813  1210 	MOVF  EEDATL,W
01E1 0020  1211 	MOVLB 0
01E2 00AF  1212 	MOVWF data_3
           1213 			;    return data;
01E3 082F  1214 	MOVF  data_3,W
01E4 0008  1215 	RETURN
           1216 			;}
           1217 			;#endif /* #ifndef X86 */
           1218 			;
           1219 			;//*********************** EEPROM BYTEARRAY SCHREIBEN  **************************************
           1220 			;
           1221 			;void EEPROM_WR_BLK(char *array, char adress, char length)			//Zum Ausführen eines beliebigen Befehls durch den Programmcode
           1222 			;{
           1223 EEPROM_WR_BLK
01E5 0020  1224 	MOVLB 0
01E6 00A8  1225 	MOVWF length_2
           1226 			;	if(!array) return;
01E7 08A6  1227 	MOVF  array,1
01E8 1903  1228 	BTFSC 0x03,Zero_
01E9 0008  1229 	RETURN
           1230 			;	char i;
           1231 			;	for(i=0;i<length;i++)
01EA 0020  1232 	MOVLB 0
01EB 01A9  1233 	CLRF  i_3
01EC 0020  1234 m027	MOVLB 0
01ED 0828  1235 	MOVF  length_2,W
01EE 0229  1236 	SUBWF i_3,W
01EF 1803  1237 	BTFSC 0x03,Carry
01F0 29FD  1238 	GOTO  m028
           1239 			;	{
           1240 			;		EEPROM_WR(adress,*array);
01F1 0827  1241 	MOVF  adress_3,W
01F2 00AA  1242 	MOVWF adress
01F3 0185  1243 	CLRF  FSR0H
01F4 0826  1244 	MOVF  array,W
01F5 0084  1245 	MOVWF FSR0L
01F6 0800  1246 	MOVF  INDF0,W
01F7 21B6  1247 	CALL  EEPROM_WR
           1248 			;		adress++;
01F8 0020  1249 	MOVLB 0
01F9 0AA7  1250 	INCF  adress_3,1
           1251 			;		array++;
01FA 0AA6  1252 	INCF  array,1
           1253 			;	}
01FB 0AA9  1254 	INCF  i_3,1
01FC 29EC  1255 	GOTO  m027
           1256 			;}
01FD 0008  1257 m028	RETURN
           1258 			;
           1259 			;//*********************** EEPROM BYTEARRAY LESEN  **************************************
           1260 			;
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 22

ADDR CODE  LINE SOURCE

           1261 			;void EEPROM_RD_BLK(char *array, char adress, char length)			//Zum Ausführen eines beliebigen Befehls durch den Programmcode
           1262 			;{
           1263 EEPROM_RD_BLK
01FE 00FF  1264 	MOVWF length_3
           1265 			;	if(!array) return;
01FF 08FF  1266 	MOVF  array_2,1
0200 1903  1267 	BTFSC 0x03,Zero_
0201 0008  1268 	RETURN
           1269 			;	char i, temp;
           1270 			;	for(i=0;i<length;i++)
0202 01FF  1271 	CLRF  i_4
0203 087F  1272 m029	MOVF  length_3,W
0204 027F  1273 	SUBWF i_4,W
0205 1803  1274 	BTFSC 0x03,Carry
0206 2A13  1275 	GOTO  m030
           1276 			;	{
           1277 			;		temp = EEPROM_RD(adress);
0207 087F  1278 	MOVF  adress_4,W
0208 21D8  1279 	CALL  EEPROM_RD
0209 00FF  1280 	MOVWF temp_3
           1281 			;		array[i] = temp;
020A 087F  1282 	MOVF  i_4,W
020B 077F  1283 	ADDWF array_2,W
020C 0084  1284 	MOVWF FSR0L
020D 0185  1285 	CLRF  FSR0H
020E 087F  1286 	MOVF  temp_3,W
020F 0080  1287 	MOVWF INDF0
           1288 			;		adress++;
0210 0AFF  1289 	INCF  adress_4,1
           1290 			;	}
0211 0AFF  1291 	INCF  i_4,1
0212 2A03  1292 	GOTO  m029
           1293 			;}
0213 0008  1294 m030	RETURN
           1295 
           1296   ; FILE ledstrip.c
           1297 			;//Nils Weiß 
           1298 			;//20.04.2012
           1299 			;//Compiler CC5x 
           1300 			;
           1301 			;#include "ledstrip.h"
           1302 			;
           1303 			;struct LedBuffer gLedBuf;
           1304 			;
           1305 			;void ledstrip_init(void)
           1306 			;{
           1307 ledstrip_init
           1308 			;	char k;
           1309 			;	for(k = 0;k < (NUM_OF_LED * 3); k++)
0214 0020  1310 	MOVLB 0
0215 01A3  1311 	CLRF  k
0216 3060  1312 m031	MOVLW 96
0217 0020  1313 	MOVLB 0
0218 0223  1314 	SUBWF k,W
0219 1803  1315 	BTFSC 0x03,Carry
021A 2A25  1316 	GOTO  m032
           1317 			;	{	
           1318 			;		gLedBuf.led_array[k] = 0;
021B 3020  1319 	MOVLW 32
021C 0085  1320 	MOVWF FSR0+1
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 23

ADDR CODE  LINE SOURCE

021D 3042  1321 	MOVLW 66
021E 0723  1322 	ADDWF k,W
021F 0084  1323 	MOVWF FSR0
0220 1803  1324 	BTFSC 0x03,Carry
0221 0A85  1325 	INCF  FSR0+1,1
0222 0180  1326 	CLRF  INDF0
           1327 			;	}
0223 0AA3  1328 	INCF  k,1
0224 2A16  1329 	GOTO  m031
           1330 			;}
0225 0008  1331 m032	RETURN
           1332 			;
           1333 			;/***
           1334 			;*** This funktion sets the values of the global LedBuffer
           1335 			;*** only Led's where the address bit is 1 will be set to the new color
           1336 			;***/
           1337 			;
           1338 			;void ledstrip_set_color(char *address, char r, char g, char b)
           1339 			;{	
           1340 ledstrip_set_color
0226 0020  1341 	MOVLB 0
0227 00B1  1342 	MOVWF b
           1343 			;	char k,mask;
           1344 			;	mask = 0b00000001;
0228 3001  1345 	MOVLW 1
0229 00B3  1346 	MOVWF mask
           1347 			;	for(k = 0; k < (NUM_OF_LED * 3); k++)
022A 01B2  1348 	CLRF  k_2
022B 3060  1349 m033	MOVLW 96
022C 0020  1350 	MOVLB 0
022D 0232  1351 	SUBWF k_2,W
022E 1803  1352 	BTFSC 0x03,Carry
022F 2A62  1353 	GOTO  m037
           1354 			;	{	
           1355 			;		if(0 != (*address & mask))
0230 0185  1356 	CLRF  FSR0H
0231 082E  1357 	MOVF  address,W
0232 0084  1358 	MOVWF FSR0L
0233 0833  1359 	MOVF  mask,W
0234 0500  1360 	ANDWF INDF0,W
0235 1903  1361 	BTFSC 0x03,Zero_
0236 2A55  1362 	GOTO  m034
           1363 			;		{
           1364 			;			gLedBuf.led_array[k] = b;
0237 3020  1365 	MOVLW 32
0238 0085  1366 	MOVWF FSR0+1
0239 3042  1367 	MOVLW 66
023A 0732  1368 	ADDWF k_2,W
023B 0084  1369 	MOVWF FSR0
023C 1803  1370 	BTFSC 0x03,Carry
023D 0A85  1371 	INCF  FSR0+1,1
023E 0831  1372 	MOVF  b,W
023F 0080  1373 	MOVWF INDF0
           1374 			;			k++;
0240 0AB2  1375 	INCF  k_2,1
           1376 			;			gLedBuf.led_array[k] = g;
0241 3020  1377 	MOVLW 32
0242 0085  1378 	MOVWF FSR0+1
0243 3042  1379 	MOVLW 66
0244 0732  1380 	ADDWF k_2,W
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 24

ADDR CODE  LINE SOURCE

0245 0084  1381 	MOVWF FSR0
0246 1803  1382 	BTFSC 0x03,Carry
0247 0A85  1383 	INCF  FSR0+1,1
0248 0830  1384 	MOVF  g,W
0249 0080  1385 	MOVWF INDF0
           1386 			;			k++;
024A 0AB2  1387 	INCF  k_2,1
           1388 			;			gLedBuf.led_array[k] = r;
024B 3020  1389 	MOVLW 32
024C 0085  1390 	MOVWF FSR0+1
024D 3042  1391 	MOVLW 66
024E 0732  1392 	ADDWF k_2,W
024F 0084  1393 	MOVWF FSR0
0250 1803  1394 	BTFSC 0x03,Carry
0251 0A85  1395 	INCF  FSR0+1,1
0252 082F  1396 	MOVF  r,W
0253 0080  1397 	MOVWF INDF0
           1398 			;		}
           1399 			;		else 
0254 2A58  1400 	GOTO  m035
           1401 			;		{
           1402 			;			k++;
0255 0020  1403 m034	MOVLB 0
0256 0AB2  1404 	INCF  k_2,1
           1405 			;			k++;
0257 0AB2  1406 	INCF  k_2,1
           1407 			;		}
           1408 			;#ifdef X86
           1409 			;		mask = mask << 1;
           1410 			;		if(0 == mask)
           1411 			;#else
           1412 			;		RLF(mask,1);
0258 0020  1413 m035	MOVLB 0
0259 0DB3  1414 	RLF   mask,1
           1415 			;		if(Carry == 1) 
025A 1C03  1416 	BTFSS 0x03,Carry
025B 2A5F  1417 	GOTO  m036
           1418 			;#endif
           1419 			;		{
           1420 			;			address++;
025C 0AAE  1421 	INCF  address,1
           1422 			;			mask= 0b00000001;
025D 3001  1423 	MOVLW 1
025E 00B3  1424 	MOVWF mask
           1425 			;		}
           1426 			;	}
025F 0020  1427 m036	MOVLB 0
0260 0AB2  1428 	INCF  k_2,1
0261 2A2B  1429 	GOTO  m033
           1430 			;	spi_send_ledbuf(&gLedBuf.led_array[0]);
0262 3042  1431 m037	MOVLW 66
0263 0020  1432 	MOVLB 0
0264 00B4  1433 	MOVWF array_4
0265 3020  1434 	MOVLW 32
0266 00B5  1435 	MOVWF array_4+1
0267 2AF3  1436 	GOTO  spi_send_ledbuf
           1437 			;}
           1438 			;
           1439 			;/** This function extracts the parameters for the set_color command
           1440 			;*** from the EEPROM in relation to the CmdWidth and give the values 
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 25

ADDR CODE  LINE SOURCE

           1441 			;*** to the next function with controls the led's
           1442 			;
           1443 			;*** BYTES according to Pointer: x=Commandpointer w=Commandwith
           1444 			;							   x-w     x-w+1   x-w+2   x-w+3  x-w+4     x-w+5         x-w+6        x-w+7                            
                                     x
           1445 			;*** Example: EEPROM DATA: <SET_COLOR> <ADDR0> <ADDR1> <ADDR2> <ADDR3> <RED_VALUE> <GREEN_VALUE> <BLUE_VALUE> <not important> <not important> <SET_COLOR(nextCom
                   mand)>
           1446 			;*/ 
           1447 			;void sub_func_set_color(char *cmdPointer)
           1448 			;{
           1449 sub_func_set_color
           1450 			;	char r,g,b,i, temp,temp1,address[4];
           1451 			;	
           1452 			;	r = EEPROM_RD(*cmdPointer - CmdWidth + 5);
0268 0185  1453 	CLRF  FSR0H
0269 0020  1454 	MOVLB 0
026A 0823  1455 	MOVF  cmdPointer,W
026B 0084  1456 	MOVWF FSR0L
026C 3005  1457 	MOVLW 5
026D 0200  1458 	SUBWF INDF0,W
026E 21D8  1459 	CALL  EEPROM_RD
026F 0020  1460 	MOVLB 0
0270 00A4  1461 	MOVWF r_2
           1462 			;	g = EEPROM_RD(*cmdPointer - CmdWidth + 6);
0271 0185  1463 	CLRF  FSR0H
0272 0823  1464 	MOVF  cmdPointer,W
0273 0084  1465 	MOVWF FSR0L
0274 3004  1466 	MOVLW 4
0275 0200  1467 	SUBWF INDF0,W
0276 21D8  1468 	CALL  EEPROM_RD
0277 0020  1469 	MOVLB 0
0278 00A5  1470 	MOVWF g_2
           1471 			;	b = EEPROM_RD(*cmdPointer - CmdWidth + 7);
0279 0185  1472 	CLRF  FSR0H
027A 0823  1473 	MOVF  cmdPointer,W
027B 0084  1474 	MOVWF FSR0L
027C 3003  1475 	MOVLW 3
027D 0200  1476 	SUBWF INDF0,W
027E 21D8  1477 	CALL  EEPROM_RD
027F 0020  1478 	MOVLB 0
0280 00A6  1479 	MOVWF b_2
           1480 			;	for(i=0;i<4;i++)
0281 01A7  1481 	CLRF  i_5
0282 3004  1482 m038	MOVLW 4
0283 0020  1483 	MOVLB 0
0284 0227  1484 	SUBWF i_5,W
0285 1803  1485 	BTFSC 0x03,Carry
0286 2A9C  1486 	GOTO  m039
           1487 			;	{
           1488 			;		temp1 = *cmdPointer;
0287 0185  1489 	CLRF  FSR0H
0288 0823  1490 	MOVF  cmdPointer,W
0289 0084  1491 	MOVWF FSR0L
028A 0800  1492 	MOVF  INDF0,W
028B 00A9  1493 	MOVWF temp1
           1494 			;		temp1 = temp1 - CmdWidth + 1 + i;
028C 3009  1495 	MOVLW 9
028D 0229  1496 	SUBWF temp1,W
028E 0727  1497 	ADDWF i_5,W
028F 00A9  1498 	MOVWF temp1
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 26

ADDR CODE  LINE SOURCE

           1499 			;		temp = EEPROM_RD(temp1);
0290 0829  1500 	MOVF  temp1,W
0291 21D8  1501 	CALL  EEPROM_RD
0292 0020  1502 	MOVLB 0
0293 00A8  1503 	MOVWF temp_4
           1504 			;		address[i] = temp;
0294 302A  1505 	MOVLW 42
0295 0727  1506 	ADDWF i_5,W
0296 0084  1507 	MOVWF FSR0L
0297 0185  1508 	CLRF  FSR0H
0298 0828  1509 	MOVF  temp_4,W
0299 0080  1510 	MOVWF INDF0
           1511 			;	}
029A 0AA7  1512 	INCF  i_5,1
029B 2A82  1513 	GOTO  m038
           1514 			;	
           1515 			;#ifdef TEST
           1516 			;	USARTsend_str("Command:");
           1517 			;	USARTsend_num(address[0],'#');
           1518 			;	USARTsend_num(address[1],'#');
           1519 			;	USARTsend_num(address[2],'#');
           1520 			;	USARTsend_num(address[3],'#');
           1521 			;	USARTsend_num(r,'R');
           1522 			;	USARTsend_num(g,'G');
           1523 			;	USARTsend_num(b,'B');
           1524 			;#endif	
           1525 			;	ledstrip_set_color(&address[0],r,g,b);
029C 302A  1526 m039	MOVLW 42
029D 0020  1527 	MOVLB 0
029E 00AE  1528 	MOVWF address
029F 0824  1529 	MOVF  r_2,W
02A0 00AF  1530 	MOVWF r
02A1 0825  1531 	MOVF  g_2,W
02A2 00B0  1532 	MOVWF g
02A3 0826  1533 	MOVF  b_2,W
02A4 2A26  1534 	GOTO  ledstrip_set_color
           1535 			;}
           1536 
           1537   ; FILE RingBuf.c
           1538 			;
           1539 			;#include "RingBuf.h"
           1540 			;
           1541 			;#ifndef X86
           1542 			;#message Global variables are defined in RingBuf.c
           1543 			;#endif /* #ifndef X86 */
           1544 			;struct RingBuffer gRingBuf;
           1545 			;
           1546 			;void RingBufInit(void)
           1547 			;{
           1548 RingBufInit
           1549 			;	gRingBuf.read = 0;
02A5 0020  1550 	MOVLB 0
02A6 01C9  1551 	CLRF  gRingBuf+16
           1552 			;	gRingBuf.write = 0;
02A7 01CA  1553 	CLRF  gRingBuf+17
           1554 			;	gRingBuf.error_full = 0;
02A8 104B  1555 	BCF   gRingBuf+18,0
           1556 			;}
02A9 0008  1557 	RETURN
           1558 			;
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 27

ADDR CODE  LINE SOURCE

           1559 			;char RingBufGet(void)
           1560 			;{
           1561 RingBufGet
           1562 			;	char result = gRingBuf.data[gRingBuf.read];
02AA 3039  1563 	MOVLW 57
02AB 0020  1564 	MOVLB 0
02AC 0749  1565 	ADDWF gRingBuf+16,W
02AD 0084  1566 	MOVWF FSR0L
02AE 0185  1567 	CLRF  FSR0H
02AF 0800  1568 	MOVF  INDF0,W
02B0 00A5  1569 	MOVWF result
           1570 			;	gRingBuf.read = RingBufInc(gRingBuf.read);
02B1 0A49  1571 	INCF  gRingBuf+16,W
02B2 390F  1572 	ANDLW 15
02B3 00C9  1573 	MOVWF gRingBuf+16
           1574 			;	return result;
02B4 0825  1575 	MOVF  result,W
02B5 0008  1576 	RETURN
           1577 			;}
           1578 			;
           1579 			;void RingBufPut(char value)
           1580 			;{
           1581 RingBufPut
02B6 0020  1582 	MOVLB 0
02B7 00A0  1583 	MOVWF value
           1584 			;	char writeNext = RingBufInc(gRingBuf.write);
02B8 0A4A  1585 	INCF  gRingBuf+17,W
02B9 390F  1586 	ANDLW 15
02BA 00A1  1587 	MOVWF writeNext
           1588 			;	if(writeNext != gRingBuf.read)
02BB 0821  1589 	MOVF  writeNext,W
02BC 0649  1590 	XORWF gRingBuf+16,W
02BD 1903  1591 	BTFSC 0x03,Zero_
02BE 2AC8  1592 	GOTO  m040
           1593 			;	{
           1594 			;		gRingBuf.data[gRingBuf.write] = value;
02BF 3039  1595 	MOVLW 57
02C0 074A  1596 	ADDWF gRingBuf+17,W
02C1 0084  1597 	MOVWF FSR0L
02C2 0185  1598 	CLRF  FSR0H
02C3 0820  1599 	MOVF  value,W
02C4 0080  1600 	MOVWF INDF0
           1601 			;		gRingBuf.write = writeNext;
02C5 0821  1602 	MOVF  writeNext,W
02C6 00CA  1603 	MOVWF gRingBuf+17
           1604 			;	}
           1605 			;	else gRingBuf.error_full = 1;
02C7 2ACA  1606 	GOTO  m041
02C8 0020  1607 m040	MOVLB 0
02C9 144B  1608 	BSF   gRingBuf+18,0
           1609 			;}
02CA 0008  1610 m041	RETURN
           1611 
           1612   ; FILE spi.c
           1613 			;//Nils Weiß 
           1614 			;//20.04.2012
           1615 			;//Compiler CC5x
           1616 			;
           1617 			;#include "ledstrip.h"
           1618 			;
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 28

ADDR CODE  LINE SOURCE

           1619 			;#ifndef X86
           1620 			;void spi_init()
           1621 			;{
           1622 spi_init
           1623 			;	TRISC.3 = 0;        // Make port RC3 an output(SPI Clock)
02CB 0021  1624 	MOVLB 1
02CC 118E  1625 	BCF   TRISC,3
           1626 			;    TRISC.4 = 1;        // Make port RC4 an input(SPI Data In)
02CD 160E  1627 	BSF   TRISC,4
           1628 			;    TRISC.5 = 0;        // Make port RC5 an output(SPI Data Out)
02CE 128E  1629 	BCF   TRISC,5
           1630 			;	SSPM1 = 0;
02CF 0024  1631 	MOVLB 4
02D0 1095  1632 	BCF   0x215,SSPM1
           1633 			;	SMP = 0;
02D1 1394  1634 	BCF   0x214,SMP
           1635 			;	CKP = 1;
02D2 1615  1636 	BSF   0x215,CKP
           1637 			;	CKE = 0;
02D3 1314  1638 	BCF   0x214,CKE
           1639 			;	SSPEN = 1;
02D4 1695  1640 	BSF   0x215,SSPEN
           1641 			;}
02D5 0008  1642 	RETURN
           1643 			;
           1644 			;char spi_send(char data)
           1645 			;{
           1646 spi_send
02D6 0020  1647 	MOVLB 0
02D7 00B8  1648 	MOVWF data_4
           1649 			;	SSPBUF = data;	
02D8 0838  1650 	MOVF  data_4,W
02D9 0024  1651 	MOVLB 4
02DA 0091  1652 	MOVWF SSPBUF
           1653 			;	while(SSPIF == 0);
02DB 0020  1654 m042	MOVLB 0
02DC 1D91  1655 	BTFSS 0x11,SSPIF
02DD 2ADB  1656 	GOTO  m042
           1657 			;	return SSPBUF;
02DE 0024  1658 	MOVLB 4
02DF 0811  1659 	MOVF  SSPBUF,W
02E0 0008  1660 	RETURN
           1661 			;}
           1662 			;#endif /* #ifndef X86 */
           1663 			;
           1664 			;/***
           1665 			;**	This function sends the array to the LED controller(WS2801)
           1666 			;**  it starts with the last byte to get a correct output
           1667 			;***/
           1668 			;void spi_send_arr(char *array, char length)
           1669 			;{
           1670 spi_send_arr
02E1 00FF  1671 	MOVWF length_4
           1672 			;	if(array == 0) return;
02E2 08FF  1673 	MOVF  array_3,1
02E3 1903  1674 	BTFSC 0x03,Zero_
02E4 0008  1675 	RETURN
           1676 			;	char i;
           1677 			;	for(i = length; i == 0; i-- )
02E5 087F  1678 	MOVF  length_4,W
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 29

ADDR CODE  LINE SOURCE

02E6 00FF  1679 	MOVWF i_6
02E7 08FF  1680 m043	MOVF  i_6,1
02E8 1D03  1681 	BTFSS 0x03,Zero_
02E9 2AF2  1682 	GOTO  m044
           1683 			;	{
           1684 			;		spi_send(array[i]);
02EA 087F  1685 	MOVF  i_6,W
02EB 077F  1686 	ADDWF array_3,W
02EC 0084  1687 	MOVWF FSR0L
02ED 0185  1688 	CLRF  FSR0H
02EE 0800  1689 	MOVF  INDF0,W
02EF 22D6  1690 	CALL  spi_send
           1691 			;	} 
02F0 03FF  1692 	DECF  i_6,1
02F1 2AE7  1693 	GOTO  m043
           1694 			;}
02F2 0008  1695 m044	RETURN
           1696 			;
           1697 			;void spi_send_ledbuf(char *array)//!!! CHECK if GIE=0 during the sendroutine improves the result
           1698 			;{
           1699 spi_send_ledbuf
           1700 			;	//array must be the address of the first byte
           1701 			;	char* end;
           1702 			;	//calculate where the end is
           1703 			;	end = array + (NUM_OF_LED * 3);
02F3 0020  1704 	MOVLB 0
02F4 0835  1705 	MOVF  array_4+1,W
02F5 00B7  1706 	MOVWF end+1
02F6 3060  1707 	MOVLW 96
02F7 0734  1708 	ADDWF array_4,W
02F8 00B6  1709 	MOVWF end
02F9 1803  1710 	BTFSC 0x03,Carry
02FA 0AB7  1711 	INCF  end+1,1
           1712 			;	//send all
           1713 			;	for(; array < end; array++)
02FB 0020  1714 m045	MOVLB 0
02FC 0837  1715 	MOVF  end+1,W
02FD 0235  1716 	SUBWF array_4+1,W
02FE 1C03  1717 	BTFSS 0x03,Carry
02FF 2B06  1718 	GOTO  m046
0300 1D03  1719 	BTFSS 0x03,Zero_
0301 2B12  1720 	GOTO  m047
0302 0836  1721 	MOVF  end,W
0303 0234  1722 	SUBWF array_4,W
0304 1803  1723 	BTFSC 0x03,Carry
0305 2B12  1724 	GOTO  m047
           1725 			;	{
           1726 			;		spi_send(*array);
0306 0020  1727 m046	MOVLB 0
0307 0835  1728 	MOVF  array_4+1,W
0308 0085  1729 	MOVWF FSR0H
0309 0834  1730 	MOVF  array_4,W
030A 0084  1731 	MOVWF FSR0L
030B 0800  1732 	MOVF  INDF0,W
030C 22D6  1733 	CALL  spi_send
           1734 			;	}
030D 0020  1735 	MOVLB 0
030E 0AB4  1736 	INCF  array_4,1
030F 1903  1737 	BTFSC 0x03,Zero_
0310 0AB5  1738 	INCF  array_4+1,1
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 30

ADDR CODE  LINE SOURCE

0311 2AFB  1739 	GOTO  m045
           1740 			;}
0312 0008  1741 m047	RETURN
           1742 
           1743   ; FILE usart.c
           1744 			;// Include-Datei für Serielle Kommunikation über Hardwaremodul des Pic
           1745 			; //
           1746 			; //
           1747 			; // Nils Weiß
           1748 			; // 29.11.2010
           1749 			; // Compiler CC5x
           1750 			;
           1751 			;#ifndef X86
           1752 			;//*******  Initialisierungs-Funktion  *************************************************
           1753 			;void USARTinit()
           1754 			;{
           1755 USARTinit
           1756 			;	//USART TX Pin als Ausgang
           1757 			;	TRISC.6 = 0;
0313 0021  1758 	MOVLB 1
0314 130E  1759 	BCF   TRISC,6
           1760 			;
           1761 			;    BRGH=1;					// High Baudrate activated
0315 0023  1762 	MOVLB 3
0316 151E  1763 	BSF   0x19E,BRGH
           1764 			;	BRG16=0;
0317 119F  1765 	BCF   0x19F,BRG16
           1766 			;	SPBRGL=25;				// 19200 Bps @ 8 MHz Clock
0318 3019  1767 	MOVLW 25
0319 009B  1768 	MOVWF SPBRGL
           1769 			;	SPBRGH=0;
031A 019C  1770 	CLRF  SPBRGH
           1771 			;    SPEN = 1;               // Set_Serial_Pins;
031B 179D  1772 	BSF   0x19D,SPEN
           1773 			;    SYNC = 0;               // Set_Async_Mode;
031C 121E  1774 	BCF   0x19E,SYNC
           1775 			;    TX9 = 0;                // Set_8bit_Tx;
031D 131E  1776 	BCF   0x19E,TX9
           1777 			;    RX9 = 0;                // Set_8bit_Rx;
031E 131D  1778 	BCF   0x19D,RX9
           1779 			;    CREN = 1;               // Enable_Rx;
031F 161D  1780 	BSF   0x19D,CREN
           1781 			;    TXEN = 1;               // Enable_Tx;
0320 169E  1782 	BSF   0x19E,TXEN
           1783 			;    RCIE=1;                 // Rx Interrupt aus
0321 0021  1784 	MOVLB 1
0322 1691  1785 	BSF   0x91,RCIE
           1786 			;	ADDEN=0;				// Disable Adressdetection
0323 0023  1787 	MOVLB 3
0324 119D  1788 	BCF   0x19D,ADDEN
           1789 			;}
0325 0008  1790 	RETURN
           1791 			;
           1792 			;//*******  Sende-char-Funktion  *************************************************
           1793 			;void USARTsend(unsigned char ch)
           1794 			;{
           1795 USARTsend
0326 0020  1796 	MOVLB 0
0327 00A6  1797 	MOVWF ch
           1798 			;	while(!TXIF);
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 31

ADDR CODE  LINE SOURCE

0328 0020  1799 m048	MOVLB 0
0329 1E11  1800 	BTFSS 0x11,TXIF
032A 2B28  1801 	GOTO  m048
           1802 			;	TXREG=ch;
032B 0020  1803 	MOVLB 0
032C 0826  1804 	MOVF  ch,W
032D 0023  1805 	MOVLB 3
032E 009A  1806 	MOVWF TXREG
           1807 			;}
032F 0008  1808 	RETURN
           1809 			;#endif /* #ifndef X86 */
           1810 			;
           1811 			;//*******  Sende-String-Funktion  *************************************************
           1812 			;void USARTsend_str(const char *string)
           1813 			;{
           1814 USARTsend_str
           1815 			; char ps;
           1816 			; ps = *string;
0330 0020  1817 	MOVLB 0
0331 0822  1818 	MOVF  string,W
0332 2012  1819 	CALL  _const1
0333 0020  1820 	MOVLB 0
0334 00A3  1821 	MOVWF ps
           1822 			; while(ps > 0)
0335 0020  1823 m049	MOVLB 0
0336 08A3  1824 	MOVF  ps,1
0337 1903  1825 	BTFSC 0x03,Zero_
0338 2B42  1826 	GOTO  m050
           1827 			;   {
           1828 			;    string++;
0339 0AA2  1829 	INCF  string,1
           1830 			;   	USARTsend(ps);
033A 0823  1831 	MOVF  ps,W
033B 2326  1832 	CALL  USARTsend
           1833 			;    ps = *string;
033C 0020  1834 	MOVLB 0
033D 0822  1835 	MOVF  string,W
033E 2012  1836 	CALL  _const1
033F 0020  1837 	MOVLB 0
0340 00A3  1838 	MOVWF ps
           1839 			;   }
0341 2B35  1840 	GOTO  m049
           1841 			;}
0342 0008  1842 m050	RETURN
           1843 			;
           1844 			;//*******  Sende-Array-Funktion  *************************************************
           1845 			;void USARTsend_arr(char *array, char length)
           1846 			;{
           1847 USARTsend_arr
0343 00FF  1848 	MOVWF length_5
           1849 			;	if(array == 0) return;
0344 08FF  1850 	MOVF  array_5,1
0345 1903  1851 	BTFSC 0x03,Zero_
0346 0008  1852 	RETURN
           1853 			;	char i;
           1854 			;	for(i=0;i<length;i++)
0347 01FF  1855 	CLRF  i_7
0348 087F  1856 m051	MOVF  length_5,W
0349 027F  1857 	SUBWF i_7,W
034A 1803  1858 	BTFSC 0x03,Carry
CC5X Version 3.4E,   File: main.c              11. May 2012  20:18   Page 32

ADDR CODE  LINE SOURCE

034B 2B54  1859 	GOTO  m052
           1860 			;	{
           1861 			;		USARTsend(*array);
034C 0185  1862 	CLRF  FSR0H
034D 087F  1863 	MOVF  array_5,W
034E 0084  1864 	MOVWF FSR0L
034F 0800  1865 	MOVF  INDF0,W
0350 2326  1866 	CALL  USARTsend
           1867 			;		array++;
0351 0AFF  1868 	INCF  array_5,1
           1869 			;	}
0352 0AFF  1870 	INCF  i_7,1
0353 2B48  1871 	GOTO  m051
           1872 			;}
0354 0008  1873 m052	RETURN
           1874 
           1875 	END
           1876 
           1877 
           1878 ; *** KEY INFO ***
           1879 
           1880 ; 0x02A5 P0    5 word(s)  0 % : RingBufInit
           1881 ; 0x02AA P0   12 word(s)  0 % : RingBufGet
           1882 ; 0x02B6 P0   21 word(s)  1 % : RingBufPut
           1883 ; 0x0313 P0   19 word(s)  0 % : USARTinit
           1884 ; 0x0326 P0   10 word(s)  0 % : USARTsend
           1885 ; 0x0330 P0   19 word(s)  0 % : USARTsend_str
           1886 ; 0x0343 P0   18 word(s)  0 % : USARTsend_arr
           1887 ; 0x01B6 P0   34 word(s)  1 % : EEPROM_WR
           1888 ; 0x01D8 P0   13 word(s)  0 % : EEPROM_RD
           1889 ; 0x01E5 P0   25 word(s)  1 % : EEPROM_WR_BLK
           1890 ; 0x01FE P0   22 word(s)  1 % : EEPROM_RD_BLK
           1891 ; 0x014D P0   40 word(s)  1 % : addCRC
           1892 ; 0x0175 P0   45 word(s)  2 % : CRC
           1893 ; 0x01A2 P0   20 word(s)  0 % : newCRC
           1894 ; 0x02CB P0   11 word(s)  0 % : spi_init
           1895 ; 0x02D6 P0   11 word(s)  0 % : spi_send
           1896 ; 0x02E1 P0   18 word(s)  0 % : spi_send_arr
           1897 ; 0x02F3 P0   32 word(s)  1 % : spi_send_ledbuf
           1898 ; 0x0214 P0   18 word(s)  0 % : ledstrip_init
           1899 ; 0x0226 P0   66 word(s)  3 % : ledstrip_set_color
           1900 ; 0x0268 P0   61 word(s)  2 % : sub_func_set_color
           1901 ; 0x0004 P0   14 word(s)  0 % : InterruptRoutine
           1902 ; 0x005A P0   54 word(s)  2 % : init_all
           1903 ; 0x0090 P0   24 word(s)  1 % : throw_errors
           1904 ; 0x00A8 P0  134 word(s)  6 % : get_commands
           1905 ; 0x012E P0   31 word(s)  1 % : execute_commands
           1906 ; 0x0055 P0    5 word(s)  0 % : main
           1907 ; 0x0012 P0   67 word(s)  3 % : _const1
           1908 
           1909 ; RAM usage: 162 bytes (25 local), 350 bytes free
           1910 ; Maximum call level: 3 (+2 for interrupt)
           1911 ;  Codepage 0 has  850 word(s) :  41 %
           1912 ;  Codepage 1 has    0 word(s) :   0 %
           1913 ;  Codepage 2 has    0 word(s) :   0 %
           1914 ;  Codepage 3 has    0 word(s) :   0 %
           1915 ; Total of 850 code words (10 %)
