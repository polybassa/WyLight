CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 1

ADDR CODE  LINE SOURCE

           0001 
           0002 ; CC5X Version 3.4E, Copyright (c) B Knudsen Data
           0003 ; C compiler for the PICmicro family
           0004 ; ************  28. May 2012  14:42  *************
           0005 
           0006 	processor  16F1936
           0007 	radix  DEC
           0008 
     0000  0009 INDF0       EQU   0x00
     0004  0010 FSR0        EQU   0x04
     0004  0011 FSR0L       EQU   0x04
     0005  0012 FSR0H       EQU   0x05
     0000  0013 Carry       EQU   0
     0002  0014 Zero_       EQU   2
     000E  0015 PORTC       EQU   0x0E
     008E  0016 TRISC       EQU   0x8E
     0099  0017 OSCCON      EQU   0x99
     0191  0018 EEADRL      EQU   0x191
     0192  0019 EEADRH      EQU   0x192
     0193  0020 EEDATL      EQU   0x193
     0194  0021 EEDATH      EQU   0x194
     0196  0022 EECON2      EQU   0x196
     0199  0023 RCREG       EQU   0x199
     019A  0024 TXREG       EQU   0x19A
     019B  0025 SPBRGL      EQU   0x19B
     019C  0026 SPBRGH      EQU   0x19C
     0211  0027 SSPBUF      EQU   0x211
     0006  0028 PEIE        EQU   6
     0007  0029 GIE         EQU   7
     0003  0030 SSPIF       EQU   3
     0004  0031 TXIF        EQU   4
     0005  0032 RCIF        EQU   5
     0005  0033 RCIE        EQU   5
     0000  0034 RD          EQU   0
     0001  0035 WR          EQU   1
     0002  0036 WREN        EQU   2
     0006  0037 CFGS        EQU   6
     0007  0038 EEPGD       EQU   7
     0003  0039 ADDEN       EQU   3
     0004  0040 CREN        EQU   4
     0006  0041 RX9         EQU   6
     0007  0042 SPEN        EQU   7
     0002  0043 BRGH        EQU   2
     0004  0044 SYNC        EQU   4
     0005  0045 TXEN        EQU   5
     0006  0046 TX9         EQU   6
     0003  0047 BRG16       EQU   3
     0006  0048 CKE         EQU   6
     0007  0049 SMP         EQU   7
     0001  0050 SSPM1       EQU   1
     0004  0051 CKP         EQU   4
     0005  0052 SSPEN       EQU   5
     0039  0053 gRingBuf    EQU   0x39
     004C  0054 gERROR      EQU   0x4C
     004D  0055 gCmdBuf     EQU   0x4D
     0020  0056 temp        EQU   0x20
     0025  0057 byte        EQU   0x25
     0026  0058 p_crcH      EQU   0x26
     0027  0059 p_crcL      EQU   0x27
     0028  0060 index       EQU   0x28
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 2

ADDR CODE  LINE SOURCE

     0029  0061 crcH        EQU   0x29
     002A  0062 crcL        EQU   0x2A
     007F  0063 data        EQU   0x7F
     007F  0064 length      EQU   0x7F
     007F  0065 crcH_out    EQU   0x7F
     007F  0066 crcL_out    EQU   0x7F
     007F  0067 crcH_2      EQU   0x7F
     007F  0068 crcL_2      EQU   0x7F
     007F  0069 i           EQU   0x7F
     007F  0070 byte_2      EQU   0x7F
     0025  0071 p_crcH_2    EQU   0x25
     0026  0072 p_crcL_2    EQU   0x26
     0030  0073 adress      EQU   0x30
     0031  0074 data_2      EQU   0x31
     0000  0075 GIE_status  EQU   0
     0035  0076 adress_2    EQU   0x35
     0036  0077 data_3      EQU   0x36
     0028  0078 array       EQU   0x28
     0029  0079 adress_3    EQU   0x29
     002A  0080 length_2    EQU   0x2A
     002B  0081 i_2         EQU   0x2B
     0030  0082 array_2     EQU   0x30
     0031  0083 adress_4    EQU   0x31
     0032  0084 length_3    EQU   0x32
     0033  0085 i_3         EQU   0x33
     0034  0086 temp_2      EQU   0x34
     0022  0087 k           EQU   0x22
     002D  0088 pCmd        EQU   0x2D
     002E  0089 address     EQU   0x2E
     002F  0090 r           EQU   0x2F
     0030  0091 g           EQU   0x30
     0031  0092 b           EQU   0x31
     0032  0093 k_2         EQU   0x32
     0033  0094 mask        EQU   0x33
     0025  0095 result      EQU   0x25
     0020  0096 value       EQU   0x20
     0021  0097 writeNext   EQU   0x21
     0038  0098 data_4      EQU   0x38
     007F  0099 array_3     EQU   0x7F
     007F  0100 length_4    EQU   0x7F
     007F  0101 i_4         EQU   0x7F
     0034  0102 array_4     EQU   0x34
     0036  0103 end         EQU   0x36
     0025  0104 ch          EQU   0x25
     0022  0105 string      EQU   0x22
     0023  0106 ps          EQU   0x23
     007F  0107 array_5     EQU   0x7F
     007F  0108 length_5    EQU   0x7F
     007F  0109 i_5         EQU   0x7F
     002D  0110 pDest       EQU   0x2D
     0000  0111 movePtr     EQU   0
     002E  0112 nextCmd     EQU   0x2E
     0025  0113 pSrc        EQU   0x25
     0026  0114 length_6    EQU   0x26
     0027  0115 nextCmd_2   EQU   0x27
     0022  0116 new_byte    EQU   0x22
     0023  0117 temp_3      EQU   0x23
     0024  0118 j           EQU   0x24
     0022  0119 nextCmd_3   EQU   0x22
     002C  0120 result_2    EQU   0x2C
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 3

ADDR CODE  LINE SOURCE

     0024  0121 ci          EQU   0x24
           0122 
0000 2863  0123 	GOTO main
           0124 
           0125   ; FILE main.c
           0126 			;//Nils Weiß 
           0127 			;//05.09.2011
           0128 			;//Compiler CC5x/
           0129 			;
           0130 			;#define NO_CRC
           0131 			;#pragma sharedAllocation
           0132 			;
           0133 			;//*********************** INCLUDEDATEIEN *********************************************
           0134 			;#include "platform.h"
           0135 			;#include "RingBuf.h"		//clean
           0136 			;#include "usart.h"			//clean
           0137 			;#include "eeprom.h"       	//clean 
           0138 			;#include "crc.h"			//clean
           0139 			;#include "commandstorage.h" //under construction
           0140 			;#include "ledstrip.h"		//clean
           0141 			;#include "spi.h"			//clean
           0142 			;#include "timer.h"			//under construction
           0143 			;#include "rn_171.h"
           0144 			;
           0145 			;//*********************** GLOBAL VARIABLES *******************************************
           0146 			;struct CommandBuffer gCmdBuf;
           0147 			;struct LedBuffer gLedBuf;
           0148 			;struct ErrorBits gERROR;
           0149 			;
           0150 			;#ifndef X86
           0151 			;//*********************** INTERRUPTSERVICEROUTINE ************************************
           0152 			;#pragma origin 4					//Adresse des Interrupts	
     0000  0153 	ORG 0x0004
           0154 			;interrupt InterruptRoutine(void)
           0155 			;{
           0156 InterruptRoutine
           0157 			;	if (RCIF)
0004 0020  0158 	MOVLB 0
0005 1E91  0159 	BTFSS 0x11,RCIF
0006 2811  0160 	GOTO  m002
           0161 			;	{
           0162 			;		if(!RingBufHasError) RingBufPut(RCREG);
0007 184B  0163 	BTFSC gRingBuf+18,0
0008 280D  0164 	GOTO  m001
0009 0023  0165 	MOVLB 3
000A 0819  0166 	MOVF  RCREG,W
000B 21DE  0167 	CALL  RingBufPut
           0168 			;		else 
000C 2811  0169 	GOTO  m002
           0170 			;		{
           0171 			;			//Register lesen um Schnittstellen Fehler zu vermeiden
           0172 			;			char temp = RCREG;
000D 0023  0173 m001	MOVLB 3
000E 0819  0174 	MOVF  RCREG,W
000F 0020  0175 	MOVLB 0
0010 00A0  0176 	MOVWF temp
           0177 			;		}
           0178 			;	}
           0179 			;}
0011 0009  0180 m002	RETFIE
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 4

ADDR CODE  LINE SOURCE

           0181 			;#endif /* #ifndef X86 */
           0182 			;
           0183 			;//*********************** FUNKTIONSPROTOTYPEN ****************************************
           0184 			;void init_all();
           0185 			;
           0186 			;//*********************** HAUPTPROGRAMM **********************************************
           0187 			;void main(void)
           0188 			;{
           0189 _const1
0012 0020  0190 	MOVLB 0
0013 00A4  0191 	MOVWF ci
0014 3000  0192 	MOVLW 0
0015 0023  0193 	MOVLB 3
0016 0092  0194 	MOVWF EEADRH
0017 0020  0195 	MOVLB 0
0018 0C24  0196 	RRF   ci,W
0019 397F  0197 	ANDLW 127
001A 3E2F  0198 	ADDLW 47
001B 0023  0199 	MOVLB 3
001C 0091  0200 	MOVWF EEADRL
001D 1803  0201 	BTFSC 0x03,Carry
001E 0A92  0202 	INCF  EEADRH,1
001F 0023  0203 	MOVLB 3
0020 1795  0204 	BSF   0x195,EEPGD
0021 1415  0205 	BSF   0x195,RD
0022 0000  0206 	NOP  
0023 0000  0207 	NOP  
0024 0020  0208 	MOVLB 0
0025 1824  0209 	BTFSC ci,0
0026 282B  0210 	GOTO  m003
0027 0023  0211 	MOVLB 3
0028 0813  0212 	MOVF  EEDATL,W
0029 397F  0213 	ANDLW 127
002A 0008  0214 	RETURN
002B 0023  0215 m003	MOVLB 3
002C 0D13  0216 	RLF   EEDATL,W
002D 0D14  0217 	RLF   EEDATH,W
002E 0008  0218 	RETURN
002F 22A0  0219 	DW    0x22A0
0030 2952  0220 	DW    0x2952
0031 294F  0221 	DW    0x294F
0032 103A  0222 	DW    0x103A
0033 32D2  0223 	DW    0x32D2
0034 32E3  0224 	DW    0x32E3
0035 3B69  0225 	DW    0x3B69
0036 3165  0226 	DW    0x3165
0037 3375  0227 	DW    0x3375
0038 32E6  0228 	DW    0x32E6
0039 1072  0229 	DW    0x1072
003A 3AE6  0230 	DW    0x3AE6
003B 366C  0231 	DW    0x366C
003C 1000  0232 	DW    0x1000
003D 2945  0233 	DW    0x2945
003E 27D2  0234 	DW    0x27D2
003F 1D52  0235 	DW    0x1D52
0040 21A0  0236 	DW    0x21A0
0041 21D2  0237 	DW    0x21D2
0042 21AD  0238 	DW    0x21AD
0043 32E8  0239 	DW    0x32E8
0044 35E3  0240 	DW    0x35E3
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 5

ADDR CODE  LINE SOURCE

0045 3320  0241 	DW    0x3320
0046 34E1  0242 	DW    0x34E1
0047 32EC  0243 	DW    0x32EC
0048 0064  0244 	DW    0x64
0049 22A0  0245 	DW    0x22A0
004A 2952  0246 	DW    0x2952
004B 294F  0247 	DW    0x294F
004C 103A  0248 	DW    0x103A
004D 22C5  0249 	DW    0x22C5
004E 2950  0250 	DW    0x2950
004F 26CF  0251 	DW    0x26CF
0050 34A0  0252 	DW    0x34A0
0051 1073  0253 	DW    0x1073
0052 3AE6  0254 	DW    0x3AE6
0053 366C  0255 	DW    0x366C
0054 3600  0256 	DW    0x3600
0055 30EF  0257 	DW    0x30EF
0056 1064  0258 	DW    0x1064
0057 37E3  0259 	DW    0x37E3
0058 336E  0260 	DW    0x336E
0059 33E9  0261 	DW    0x33E9
005A 375F  0262 	DW    0x375F
005B 3669  0263 	DW    0x3669
005C 0073  0264 	DW    0x73
005D 30F3  0265 	DW    0x30F3
005E 32F6  0266 	DW    0x32F6
005F 3900  0267 	DW    0x3900
0060 3165  0268 	DW    0x3165
0061 37EF  0269 	DW    0x37EF
0062 0074  0270 	DW    0x74
           0271 main
           0272 			;	init_all();
0063 2068  0273 	CALL  init_all
           0274 			;	//FactoryRestoreWLAN();
           0275 			;	//Rn171FactoryRestore();
           0276 			;	while(1)
           0277 			;	{
           0278 			;		throw_errors();
0064 214D  0279 m004	CALL  throw_errors
           0280 			;		commandstorage_get_commands();
0065 22BB  0281 	CALL  commandstorage_get_commands
           0282 			;		commandstorage_execute_commands();
0066 2338  0283 	CALL  commandstorage_execute_commands
           0284 			;	}
0067 2864  0285 	GOTO  m004
           0286 			;}
           0287 			;//*********************** UNTERPROGRAMME **********************************************
           0288 			;
           0289 			;void init_all()
           0290 			;{
           0291 init_all
           0292 			;	OsciInit();
0068 3072  0293 	MOVLW 114
0069 0021  0294 	MOVLB 1
006A 0099  0295 	MOVWF OSCCON
           0296 			;	RingBufInit();
006B 21CD  0297 	CALL  RingBufInit
           0298 			;	USARTinit();
006C 223B  0299 	CALL  USARTinit
           0300 			;	spi_init();
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 6

ADDR CODE  LINE SOURCE

006D 21F3  0301 	CALL  spi_init
           0302 			;	ledstrip_init();
006E 2166  0303 	CALL  ledstrip_init
           0304 			;	commandstorage_init();
006F 2352  0305 	CALL  commandstorage_init
           0306 			;	InitFET();
0070 0021  0307 	MOVLB 1
0071 100E  0308 	BCF   TRISC,0
           0309 			;	PowerOnLEDs();
0072 0020  0310 	MOVLB 0
0073 100E  0311 	BCF   PORTC,0
           0312 			;    
           0313 			;	ErrorInit();
0074 104C  0314 	BCF   gERROR,0
0075 10CC  0315 	BCF   gERROR,1
           0316 			;	ClearCmdBuf();	
0076 01CD  0317 	CLRF  gCmdBuf
0077 01CE  0318 	CLRF  gCmdBuf+1
           0319 			;	AllowInterrupts();
0078 0021  0320 	MOVLB 1
0079 1691  0321 	BSF   0x91,RCIE
007A 170B  0322 	BSF   0x0B,PEIE
007B 178B  0323 	BSF   0x0B,GIE
           0324 			;	
           0325 			;	// *** send ready after init
           0326 			;	USARTsend('R');
007C 3052  0327 	MOVLW 82
007D 224E  0328 	CALL  USARTsend
           0329 			;	USARTsend('D');
007E 3044  0330 	MOVLW 68
007F 224E  0331 	CALL  USARTsend
           0332 			;	USARTsend('Y');
0080 3059  0333 	MOVLW 89
0081 2A4E  0334 	GOTO  USARTsend
           0335 			;}
           0336 
           0337   ; FILE crc.c
           0338 			; // Include-Datei zum Erstellen von CRC Prüfsummen
           0339 			; //
           0340 			; //
           0341 			; // Nils Weiß
           0342 			; // 14.04.2012
           0343 			; // Compiler CC5x
           0344 			;
           0345 			;// 16-bit CCIT CRC
           0346 			;
           0347 			;void addCRC(char byte, char* p_crcH, char* p_crcL)
           0348 			;{
           0349 addCRC
           0350 			;	char index;
           0351 			;	char crcH,crcL;
           0352 			;	crcH = *p_crcH;
0082 0185  0353 	CLRF  FSR0H
0083 0020  0354 	MOVLB 0
0084 0826  0355 	MOVF  p_crcH,W
0085 0084  0356 	MOVWF FSR0L
0086 0800  0357 	MOVF  INDF0,W
0087 00A9  0358 	MOVWF crcH
           0359 			;	crcL = *p_crcL;
0088 0185  0360 	CLRF  FSR0H
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 7

ADDR CODE  LINE SOURCE

0089 0827  0361 	MOVF  p_crcL,W
008A 0084  0362 	MOVWF FSR0L
008B 0800  0363 	MOVF  INDF0,W
008C 00AA  0364 	MOVWF crcL
           0365 			;
           0366 			;	MOVF(byte,0);
008D 0825  0367 	MOVF  byte,W
           0368 			;	
           0369 			;	XORWF(crcH,0);
008E 0629  0370 	XORWF crcH,W
           0371 			;	MOVWF(index);
008F 00A8  0372 	MOVWF index
           0373 			;	ANDLW(0xf0);
0090 39F0  0374 	ANDLW 240
           0375 			;	SWAPF(index,1);
0091 0EA8  0376 	SWAPF index,1
           0377 			;	XORWF(index,1);
0092 06A8  0378 	XORWF index,1
           0379 			;	
           0380 			;	MOVF(index,0);
0093 0828  0381 	MOVF  index,W
           0382 			;	ANDLW(0xf0);
0094 39F0  0383 	ANDLW 240
           0384 			;	XORWF(crcL,0);
0095 062A  0385 	XORWF crcL,W
           0386 			;	MOVWF(crcH);
0096 00A9  0387 	MOVWF crcH
           0388 			;	
           0389 			;	RLF(index,0);
0097 0D28  0390 	RLF   index,W
           0391 			;	RLF(index,0);
0098 0D28  0392 	RLF   index,W
           0393 			;	XORWF(crcH,1);
0099 06A9  0394 	XORWF crcH,1
           0395 			;	ANDLW(0xe0);
009A 39E0  0396 	ANDLW 224
           0397 			;	XORWF(crcH,1);
009B 06A9  0398 	XORWF crcH,1
           0399 			;		
           0400 			;	SWAPF(index,1);
009C 0EA8  0401 	SWAPF index,1
           0402 			;	XORWF(index,0);
009D 0628  0403 	XORWF index,W
           0404 			;	MOVWF(crcL);
009E 00AA  0405 	MOVWF crcL
           0406 			;
           0407 			;	*p_crcH = crcH;
009F 0185  0408 	CLRF  FSR0H
00A0 0826  0409 	MOVF  p_crcH,W
00A1 0084  0410 	MOVWF FSR0L
00A2 0829  0411 	MOVF  crcH,W
00A3 0080  0412 	MOVWF INDF0
           0413 			;	*p_crcL = crcL;
00A4 0185  0414 	CLRF  FSR0H
00A5 0827  0415 	MOVF  p_crcL,W
00A6 0084  0416 	MOVWF FSR0L
00A7 082A  0417 	MOVF  crcL,W
00A8 0080  0418 	MOVWF INDF0
           0419 			;
           0420 			;}
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 8

ADDR CODE  LINE SOURCE

00A9 0008  0421 	RETURN
           0422 			;
           0423 			;void CRC(char *data, char length, char* crcH_out, char* crcL_out)
           0424 			;{
           0425 CRC
           0426 			;	if(!crcH_out)return;
00AA 08FF  0427 	MOVF  crcH_out,1
00AB 1903  0428 	BTFSC 0x03,Zero_
00AC 0008  0429 	RETURN
           0430 			;	if(!crcL_out)return;
00AD 08FF  0431 	MOVF  crcL_out,1
00AE 1903  0432 	BTFSC 0x03,Zero_
00AF 0008  0433 	RETURN
           0434 			;	if(!data)return;
00B0 08FF  0435 	MOVF  data,1
00B1 1903  0436 	BTFSC 0x03,Zero_
00B2 0008  0437 	RETURN
           0438 			;	char crcH,crcL,i,byte;
           0439 			;	crcH=0xff;
00B3 30FF  0440 	MOVLW 255
00B4 00FF  0441 	MOVWF crcH_2
           0442 			;	crcL=0xff;
00B5 30FF  0443 	MOVLW 255
00B6 00FF  0444 	MOVWF crcL_2
           0445 			;
           0446 			;	for(i=0;i<length;i++)
00B7 01FF  0447 	CLRF  i
00B8 087F  0448 m005	MOVF  length,W
00B9 027F  0449 	SUBWF i,W
00BA 1803  0450 	BTFSC 0x03,Carry
00BB 28CC  0451 	GOTO  m006
           0452 			;	{
           0453 			;		byte = data[i];
00BC 087F  0454 	MOVF  i,W
00BD 077F  0455 	ADDWF data,W
00BE 0084  0456 	MOVWF FSR0L
00BF 0185  0457 	CLRF  FSR0H
00C0 0800  0458 	MOVF  INDF0,W
00C1 00FF  0459 	MOVWF byte_2
           0460 			;		addCRC(byte,&crcH,&crcL);
00C2 087F  0461 	MOVF  byte_2,W
00C3 0020  0462 	MOVLB 0
00C4 00A5  0463 	MOVWF byte
00C5 307F  0464 	MOVLW 127
00C6 00A6  0465 	MOVWF p_crcH
00C7 307F  0466 	MOVLW 127
00C8 00A7  0467 	MOVWF p_crcL
00C9 2082  0468 	CALL  addCRC
           0469 			;	}
00CA 0AFF  0470 	INCF  i,1
00CB 28B8  0471 	GOTO  m005
           0472 			;	
           0473 			;	*crcH_out = crcH;
00CC 0185  0474 m006	CLRF  FSR0H
00CD 087F  0475 	MOVF  crcH_out,W
00CE 0084  0476 	MOVWF FSR0L
00CF 087F  0477 	MOVF  crcH_2,W
00D0 0080  0478 	MOVWF INDF0
           0479 			;	*crcL_out = crcL;
00D1 0185  0480 	CLRF  FSR0H
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 9

ADDR CODE  LINE SOURCE

00D2 087F  0481 	MOVF  crcL_out,W
00D3 0084  0482 	MOVWF FSR0L
00D4 087F  0483 	MOVF  crcL_2,W
00D5 0080  0484 	MOVWF INDF0
           0485 			;}
00D6 0008  0486 	RETURN
           0487 			;
           0488 			;void newCRC(char* p_crcH, char* p_crcL)
           0489 			;{
           0490 newCRC
           0491 			;    if(!p_crcH) return;
00D7 0020  0492 	MOVLB 0
00D8 08A5  0493 	MOVF  p_crcH_2,1
00D9 1903  0494 	BTFSC 0x03,Zero_
00DA 0008  0495 	RETURN
           0496 			;    if(!p_crcL) return;
00DB 0020  0497 	MOVLB 0
00DC 08A6  0498 	MOVF  p_crcL_2,1
00DD 1903  0499 	BTFSC 0x03,Zero_
00DE 0008  0500 	RETURN
           0501 			;    *p_crcH = 0xff;
00DF 0185  0502 	CLRF  FSR0H
00E0 0020  0503 	MOVLB 0
00E1 0825  0504 	MOVF  p_crcH_2,W
00E2 0084  0505 	MOVWF FSR0L
00E3 30FF  0506 	MOVLW 255
00E4 0080  0507 	MOVWF INDF0
           0508 			;    *p_crcL = 0xff;
00E5 0185  0509 	CLRF  FSR0H
00E6 0826  0510 	MOVF  p_crcL_2,W
00E7 0084  0511 	MOVWF FSR0L
00E8 30FF  0512 	MOVLW 255
00E9 0080  0513 	MOVWF INDF0
           0514 			;}
00EA 0008  0515 	RETURN
           0516 
           0517   ; FILE eeprom.c
           0518 			;//Funktionen für EEPROM-Zugriffe
           0519 			;
           0520 			;//Nils Weiß 
           0521 			;//05.09.2011
           0522 			;//Compiler CC5x
           0523 			;
           0524 			;#ifndef X86
           0525 			;//*********************** EEPROM BYTE SCHREIBEN  **********************************************
           0526 			;
           0527 			;void EEPROM_WR(char adress, char data)
           0528 			;{
           0529 EEPROM_WR
00EB 0020  0530 	MOVLB 0
00EC 00B1  0531 	MOVWF data_2
           0532 			;	bit GIE_status; 
           0533 			;	//EEADRH = (char)(adress<<8);
           0534 			;    EEADRL = (char)adress;        // Adresse in Adressregister übertragen
00ED 0830  0535 	MOVF  adress,W
00EE 0023  0536 	MOVLB 3
00EF 0091  0537 	MOVWF EEADRL
           0538 			;	EEDATL = data;          // Daten in Datenregister übertragen
00F0 0020  0539 	MOVLB 0
00F1 0831  0540 	MOVF  data_2,W
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 10

ADDR CODE  LINE SOURCE

00F2 0023  0541 	MOVLB 3
00F3 0093  0542 	MOVWF EEDATL
           0543 			;    CFGS = 0;
00F4 1315  0544 	BCF   0x195,CFGS
           0545 			;	EEPGD = 0;                // Auswahl: Programmspeicher lesen oder EEPROM
00F5 1395  0546 	BCF   0x195,EEPGD
           0547 			;    WREN = 1;                 // Schreiben ins EEPROM erlauben
00F6 1515  0548 	BSF   0x195,WREN
           0549 			;	GIE_status=GIE;			
00F7 0020  0550 	MOVLB 0
00F8 1032  0551 	BCF   0x32,GIE_status
00F9 1B8B  0552 	BTFSC 0x0B,GIE
00FA 1432  0553 	BSF   0x32,GIE_status
           0554 			;    GIE=0;                  // Interrups verbieten
00FB 138B  0555 	BCF   0x0B,GIE
           0556 			;    EECON2 = 0x55;
00FC 3055  0557 	MOVLW 85
00FD 0023  0558 	MOVLB 3
00FE 0096  0559 	MOVWF EECON2
           0560 			;    EECON2 = 0xAA;
00FF 30AA  0561 	MOVLW 170
0100 0096  0562 	MOVWF EECON2
           0563 			;	WR=1; 					// Starten des Schreibens
0101 1495  0564 	BSF   0x195,WR
           0565 			;    GIE=GIE_status;                  // Interrups erlauben
0102 0020  0566 	MOVLB 0
0103 1C32  0567 	BTFSS 0x32,GIE_status
0104 138B  0568 	BCF   0x0B,GIE
0105 1832  0569 	BTFSC 0x32,GIE_status
0106 178B  0570 	BSF   0x0B,GIE
           0571 			;	WREN=0;
0107 0023  0572 	MOVLB 3
0108 1115  0573 	BCF   0x195,WREN
           0574 			;	while(WR);
0109 0023  0575 m007	MOVLB 3
010A 1895  0576 	BTFSC 0x195,WR
010B 2909  0577 	GOTO  m007
           0578 			;}
010C 0008  0579 	RETURN
           0580 			;
           0581 			;//*********************** EEPROM BYTE LESEN  **********************************************
           0582 			;
           0583 			;char EEPROM_RD(char adress)
           0584 			;{
           0585 EEPROM_RD
010D 0020  0586 	MOVLB 0
010E 00B5  0587 	MOVWF adress_2
           0588 			;    char data;
           0589 			;    //EEADRH = (char)(adress<<8);        // Adresse in Adressregister übertragen
           0590 			;    EEADRL = (char)(adress);
010F 0835  0591 	MOVF  adress_2,W
0110 0023  0592 	MOVLB 3
0111 0091  0593 	MOVWF EEADRL
           0594 			;	CFGS=0;
0112 1315  0595 	BCF   0x195,CFGS
           0596 			;	EEPGD=0;                // Auswahl: Programmspeicher lesen oder EEPROM
0113 1395  0597 	BCF   0x195,EEPGD
           0598 			;    RD=1;                   // Starten des Lesesn
0114 1415  0599 	BSF   0x195,RD
           0600 			;    data = EEDATL;       // Daten aus Datenregister auslesen
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 11

ADDR CODE  LINE SOURCE

0115 0813  0601 	MOVF  EEDATL,W
0116 0020  0602 	MOVLB 0
0117 00B6  0603 	MOVWF data_3
           0604 			;    return data;
0118 0836  0605 	MOVF  data_3,W
0119 0008  0606 	RETURN
           0607 			;}
           0608 			;#endif /* #ifndef X86 */
           0609 			;
           0610 			;//*********************** EEPROM BYTEARRAY SCHREIBEN  **************************************
           0611 			;
           0612 			;void EEPROM_WR_BLK(char *array, char adress, char length)			//Zum Ausführen eines beliebigen Befehls durch den Programmcode
           0613 			;{
           0614 EEPROM_WR_BLK
011A 0020  0615 	MOVLB 0
011B 00AA  0616 	MOVWF length_2
           0617 			;	if(!array) return;
011C 08A8  0618 	MOVF  array,1
011D 1903  0619 	BTFSC 0x03,Zero_
011E 0008  0620 	RETURN
           0621 			;	char i;
           0622 			;	for(i=0;i<length;i++)
011F 0020  0623 	MOVLB 0
0120 01AB  0624 	CLRF  i_2
0121 0020  0625 m008	MOVLB 0
0122 082A  0626 	MOVF  length_2,W
0123 022B  0627 	SUBWF i_2,W
0124 1803  0628 	BTFSC 0x03,Carry
0125 2932  0629 	GOTO  m009
           0630 			;	{
           0631 			;		EEPROM_WR(adress,*array);
0126 0829  0632 	MOVF  adress_3,W
0127 00B0  0633 	MOVWF adress
0128 0185  0634 	CLRF  FSR0H
0129 0828  0635 	MOVF  array,W
012A 0084  0636 	MOVWF FSR0L
012B 0800  0637 	MOVF  INDF0,W
012C 20EB  0638 	CALL  EEPROM_WR
           0639 			;		adress++;
012D 0020  0640 	MOVLB 0
012E 0AA9  0641 	INCF  adress_3,1
           0642 			;		array++;
012F 0AA8  0643 	INCF  array,1
           0644 			;	}
0130 0AAB  0645 	INCF  i_2,1
0131 2921  0646 	GOTO  m008
           0647 			;}
0132 0008  0648 m009	RETURN
           0649 			;
           0650 			;//*********************** EEPROM BYTEARRAY LESEN  **************************************
           0651 			;
           0652 			;void EEPROM_RD_BLK(char *array, char adress, char length)			//Zum Ausführen eines beliebigen Befehls durch den Programmcode
           0653 			;{
           0654 EEPROM_RD_BLK
0133 0020  0655 	MOVLB 0
0134 00B2  0656 	MOVWF length_3
           0657 			;	if(!array) return;
0135 08B0  0658 	MOVF  array_2,1
0136 1903  0659 	BTFSC 0x03,Zero_
0137 0008  0660 	RETURN
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 12

ADDR CODE  LINE SOURCE

           0661 			;	char i, temp;
           0662 			;	for(i=0;i<length;i++)
0138 0020  0663 	MOVLB 0
0139 01B3  0664 	CLRF  i_3
013A 0020  0665 m010	MOVLB 0
013B 0832  0666 	MOVF  length_3,W
013C 0233  0667 	SUBWF i_3,W
013D 1803  0668 	BTFSC 0x03,Carry
013E 294C  0669 	GOTO  m011
           0670 			;	{
           0671 			;		temp = EEPROM_RD(adress);
013F 0831  0672 	MOVF  adress_4,W
0140 210D  0673 	CALL  EEPROM_RD
0141 0020  0674 	MOVLB 0
0142 00B4  0675 	MOVWF temp_2
           0676 			;		array[i] = temp;
0143 0833  0677 	MOVF  i_3,W
0144 0730  0678 	ADDWF array_2,W
0145 0084  0679 	MOVWF FSR0L
0146 0185  0680 	CLRF  FSR0H
0147 0834  0681 	MOVF  temp_2,W
0148 0080  0682 	MOVWF INDF0
           0683 			;		adress++;
0149 0AB1  0684 	INCF  adress_4,1
           0685 			;	}
014A 0AB3  0686 	INCF  i_3,1
014B 293A  0687 	GOTO  m010
           0688 			;}
014C 0008  0689 m011	RETURN
           0690 
           0691   ; FILE error.c
           0692 			;
           0693 			;#include "commandstorage.h"
           0694 			;#include "error.h"
           0695 			;#include "RingBuf.h"
           0696 			;#include "usart.h"
           0697 			;
           0698 			;void throw_errors()
           0699 			;{
           0700 throw_errors
           0701 			;	if(RingBufHasError) 
014D 0020  0702 	MOVLB 0
014E 1C4B  0703 	BTFSS gRingBuf+18,0
014F 2955  0704 	GOTO  m012
           0705 			;	{
           0706 			;		// *** if a RingBufError occure, I have to throw away the current command,
           0707 			;		// *** because the last byte was not saved. Commandstring is inconsistent
           0708 			;		ClearCmdBuf();
0150 01CD  0709 	CLRF  gCmdBuf
0151 01CE  0710 	CLRF  gCmdBuf+1
           0711 			;		USARTsend_str(" ERROR: Receivebuffer full");
0152 01A2  0712 	CLRF  string
0153 2258  0713 	CALL  USARTsend_str
           0714 			;		// *** Re-init the Ringbuffer to get a consistent commandstring and reset error
           0715 			;		RingBufInit();
0154 21CD  0716 	CALL  RingBufInit
           0717 			;	}
           0718 			;	if(gERROR.crc_failure)
0155 0020  0719 m012	MOVLB 0
0156 1C4C  0720 	BTFSS gERROR,0
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 13

ADDR CODE  LINE SOURCE

0157 295D  0721 	GOTO  m013
           0722 			;	{
           0723 			;		USARTsend_str(" ERROR: CRC-Check failed");
0158 301B  0724 	MOVLW 27
0159 00A2  0725 	MOVWF string
015A 2258  0726 	CALL  USARTsend_str
           0727 			;		gERROR.crc_failure = 0;
015B 0020  0728 	MOVLB 0
015C 104C  0729 	BCF   gERROR,0
           0730 			;	}
           0731 			;	if(gERROR.eeprom_failure)
015D 0020  0732 m013	MOVLB 0
015E 1CCC  0733 	BTFSS gERROR,1
015F 2965  0734 	GOTO  m014
           0735 			;	{
           0736 			;		USARTsend_str(" ERROR: EEPROM is full");
0160 3034  0737 	MOVLW 52
0161 00A2  0738 	MOVWF string
0162 2258  0739 	CALL  USARTsend_str
           0740 			;		gERROR.eeprom_failure = 0;
0163 0020  0741 	MOVLB 0
0164 10CC  0742 	BCF   gERROR,1
           0743 			;	}
           0744 			;}
0165 0008  0745 m014	RETURN
           0746 
           0747   ; FILE ledstrip.c
           0748 			;//Nils Weiß 
           0749 			;//20.04.2012
           0750 			;//Compiler CC5x 
           0751 			;
           0752 			;#include "ledstrip.h"
           0753 			;
           0754 			;void ledstrip_init(void)
           0755 			;{
           0756 ledstrip_init
           0757 			;	char k;
           0758 			;	for(k = 0;k < (NUM_OF_LED * 3); k++)
0166 0020  0759 	MOVLB 0
0167 01A2  0760 	CLRF  k
0168 3060  0761 m015	MOVLW 96
0169 0020  0762 	MOVLB 0
016A 0222  0763 	SUBWF k,W
016B 1803  0764 	BTFSC 0x03,Carry
016C 2977  0765 	GOTO  m016
           0766 			;	{	
           0767 			;		gLedBuf.led_array[k] = 0;
016D 3020  0768 	MOVLW 32
016E 0085  0769 	MOVWF FSR0+1
016F 3040  0770 	MOVLW 64
0170 0722  0771 	ADDWF k,W
0171 0084  0772 	MOVWF FSR0
0172 1803  0773 	BTFSC 0x03,Carry
0173 0A85  0774 	INCF  FSR0+1,1
0174 0180  0775 	CLRF  INDF0
           0776 			;	}
0175 0AA2  0777 	INCF  k,1
0176 2968  0778 	GOTO  m015
           0779 			;}
0177 0008  0780 m016	RETURN
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 14

ADDR CODE  LINE SOURCE

           0781 			;
           0782 			;/***
           0783 			;*** This funktion sets the values of the global LedBuffer
           0784 			;*** only Led's where the address bit is 1 will be set to the new color
           0785 			;***/
           0786 			;void ledstrip_set_color(struct cmd_set_color *pCmd)
           0787 			;{	
           0788 ledstrip_set_color
           0789 			;	char *address = pCmd->addr;
0178 0020  0790 	MOVLB 0
0179 082D  0791 	MOVF  pCmd,W
017A 00AE  0792 	MOVWF address
           0793 			;	char r = pCmd->red;
017B 3004  0794 	MOVLW 4
017C 072D  0795 	ADDWF pCmd,W
017D 0084  0796 	MOVWF FSR0L
017E 0185  0797 	CLRF  FSR0H
017F 0800  0798 	MOVF  INDF0,W
0180 00AF  0799 	MOVWF r
           0800 			;	char g = pCmd->green;
0181 3005  0801 	MOVLW 5
0182 072D  0802 	ADDWF pCmd,W
0183 0084  0803 	MOVWF FSR0L
0184 0185  0804 	CLRF  FSR0H
0185 0800  0805 	MOVF  INDF0,W
0186 00B0  0806 	MOVWF g
           0807 			;	char b = pCmd->blue;
0187 3006  0808 	MOVLW 6
0188 072D  0809 	ADDWF pCmd,W
0189 0084  0810 	MOVWF FSR0L
018A 0185  0811 	CLRF  FSR0H
018B 0800  0812 	MOVF  INDF0,W
018C 00B1  0813 	MOVWF b
           0814 			;	
           0815 			;	char k,mask;
           0816 			;	mask = 0b00000001;
018D 3001  0817 	MOVLW 1
018E 00B3  0818 	MOVWF mask
           0819 			;	for(k = 0; k < (NUM_OF_LED * 3); k++)
018F 01B2  0820 	CLRF  k_2
0190 3060  0821 m017	MOVLW 96
0191 0020  0822 	MOVLB 0
0192 0232  0823 	SUBWF k_2,W
0193 1803  0824 	BTFSC 0x03,Carry
0194 29C7  0825 	GOTO  m021
           0826 			;	{	
           0827 			;		if(0 != (*address & mask))
0195 0185  0828 	CLRF  FSR0H
0196 082E  0829 	MOVF  address,W
0197 0084  0830 	MOVWF FSR0L
0198 0833  0831 	MOVF  mask,W
0199 0500  0832 	ANDWF INDF0,W
019A 1903  0833 	BTFSC 0x03,Zero_
019B 29BA  0834 	GOTO  m018
           0835 			;		{
           0836 			;			gLedBuf.led_array[k] = b;
019C 3020  0837 	MOVLW 32
019D 0085  0838 	MOVWF FSR0+1
019E 3040  0839 	MOVLW 64
019F 0732  0840 	ADDWF k_2,W
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 15

ADDR CODE  LINE SOURCE

01A0 0084  0841 	MOVWF FSR0
01A1 1803  0842 	BTFSC 0x03,Carry
01A2 0A85  0843 	INCF  FSR0+1,1
01A3 0831  0844 	MOVF  b,W
01A4 0080  0845 	MOVWF INDF0
           0846 			;			k++;
01A5 0AB2  0847 	INCF  k_2,1
           0848 			;			gLedBuf.led_array[k] = g;
01A6 3020  0849 	MOVLW 32
01A7 0085  0850 	MOVWF FSR0+1
01A8 3040  0851 	MOVLW 64
01A9 0732  0852 	ADDWF k_2,W
01AA 0084  0853 	MOVWF FSR0
01AB 1803  0854 	BTFSC 0x03,Carry
01AC 0A85  0855 	INCF  FSR0+1,1
01AD 0830  0856 	MOVF  g,W
01AE 0080  0857 	MOVWF INDF0
           0858 			;			k++;
01AF 0AB2  0859 	INCF  k_2,1
           0860 			;			gLedBuf.led_array[k] = r;
01B0 3020  0861 	MOVLW 32
01B1 0085  0862 	MOVWF FSR0+1
01B2 3040  0863 	MOVLW 64
01B3 0732  0864 	ADDWF k_2,W
01B4 0084  0865 	MOVWF FSR0
01B5 1803  0866 	BTFSC 0x03,Carry
01B6 0A85  0867 	INCF  FSR0+1,1
01B7 082F  0868 	MOVF  r,W
01B8 0080  0869 	MOVWF INDF0
           0870 			;		}
           0871 			;		else 
01B9 29BD  0872 	GOTO  m019
           0873 			;		{
           0874 			;			k++;
01BA 0020  0875 m018	MOVLB 0
01BB 0AB2  0876 	INCF  k_2,1
           0877 			;			k++;
01BC 0AB2  0878 	INCF  k_2,1
           0879 			;		}
           0880 			;#ifdef X86
           0881 			;		mask = mask << 1;
           0882 			;		if(0 == mask)
           0883 			;#else
           0884 			;		RLF(mask,1);
01BD 0020  0885 m019	MOVLB 0
01BE 0DB3  0886 	RLF   mask,1
           0887 			;		if(Carry == 1) 
01BF 1C03  0888 	BTFSS 0x03,Carry
01C0 29C4  0889 	GOTO  m020
           0890 			;#endif
           0891 			;		{
           0892 			;			address++;
01C1 0AAE  0893 	INCF  address,1
           0894 			;			mask= 0b00000001;
01C2 3001  0895 	MOVLW 1
01C3 00B3  0896 	MOVWF mask
           0897 			;		}
           0898 			;	}
01C4 0020  0899 m020	MOVLB 0
01C5 0AB2  0900 	INCF  k_2,1
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 16

ADDR CODE  LINE SOURCE

01C6 2990  0901 	GOTO  m017
           0902 			;	spi_send_ledbuf(&gLedBuf.led_array[0]);
01C7 3040  0903 m021	MOVLW 64
01C8 0020  0904 	MOVLB 0
01C9 00B4  0905 	MOVWF array_4
01CA 3020  0906 	MOVLW 32
01CB 00B5  0907 	MOVWF array_4+1
01CC 2A1B  0908 	GOTO  spi_send_ledbuf
           0909 
           0910   ; FILE main.c
           0911 			;
           0912 			;// cc5xfree is a bit stupid so we include the other implementation files here
           0913 			;#ifndef X86
           0914 			;#include "crc.c"
           0915 			;#include "eeprom.c"
           0916 			;#include "error.c"
           0917 			;#include "ledstrip.c"
           0918 
           0919   ; FILE RingBuf.c
           0920 			;
           0921 			;#include "RingBuf.h"
           0922 			;
           0923 			;#ifndef X86
           0924 			;#message Global variables are defined in RingBuf.c
           0925 			;#endif /* #ifndef X86 */
           0926 			;struct RingBuffer gRingBuf;
           0927 			;
           0928 			;void RingBufInit(void)
           0929 			;{
           0930 RingBufInit
           0931 			;	gRingBuf.read = 0;
01CD 0020  0932 	MOVLB 0
01CE 01C9  0933 	CLRF  gRingBuf+16
           0934 			;	gRingBuf.write = 0;
01CF 01CA  0935 	CLRF  gRingBuf+17
           0936 			;	gRingBuf.error_full = 0;
01D0 104B  0937 	BCF   gRingBuf+18,0
           0938 			;}
01D1 0008  0939 	RETURN
           0940 			;
           0941 			;char RingBufGet(void)
           0942 			;{
           0943 RingBufGet
           0944 			;	char result = gRingBuf.data[gRingBuf.read];
01D2 3039  0945 	MOVLW 57
01D3 0020  0946 	MOVLB 0
01D4 0749  0947 	ADDWF gRingBuf+16,W
01D5 0084  0948 	MOVWF FSR0L
01D6 0185  0949 	CLRF  FSR0H
01D7 0800  0950 	MOVF  INDF0,W
01D8 00A5  0951 	MOVWF result
           0952 			;	gRingBuf.read = RingBufInc(gRingBuf.read);
01D9 0A49  0953 	INCF  gRingBuf+16,W
01DA 390F  0954 	ANDLW 15
01DB 00C9  0955 	MOVWF gRingBuf+16
           0956 			;	return result;
01DC 0825  0957 	MOVF  result,W
01DD 0008  0958 	RETURN
           0959 			;}
           0960 			;
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 17

ADDR CODE  LINE SOURCE

           0961 			;void RingBufPut(char value)
           0962 			;{
           0963 RingBufPut
01DE 0020  0964 	MOVLB 0
01DF 00A0  0965 	MOVWF value
           0966 			;	char writeNext = RingBufInc(gRingBuf.write);
01E0 0A4A  0967 	INCF  gRingBuf+17,W
01E1 390F  0968 	ANDLW 15
01E2 00A1  0969 	MOVWF writeNext
           0970 			;	if(writeNext != gRingBuf.read)
01E3 0821  0971 	MOVF  writeNext,W
01E4 0649  0972 	XORWF gRingBuf+16,W
01E5 1903  0973 	BTFSC 0x03,Zero_
01E6 29F0  0974 	GOTO  m022
           0975 			;	{
           0976 			;		gRingBuf.data[gRingBuf.write] = value;
01E7 3039  0977 	MOVLW 57
01E8 074A  0978 	ADDWF gRingBuf+17,W
01E9 0084  0979 	MOVWF FSR0L
01EA 0185  0980 	CLRF  FSR0H
01EB 0820  0981 	MOVF  value,W
01EC 0080  0982 	MOVWF INDF0
           0983 			;		gRingBuf.write = writeNext;
01ED 0821  0984 	MOVF  writeNext,W
01EE 00CA  0985 	MOVWF gRingBuf+17
           0986 			;	}
           0987 			;	else gRingBuf.error_full = 1;
01EF 29F2  0988 	GOTO  m023
01F0 0020  0989 m022	MOVLB 0
01F1 144B  0990 	BSF   gRingBuf+18,0
           0991 			;}
01F2 0008  0992 m023	RETURN
           0993 
           0994   ; FILE spi.c
           0995 			;//Nils Weiß 
           0996 			;//20.04.2012
           0997 			;//Compiler CC5x
           0998 			;
           0999 			;#include "ledstrip.h"
           1000 			;
           1001 			;#ifndef X86
           1002 			;void spi_init()
           1003 			;{
           1004 spi_init
           1005 			;	TRISC.3 = 0;        // Make port RC3 an output(SPI Clock)
01F3 0021  1006 	MOVLB 1
01F4 118E  1007 	BCF   TRISC,3
           1008 			;    TRISC.4 = 1;        // Make port RC4 an input(SPI Data In)
01F5 160E  1009 	BSF   TRISC,4
           1010 			;    TRISC.5 = 0;        // Make port RC5 an output(SPI Data Out)
01F6 128E  1011 	BCF   TRISC,5
           1012 			;	SSPM1 = 0;
01F7 0024  1013 	MOVLB 4
01F8 1095  1014 	BCF   0x215,SSPM1
           1015 			;	SMP = 0;
01F9 1394  1016 	BCF   0x214,SMP
           1017 			;	CKP = 1;
01FA 1615  1018 	BSF   0x215,CKP
           1019 			;	CKE = 0;
01FB 1314  1020 	BCF   0x214,CKE
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 18

ADDR CODE  LINE SOURCE

           1021 			;	SSPEN = 1;
01FC 1695  1022 	BSF   0x215,SSPEN
           1023 			;}
01FD 0008  1024 	RETURN
           1025 			;
           1026 			;char spi_send(char data)
           1027 			;{
           1028 spi_send
01FE 0020  1029 	MOVLB 0
01FF 00B8  1030 	MOVWF data_4
           1031 			;	SSPBUF = data;	
0200 0838  1032 	MOVF  data_4,W
0201 0024  1033 	MOVLB 4
0202 0091  1034 	MOVWF SSPBUF
           1035 			;	while(SSPIF == 0);
0203 0020  1036 m024	MOVLB 0
0204 1D91  1037 	BTFSS 0x11,SSPIF
0205 2A03  1038 	GOTO  m024
           1039 			;	return SSPBUF;
0206 0024  1040 	MOVLB 4
0207 0811  1041 	MOVF  SSPBUF,W
0208 0008  1042 	RETURN
           1043 			;}
           1044 			;#endif /* #ifndef X86 */
           1045 			;
           1046 			;/***
           1047 			;**	This function sends the array to the LED controller(WS2801)
           1048 			;**  it starts with the last byte to get a correct output
           1049 			;***/
           1050 			;void spi_send_arr(char *array, char length)
           1051 			;{
           1052 spi_send_arr
0209 00FF  1053 	MOVWF length_4
           1054 			;	if(array == 0) return;
020A 08FF  1055 	MOVF  array_3,1
020B 1903  1056 	BTFSC 0x03,Zero_
020C 0008  1057 	RETURN
           1058 			;	char i;
           1059 			;	for(i = length; i == 0; i-- )
020D 087F  1060 	MOVF  length_4,W
020E 00FF  1061 	MOVWF i_4
020F 08FF  1062 m025	MOVF  i_4,1
0210 1D03  1063 	BTFSS 0x03,Zero_
0211 2A1A  1064 	GOTO  m026
           1065 			;	{
           1066 			;		spi_send(array[i]);
0212 087F  1067 	MOVF  i_4,W
0213 077F  1068 	ADDWF array_3,W
0214 0084  1069 	MOVWF FSR0L
0215 0185  1070 	CLRF  FSR0H
0216 0800  1071 	MOVF  INDF0,W
0217 21FE  1072 	CALL  spi_send
           1073 			;	} 
0218 03FF  1074 	DECF  i_4,1
0219 2A0F  1075 	GOTO  m025
           1076 			;}
021A 0008  1077 m026	RETURN
           1078 			;
           1079 			;void spi_send_ledbuf(char *array)//!!! CHECK if GIE=0 during the sendroutine improves the result
           1080 			;{
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 19

ADDR CODE  LINE SOURCE

           1081 spi_send_ledbuf
           1082 			;	//array must be the address of the first byte
           1083 			;	char* end;
           1084 			;	//calculate where the end is
           1085 			;	end = array + (NUM_OF_LED * 3);
021B 0020  1086 	MOVLB 0
021C 0835  1087 	MOVF  array_4+1,W
021D 00B7  1088 	MOVWF end+1
021E 3060  1089 	MOVLW 96
021F 0734  1090 	ADDWF array_4,W
0220 00B6  1091 	MOVWF end
0221 1803  1092 	BTFSC 0x03,Carry
0222 0AB7  1093 	INCF  end+1,1
           1094 			;	//send all
           1095 			;	for(; array < end; array++)
0223 0020  1096 m027	MOVLB 0
0224 0837  1097 	MOVF  end+1,W
0225 0235  1098 	SUBWF array_4+1,W
0226 1C03  1099 	BTFSS 0x03,Carry
0227 2A2E  1100 	GOTO  m028
0228 1D03  1101 	BTFSS 0x03,Zero_
0229 2A3A  1102 	GOTO  m029
022A 0836  1103 	MOVF  end,W
022B 0234  1104 	SUBWF array_4,W
022C 1803  1105 	BTFSC 0x03,Carry
022D 2A3A  1106 	GOTO  m029
           1107 			;	{
           1108 			;		spi_send(*array);
022E 0020  1109 m028	MOVLB 0
022F 0835  1110 	MOVF  array_4+1,W
0230 0085  1111 	MOVWF FSR0H
0231 0834  1112 	MOVF  array_4,W
0232 0084  1113 	MOVWF FSR0L
0233 0800  1114 	MOVF  INDF0,W
0234 21FE  1115 	CALL  spi_send
           1116 			;	}
0235 0020  1117 	MOVLB 0
0236 0AB4  1118 	INCF  array_4,1
0237 1903  1119 	BTFSC 0x03,Zero_
0238 0AB5  1120 	INCF  array_4+1,1
0239 2A23  1121 	GOTO  m027
           1122 			;}
023A 0008  1123 m029	RETURN
           1124 
           1125   ; FILE usart.c
           1126 			;// Include-Datei für Serielle Kommunikation über Hardwaremodul des Pic
           1127 			; //
           1128 			; //
           1129 			; // Nils Weiß
           1130 			; // 29.11.2010
           1131 			; // Compiler CC5x
           1132 			;
           1133 			;#ifndef X86
           1134 			;//*******  Initialisierungs-Funktion  *************************************************
           1135 			;void USARTinit()
           1136 			;{
           1137 USARTinit
           1138 			;	//USART TX Pin als Ausgang
           1139 			;	TRISC.6 = 0;
023B 0021  1140 	MOVLB 1
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 20

ADDR CODE  LINE SOURCE

023C 130E  1141 	BCF   TRISC,6
           1142 			;
           1143 			;    BRGH=1;					// High Baudrate activated
023D 0023  1144 	MOVLB 3
023E 151E  1145 	BSF   0x19E,BRGH
           1146 			;	BRG16=0;
023F 119F  1147 	BCF   0x19F,BRG16
           1148 			;	SPBRGL=25;				// 19200 Bps @ 8 MHz Clock
0240 3019  1149 	MOVLW 25
0241 009B  1150 	MOVWF SPBRGL
           1151 			;	SPBRGH=0;
0242 019C  1152 	CLRF  SPBRGH
           1153 			;    SPEN = 1;               // Set_Serial_Pins;
0243 179D  1154 	BSF   0x19D,SPEN
           1155 			;    SYNC = 0;               // Set_Async_Mode;
0244 121E  1156 	BCF   0x19E,SYNC
           1157 			;    TX9 = 0;                // Set_8bit_Tx;
0245 131E  1158 	BCF   0x19E,TX9
           1159 			;    RX9 = 0;                // Set_8bit_Rx;
0246 131D  1160 	BCF   0x19D,RX9
           1161 			;    CREN = 1;               // Enable_Rx;
0247 161D  1162 	BSF   0x19D,CREN
           1163 			;    TXEN = 1;               // Enable_Tx;
0248 169E  1164 	BSF   0x19E,TXEN
           1165 			;    RCIE=1;                 // Rx Interrupt aus
0249 0021  1166 	MOVLB 1
024A 1691  1167 	BSF   0x91,RCIE
           1168 			;	ADDEN=0;				// Disable Adressdetection
024B 0023  1169 	MOVLB 3
024C 119D  1170 	BCF   0x19D,ADDEN
           1171 			;}
024D 0008  1172 	RETURN
           1173 			;
           1174 			;//*******  Sende-char-Funktion  *************************************************
           1175 			;void USARTsend(unsigned char ch)
           1176 			;{
           1177 USARTsend
024E 0020  1178 	MOVLB 0
024F 00A5  1179 	MOVWF ch
           1180 			;	while(!TXIF);
0250 0020  1181 m030	MOVLB 0
0251 1E11  1182 	BTFSS 0x11,TXIF
0252 2A50  1183 	GOTO  m030
           1184 			;	TXREG=ch;
0253 0020  1185 	MOVLB 0
0254 0825  1186 	MOVF  ch,W
0255 0023  1187 	MOVLB 3
0256 009A  1188 	MOVWF TXREG
           1189 			;}
0257 0008  1190 	RETURN
           1191 			;#endif /* #ifndef X86 */
           1192 			;
           1193 			;//*******  Sende-String-Funktion  *************************************************
           1194 			;void USARTsend_str(const char *string)
           1195 			;{
           1196 USARTsend_str
           1197 			; char ps;
           1198 			; ps = *string;
0258 0020  1199 	MOVLB 0
0259 0822  1200 	MOVF  string,W
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 21

ADDR CODE  LINE SOURCE

025A 2012  1201 	CALL  _const1
025B 0020  1202 	MOVLB 0
025C 00A3  1203 	MOVWF ps
           1204 			; while(ps > 0)
025D 0020  1205 m031	MOVLB 0
025E 08A3  1206 	MOVF  ps,1
025F 1903  1207 	BTFSC 0x03,Zero_
0260 2A6A  1208 	GOTO  m032
           1209 			;   {
           1210 			;    string++;
0261 0AA2  1211 	INCF  string,1
           1212 			;   	USARTsend(ps);
0262 0823  1213 	MOVF  ps,W
0263 224E  1214 	CALL  USARTsend
           1215 			;    ps = *string;
0264 0020  1216 	MOVLB 0
0265 0822  1217 	MOVF  string,W
0266 2012  1218 	CALL  _const1
0267 0020  1219 	MOVLB 0
0268 00A3  1220 	MOVWF ps
           1221 			;   }
0269 2A5D  1222 	GOTO  m031
           1223 			;}
026A 0008  1224 m032	RETURN
           1225 			;
           1226 			;//*******  Sende-Array-Funktion  *************************************************
           1227 			;void USARTsend_arr(char *array, char length)
           1228 			;{
           1229 USARTsend_arr
026B 00FF  1230 	MOVWF length_5
           1231 			;	if(array == 0) return;
026C 08FF  1232 	MOVF  array_5,1
026D 1903  1233 	BTFSC 0x03,Zero_
026E 0008  1234 	RETURN
           1235 			;	char i;
           1236 			;	for(i=0;i<length;i++)
026F 01FF  1237 	CLRF  i_5
0270 087F  1238 m033	MOVF  length_5,W
0271 027F  1239 	SUBWF i_5,W
0272 1803  1240 	BTFSC 0x03,Carry
0273 2A7C  1241 	GOTO  m034
           1242 			;	{
           1243 			;		USARTsend(*array);
0274 0185  1244 	CLRF  FSR0H
0275 087F  1245 	MOVF  array_5,W
0276 0084  1246 	MOVWF FSR0L
0277 0800  1247 	MOVF  INDF0,W
0278 224E  1248 	CALL  USARTsend
           1249 			;		array++;
0279 0AFF  1250 	INCF  array_5,1
           1251 			;	}
027A 0AFF  1252 	INCF  i_5,1
027B 2A70  1253 	GOTO  m033
           1254 			;}
027C 0008  1255 m034	RETURN
           1256 
           1257   ; FILE commandstorage.c
           1258 			;#include "platform.h"
           1259 			;#include "commandstorage.h"
           1260 			;
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 22

ADDR CODE  LINE SOURCE

           1261 			;struct led_cmd* commandstorage_read(struct led_cmd *pDest, bit movePtr)
           1262 			;{
           1263 commandstorage_read
           1264 			;	//check parameter
           1265 			;	if(0 == pDest) return 0;
027D 0020  1266 	MOVLB 0
027E 08AD  1267 	MOVF  pDest,1
027F 1903  1268 	BTFSC 0x03,Zero_
0280 3400  1269 	RETLW 0
           1270 			;
           1271 			;	//commands available in eeprom?
           1272 			;	char nextCmd = EEPROM_RD(CmdPointerAddr);
0281 30FF  1273 	MOVLW 255
0282 210D  1274 	CALL  EEPROM_RD
0283 0020  1275 	MOVLB 0
0284 00AE  1276 	MOVWF nextCmd
           1277 			;	if(0 == nextCmd) return 0;
0285 08AE  1278 	MOVF  nextCmd,1
0286 1903  1279 	BTFSC 0x03,Zero_
0287 3400  1280 	RETLW 0
           1281 			;
           1282 			;	//read command from eeprom
           1283 			;	EEPROM_RD_BLK((char*)pDest, (nextCmd - CmdWidth), CmdWidth);
0288 0020  1284 	MOVLB 0
0289 082D  1285 	MOVF  pDest,W
028A 00B0  1286 	MOVWF array_2
028B 300A  1287 	MOVLW 10
028C 022E  1288 	SUBWF nextCmd,W
028D 00B1  1289 	MOVWF adress_4
028E 300A  1290 	MOVLW 10
028F 2133  1291 	CALL  EEPROM_RD_BLK
           1292 			;
           1293 			;	//do we have to update the CmdPointer?
           1294 			;	if(movePtr)
0290 0020  1295 	MOVLB 0
0291 1C2F  1296 	BTFSS 0x2F,movePtr
0292 2A98  1297 	GOTO  m035
           1298 			;	{		
           1299 			;		EEPROM_WR(CmdPointerAddr, nextCmd - CmdWidth);
0293 30FF  1300 	MOVLW 255
0294 00B0  1301 	MOVWF adress
0295 300A  1302 	MOVLW 10
0296 022E  1303 	SUBWF nextCmd,W
0297 20EB  1304 	CALL  EEPROM_WR
           1305 			;	}
           1306 			;	return pDest;
0298 0020  1307 m035	MOVLB 0
0299 082D  1308 	MOVF  pDest,W
029A 0008  1309 	RETURN
           1310 			;}
           1311 			;
           1312 			;bit commandstorage_write(char *pSrc, char length)
           1313 			;{
           1314 commandstorage_write
029B 0020  1315 	MOVLB 0
029C 00A6  1316 	MOVWF length_6
           1317 			;	//check parameter
           1318 			;	if(0 == pSrc) return FALSE;
029D 08A5  1319 	MOVF  pSrc,1
029E 1D03  1320 	BTFSS 0x03,Zero_
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 23

ADDR CODE  LINE SOURCE

029F 2AA2  1321 	GOTO  m036
02A0 1003  1322 	BCF   0x03,Carry
02A1 0008  1323 	RETURN
           1324 			;	
           1325 			;	//enought free space in eeprom?
           1326 			;	char nextCmd = EEPROM_RD(CmdPointerAddr);
02A2 30FF  1327 m036	MOVLW 255
02A3 210D  1328 	CALL  EEPROM_RD
02A4 0020  1329 	MOVLB 0
02A5 00A7  1330 	MOVWF nextCmd_2
           1331 			;	if(nextCmd >= (CmdPointerAddr - CmdWidth)) return FALSE;
02A6 30F5  1332 	MOVLW 245
02A7 0227  1333 	SUBWF nextCmd_2,W
02A8 1C03  1334 	BTFSS 0x03,Carry
02A9 2AAC  1335 	GOTO  m037
02AA 1003  1336 	BCF   0x03,Carry
02AB 0008  1337 	RETURN
           1338 			;
           1339 			;	//increase the command pointer in eeprom
           1340 			;	EEPROM_WR(CmdPointerAddr,(nextCmd + CmdWidth));
02AC 30FF  1341 m037	MOVLW 255
02AD 0020  1342 	MOVLB 0
02AE 00B0  1343 	MOVWF adress
02AF 300A  1344 	MOVLW 10
02B0 0727  1345 	ADDWF nextCmd_2,W
02B1 20EB  1346 	CALL  EEPROM_WR
           1347 			;		
           1348 			;	//write data to eeprom
           1349 			;	EEPROM_WR_BLK(pSrc, nextCmd, length);
02B2 0020  1350 	MOVLB 0
02B3 0825  1351 	MOVF  pSrc,W
02B4 00A8  1352 	MOVWF array
02B5 0827  1353 	MOVF  nextCmd_2,W
02B6 00A9  1354 	MOVWF adress_3
02B7 0826  1355 	MOVF  length_6,W
02B8 211A  1356 	CALL  EEPROM_WR_BLK
           1357 			;		
           1358 			;	return TRUE;
02B9 1403  1359 	BSF   0x03,Carry
02BA 0008  1360 	RETURN
           1361 			;}
           1362 			;
           1363 			;void commandstorage_get_commands()
           1364 			;{	
           1365 commandstorage_get_commands
           1366 			;	if(RingBufHasError)
02BB 0020  1367 	MOVLB 0
02BC 1C4B  1368 	BTFSS gRingBuf+18,0
02BD 2AC0  1369 	GOTO  m038
           1370 			;	{
           1371 			;		// *** if a RingBufError occure, I have to throw away the current command,
           1372 			;		// *** because the last byte was not saved. Commandstring is inconsistent
           1373 			;		ClearCmdBuf();
02BE 01CD  1374 	CLRF  gCmdBuf
02BF 01CE  1375 	CLRF  gCmdBuf+1
           1376 			;	}
           1377 			;
           1378 			;	if(RingBufIsNotEmpty)
02C0 0020  1379 m038	MOVLB 0
02C1 084A  1380 	MOVF  gRingBuf+17,W
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 24

ADDR CODE  LINE SOURCE

02C2 0649  1381 	XORWF gRingBuf+16,W
02C3 1903  1382 	BTFSC 0x03,Zero_
02C4 2B37  1383 	GOTO  m047
           1384 			;	{
           1385 			;		// *** preload variables and 
           1386 			;		// *** get new_byte from ringbuffer
           1387 			;		char new_byte, temp, j;
           1388 			;		temp = 0;
02C5 01A3  1389 	CLRF  temp_3
           1390 			;		j = 0;
02C6 01A4  1391 	CLRF  j
           1392 			;		// *** get new byte
           1393 			;		new_byte = RingBufGet();	
02C7 21D2  1394 	CALL  RingBufGet
02C8 0020  1395 	MOVLB 0
02C9 00A2  1396 	MOVWF new_byte
           1397 			;		// *** do I wait for databytes?
           1398 			;		if(gCmdBuf.frame_counter == 0)
02CA 08CE  1399 	MOVF  gCmdBuf+1,1
02CB 1D03  1400 	BTFSS 0x03,Zero_
02CC 2AF8  1401 	GOTO  m040
           1402 			;		{
           1403 			;			// *** I don't wait for databytes
           1404 			;			// *** Do I receive a Start_of_Text sign
           1405 			;			if(new_byte == STX)
02CD 0F22  1406 	INCFSZ new_byte,W
02CE 2AE1  1407 	GOTO  m039
           1408 			;			{
           1409 			;				// *** increse the cmd_counter
           1410 			;				gCmdBuf.cmd_counter = 1;
02CF 3001  1411 	MOVLW 1
02D0 00CD  1412 	MOVWF gCmdBuf
           1413 			;				// *** Write the startsign at the begin of the buffer
           1414 			;				gCmdBuf.cmd_buf[0] = new_byte;
02D1 0822  1415 	MOVF  new_byte,W
02D2 00CF  1416 	MOVWF gCmdBuf+2
           1417 			;                // *** Reset crc Variables
           1418 			;                newCRC(&gCmdBuf.crcH, &gCmdBuf.crcL);
02D3 305E  1419 	MOVLW 94
02D4 00A5  1420 	MOVWF p_crcH_2
02D5 305F  1421 	MOVLW 95
02D6 00A6  1422 	MOVWF p_crcL_2
02D7 20D7  1423 	CALL  newCRC
           1424 			;                // *** add new_byte to crc checksum
           1425 			;                addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
02D8 0020  1426 	MOVLB 0
02D9 0822  1427 	MOVF  new_byte,W
02DA 00A5  1428 	MOVWF byte
02DB 305E  1429 	MOVLW 94
02DC 00A6  1430 	MOVWF p_crcH
02DD 305F  1431 	MOVLW 95
02DE 00A7  1432 	MOVWF p_crcL
02DF 2082  1433 	CALL  addCRC
           1434 			;			}
           1435 			;			else
02E0 2B37  1436 	GOTO  m047
           1437 			;			{	
           1438 			;				// *** to avoid arrayoverflow
           1439 			;				temp = FRAMELENGTH - 2;
02E1 300D  1440 m039	MOVLW 13
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 25

ADDR CODE  LINE SOURCE

02E2 0020  1441 	MOVLB 0
02E3 00A3  1442 	MOVWF temp_3
           1443 			;				// *** check if I get the framelength byte
           1444 			;				if((new_byte < temp) && (gCmdBuf.cmd_counter == 1))
02E4 0823  1445 	MOVF  temp_3,W
02E5 0222  1446 	SUBWF new_byte,W
02E6 1803  1447 	BTFSC 0x03,Carry
02E7 2B37  1448 	GOTO  m047
02E8 0B4D  1449 	DECFSZ gCmdBuf,W
02E9 2B37  1450 	GOTO  m047
           1451 			;				{
           1452 			;					gCmdBuf.frame_counter = new_byte;
02EA 0822  1453 	MOVF  new_byte,W
02EB 00CE  1454 	MOVWF gCmdBuf+1
           1455 			;					gCmdBuf.cmd_buf[1] = new_byte;
02EC 0822  1456 	MOVF  new_byte,W
02ED 00D0  1457 	MOVWF gCmdBuf+3
           1458 			;					gCmdBuf.cmd_counter = 2;
02EE 3002  1459 	MOVLW 2
02EF 00CD  1460 	MOVWF gCmdBuf
           1461 			;                    // *** add new_byte to crc checksum
           1462 			;                    addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
02F0 0822  1463 	MOVF  new_byte,W
02F1 00A5  1464 	MOVWF byte
02F2 305E  1465 	MOVLW 94
02F3 00A6  1466 	MOVWF p_crcH
02F4 305F  1467 	MOVLW 95
02F5 00A7  1468 	MOVWF p_crcL
02F6 2082  1469 	CALL  addCRC
           1470 			;				}
           1471 			;			}
           1472 			;		}
           1473 			;		else
02F7 2B37  1474 	GOTO  m047
           1475 			;		{
           1476 			;			// *** I wait for Databytes, so I save all bytes 
           1477 			;			// *** that I get until my framecounter is > 0
           1478 			;			gCmdBuf.cmd_buf[gCmdBuf.cmd_counter] = new_byte;
02F8 304F  1479 m040	MOVLW 79
02F9 0020  1480 	MOVLB 0
02FA 074D  1481 	ADDWF gCmdBuf,W
02FB 0084  1482 	MOVWF FSR0L
02FC 0185  1483 	CLRF  FSR0H
02FD 0822  1484 	MOVF  new_byte,W
02FE 0080  1485 	MOVWF INDF0
           1486 			;			gCmdBuf.cmd_counter++;
02FF 0ACD  1487 	INCF  gCmdBuf,1
           1488 			;			
           1489 			;            // *** add new_byte to crc checksum
           1490 			;			if(gCmdBuf.frame_counter > 2)
0300 3003  1491 	MOVLW 3
0301 024E  1492 	SUBWF gCmdBuf+1,W
0302 1C03  1493 	BTFSS 0x03,Carry
0303 2B0B  1494 	GOTO  m041
           1495 			;            addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
0304 0822  1496 	MOVF  new_byte,W
0305 00A5  1497 	MOVWF byte
0306 305E  1498 	MOVLW 94
0307 00A6  1499 	MOVWF p_crcH
0308 305F  1500 	MOVLW 95
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 26

ADDR CODE  LINE SOURCE

0309 00A7  1501 	MOVWF p_crcL
030A 2082  1502 	CALL  addCRC
           1503 			;			gCmdBuf.frame_counter--;
030B 0020  1504 m041	MOVLB 0
030C 0BCE  1505 	DECFSZ gCmdBuf+1,1
           1506 			;			// *** now I have to check if my framecounter is null.
           1507 			;			// *** If it's null my string is complete 
           1508 			;			// *** and I can give the string to the crc check function.
           1509 			;			if(gCmdBuf.frame_counter == 0)
030D 2B37  1510 	GOTO  m047
           1511 			;			{
           1512 			;#ifdef NO_CRC
           1513 			;				if(1==1)
           1514 			;#else
           1515 			;                // *** verify crc checksum
           1516 			;                if( (gCmdBuf.crcL == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 1]) &&
           1517 			;                    (gCmdBuf.crcH == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 2]) )
           1518 			;#endif
           1519 			;                {
           1520 			;					// *** Execute the simple Commands
           1521 			;					switch(gCmdBuf.cmd_buf[2])
030E 0851  1522 	MOVF  gCmdBuf+4,W
030F 3AF8  1523 	XORLW 248
0310 1903  1524 	BTFSC 0x03,Zero_
0311 2B19  1525 	GOTO  m042
0312 3A02  1526 	XORLW 2
0313 1903  1527 	BTFSC 0x03,Zero_
0314 2B1E  1528 	GOTO  m043
0315 3A03  1529 	XORLW 3
0316 1903  1530 	BTFSC 0x03,Zero_
0317 2B21  1531 	GOTO  m044
0318 2B24  1532 	GOTO  m045
           1533 			;					{
           1534 			;						case DELETE: 
           1535 			;							{
           1536 			;								EEPROM_WR(CmdPointerAddr,0);
0319 30FF  1537 m042	MOVLW 255
031A 0020  1538 	MOVLB 0
031B 00B0  1539 	MOVWF adress
031C 3000  1540 	MOVLW 0
031D 28EB  1541 	GOTO  EEPROM_WR
           1542 			;								return;
           1543 			;							}
           1544 			;#ifndef X86
           1545 			;						case SET_ON: 
           1546 			;							{
           1547 			;								PowerOnLEDs();
031E 0020  1548 m043	MOVLB 0
031F 100E  1549 	BCF   PORTC,0
           1550 			;								return;
0320 0008  1551 	RETURN
           1552 			;								}
           1553 			;						case SET_OFF: 
           1554 			;							{
           1555 			;								PowerOffLEDs();
0321 0020  1556 m044	MOVLB 0
0322 140E  1557 	BSF   PORTC,0
           1558 			;								return;
0323 0008  1559 	RETURN
           1560 			;							}
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 27

ADDR CODE  LINE SOURCE

           1561 			;#endif /* #ifndef X86 */
           1562 			;					}			
           1563 			;					if( commandstorage_write(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4)))
0324 3051  1564 m045	MOVLW 81
0325 0020  1565 	MOVLB 0
0326 00A5  1566 	MOVWF pSrc
0327 3004  1567 	MOVLW 4
0328 024D  1568 	SUBWF gCmdBuf,W
0329 229B  1569 	CALL  commandstorage_write
032A 1C03  1570 	BTFSS 0x03,Carry
032B 2B31  1571 	GOTO  m046
           1572 			;					{
           1573 			;						USARTsend('G');
032C 3047  1574 	MOVLW 71
032D 224E  1575 	CALL  USARTsend
           1576 			;						USARTsend('C');
032E 3043  1577 	MOVLW 67
032F 224E  1578 	CALL  USARTsend
           1579 			;					}
           1580 			;					else 
0330 2B37  1581 	GOTO  m047
           1582 			;						gERROR.eeprom_failure = 1;
0331 0020  1583 m046	MOVLB 0
0332 14CC  1584 	BSF   gERROR,1
           1585 			;#ifdef TEST
           1586 			;					USARTsend_arr(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4));
           1587 			;#endif
           1588 			;                }
           1589 			;                else
0333 2B37  1590 	GOTO  m047
           1591 			;                {
           1592 			;                    // *** Do some error handling in case of an CRC failure here
           1593 			;					gERROR.crc_failure = 1;
0334 0020  1594 	MOVLB 0
0335 144C  1595 	BSF   gERROR,0
           1596 			;                    return;
0336 0008  1597 	RETURN
           1598 			;                }
           1599 			;			}
           1600 			;		}
           1601 			;	}
           1602 			;}
0337 0008  1603 m047	RETURN
           1604 			;
           1605 			;void commandstorage_execute_commands()
           1606 			;{
           1607 commandstorage_execute_commands
           1608 			;	// *** get the pointer to commands in the EEPROM
           1609 			;	struct led_cmd nextCmd;
           1610 			;
           1611 			;	// read next command from eeprom and move command pointer in eeprom to the next command (TRUE)
           1612 			;	struct led_cmd *result = commandstorage_read(&nextCmd, TRUE);
0338 3022  1613 	MOVLW 34
0339 0020  1614 	MOVLB 0
033A 00AD  1615 	MOVWF pDest
033B 142F  1616 	BSF   0x2F,movePtr
033C 227D  1617 	CALL  commandstorage_read
033D 0020  1618 	MOVLB 0
033E 00AC  1619 	MOVWF result_2
           1620 			;	if(0 != result)
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 28

ADDR CODE  LINE SOURCE

033F 08AC  1621 	MOVF  result_2,1
0340 1903  1622 	BTFSC 0x03,Zero_
0341 2B51  1623 	GOTO  m049
           1624 			;	{
           1625 			;		// *** commands available, check what to do
           1626 			;		switch(nextCmd.cmd) 
0342 0822  1627 	MOVF  nextCmd_3,W
0343 3AFD  1628 	XORLW 253
0344 1903  1629 	BTFSC 0x03,Zero_
0345 2B4D  1630 	GOTO  m048
0346 3A01  1631 	XORLW 1
0347 1903  1632 	BTFSC 0x03,Zero_
0348 2B51  1633 	GOTO  m049
0349 3A07  1634 	XORLW 7
034A 1903  1635 	BTFSC 0x03,Zero_
034B 2B51  1636 	GOTO  m049
034C 2B51  1637 	GOTO  m049
           1638 			;		{	
           1639 			;			case SET_COLOR: 
           1640 			;			{
           1641 			;				ledstrip_set_color(&nextCmd.data.set_color);
034D 3023  1642 m048	MOVLW 35
034E 0020  1643 	MOVLB 0
034F 00AD  1644 	MOVWF pCmd
0350 2178  1645 	CALL  ledstrip_set_color
           1646 			;				break;
           1647 			;			}
           1648 			;			case SET_FADE: {break;}
           1649 			;			case SET_RUN: {break;}
           1650 			;		}
           1651 			;	}
           1652 			;}
0351 0008  1653 m049	RETURN
           1654 			;
           1655 			;void commandstorage_init()
           1656 			;{
           1657 commandstorage_init
           1658 			;	/** EEPROM contains FF in every cell after inital start,
           1659 			;	*** so I have to delete the pointer address
           1660 			;	*** otherwise the PIC thinks he has the EEPROM full with commands
           1661 			;	**/
           1662 			;	if (EEPROM_RD(CmdPointerAddr) == 0xff)
0352 30FF  1663 	MOVLW 255
0353 210D  1664 	CALL  EEPROM_RD
0354 3AFF  1665 	XORLW 255
0355 1D03  1666 	BTFSS 0x03,Zero_
0356 2B5C  1667 	GOTO  m050
           1668 			;		EEPROM_WR(CmdPointerAddr, 0);
0357 30FF  1669 	MOVLW 255
0358 0020  1670 	MOVLB 0
0359 00B0  1671 	MOVWF adress
035A 3000  1672 	MOVLW 0
035B 20EB  1673 	CALL  EEPROM_WR
           1674 			;
           1675 			;	// set loop pointer address to start
           1676 			;	EEPROM_WR(CmdLoopPointerAddr, 0);
035C 30FD  1677 m050	MOVLW 253
035D 0020  1678 	MOVLB 0
035E 00B0  1679 	MOVWF adress
035F 3000  1680 	MOVLW 0
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 29

ADDR CODE  LINE SOURCE

0360 28EB  1681 	GOTO  EEPROM_WR
           1682 			;}
           1683 
           1684   ; FILE rn_171.c
           1685 			;#include "usart.h"
           1686 			;#include "rn_171.h"
           1687 			;
           1688 			;void Rn171FactoryRestore()
           1689 			;{
           1690 Rn171FactoryRestore
           1691 			;	USARTsend('$');
0361 3024  1692 	MOVLW 36
0362 224E  1693 	CALL  USARTsend
           1694 			;	USARTsend('$');
0363 3024  1695 	MOVLW 36
0364 224E  1696 	CALL  USARTsend
           1697 			;	USARTsend('$');
0365 3024  1698 	MOVLW 36
0366 224E  1699 	CALL  USARTsend
           1700 			;	
           1701 			;	USARTsend_str("load config_nils");
0367 304B  1702 	MOVLW 75
0368 0020  1703 	MOVLB 0
0369 00A2  1704 	MOVWF string
036A 2258  1705 	CALL  USARTsend_str
           1706 			;	USARTsend_str("save");
036B 305C  1707 	MOVLW 92
036C 0020  1708 	MOVLB 0
036D 00A2  1709 	MOVWF string
036E 2258  1710 	CALL  USARTsend_str
           1711 			;	USARTsend_str("reboot");
036F 3061  1712 	MOVLW 97
0370 0020  1713 	MOVLB 0
0371 00A2  1714 	MOVWF string
0372 2A58  1715 	GOTO  USARTsend_str
           1716 
           1717   ; FILE main.c
           1718 			;#include "RingBuf.c"
           1719 			;#include "spi.c"
           1720 			;#include "timer.c"
           1721 			;#include "usart.c"
           1722 			;#include "commandstorage.c"
           1723 			;#include "rn_171.c"
           1724 
           1725 	END
           1726 
           1727 
           1728 ; *** KEY INFO ***
           1729 
           1730 ; 0x01CD P0    5 word(s)  0 % : RingBufInit
           1731 ; 0x01D2 P0   12 word(s)  0 % : RingBufGet
           1732 ; 0x01DE P0   21 word(s)  1 % : RingBufPut
           1733 ; 0x023B P0   19 word(s)  0 % : USARTinit
           1734 ; 0x024E P0   10 word(s)  0 % : USARTsend
           1735 ; 0x0258 P0   19 word(s)  0 % : USARTsend_str
           1736 ; 0x026B P0   18 word(s)  0 % : USARTsend_arr
           1737 ; 0x00EB P0   34 word(s)  1 % : EEPROM_WR
           1738 ; 0x010D P0   13 word(s)  0 % : EEPROM_RD
           1739 ; 0x011A P0   25 word(s)  1 % : EEPROM_WR_BLK
           1740 ; 0x0133 P0   26 word(s)  1 % : EEPROM_RD_BLK
CC5X Version 3.4E,   File: main.c              28. May 2012  14:42   Page 30

ADDR CODE  LINE SOURCE

           1741 ; 0x0082 P0   40 word(s)  1 % : addCRC
           1742 ; 0x00AA P0   45 word(s)  2 % : CRC
           1743 ; 0x00D7 P0   20 word(s)  0 % : newCRC
           1744 ; 0x014D P0   25 word(s)  1 % : throw_errors
           1745 ; 0x027D P0   30 word(s)  1 % : commandstorage_read
           1746 ; 0x029B P0   32 word(s)  1 % : commandstorage_write
           1747 ; 0x02BB P0  125 word(s)  6 % : commandstorage_get_commands
           1748 ; 0x0338 P0   26 word(s)  1 % : commandstorage_execute_commands
           1749 ; 0x0352 P0   15 word(s)  0 % : commandstorage_init
           1750 ; 0x01F3 P0   11 word(s)  0 % : spi_init
           1751 ; 0x01FE P0   11 word(s)  0 % : spi_send
           1752 ; 0x0209 P0   18 word(s)  0 % : spi_send_arr
           1753 ; 0x021B P0   32 word(s)  1 % : spi_send_ledbuf
           1754 ; 0x0166 P0   18 word(s)  0 % : ledstrip_init
           1755 ; 0x0178 P0   85 word(s)  4 % : ledstrip_set_color
           1756 ; 0x0361 P0   18 word(s)  0 % : Rn171FactoryRestore
           1757 ; 0x0004 P0   14 word(s)  0 % : InterruptRoutine
           1758 ; 0x0068 P0   26 word(s)  1 % : init_all
           1759 ; 0x0063 P0    5 word(s)  0 % : main
           1760 ; 0x0012 P0   81 word(s)  3 % : _const1
           1761 
           1762 ; RAM usage: 352 bytes (25 local), 160 bytes free
           1763 ; Maximum call level: 4 (+2 for interrupt)
           1764 ;  Codepage 0 has  880 word(s) :  42 %
           1765 ;  Codepage 1 has    0 word(s) :   0 %
           1766 ;  Codepage 2 has    0 word(s) :   0 %
           1767 ;  Codepage 3 has    0 word(s) :   0 %
           1768 ; Total of 880 code words (10 %)
