CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 1

ADDR CODE  LINE SOURCE

           0001 
           0002 ; CC5X Version 3.4E, Copyright (c) B Knudsen Data
           0003 ; C compiler for the PICmicro family
           0004 ; ************  25. Apr 2012  17:06  *************
           0005 
           0006 	processor  16F1936
           0007 	radix  DEC
           0008 
     0000  0009 INDF0       EQU   0x00
     0004  0010 FSR0        EQU   0x04
     0004  0011 FSR0L       EQU   0x04
     0005  0012 FSR0H       EQU   0x05
     0000  0013 Carry       EQU   0
     0002  0014 Zero_       EQU   2
     000E  0015 PORTC       EQU   0x0E
     008E  0016 TRISC       EQU   0x8E
     0099  0017 OSCCON      EQU   0x99
     0191  0018 EEADRL      EQU   0x191
     0192  0019 EEADRH      EQU   0x192
     0193  0020 EEDATL      EQU   0x193
     0196  0021 EECON2      EQU   0x196
     0199  0022 RCREG       EQU   0x199
     019A  0023 TXREG       EQU   0x19A
     019B  0024 SPBRGL      EQU   0x19B
     019C  0025 SPBRGH      EQU   0x19C
     0211  0026 SSPBUF      EQU   0x211
     0006  0027 PEIE        EQU   6
     0007  0028 GIE         EQU   7
     0003  0029 SSPIF       EQU   3
     0004  0030 TXIF        EQU   4
     0005  0031 RCIF        EQU   5
     0005  0032 RCIE        EQU   5
     0000  0033 RD          EQU   0
     0001  0034 WR          EQU   1
     0002  0035 WREN        EQU   2
     0006  0036 CFGS        EQU   6
     0007  0037 EEPGD       EQU   7
     0003  0038 ADDEN       EQU   3
     0004  0039 CREN        EQU   4
     0006  0040 RX9         EQU   6
     0007  0041 SPEN        EQU   7
     0002  0042 BRGH        EQU   2
     0004  0043 SYNC        EQU   4
     0005  0044 TXEN        EQU   5
     0006  0045 TX9         EQU   6
     0003  0046 BRG16       EQU   3
     0005  0047 SSPEN       EQU   5
     002B  0048 gRingBuf    EQU   0x2B
     0025  0049 result      EQU   0x25
     0020  0050 value       EQU   0x20
     0021  0051 writeNext   EQU   0x21
     0024  0052 ch          EQU   0x24
     0022  0053 putstr      EQU   0x22
     0023  0054 ps          EQU   0x23
     007F  0055 array       EQU   0x7F
     007F  0056 length      EQU   0x7F
     007F  0057 i           EQU   0x7F
     0026  0058 adress      EQU   0x26
     0027  0059 data        EQU   0x27
     0000  0060 GIE_status  EQU   0
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 2

ADDR CODE  LINE SOURCE

     0026  0061 adress_2    EQU   0x26
     0027  0062 data_2      EQU   0x27
     007F  0063 array_2     EQU   0x7F
     007F  0064 adress_3    EQU   0x7F
     007F  0065 length_2    EQU   0x7F
     007F  0066 i_2         EQU   0x7F
     007F  0067 array_3     EQU   0x7F
     007F  0068 adress_4    EQU   0x7F
     007F  0069 length_3    EQU   0x7F
     007F  0070 i_3         EQU   0x7F
     007F  0071 temp        EQU   0x7F
     0025  0072 byte        EQU   0x25
     0026  0073 p_crcH      EQU   0x26
     0027  0074 p_crcL      EQU   0x27
     0028  0075 index       EQU   0x28
     0029  0076 crcH        EQU   0x29
     002A  0077 crcL        EQU   0x2A
     007F  0078 data_3      EQU   0x7F
     007F  0079 length_4    EQU   0x7F
     007F  0080 crcH_out    EQU   0x7F
     007F  0081 crcL_out    EQU   0x7F
     007F  0082 crcH_2      EQU   0x7F
     007F  0083 crcL_2      EQU   0x7F
     007F  0084 i_4         EQU   0x7F
     007F  0085 byte_2      EQU   0x7F
     0025  0086 p_crcH_2    EQU   0x25
     0026  0087 p_crcL_2    EQU   0x26
     007F  0088 data_4      EQU   0x7F
     007F  0089 data_5      EQU   0x7F
     007F  0090 array_4     EQU   0x7F
     007F  0091 length_5    EQU   0x7F
     007F  0092 i_5         EQU   0x7F
     0023  0093 k           EQU   0x23
     007F  0094 red         EQU   0x7F
     007F  0095 green       EQU   0x7F
     007F  0096 blue        EQU   0x7F
     007F  0097 k_2         EQU   0x7F
     007F  0098 selector    EQU   0x7F
     003E  0099 gCmdBuf     EQU   0x3E
     0020  0100 temp_2      EQU   0x20
     0022  0101 i_6         EQU   0x22
     0022  0102 new_byte    EQU   0x22
     0023  0103 temp_3      EQU   0x23
     0024  0104 j           EQU   0x24
     0025  0105 CmdPointer  EQU   0x25
     0024  0106 ci          EQU   0x24
           0107 
0000 2814  0108 	GOTO main
           0109 
           0110   ; FILE main.c
           0111 			;//Nils Weiﬂ 
           0112 			;//05.09.2011
           0113 			;//Compiler CC5x/
           0114 			;//HELLO GIT 
           0115 			;#pragma sharedAllocation
           0116 			;
           0117 			;//Enumerationen definieren
           0118 			;#define TRUE  1
           0119 			;#define FALSE 0
           0120 			;
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 3

ADDR CODE  LINE SOURCE

           0121 			;#define STX 0xff
           0122 			;#define SET_COLOR 0xfd
           0123 			;#define SET_FADE 0xfc
           0124 			;#define SET_RUN 0xfb
           0125 			;
           0126 			;#define FRAMELENGTH 16			// *** max length of one commandframe
           0127 			;#define CmdPointerAddr 0xff		// *** Address at EERPOM, where the Commandpointer is saved
           0128 			;
           0129 			;//*********************** INCLUDEDATEIEN *********************************************
           0130 			;#pragma codepage 1
     0000  0131 	ORG 0x0800
           0132 
           0133   ; FILE include_files\RingBuf.c
           0134 			;
           0135 			;//#include "unused_files/RingBuf.h"
           0136 			;//#include "RingBuf.h"
           0137 			;
           0138 			;
           0139 			;#message Global variables are defined in RingBuf.c
           0140 			;
           0141 			;struct RingBuffer gRingBuf;
           0142 			;
           0143 			;void RingBufInit(void)
           0144 			;{
           0145 _const1
0800 0020  0146 	MOVLB 0
0801 00A4  0147 	MOVWF ci
0802 3019  0148 	MOVLW 25
0803 0224  0149 	SUBWF ci,W
0804 1803  0150 	BTFSC 0x03,Carry
0805 3400  0151 	RETLW 0
0806 0020  0152 	MOVLB 0
0807 0824  0153 	MOVF  ci,W
0808 000B  0154 	BRW  
0809 3445  0155 	RETLW 69
080A 3452  0156 	RETLW 82
080B 3452  0157 	RETLW 82
080C 344F  0158 	RETLW 79
080D 3452  0159 	RETLW 82
080E 343A  0160 	RETLW 58
080F 3452  0161 	RETLW 82
0810 3465  0162 	RETLW 101
0811 3463  0163 	RETLW 99
0812 3465  0164 	RETLW 101
0813 3469  0165 	RETLW 105
0814 3476  0166 	RETLW 118
0815 3465  0167 	RETLW 101
0816 3462  0168 	RETLW 98
0817 3475  0169 	RETLW 117
0818 3466  0170 	RETLW 102
0819 3466  0171 	RETLW 102
081A 3465  0172 	RETLW 101
081B 3472  0173 	RETLW 114
081C 3420  0174 	RETLW 32
081D 3466  0175 	RETLW 102
081E 3475  0176 	RETLW 117
081F 346C  0177 	RETLW 108
0820 346C  0178 	RETLW 108
0821 3400  0179 	RETLW 0
           0180 RingBufInit
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 4

ADDR CODE  LINE SOURCE

           0181 			;	gRingBuf.read = 0;
0822 0020  0182 	MOVLB 0
0823 01BB  0183 	CLRF  gRingBuf+16
           0184 			;	gRingBuf.write = 0;
0824 01BC  0185 	CLRF  gRingBuf+17
           0186 			;	gRingBuf.error_full = 0;
0825 103D  0187 	BCF   gRingBuf+18,0
           0188 			;}
0826 0008  0189 	RETURN
           0190 			;
           0191 			;char RingBufGet(void)
           0192 			;{
           0193 RingBufGet
           0194 			;	char result = gRingBuf.data[gRingBuf.read];
0827 302B  0195 	MOVLW 43
0828 0020  0196 	MOVLB 0
0829 073B  0197 	ADDWF gRingBuf+16,W
082A 0084  0198 	MOVWF FSR0L
082B 0185  0199 	CLRF  FSR0H
082C 0800  0200 	MOVF  INDF0,W
082D 00A5  0201 	MOVWF result
           0202 			;	gRingBuf.read = RingBufInc(gRingBuf.read);
082E 0A3B  0203 	INCF  gRingBuf+16,W
082F 390F  0204 	ANDLW 15
0830 00BB  0205 	MOVWF gRingBuf+16
           0206 			;	return result;
0831 0825  0207 	MOVF  result,W
0832 0008  0208 	RETURN
           0209 			;}
           0210 			;
           0211 			;void RingBufPut(char value)
           0212 			;{
           0213 RingBufPut
0833 0020  0214 	MOVLB 0
0834 00A0  0215 	MOVWF value
           0216 			;	char writeNext = RingBufInc(gRingBuf.write);
0835 0A3C  0217 	INCF  gRingBuf+17,W
0836 390F  0218 	ANDLW 15
0837 00A1  0219 	MOVWF writeNext
           0220 			;	if(writeNext != gRingBuf.read)
0838 0821  0221 	MOVF  writeNext,W
0839 063B  0222 	XORWF gRingBuf+16,W
083A 1903  0223 	BTFSC 0x03,Zero_
083B 2845  0224 	GOTO  m001
           0225 			;	{
           0226 			;		gRingBuf.data[gRingBuf.write] = value;
083C 302B  0227 	MOVLW 43
083D 073C  0228 	ADDWF gRingBuf+17,W
083E 0084  0229 	MOVWF FSR0L
083F 0185  0230 	CLRF  FSR0H
0840 0820  0231 	MOVF  value,W
0841 0080  0232 	MOVWF INDF0
           0233 			;		gRingBuf.write = writeNext;
0842 0821  0234 	MOVF  writeNext,W
0843 00BC  0235 	MOVWF gRingBuf+17
           0236 			;	}
           0237 			;	else gRingBuf.error_full = 1;
0844 2847  0238 	GOTO  m002
0845 0020  0239 m001	MOVLB 0
0846 143D  0240 	BSF   gRingBuf+18,0
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 5

ADDR CODE  LINE SOURCE

           0241 			;}
0847 0008  0242 m002	RETURN
           0243 
           0244   ; FILE include_files\usart.c
           0245 			;// Include-Datei f¸r Serielle Kommunikation ¸ber Hardwaremodul des Pic
           0246 			; //
           0247 			; //
           0248 			; // Nils Weiﬂ
           0249 			; // 29.11.2010
           0250 			; // Compiler CC5x
           0251 			;
           0252 			;//*******  Initialisierungs-Funktion  *************************************************
           0253 			;void USARTinit()
           0254 			;{
           0255 USARTinit
           0256 			;	//USART TX Pin als Ausgang
           0257 			;	TRISC.6 = 0;
0848 0021  0258 	MOVLB 1
0849 130E  0259 	BCF   TRISC,6
           0260 			;
           0261 			;    BRGH=1;					// High Baudrate activated
084A 0023  0262 	MOVLB 3
084B 151E  0263 	BSF   0x19E,BRGH
           0264 			;	BRG16=1;
084C 159F  0265 	BSF   0x19F,BRG16
           0266 			;	SPBRGL=68;				// 57600 Bps @ 16 MHz Clock
084D 3044  0267 	MOVLW 68
084E 009B  0268 	MOVWF SPBRGL
           0269 			;	SPBRGH=0;
084F 019C  0270 	CLRF  SPBRGH
           0271 			;    SPEN = 1;               // Set_Serial_Pins;
0850 179D  0272 	BSF   0x19D,SPEN
           0273 			;    SYNC = 0;               // Set_Async_Mode;
0851 121E  0274 	BCF   0x19E,SYNC
           0275 			;    TX9 = 0;                // Set_8bit_Tx;
0852 131E  0276 	BCF   0x19E,TX9
           0277 			;    RX9 = 0;                // Set_8bit_Rx;
0853 131D  0278 	BCF   0x19D,RX9
           0279 			;    CREN = 1;               // Enable_Rx;
0854 161D  0280 	BSF   0x19D,CREN
           0281 			;    TXEN = 1;               // Enable_Tx;
0855 169E  0282 	BSF   0x19E,TXEN
           0283 			;    RCIE=1;                 // Rx Interrupt aus
0856 0021  0284 	MOVLB 1
0857 1691  0285 	BSF   0x91,RCIE
           0286 			;	ADDEN=0;				// Disable Adressdetection
0858 0023  0287 	MOVLB 3
0859 119D  0288 	BCF   0x19D,ADDEN
           0289 			;}
085A 0008  0290 	RETURN
           0291 			;
           0292 			;//*******  Sende-char-Funktion  *************************************************
           0293 			;void USARTsend(unsigned char ch)
           0294 			;{
           0295 USARTsend
085B 0020  0296 	MOVLB 0
085C 00A4  0297 	MOVWF ch
           0298 			;	while(!TXIF);
085D 0020  0299 m003	MOVLB 0
085E 1E11  0300 	BTFSS 0x11,TXIF
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 6

ADDR CODE  LINE SOURCE

085F 285D  0301 	GOTO  m003
           0302 			;	TXREG=ch;
0860 0020  0303 	MOVLB 0
0861 0824  0304 	MOVF  ch,W
0862 0023  0305 	MOVLB 3
0863 009A  0306 	MOVWF TXREG
           0307 			;}
0864 0008  0308 	RETURN
           0309 			;
           0310 			;//*******  Sende-String-Funktion  *************************************************
           0311 			;void USARTsend_str(const char *putstr)
           0312 			;{
           0313 USARTsend_str
           0314 			; char ps;
           0315 			; ps = *putstr;
0865 0020  0316 	MOVLB 0
0866 0822  0317 	MOVF  putstr,W
0867 2000  0318 	CALL  _const1
0868 0020  0319 	MOVLB 0
0869 00A3  0320 	MOVWF ps
           0321 			;
           0322 			;  while(ps > 0)
086A 0020  0323 m004	MOVLB 0
086B 08A3  0324 	MOVF  ps,1
086C 1903  0325 	BTFSC 0x03,Zero_
086D 287B  0326 	GOTO  m005
           0327 			;   {
           0328 			;    putstr++;
086E 0AA2  0329 	INCF  putstr,1
           0330 			;    if (ps == 0) break;
086F 08A3  0331 	MOVF  ps,1
0870 1903  0332 	BTFSC 0x03,Zero_
0871 287B  0333 	GOTO  m005
           0334 			;   	USARTsend(ps);
0872 0020  0335 	MOVLB 0
0873 0823  0336 	MOVF  ps,W
0874 205B  0337 	CALL  USARTsend
           0338 			;    ps = *putstr;
0875 0020  0339 	MOVLB 0
0876 0822  0340 	MOVF  putstr,W
0877 2000  0341 	CALL  _const1
0878 0020  0342 	MOVLB 0
0879 00A3  0343 	MOVWF ps
           0344 			;   }
087A 286A  0345 	GOTO  m004
           0346 			;}
087B 0008  0347 m005	RETURN
           0348 			;
           0349 			;//*******  Sende-Array-Funktion  *************************************************
           0350 			;void USARTsend_arr(char *array, char length)
           0351 			;{
           0352 USARTsend_arr
087C 00FF  0353 	MOVWF length
           0354 			;	if(array == 0) return;
087D 08FF  0355 	MOVF  array,1
087E 1903  0356 	BTFSC 0x03,Zero_
087F 0008  0357 	RETURN
           0358 			;	char i;
           0359 			;	for(i=0;i<length;i++)
0880 01FF  0360 	CLRF  i
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 7

ADDR CODE  LINE SOURCE

0881 087F  0361 m006	MOVF  length,W
0882 027F  0362 	SUBWF i,W
0883 1803  0363 	BTFSC 0x03,Carry
0884 288D  0364 	GOTO  m007
           0365 			;	{
           0366 			;		USARTsend(*array);
0885 0185  0367 	CLRF  FSR0H
0886 087F  0368 	MOVF  array,W
0887 0084  0369 	MOVWF FSR0L
0888 0800  0370 	MOVF  INDF0,W
0889 205B  0371 	CALL  USARTsend
           0372 			;		array++;
088A 0AFF  0373 	INCF  array,1
           0374 			;	}
088B 0AFF  0375 	INCF  i,1
088C 2881  0376 	GOTO  m006
           0377 			;}
088D 0008  0378 m007	RETURN
           0379 
           0380   ; FILE include_files\eeprom_nt.c
           0381 			;//Funktionen f¸r EEPROM-Zugriffe
           0382 			;
           0383 			;//Nils Weiﬂ 
           0384 			;//05.09.2011
           0385 			;//Compiler CC5x
           0386 			;
           0387 			;//*********************** EEPROM BYTE SCHREIBEN  **********************************************
           0388 			;
           0389 			;void EEPROM_WR(int adress, char data)
           0390 			;{
           0391 EEPROM_WR
088E 0020  0392 	MOVLB 0
088F 00A7  0393 	MOVWF data
           0394 			;	bit GIE_status; 
           0395 			;	EEADRH = (char)(adress<<8);
0890 0023  0396 	MOVLB 3
0891 0192  0397 	CLRF  EEADRH
           0398 			;    EEADRL = (char)adress;        // Adresse in Adressregister ¸bertragen
0892 0020  0399 	MOVLB 0
0893 0826  0400 	MOVF  adress,W
0894 0023  0401 	MOVLB 3
0895 0091  0402 	MOVWF EEADRL
           0403 			;	EEDATL = data;          // Daten in Datenregister ¸bertragen
0896 0020  0404 	MOVLB 0
0897 0827  0405 	MOVF  data,W
0898 0023  0406 	MOVLB 3
0899 0093  0407 	MOVWF EEDATL
           0408 			;    CFGS = 0;
089A 1315  0409 	BCF   0x195,CFGS
           0410 			;	EEPGD = 0;                // Auswahl: Programmspeicher lesen oder EEPROM
089B 1395  0411 	BCF   0x195,EEPGD
           0412 			;    WREN = 1;                 // Schreiben ins EEPROM erlauben
089C 1515  0413 	BSF   0x195,WREN
           0414 			;	GIE_status=GIE;			
089D 0020  0415 	MOVLB 0
089E 1028  0416 	BCF   0x28,GIE_status
089F 1B8B  0417 	BTFSC 0x0B,GIE
08A0 1428  0418 	BSF   0x28,GIE_status
           0419 			;    GIE=0;                  // Interrups verbieten
08A1 138B  0420 	BCF   0x0B,GIE
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 8

ADDR CODE  LINE SOURCE

           0421 			;    EECON2 = 0x55;
08A2 3055  0422 	MOVLW 85
08A3 0023  0423 	MOVLB 3
08A4 0096  0424 	MOVWF EECON2
           0425 			;    EECON2 = 0xAA;
08A5 30AA  0426 	MOVLW 170
08A6 0096  0427 	MOVWF EECON2
           0428 			;	WR=1; 					// Starten des Schreibens
08A7 1495  0429 	BSF   0x195,WR
           0430 			;    GIE=GIE_status;                  // Interrups erlauben
08A8 0020  0431 	MOVLB 0
08A9 1C28  0432 	BTFSS 0x28,GIE_status
08AA 138B  0433 	BCF   0x0B,GIE
08AB 1828  0434 	BTFSC 0x28,GIE_status
08AC 178B  0435 	BSF   0x0B,GIE
           0436 			;	WREN=0;
08AD 0023  0437 	MOVLB 3
08AE 1115  0438 	BCF   0x195,WREN
           0439 			;	while(WR);
08AF 0023  0440 m008	MOVLB 3
08B0 1895  0441 	BTFSC 0x195,WR
08B1 28AF  0442 	GOTO  m008
           0443 			;}
08B2 0008  0444 	RETURN
           0445 			;
           0446 			;//*********************** EEPROM BYTE LESEN  **********************************************
           0447 			;
           0448 			;char EEPROM_RD(int adress)
           0449 			;{
           0450 EEPROM_RD
           0451 			;    char data;
           0452 			;    EEADRH = (char)(adress<<8);        // Adresse in Adressregister ¸bertragen
08B3 0023  0453 	MOVLB 3
08B4 0192  0454 	CLRF  EEADRH
           0455 			;    EEADRL = (char)(adress);
08B5 0020  0456 	MOVLB 0
08B6 0826  0457 	MOVF  adress_2,W
08B7 0023  0458 	MOVLB 3
08B8 0091  0459 	MOVWF EEADRL
           0460 			;	CFGS=0;
08B9 1315  0461 	BCF   0x195,CFGS
           0462 			;	EEPGD=0;                // Auswahl: Programmspeicher lesen oder EEPROM
08BA 1395  0463 	BCF   0x195,EEPGD
           0464 			;    RD=1;                   // Starten des Lesesn
08BB 1415  0465 	BSF   0x195,RD
           0466 			;    data = EEDATL;       // Daten aus Datenregister auslesen
08BC 0813  0467 	MOVF  EEDATL,W
08BD 0020  0468 	MOVLB 0
08BE 00A7  0469 	MOVWF data_2
           0470 			;    return data;
08BF 0827  0471 	MOVF  data_2,W
08C0 0008  0472 	RETURN
           0473 			;}
           0474 			;
           0475 			;//*********************** EEPROM BYTEARRAY SCHREIBEN  **************************************
           0476 			;
           0477 			;void EEPROM_WR_BLK(char *array, int adress, char length)			//Zum Ausf¸hren eines beliebigen Befehls durch den Programmcode
           0478 			;{
           0479 EEPROM_WR_BLK
08C1 00FF  0480 	MOVWF length_2
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 9

ADDR CODE  LINE SOURCE

           0481 			;	if(!array) return;
08C2 08FF  0482 	MOVF  array_2,1
08C3 1903  0483 	BTFSC 0x03,Zero_
08C4 0008  0484 	RETURN
           0485 			;	char i;
           0486 			;	for(i=0;i<length;i++)
08C5 01FF  0487 	CLRF  i_2
08C6 087F  0488 m009	MOVF  length_2,W
08C7 027F  0489 	SUBWF i_2,W
08C8 1803  0490 	BTFSC 0x03,Carry
08C9 28D6  0491 	GOTO  m010
           0492 			;	{
           0493 			;		EEPROM_WR(adress,*array);
08CA 087F  0494 	MOVF  adress_3,W
08CB 0020  0495 	MOVLB 0
08CC 00A6  0496 	MOVWF adress
08CD 0185  0497 	CLRF  FSR0H
08CE 087F  0498 	MOVF  array_2,W
08CF 0084  0499 	MOVWF FSR0L
08D0 0800  0500 	MOVF  INDF0,W
08D1 208E  0501 	CALL  EEPROM_WR
           0502 			;		adress++;
08D2 0AFF  0503 	INCF  adress_3,1
           0504 			;		array++;
08D3 0AFF  0505 	INCF  array_2,1
           0506 			;	}
08D4 0AFF  0507 	INCF  i_2,1
08D5 28C6  0508 	GOTO  m009
           0509 			;}
08D6 0008  0510 m010	RETURN
           0511 			;
           0512 			;//*********************** EEPROM BYTEARRAY LESEN  **************************************
           0513 			;
           0514 			;void EEPROM_RD_BLK(char *array, int adress, char length)			//Zum Ausf¸hren eines beliebigen Befehls durch den Programmcode
           0515 			;{
           0516 EEPROM_RD_BLK
08D7 00FF  0517 	MOVWF length_3
           0518 			;	if(!array) return;
08D8 08FF  0519 	MOVF  array_3,1
08D9 1903  0520 	BTFSC 0x03,Zero_
08DA 0008  0521 	RETURN
           0522 			;	char i, temp;
           0523 			;	for(i=0;i<length;i++)
08DB 01FF  0524 	CLRF  i_3
08DC 087F  0525 m011	MOVF  length_3,W
08DD 027F  0526 	SUBWF i_3,W
08DE 1803  0527 	BTFSC 0x03,Carry
08DF 28EE  0528 	GOTO  m012
           0529 			;	{
           0530 			;		temp = EEPROM_RD(adress);
08E0 087F  0531 	MOVF  adress_4,W
08E1 0020  0532 	MOVLB 0
08E2 00A6  0533 	MOVWF adress_2
08E3 20B3  0534 	CALL  EEPROM_RD
08E4 00FF  0535 	MOVWF temp
           0536 			;		array[i] = temp;
08E5 087F  0537 	MOVF  i_3,W
08E6 077F  0538 	ADDWF array_3,W
08E7 0084  0539 	MOVWF FSR0L
08E8 0185  0540 	CLRF  FSR0H
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 10

ADDR CODE  LINE SOURCE

08E9 087F  0541 	MOVF  temp,W
08EA 0080  0542 	MOVWF INDF0
           0543 			;		adress++;
08EB 0AFF  0544 	INCF  adress_4,1
           0545 			;	}
08EC 0AFF  0546 	INCF  i_3,1
08ED 28DC  0547 	GOTO  m011
           0548 
           0549   ; FILE main.c
           0550 			;#include "inline.h"
           0551 			;#include "include_files\Ringbuf.h"
           0552 			;#include "include_files\usart.h"
           0553 			;#include "include_files\eeprom_nt.c"        // 2do* Check EEPROM routines for failure, I use new routines now
08EE 0008  0554 m012	RETURN
           0555 
           0556   ; FILE include_files\crc.c
           0557 			; // Include-Datei zum Erstellen von CRC Pr¸fsummen
           0558 			; //
           0559 			; //
           0560 			; // Nils Weiﬂ
           0561 			; // 14.04.2012
           0562 			; // Compiler CC5x
           0563 			;
           0564 			;// 16-bit CCIT CRC
           0565 			;
           0566 			;void addCRC(char byte, char* p_crcH, char* p_crcL)
           0567 			;{
           0568 addCRC
           0569 			;	char index;
           0570 			;	char crcH,crcL;
           0571 			;	crcH = *p_crcH;
08EF 0185  0572 	CLRF  FSR0H
08F0 0020  0573 	MOVLB 0
08F1 0826  0574 	MOVF  p_crcH,W
08F2 0084  0575 	MOVWF FSR0L
08F3 0800  0576 	MOVF  INDF0,W
08F4 00A9  0577 	MOVWF crcH
           0578 			;	crcL = *p_crcL;
08F5 0185  0579 	CLRF  FSR0H
08F6 0827  0580 	MOVF  p_crcL,W
08F7 0084  0581 	MOVWF FSR0L
08F8 0800  0582 	MOVF  INDF0,W
08F9 00AA  0583 	MOVWF crcL
           0584 			;
           0585 			;	MOVF(byte,0);
08FA 0825  0586 	MOVF  byte,W
           0587 			;	
           0588 			;	XORWF(crcH,0);
08FB 0629  0589 	XORWF crcH,W
           0590 			;	MOVWF(index);
08FC 00A8  0591 	MOVWF index
           0592 			;	ANDLW(0xf0);
08FD 39F0  0593 	ANDLW 240
           0594 			;	SWAPF(index,1);
08FE 0EA8  0595 	SWAPF index,1
           0596 			;	XORWF(index,1);
08FF 06A8  0597 	XORWF index,1
           0598 			;	
           0599 			;	MOVF(index,0);
0900 0828  0600 	MOVF  index,W
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 11

ADDR CODE  LINE SOURCE

           0601 			;	ANDLW(0xf0);
0901 39F0  0602 	ANDLW 240
           0603 			;	XORWF(crcL,0);
0902 062A  0604 	XORWF crcL,W
           0605 			;	MOVWF(crcH);
0903 00A9  0606 	MOVWF crcH
           0607 			;	
           0608 			;	RLF(index,0);
0904 0D28  0609 	RLF   index,W
           0610 			;	RLF(index,0);
0905 0D28  0611 	RLF   index,W
           0612 			;	XORWF(crcH,1);
0906 06A9  0613 	XORWF crcH,1
           0614 			;	ANDLW(0xe0);
0907 39E0  0615 	ANDLW 224
           0616 			;	XORWF(crcH,1);
0908 06A9  0617 	XORWF crcH,1
           0618 			;		
           0619 			;	SWAPF(index,1);
0909 0EA8  0620 	SWAPF index,1
           0621 			;	XORWF(index,0);
090A 0628  0622 	XORWF index,W
           0623 			;	MOVWF(crcL);
090B 00AA  0624 	MOVWF crcL
           0625 			;
           0626 			;	*p_crcH = crcH;
090C 0185  0627 	CLRF  FSR0H
090D 0826  0628 	MOVF  p_crcH,W
090E 0084  0629 	MOVWF FSR0L
090F 0829  0630 	MOVF  crcH,W
0910 0080  0631 	MOVWF INDF0
           0632 			;	*p_crcL = crcL;
0911 0185  0633 	CLRF  FSR0H
0912 0827  0634 	MOVF  p_crcL,W
0913 0084  0635 	MOVWF FSR0L
0914 082A  0636 	MOVF  crcL,W
0915 0080  0637 	MOVWF INDF0
           0638 			;
           0639 			;}
0916 0008  0640 	RETURN
           0641 			;
           0642 			;void CRC(char *data, char length, char* crcH_out, char* crcL_out)
           0643 			;{
           0644 CRC
           0645 			;	if(!crcH_out)return;
0917 08FF  0646 	MOVF  crcH_out,1
0918 1903  0647 	BTFSC 0x03,Zero_
0919 0008  0648 	RETURN
           0649 			;	if(!crcL_out)return;
091A 08FF  0650 	MOVF  crcL_out,1
091B 1903  0651 	BTFSC 0x03,Zero_
091C 0008  0652 	RETURN
           0653 			;	if(!data)return;
091D 08FF  0654 	MOVF  data_3,1
091E 1903  0655 	BTFSC 0x03,Zero_
091F 0008  0656 	RETURN
           0657 			;	char crcH,crcL,i,byte;
           0658 			;	crcH=0xff;
0920 30FF  0659 	MOVLW 255
0921 00FF  0660 	MOVWF crcH_2
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 12

ADDR CODE  LINE SOURCE

           0661 			;	crcL=0xff;
0922 30FF  0662 	MOVLW 255
0923 00FF  0663 	MOVWF crcL_2
           0664 			;
           0665 			;	for(i=0;i<length;i++)
0924 01FF  0666 	CLRF  i_4
0925 087F  0667 m013	MOVF  length_4,W
0926 027F  0668 	SUBWF i_4,W
0927 1803  0669 	BTFSC 0x03,Carry
0928 2939  0670 	GOTO  m014
           0671 			;	{
           0672 			;		byte = data[i];
0929 087F  0673 	MOVF  i_4,W
092A 077F  0674 	ADDWF data_3,W
092B 0084  0675 	MOVWF FSR0L
092C 0185  0676 	CLRF  FSR0H
092D 0800  0677 	MOVF  INDF0,W
092E 00FF  0678 	MOVWF byte_2
           0679 			;		addCRC(byte,&crcH,&crcL);
092F 087F  0680 	MOVF  byte_2,W
0930 0020  0681 	MOVLB 0
0931 00A5  0682 	MOVWF byte
0932 307F  0683 	MOVLW 127
0933 00A6  0684 	MOVWF p_crcH
0934 307F  0685 	MOVLW 127
0935 00A7  0686 	MOVWF p_crcL
0936 20EF  0687 	CALL  addCRC
           0688 			;	}
0937 0AFF  0689 	INCF  i_4,1
0938 2925  0690 	GOTO  m013
           0691 			;	
           0692 			;	*crcH_out = crcH;
0939 0185  0693 m014	CLRF  FSR0H
093A 087F  0694 	MOVF  crcH_out,W
093B 0084  0695 	MOVWF FSR0L
093C 087F  0696 	MOVF  crcH_2,W
093D 0080  0697 	MOVWF INDF0
           0698 			;	*crcL_out = crcL;
093E 0185  0699 	CLRF  FSR0H
093F 087F  0700 	MOVF  crcL_out,W
0940 0084  0701 	MOVWF FSR0L
0941 087F  0702 	MOVF  crcL_2,W
0942 0080  0703 	MOVWF INDF0
           0704 			;}
0943 0008  0705 	RETURN
           0706 			;
           0707 			;void newCRC(char* p_crcH, char* p_crcL)
           0708 			;{
           0709 newCRC
           0710 			;    if(!p_crcH) return;
0944 0020  0711 	MOVLB 0
0945 08A5  0712 	MOVF  p_crcH_2,1
0946 1903  0713 	BTFSC 0x03,Zero_
0947 0008  0714 	RETURN
           0715 			;    if(!p_crcL) return;
0948 0020  0716 	MOVLB 0
0949 08A6  0717 	MOVF  p_crcL_2,1
094A 1903  0718 	BTFSC 0x03,Zero_
094B 0008  0719 	RETURN
           0720 			;    *p_crcH = 0xff;
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 13

ADDR CODE  LINE SOURCE

094C 0185  0721 	CLRF  FSR0H
094D 0020  0722 	MOVLB 0
094E 0825  0723 	MOVF  p_crcH_2,W
094F 0084  0724 	MOVWF FSR0L
0950 30FF  0725 	MOVLW 255
0951 0080  0726 	MOVWF INDF0
           0727 			;    *p_crcL = 0xff;
0952 0185  0728 	CLRF  FSR0H
0953 0826  0729 	MOVF  p_crcL_2,W
0954 0084  0730 	MOVWF FSR0L
0955 30FF  0731 	MOVLW 255
0956 0080  0732 	MOVWF INDF0
           0733 			;}
0957 0008  0734 	RETURN
           0735 
           0736   ; FILE include_files\spi.c
           0737 			;//Nils Weiﬂ 
           0738 			;//20.04.2012
           0739 			;//Compiler CC5x
           0740 			;void spi_init()
           0741 			;{
           0742 spi_init
           0743 			;	TRISC.3 = 0;        // Make port RC3 an output(SPI Clock)
0958 0021  0744 	MOVLB 1
0959 118E  0745 	BCF   TRISC,3
           0746 			;    TRISC.4 = 1;        // Make port RC4 an input(SPI Data In)
095A 160E  0747 	BSF   TRISC,4
           0748 			;    TRISC.5 = 0;        // Make port RC5 an output(SPI Data Out)
095B 128E  0749 	BCF   TRISC,5
           0750 			;    /* 
           0751 			;	SMP = 0;
           0752 			;	CKP = 0;
           0753 			;	CKE = 0;
           0754 			;	*/
           0755 			;	SSPEN = 1;
095C 0024  0756 	MOVLB 4
095D 1695  0757 	BSF   0x215,SSPEN
           0758 			;}
095E 0008  0759 	RETURN
           0760 			;
           0761 			;void spi_send(char data)
           0762 			;{
           0763 spi_send
095F 00FF  0764 	MOVWF data_4
           0765 			;	SSPBUF = data;	
0960 087F  0766 	MOVF  data_4,W
0961 0024  0767 	MOVLB 4
0962 0091  0768 	MOVWF SSPBUF
           0769 			;	while(SSPIF == 0);
0963 0020  0770 m015	MOVLB 0
0964 1D91  0771 	BTFSS 0x11,SSPIF
0965 2963  0772 	GOTO  m015
           0773 			;}
0966 0008  0774 	RETURN
           0775 			;
           0776 			;char spi_receive(char data)
           0777 			;{
           0778 spi_receive
0967 00FF  0779 	MOVWF data_5
           0780 			;	SSPBUF = data;	
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 14

ADDR CODE  LINE SOURCE

0968 087F  0781 	MOVF  data_5,W
0969 0024  0782 	MOVLB 4
096A 0091  0783 	MOVWF SSPBUF
           0784 			;	while(SSPIF == 0);
096B 0020  0785 m016	MOVLB 0
096C 1D91  0786 	BTFSS 0x11,SSPIF
096D 296B  0787 	GOTO  m016
           0788 			;	return SSPBUF;
096E 0024  0789 	MOVLB 4
096F 0811  0790 	MOVF  SSPBUF,W
0970 0008  0791 	RETURN
           0792 			;}
           0793 			;/***
           0794 			;**	This function sends the array to the LED controller(WS2801)
           0795 			;**  it starts with the last byte to get a correct output
           0796 			;***/
           0797 			;void spi_send_arr(char *array, char length)
           0798 			;{
           0799 spi_send_arr
0971 00FF  0800 	MOVWF length_5
           0801 			;	if(array == 0) return;
0972 087F  0802 	MOVF  array_4,W
0973 047F  0803 	IORWF array_4+1,W
0974 1903  0804 	BTFSC 0x03,Zero_
0975 0008  0805 	RETURN
           0806 			;	char i;
           0807 			;	for(i = (length - 1); i > 0; i-- )
0976 037F  0808 	DECF  length_5,W
0977 00FF  0809 	MOVWF i_5
0978 08FF  0810 m017	MOVF  i_5,1
0979 1903  0811 	BTFSC 0x03,Zero_
097A 2986  0812 	GOTO  m018
           0813 			;	{
           0814 			;		spi_send(array[i]);
097B 087F  0815 	MOVF  array_4+1,W
097C 0085  0816 	MOVWF FSR0+1
097D 087F  0817 	MOVF  i_5,W
097E 077F  0818 	ADDWF array_4,W
097F 0084  0819 	MOVWF FSR0
0980 1803  0820 	BTFSC 0x03,Carry
0981 0A85  0821 	INCF  FSR0+1,1
0982 0800  0822 	MOVF  INDF0,W
0983 215F  0823 	CALL  spi_send
           0824 			;	} 
0984 03FF  0825 	DECF  i_5,1
0985 2978  0826 	GOTO  m017
           0827 
           0828   ; FILE include_files\spi.h
           0829 			;#ifndef _SPI_H_
           0830 			;#define _SPI_H_
           0831 			;
           0832 			;//Nils Weiﬂ 
           0833 			;//20.04.2012
           0834 			;//Compiler CC5x
           0835 			;
           0836 			;void spi_init();
           0837 			;void spi_send(char data);
           0838 			;char spi_receive(char data);
           0839 			;void spi_send_arr(char *array, char length);
           0840 			;
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 15

ADDR CODE  LINE SOURCE

           0841 			;#include "include_files\spi.c"
0986 0008  0842 m018	RETURN
           0843 
           0844   ; FILE include_files\ledstrip.c
           0845 			;//Nils Weiﬂ 
           0846 			;//20.04.2012
           0847 			;//Compiler CC5x
           0848 			;
           0849 			;static struct LedBuffer gLedBuf;
           0850 			;
           0851 			;void ledstrip_init(void)
           0852 			;{
           0853 ledstrip_init
           0854 			;	char k;
           0855 			;	for(k = 0;k < BUFFERSIZE; k++)
0987 0020  0856 	MOVLB 0
0988 01A3  0857 	CLRF  k
0989 3060  0858 m019	MOVLW 96
098A 0020  0859 	MOVLB 0
098B 0223  0860 	SUBWF k,W
098C 1803  0861 	BTFSC 0x03,Carry
098D 29A0  0862 	GOTO  m020
           0863 			;	{
           0864 			;		gLedBuf.led_array[k] = 0;
098E 3020  0865 	MOVLW 32
098F 0085  0866 	MOVWF FSR0+1
0990 3032  0867 	MOVLW 50
0991 0723  0868 	ADDWF k,W
0992 0084  0869 	MOVWF FSR0
0993 1803  0870 	BTFSC 0x03,Carry
0994 0A85  0871 	INCF  FSR0+1,1
0995 0180  0872 	CLRF  INDF0
           0873 			;		gLedBuf.led_ctrl_array[k] = 0;
0996 3020  0874 	MOVLW 32
0997 0085  0875 	MOVWF FSR0+1
0998 3092  0876 	MOVLW 146
0999 0723  0877 	ADDWF k,W
099A 0084  0878 	MOVWF FSR0
099B 1803  0879 	BTFSC 0x03,Carry
099C 0A85  0880 	INCF  FSR0+1,1
099D 0180  0881 	CLRF  INDF0
           0882 			;	}
099E 0AA3  0883 	INCF  k,1
099F 2989  0884 	GOTO  m019
           0885 			;}
09A0 0008  0886 m020	RETURN
           0887 			;
           0888 			;void ledstrip_set_color(char red, char green, char blue)
           0889 			;{
           0890 ledstrip_set_color
09A1 00FF  0891 	MOVWF blue
           0892 			;	char k,selector;
           0893 			;	selector = 0;
09A2 01FF  0894 	CLRF  selector
           0895 			;	for(k = 0; k < BUFFERSIZE; k++)
09A3 01FF  0896 	CLRF  k_2
09A4 3060  0897 m021	MOVLW 96
09A5 027F  0898 	SUBWF k_2,W
09A6 1803  0899 	BTFSC 0x03,Carry
09A7 29D6  0900 	GOTO  m026
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 16

ADDR CODE  LINE SOURCE

           0901 			;	{	
           0902 			;		switch (selector)
09A8 087F  0903 	MOVF  selector,W
09A9 1903  0904 	BTFSC 0x03,Zero_
09AA 29B2  0905 	GOTO  m022
09AB 3A01  0906 	XORLW 1
09AC 1903  0907 	BTFSC 0x03,Zero_
09AD 29BE  0908 	GOTO  m023
09AE 3A03  0909 	XORLW 3
09AF 1903  0910 	BTFSC 0x03,Zero_
09B0 29CA  0911 	GOTO  m024
09B1 29D4  0912 	GOTO  m025
           0913 			;		{
           0914 			;			case 0: 
           0915 			;				{
           0916 			;					gLedBuf.led_array[k] = red;
09B2 3020  0917 m022	MOVLW 32
09B3 0085  0918 	MOVWF FSR0+1
09B4 3032  0919 	MOVLW 50
09B5 077F  0920 	ADDWF k_2,W
09B6 0084  0921 	MOVWF FSR0
09B7 1803  0922 	BTFSC 0x03,Carry
09B8 0A85  0923 	INCF  FSR0+1,1
09B9 087F  0924 	MOVF  red,W
09BA 0080  0925 	MOVWF INDF0
           0926 			;					selector = 1;
09BB 3001  0927 	MOVLW 1
09BC 00FF  0928 	MOVWF selector
           0929 			;				} break;
09BD 29D4  0930 	GOTO  m025
           0931 			;			case 1:
           0932 			;				{	
           0933 			;					gLedBuf.led_array[k] = green;
09BE 3020  0934 m023	MOVLW 32
09BF 0085  0935 	MOVWF FSR0+1
09C0 3032  0936 	MOVLW 50
09C1 077F  0937 	ADDWF k_2,W
09C2 0084  0938 	MOVWF FSR0
09C3 1803  0939 	BTFSC 0x03,Carry
09C4 0A85  0940 	INCF  FSR0+1,1
09C5 087F  0941 	MOVF  green,W
09C6 0080  0942 	MOVWF INDF0
           0943 			;					selector = 2;
09C7 3002  0944 	MOVLW 2
09C8 00FF  0945 	MOVWF selector
           0946 			;				}break;
09C9 29D4  0947 	GOTO  m025
           0948 			;			case 2:
           0949 			;				{
           0950 			;					gLedBuf.led_array[k] = blue;
09CA 3020  0951 m024	MOVLW 32
09CB 0085  0952 	MOVWF FSR0+1
09CC 3032  0953 	MOVLW 50
09CD 077F  0954 	ADDWF k_2,W
09CE 0084  0955 	MOVWF FSR0
09CF 1803  0956 	BTFSC 0x03,Carry
09D0 0A85  0957 	INCF  FSR0+1,1
09D1 087F  0958 	MOVF  blue,W
09D2 0080  0959 	MOVWF INDF0
           0960 			;					selector = 0;
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 17

ADDR CODE  LINE SOURCE

09D3 01FF  0961 	CLRF  selector
           0962 			;				}break;
           0963 			;		}
           0964 			;	}
09D4 0AFF  0965 m025	INCF  k_2,1
09D5 29A4  0966 	GOTO  m021
           0967 			;	spi_send_arr(&gLedBuf.led_array[0], BUFFERSIZE);
09D6 3032  0968 m026	MOVLW 50
09D7 00FF  0969 	MOVWF array_4
09D8 3020  0970 	MOVLW 32
09D9 00FF  0971 	MOVWF array_4+1
09DA 3060  0972 	MOVLW 96
09DB 2971  0973 	GOTO  spi_send_arr
           0974 
           0975   ; FILE include_files\ledstrip.h
           0976 			;#ifndef _LEDSTRIP_H_
           0977 			;#define _LEDSTRIP_H_
           0978 			;
           0979 			;//Nils Weiﬂ 
           0980 			;//20.04.2012
           0981 			;//Compiler CC5x
           0982 			;
           0983 			;#include "include_files\spi.h"
           0984 			;
           0985 			;#define NUM_OF_LED 32
           0986 			;#define BUFFERSIZE (NUM_OF_LED*3)
           0987 			;
           0988 			;struct LedBuffer{
           0989 			;	char led_array[BUFFERSIZE];
           0990 			;	char led_ctrl_array[BUFFERSIZE];
           0991 			;	};
           0992 			;extern struct LedBuffer gLedBuf;
           0993 			;
           0994 			;void ledstrip_init(void);
           0995 			;void ledstrip_set_color(char red, char green, char blue);
           0996 			;
           0997 			;#include "include_files\ledstrip.c"
           0998 
           0999   ; FILE main.c
           1000 			;#include "include_files\crc.c"
           1001 			;#include "include_files\spi.h"
           1002 			;#include "include_files\ledstrip.h"
           1003 			;
           1004 			;//*********************** GLOBAL VARIABLES *******************************************
           1005 			;struct CommandBuffer{
           1006 			;    char cmd_counter;
           1007 			;    char frame_counter;
           1008 			;    char cmd_buf[FRAMELENGTH];
           1009 			;    char crcH;
           1010 			;    char crcL;
           1011 			;};
           1012 			;static struct CommandBuffer gCmdBuf;	
           1013 			;
           1014 			;//*********************** INTERRUPTSERVICEROUTINE ************************************
           1015 			;#pragma origin 4					//Adresse des Interrupts	
     0000  1016 	ORG 0x0004
           1017 			;interrupt InterruptRoutine(void)
           1018 			;{
           1019 InterruptRoutine
           1020 			;	if (RCIF)
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 18

ADDR CODE  LINE SOURCE

0004 0020  1021 	MOVLB 0
0005 1E91  1022 	BTFSS 0x11,RCIF
0006 2813  1023 	GOTO  m028
           1024 			;	{
           1025 			;		if(!RingBufHasError) RingBufPut(RCREG);
0007 183D  1026 	BTFSC gRingBuf+18,0
0008 280F  1027 	GOTO  m027
0009 0023  1028 	MOVLB 3
000A 0819  1029 	MOVF  RCREG,W
000B 3188  1030 	MOVLP 8
000C 2033  1031 	CALL  RingBufPut
000D 3180  1032 	MOVLP 0
           1033 			;		else 
000E 2813  1034 	GOTO  m028
           1035 			;		{
           1036 			;			//Register lesen um Schnittstellen Fehler zu vermeiden
           1037 			;			char temp = RCREG;
000F 0023  1038 m027	MOVLB 3
0010 0819  1039 	MOVF  RCREG,W
0011 0020  1040 	MOVLB 0
0012 00A0  1041 	MOVWF temp_2
           1042 			;		}
           1043 			;	}
           1044 			;}
0013 0009  1045 m028	RETFIE
           1046 			;
           1047 			;//*********************** FUNKTIONSPROTOTYPEN ****************************************
           1048 			;void init_all();
           1049 			;void throw_errors();
           1050 			;void read_commands();
           1051 			;void execute_commands();
           1052 			;
           1053 			;//*********************** HAUPTPROGRAMM **********************************************
           1054 			;void main(void)
           1055 			;{
           1056 main
           1057 			;	init_all();
0014 2018  1058 	CALL  init_all
           1059 			;	
           1060 			;    while(1)
           1061 			;    {	
           1062 			;        throw_errors();
0015 203F  1063 m029	CALL  throw_errors
           1064 			;		read_commands();
0016 2047  1065 	CALL  read_commands
           1066 			;    }
0017 2815  1067 	GOTO  m029
           1068 			;}
           1069 			;//*********************** UNTERPROGRAMME **********************************************
           1070 			;
           1071 			;void init_all()
           1072 			;{
           1073 init_all
           1074 			;	//OSZILLATOR initialisieren: 4xPLL deactivated;INTOSC 16MHz
           1075 			;	OSCCON = 0b01111010;		
0018 307A  1076 	MOVLW 122
0019 0021  1077 	MOVLB 1
001A 0099  1078 	MOVWF OSCCON
           1079 			;	RingBufInit();
001B 3188  1080 	MOVLP 8
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 19

ADDR CODE  LINE SOURCE

001C 2022  1081 	CALL  RingBufInit
001D 3180  1082 	MOVLP 0
           1083 			;	//initialise UART interface
           1084 			;	USARTinit();
001E 3188  1085 	MOVLP 8
001F 2048  1086 	CALL  USARTinit
0020 3180  1087 	MOVLP 0
           1088 			;	spi_init();
0021 3188  1089 	MOVLP 8
0022 2158  1090 	CALL  spi_init
0023 3180  1091 	MOVLP 0
           1092 			;	ledstrip_init();
0024 3188  1093 	MOVLP 8
0025 2187  1094 	CALL  ledstrip_init
0026 3180  1095 	MOVLP 0
           1096 			;	
           1097 			;	//Ausgang f¸r FET initalisieren
           1098 			;	TRISC.0 = 0;
0027 0021  1099 	MOVLB 1
0028 100E  1100 	BCF   TRISC,0
           1101 			;	//Spannungsversorgung f¸r LED's einschalten
           1102 			;	PORTC.0 = 0;
0029 0020  1103 	MOVLB 0
002A 100E  1104 	BCF   PORTC,0
           1105 			;
           1106 			;	//To Factory Restore WLAN Modul
           1107 			;	//TRISA.0=0;
           1108 			;	//PORTA.0 = 1;
           1109 			;    
           1110 			;    // *** load globals variables
           1111 			;    
           1112 			;    gCmdBuf.cmd_counter = 0;
002B 01BE  1113 	CLRF  gCmdBuf
           1114 			;    gCmdBuf.frame_counter = 0;
002C 01BF  1115 	CLRF  gCmdBuf+1
           1116 			;	
           1117 			;	char i;
           1118 			;	for(i=0;i<FRAMELENGTH;i++)
002D 01A2  1119 	CLRF  i_6
002E 3010  1120 m030	MOVLW 16
002F 0020  1121 	MOVLB 0
0030 0222  1122 	SUBWF i_6,W
0031 1803  1123 	BTFSC 0x03,Carry
0032 283A  1124 	GOTO  m031
           1125 			;	{
           1126 			;        gCmdBuf.cmd_buf[i] = 0;
0033 3040  1127 	MOVLW 64
0034 0722  1128 	ADDWF i_6,W
0035 0084  1129 	MOVWF FSR0L
0036 0185  1130 	CLRF  FSR0H
0037 0180  1131 	CLRF  INDF0
           1132 			;	}
0038 0AA2  1133 	INCF  i_6,1
0039 282E  1134 	GOTO  m030
           1135 			;    
           1136 			;	// *** allow interrupts
           1137 			;	RCIE=1;
003A 0021  1138 m031	MOVLB 1
003B 1691  1139 	BSF   0x91,RCIE
           1140 			;	PEIE=1;
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 20

ADDR CODE  LINE SOURCE

003C 170B  1141 	BSF   0x0B,PEIE
           1142 			;	GIE=1;
003D 178B  1143 	BSF   0x0B,GIE
           1144 			;	
           1145 			;}
003E 0008  1146 	RETURN
           1147 			;
           1148 			;void throw_errors()
           1149 			;{
           1150 throw_errors
           1151 			;	if(RingBufHasError) 
003F 0020  1152 	MOVLB 0
0040 1C3D  1153 	BTFSS gRingBuf+18,0
0041 2846  1154 	GOTO  m032
           1155 			;	{
           1156 			;		USARTsend_str("ERROR:Receivebuffer full");
0042 01A2  1157 	CLRF  putstr
0043 3188  1158 	MOVLP 8
0044 2065  1159 	CALL  USARTsend_str
0045 3180  1160 	MOVLP 0
           1161 			;	}
           1162 			;}
0046 0008  1163 m032	RETURN
           1164 			;
           1165 			;/** This function reads one byte from the ringbuffer and check
           1166 			;*** for framestart, framelength, or databyte 
           1167 			;*** if a frame is complete, the function save the frame as a new
           1168 			;*** command in the internal EEPROM and calculate the Pointer for the next Command
           1169 			;**/
           1170 			;void read_commands()
           1171 			;{	
           1172 read_commands
           1173 			;	if(RingBufIsNotEmpty)
0047 0020  1174 	MOVLB 0
0048 083C  1175 	MOVF  gRingBuf+17,W
0049 063B  1176 	XORWF gRingBuf+16,W
004A 1903  1177 	BTFSC 0x03,Zero_
004B 28D8  1178 	GOTO  m039
           1179 			;	{
           1180 			;		// *** preload variables and 
           1181 			;		// *** get new_byte from ringbuffer
           1182 			;		char new_byte, temp, j;
           1183 			;		// *** get new byte
           1184 			;		new_byte = RingBufGet();	
004C 3188  1185 	MOVLP 8
004D 2027  1186 	CALL  RingBufGet
004E 3180  1187 	MOVLP 0
004F 0020  1188 	MOVLB 0
0050 00A2  1189 	MOVWF new_byte
           1190 			;		// *** do I wait for databytes?
           1191 			;		if(gCmdBuf.frame_counter == 0)
0051 08BF  1192 	MOVF  gCmdBuf+1,1
0052 1D03  1193 	BTFSS 0x03,Zero_
0053 2885  1194 	GOTO  m034
           1195 			;		{
           1196 			;			// *** I don't wait for databytes
           1197 			;			// *** Do I receive a Start_of_Text sign
           1198 			;			if(new_byte == STX)
0054 0F22  1199 	INCFSZ new_byte,W
0055 286C  1200 	GOTO  m033
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 21

ADDR CODE  LINE SOURCE

           1201 			;			{
           1202 			;				// *** Do some cleaning
           1203 			;				gCmdBuf.cmd_counter = 1;
0056 3001  1204 	MOVLW 1
0057 00BE  1205 	MOVWF gCmdBuf
           1206 			;				// *** Write the startsign at the begin of the buffer
           1207 			;				gCmdBuf.cmd_buf[0] = new_byte;
0058 0822  1208 	MOVF  new_byte,W
0059 00C0  1209 	MOVWF gCmdBuf+2
           1210 			;                // *** Reset crc Variables
           1211 			;                newCRC(&gCmdBuf.crcH, &gCmdBuf.crcL);
005A 3050  1212 	MOVLW 80
005B 00A5  1213 	MOVWF p_crcH_2
005C 3051  1214 	MOVLW 81
005D 00A6  1215 	MOVWF p_crcL_2
005E 3188  1216 	MOVLP 8
005F 2144  1217 	CALL  newCRC
0060 3180  1218 	MOVLP 0
           1219 			;                // *** add new_byte to crc checksum
           1220 			;                addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
0061 0020  1221 	MOVLB 0
0062 0822  1222 	MOVF  new_byte,W
0063 00A5  1223 	MOVWF byte
0064 3050  1224 	MOVLW 80
0065 00A6  1225 	MOVWF p_crcH
0066 3051  1226 	MOVLW 81
0067 00A7  1227 	MOVWF p_crcL
0068 3188  1228 	MOVLP 8
0069 20EF  1229 	CALL  addCRC
006A 3180  1230 	MOVLP 0
           1231 			;			}
           1232 			;			else
006B 28D8  1233 	GOTO  m039
           1234 			;			{	
           1235 			;				// *** to avoid arrayoverflow
           1236 			;				temp = FRAMELENGTH - 2;
006C 300E  1237 m033	MOVLW 14
006D 0020  1238 	MOVLB 0
006E 00A3  1239 	MOVWF temp_3
           1240 			;				// *** check if I get the framelength byte
           1241 			;				if((new_byte < temp) && (gCmdBuf.cmd_counter == 1))
006F 0823  1242 	MOVF  temp_3,W
0070 0222  1243 	SUBWF new_byte,W
0071 1803  1244 	BTFSC 0x03,Carry
0072 28D8  1245 	GOTO  m039
0073 0B3E  1246 	DECFSZ gCmdBuf,W
0074 28D8  1247 	GOTO  m039
           1248 			;				{
           1249 			;					gCmdBuf.frame_counter = new_byte;
0075 0822  1250 	MOVF  new_byte,W
0076 00BF  1251 	MOVWF gCmdBuf+1
           1252 			;					gCmdBuf.cmd_buf[1] = new_byte;
0077 0822  1253 	MOVF  new_byte,W
0078 00C1  1254 	MOVWF gCmdBuf+3
           1255 			;					gCmdBuf.cmd_counter = 2;
0079 3002  1256 	MOVLW 2
007A 00BE  1257 	MOVWF gCmdBuf
           1258 			;                    // *** add new_byte to crc checksum
           1259 			;                    addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
007B 0822  1260 	MOVF  new_byte,W
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 22

ADDR CODE  LINE SOURCE

007C 00A5  1261 	MOVWF byte
007D 3050  1262 	MOVLW 80
007E 00A6  1263 	MOVWF p_crcH
007F 3051  1264 	MOVLW 81
0080 00A7  1265 	MOVWF p_crcL
0081 3188  1266 	MOVLP 8
0082 20EF  1267 	CALL  addCRC
0083 3180  1268 	MOVLP 0
           1269 			;				}
           1270 			;			}
           1271 			;		}
           1272 			;		else
0084 28D8  1273 	GOTO  m039
           1274 			;		{
           1275 			;			// *** I wait for Databytes, so I save all bytes 
           1276 			;			// *** that I get until my framecounter is > 0
           1277 			;			gCmdBuf.cmd_buf[gCmdBuf.cmd_counter] = new_byte;
0085 3040  1278 m034	MOVLW 64
0086 0020  1279 	MOVLB 0
0087 073E  1280 	ADDWF gCmdBuf,W
0088 0084  1281 	MOVWF FSR0L
0089 0185  1282 	CLRF  FSR0H
008A 0822  1283 	MOVF  new_byte,W
008B 0080  1284 	MOVWF INDF0
           1285 			;			gCmdBuf.cmd_counter++;
008C 0ABE  1286 	INCF  gCmdBuf,1
           1287 			;			gCmdBuf.frame_counter--;
008D 03BF  1288 	DECF  gCmdBuf+1,1
           1289 			;            // *** add new_byte to crc checksum
           1290 			;            addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
008E 0822  1291 	MOVF  new_byte,W
008F 00A5  1292 	MOVWF byte
0090 3050  1293 	MOVLW 80
0091 00A6  1294 	MOVWF p_crcH
0092 3051  1295 	MOVLW 81
0093 00A7  1296 	MOVWF p_crcL
0094 3188  1297 	MOVLP 8
0095 20EF  1298 	CALL  addCRC
0096 3180  1299 	MOVLP 0
           1300 			;			// *** now I have to check if my framecounter is null.
           1301 			;			// *** If it's null my string is complete 
           1302 			;			// *** and I can give the string to the crc check function.
           1303 			;			if(gCmdBuf.frame_counter == 0)
0097 0020  1304 	MOVLB 0
0098 08BF  1305 	MOVF  gCmdBuf+1,1
0099 1D03  1306 	BTFSS 0x03,Zero_
009A 28D8  1307 	GOTO  m039
           1308 			;			{
           1309 			;                // *** verify crc checksum
           1310 			;                if( (gCmdBuf.crcL == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 1]) &&
009B 303F  1311 	MOVLW 63
009C 073E  1312 	ADDWF gCmdBuf,W
009D 0084  1313 	MOVWF FSR0L
009E 0185  1314 	CLRF  FSR0H
009F 0851  1315 	MOVF  gCmdBuf+19,W
00A0 0600  1316 	XORWF INDF0,W
00A1 1D03  1317 	BTFSS 0x03,Zero_
00A2 28D7  1318 	GOTO  m038
           1319 			;                    (gCmdBuf.crcH == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 2]) )
00A3 303E  1320 	MOVLW 62
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 23

ADDR CODE  LINE SOURCE

00A4 073E  1321 	ADDWF gCmdBuf,W
00A5 0084  1322 	MOVWF FSR0L
00A6 0185  1323 	CLRF  FSR0H
00A7 0850  1324 	MOVF  gCmdBuf+18,W
00A8 0600  1325 	XORWF INDF0,W
00A9 1D03  1326 	BTFSS 0x03,Zero_
00AA 28D7  1327 	GOTO  m038
           1328 			;                {
           1329 			;                    // *** copy new command             
           1330 			;                    // !!!*** ATTENTION check value of cmd_counter after if statement. 
           1331 			;                    // *** cmd_counter should point to crcL to copy only the command 
           1332 			;                    // *** whitout crc, STX and framelength
           1333 			;                    gCmdBuf.cmd_counter =- 2;
00AB 30FE  1334 	MOVLW 254
00AC 00BE  1335 	MOVWF gCmdBuf
           1336 			;                    
           1337 			;                    char CmdPointer = EEPROM_RD(CmdPointerAddr);
00AD 30FF  1338 	MOVLW 255
00AE 00A6  1339 	MOVWF adress_2
00AF 3188  1340 	MOVLP 8
00B0 20B3  1341 	CALL  EEPROM_RD
00B1 3180  1342 	MOVLP 0
00B2 0020  1343 	MOVLB 0
00B3 00A5  1344 	MOVWF CmdPointer
           1345 			;                    if(CmdPointer < 241)
00B4 30F1  1346 	MOVLW 241
00B5 0225  1347 	SUBWF CmdPointer,W
00B6 1803  1348 	BTFSC 0x03,Carry
00B7 28C0  1349 	GOTO  m035
           1350 			;                    {
           1351 			;                        // *** calculate the next address for EEPROM write
           1352 			;                        EEPROM_WR(CmdPointerAddr,CmdPointer + 10);
00B8 30FF  1353 	MOVLW 255
00B9 00A6  1354 	MOVWF adress
00BA 300A  1355 	MOVLW 10
00BB 0725  1356 	ADDWF CmdPointer,W
00BC 3188  1357 	MOVLP 8
00BD 208E  1358 	CALL  EEPROM_WR
00BE 3180  1359 	MOVLP 0
           1360 			;                    }
           1361 			;                    else 
00BF 28C1  1362 	GOTO  m036
           1363 			;                    {
           1364 			;                        // *** EEPROM is full with commands
           1365 			;                        // *** Some errorhandling should be here
           1366 			;                        return;
00C0 0008  1367 m035	RETURN
           1368 			;                    }
           1369 			;                        
           1370 			;                    
           1371 			;                    for(j = 2;j < gCmdBuf.cmd_counter; j++)
00C1 3002  1372 m036	MOVLW 2
00C2 0020  1373 	MOVLB 0
00C3 00A4  1374 	MOVWF j
00C4 0020  1375 m037	MOVLB 0
00C5 083E  1376 	MOVF  gCmdBuf,W
00C6 0224  1377 	SUBWF j,W
00C7 1803  1378 	BTFSC 0x03,Carry
00C8 28D8  1379 	GOTO  m039
           1380 			;                    {	
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 24

ADDR CODE  LINE SOURCE

           1381 			;                        EEPROM_WR(CmdPointer, gCmdBuf.cmd_buf[j]);
00C9 0825  1382 	MOVF  CmdPointer,W
00CA 00A6  1383 	MOVWF adress
00CB 3040  1384 	MOVLW 64
00CC 0724  1385 	ADDWF j,W
00CD 0084  1386 	MOVWF FSR0L
00CE 0185  1387 	CLRF  FSR0H
00CF 0800  1388 	MOVF  INDF0,W
00D0 3188  1389 	MOVLP 8
00D1 208E  1390 	CALL  EEPROM_WR
00D2 3180  1391 	MOVLP 0
           1392 			;                        CmdPointer ++;
00D3 0020  1393 	MOVLB 0
00D4 0AA5  1394 	INCF  CmdPointer,1
           1395 			;                    }
00D5 0AA4  1396 	INCF  j,1
00D6 28C4  1397 	GOTO  m037
           1398 			;                }
           1399 			;                else
           1400 			;                {
           1401 			;                    // *** Do some error handling in case of an CRC failure here
           1402 			;                    return;
00D7 0008  1403 m038	RETURN
           1404 			;                }
           1405 			;			}
           1406 			;		}
           1407 			;	}
           1408 			;}
00D8 0008  1409 m039	RETURN
           1410 
           1411 	END
           1412 
           1413 
           1414 ; *** KEY INFO ***
           1415 
           1416 ; 0x0004 P0   16 word(s)  0 % : InterruptRoutine
           1417 ; 0x0018 P0   39 word(s)  1 % : init_all
           1418 ; 0x003F P0    8 word(s)  0 % : throw_errors
           1419 ; 0x0047 P0  146 word(s)  7 % : read_commands
           1420 ; 0x0014 P0    4 word(s)  0 % : main
           1421 
           1422 ; 0x0822 P1    5 word(s)  0 % : RingBufInit
           1423 ; 0x0827 P1   12 word(s)  0 % : RingBufGet
           1424 ; 0x0833 P1   21 word(s)  1 % : RingBufPut
           1425 ; 0x0848 P1   19 word(s)  0 % : USARTinit
           1426 ; 0x085B P1   10 word(s)  0 % : USARTsend
           1427 ; 0x0865 P1   23 word(s)  1 % : USARTsend_str
           1428 ; 0x087C P1   18 word(s)  0 % : USARTsend_arr
           1429 ; 0x0800 P1   34 word(s)  1 % : _const1
           1430 ; 0x088E P1   37 word(s)  1 % : EEPROM_WR
           1431 ; 0x08B3 P1   14 word(s)  0 % : EEPROM_RD
           1432 ; 0x08C1 P1   22 word(s)  1 % : EEPROM_WR_BLK
           1433 ; 0x08D7 P1   24 word(s)  1 % : EEPROM_RD_BLK
           1434 ; 0x08EF P1   40 word(s)  1 % : addCRC
           1435 ; 0x0917 P1   45 word(s)  2 % : CRC
           1436 ; 0x0944 P1   20 word(s)  0 % : newCRC
           1437 ; 0x0958 P1    7 word(s)  0 % : spi_init
           1438 ; 0x095F P1    8 word(s)  0 % : spi_send
           1439 ; 0x0967 P1   10 word(s)  0 % : spi_receive
           1440 ; 0x0971 P1   22 word(s)  1 % : spi_send_arr
CC5X Version 3.4E,   File: main.c              25. Apr 2012  17:06   Page 25

ADDR CODE  LINE SOURCE

           1441 ; 0x0987 P1   26 word(s)  1 % : ledstrip_init
           1442 ; 0x09A1 P1   59 word(s)  2 % : ledstrip_set_color
           1443 
           1444 ; RAM usage: 242 bytes (11 local), 270 bytes free
           1445 ; Maximum call level: 3 (+2 for interrupt)
           1446 ;  Codepage 0 has  214 word(s) :  10 %
           1447 ;  Codepage 1 has  476 word(s) :  23 %
           1448 ;  Codepage 2 has    0 word(s) :   0 %
           1449 ;  Codepage 3 has    0 word(s) :   0 %
           1450 ; Total of 690 code words (8 %)
