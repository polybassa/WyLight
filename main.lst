CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 1

ADDR CODE  LINE SOURCE

           0001 
           0002 ; CC5X Version 3.4E, Copyright (c) B Knudsen Data
           0003 ; C compiler for the PICmicro family
           0004 ; ************  28. May 2012  16:07  *************
           0005 
           0006 	processor  16F1936
           0007 	radix  DEC
           0008 
     0000  0009 INDF0       EQU   0x00
     0004  0010 FSR0        EQU   0x04
     0004  0011 FSR0L       EQU   0x04
     0005  0012 FSR0H       EQU   0x05
     0000  0013 Carry       EQU   0
     0002  0014 Zero_       EQU   2
     000E  0015 PORTC       EQU   0x0E
     008E  0016 TRISC       EQU   0x8E
     0099  0017 OSCCON      EQU   0x99
     0191  0018 EEADRL      EQU   0x191
     0192  0019 EEADRH      EQU   0x192
     0193  0020 EEDATL      EQU   0x193
     0194  0021 EEDATH      EQU   0x194
     0196  0022 EECON2      EQU   0x196
     0199  0023 RCREG       EQU   0x199
     019A  0024 TXREG       EQU   0x19A
     019B  0025 SPBRGL      EQU   0x19B
     019C  0026 SPBRGH      EQU   0x19C
     0211  0027 SSPBUF      EQU   0x211
     0006  0028 PEIE        EQU   6
     0007  0029 GIE         EQU   7
     0003  0030 SSPIF       EQU   3
     0004  0031 TXIF        EQU   4
     0005  0032 RCIF        EQU   5
     0005  0033 RCIE        EQU   5
     0000  0034 RD          EQU   0
     0001  0035 WR          EQU   1
     0002  0036 WREN        EQU   2
     0006  0037 CFGS        EQU   6
     0007  0038 EEPGD       EQU   7
     0003  0039 ADDEN       EQU   3
     0004  0040 CREN        EQU   4
     0006  0041 RX9         EQU   6
     0007  0042 SPEN        EQU   7
     0002  0043 BRGH        EQU   2
     0004  0044 SYNC        EQU   4
     0005  0045 TXEN        EQU   5
     0006  0046 TX9         EQU   6
     0003  0047 BRG16       EQU   3
     0006  0048 CKE         EQU   6
     0007  0049 SMP         EQU   7
     0001  0050 SSPM1       EQU   1
     0004  0051 CKP         EQU   4
     0005  0052 SSPEN       EQU   5
     0039  0053 gRingBuf    EQU   0x39
     004C  0054 gERROR      EQU   0x4C
     004D  0055 gCmdBuf     EQU   0x4D
     0020  0056 temp        EQU   0x20
     0025  0057 byte        EQU   0x25
     0026  0058 p_crcH      EQU   0x26
     0027  0059 p_crcL      EQU   0x27
     0028  0060 index       EQU   0x28
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 2

ADDR CODE  LINE SOURCE

     0029  0061 crcH        EQU   0x29
     002A  0062 crcL        EQU   0x2A
     007F  0063 data        EQU   0x7F
     007F  0064 length      EQU   0x7F
     007F  0065 crcH_out    EQU   0x7F
     007F  0066 crcL_out    EQU   0x7F
     007F  0067 crcH_2      EQU   0x7F
     007F  0068 crcL_2      EQU   0x7F
     007F  0069 i           EQU   0x7F
     007F  0070 byte_2      EQU   0x7F
     0025  0071 p_crcH_2    EQU   0x25
     0026  0072 p_crcL_2    EQU   0x26
     0030  0073 adress      EQU   0x30
     0031  0074 data_2      EQU   0x31
     0000  0075 GIE_status  EQU   0
     0035  0076 adress_2    EQU   0x35
     0036  0077 data_3      EQU   0x36
     0028  0078 array       EQU   0x28
     0029  0079 adress_3    EQU   0x29
     002A  0080 length_2    EQU   0x2A
     002B  0081 i_2         EQU   0x2B
     0030  0082 array_2     EQU   0x30
     0031  0083 adress_4    EQU   0x31
     0032  0084 length_3    EQU   0x32
     0033  0085 i_3         EQU   0x33
     0034  0086 temp_2      EQU   0x34
     007F  0087 arg1        EQU   0x7F
     007F  0088 rval        EQU   0x7F
     007F  0089 arg1_5      EQU   0x7F
     0022  0090 k           EQU   0x22
     002D  0091 pCmd        EQU   0x2D
     002E  0092 address     EQU   0x2E
     002F  0093 r           EQU   0x2F
     0030  0094 g           EQU   0x30
     0031  0095 b           EQU   0x31
     0032  0096 k_2         EQU   0x32
     0033  0097 mask        EQU   0x33
     007F  0098 pCmd_2      EQU   0x7F
     007F  0099 address_2   EQU   0x7F
     007F  0100 r_2         EQU   0x7F
     007F  0101 g_2         EQU   0x7F
     007F  0102 b_2         EQU   0x7F
     007F  0103 k_3         EQU   0x7F
     007F  0104 mask_2      EQU   0x7F
     007F  0105 temp_3      EQU   0x7F
     007F  0106 destinationvalue EQU   0x7F
     007F  0107 currentvalue EQU   0x7F
     007F  0108 temp_4      EQU   0x7F
     007F  0109 C1tmp       EQU   0x7F
     0025  0110 result      EQU   0x25
     0020  0111 value       EQU   0x20
     0021  0112 writeNext   EQU   0x21
     0038  0113 data_4      EQU   0x38
     007F  0114 array_3     EQU   0x7F
     007F  0115 length_4    EQU   0x7F
     007F  0116 i_4         EQU   0x7F
     0034  0117 array_4     EQU   0x34
     0036  0118 end         EQU   0x36
     007F  0119 configvalues EQU   0x7F
     0025  0120 ch          EQU   0x25
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 3

ADDR CODE  LINE SOURCE

     0022  0121 string      EQU   0x22
     0023  0122 ps          EQU   0x23
     007F  0123 array_5     EQU   0x7F
     007F  0124 length_5    EQU   0x7F
     007F  0125 i_5         EQU   0x7F
     002D  0126 pDest       EQU   0x2D
     0000  0127 movePtr     EQU   0
     002E  0128 nextCmd     EQU   0x2E
     0025  0129 pSrc        EQU   0x25
     0026  0130 length_6    EQU   0x26
     0027  0131 nextCmd_2   EQU   0x27
     0022  0132 new_byte    EQU   0x22
     0023  0133 temp_5      EQU   0x23
     0024  0134 j           EQU   0x24
     0022  0135 nextCmd_3   EQU   0x22
     002C  0136 result_2    EQU   0x2C
     0024  0137 ci          EQU   0x24
           0138 
0000 2855  0139 	GOTO main
           0140 
           0141   ; FILE main.c
           0142 			;//Nils Weiß 
           0143 			;//05.09.2011
           0144 			;//Compiler CC5x/
           0145 			;
           0146 			;#define NO_CRC
           0147 			;#pragma sharedAllocation
           0148 			;
           0149 			;//*********************** INCLUDEDATEIEN *********************************************
           0150 			;#include "platform.h"
           0151 			;#include "RingBuf.h"		//clean
           0152 			;#include "usart.h"			//clean
           0153 			;#include "eeprom.h"       	//clean 
           0154 			;#include "crc.h"			//clean
           0155 			;#include "commandstorage.h" //under construction
           0156 			;#include "ledstrip.h"		//clean
           0157 			;#include "spi.h"			//clean
           0158 			;#include "timer.h"			//under construction
           0159 			;
           0160 			;//*********************** GLOBAL VARIABLES *******************************************
           0161 			;struct CommandBuffer gCmdBuf;
           0162 			;struct LedBuffer gLedBuf;
           0163 			;struct ErrorBits gERROR;
           0164 			;
           0165 			;#ifndef X86
           0166 			;//*********************** INTERRUPTSERVICEROUTINE ************************************
           0167 			;#pragma origin 4					//Adresse des Interrupts	
     0000  0168 	ORG 0x0004
           0169 			;interrupt InterruptRoutine(void)
           0170 			;{
           0171 InterruptRoutine
           0172 			;	if (RCIF)
0004 0020  0173 	MOVLB 0
0005 1E91  0174 	BTFSS 0x11,RCIF
0006 2811  0175 	GOTO  m002
           0176 			;	{
           0177 			;		if(!RingBufHasError) RingBufPut(RCREG);
0007 184B  0178 	BTFSC gRingBuf+18,0
0008 280D  0179 	GOTO  m001
0009 0023  0180 	MOVLB 3
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 4

ADDR CODE  LINE SOURCE

000A 0819  0181 	MOVF  RCREG,W
000B 22C4  0182 	CALL  RingBufPut
           0183 			;		else 
000C 2811  0184 	GOTO  m002
           0185 			;		{
           0186 			;			//Register lesen um Schnittstellen Fehler zu vermeiden
           0187 			;			char temp = RCREG;
000D 0023  0188 m001	MOVLB 3
000E 0819  0189 	MOVF  RCREG,W
000F 0020  0190 	MOVLB 0
0010 00A0  0191 	MOVWF temp
           0192 			;		}
           0193 			;	}
           0194 			;}
0011 0009  0195 m002	RETFIE
           0196 			;#endif /* #ifndef X86 */
           0197 			;
           0198 			;//*********************** FUNKTIONSPROTOTYPEN ****************************************
           0199 			;void init_all();
           0200 			;
           0201 			;//*********************** HAUPTPROGRAMM **********************************************
           0202 			;void main(void)
           0203 			;{
           0204 _const1
0012 0020  0205 	MOVLB 0
0013 00A4  0206 	MOVWF ci
0014 3000  0207 	MOVLW 0
0015 0023  0208 	MOVLB 3
0016 0092  0209 	MOVWF EEADRH
0017 0020  0210 	MOVLB 0
0018 0C24  0211 	RRF   ci,W
0019 397F  0212 	ANDLW 127
001A 3E2F  0213 	ADDLW 47
001B 0023  0214 	MOVLB 3
001C 0091  0215 	MOVWF EEADRL
001D 1803  0216 	BTFSC 0x03,Carry
001E 0A92  0217 	INCF  EEADRH,1
001F 0023  0218 	MOVLB 3
0020 1795  0219 	BSF   0x195,EEPGD
0021 1415  0220 	BSF   0x195,RD
0022 0000  0221 	NOP  
0023 0000  0222 	NOP  
0024 0020  0223 	MOVLB 0
0025 1824  0224 	BTFSC ci,0
0026 282B  0225 	GOTO  m003
0027 0023  0226 	MOVLB 3
0028 0813  0227 	MOVF  EEDATL,W
0029 397F  0228 	ANDLW 127
002A 0008  0229 	RETURN
002B 0023  0230 m003	MOVLB 3
002C 0D13  0231 	RLF   EEDATL,W
002D 0D14  0232 	RLF   EEDATH,W
002E 0008  0233 	RETURN
002F 22A0  0234 	DW    0x22A0
0030 2952  0235 	DW    0x2952
0031 294F  0236 	DW    0x294F
0032 103A  0237 	DW    0x103A
0033 32D2  0238 	DW    0x32D2
0034 32E3  0239 	DW    0x32E3
0035 3B69  0240 	DW    0x3B69
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 5

ADDR CODE  LINE SOURCE

0036 3165  0241 	DW    0x3165
0037 3375  0242 	DW    0x3375
0038 32E6  0243 	DW    0x32E6
0039 1072  0244 	DW    0x1072
003A 3AE6  0245 	DW    0x3AE6
003B 366C  0246 	DW    0x366C
003C 1000  0247 	DW    0x1000
003D 2945  0248 	DW    0x2945
003E 27D2  0249 	DW    0x27D2
003F 1D52  0250 	DW    0x1D52
0040 21A0  0251 	DW    0x21A0
0041 21D2  0252 	DW    0x21D2
0042 21AD  0253 	DW    0x21AD
0043 32E8  0254 	DW    0x32E8
0044 35E3  0255 	DW    0x35E3
0045 3320  0256 	DW    0x3320
0046 34E1  0257 	DW    0x34E1
0047 32EC  0258 	DW    0x32EC
0048 0064  0259 	DW    0x64
0049 22A0  0260 	DW    0x22A0
004A 2952  0261 	DW    0x2952
004B 294F  0262 	DW    0x294F
004C 103A  0263 	DW    0x103A
004D 22C5  0264 	DW    0x22C5
004E 2950  0265 	DW    0x2950
004F 26CF  0266 	DW    0x26CF
0050 34A0  0267 	DW    0x34A0
0051 1073  0268 	DW    0x1073
0052 3AE6  0269 	DW    0x3AE6
0053 366C  0270 	DW    0x366C
0054 0000  0271 	DW    0x0
           0272 main
           0273 			;	init_all();
0055 205A  0274 	CALL  init_all
           0275 			;	//FactoryRestoreWLAN();
           0276 			;	//Rn171FactoryRestore();
           0277 			;	while(1)
           0278 			;	{
           0279 			;		throw_errors();
0056 213F  0280 m004	CALL  throw_errors
           0281 			;		commandstorage_get_commands();
0057 23A4  0282 	CALL  commandstorage_get_commands
           0283 			;		commandstorage_execute_commands();
0058 2421  0284 	CALL  commandstorage_execute_commands
           0285 			;	}
0059 2856  0286 	GOTO  m004
           0287 			;}
           0288 			;//*********************** UNTERPROGRAMME **********************************************
           0289 			;
           0290 			;void init_all()
           0291 			;{
           0292 init_all
           0293 			;	OsciInit();
005A 3072  0294 	MOVLW 114
005B 0021  0295 	MOVLB 1
005C 0099  0296 	MOVWF OSCCON
           0297 			;	RingBufInit();
005D 22B3  0298 	CALL  RingBufInit
           0299 			;	USARTinit();
005E 2324  0300 	CALL  USARTinit
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 6

ADDR CODE  LINE SOURCE

           0301 			;	spi_init();
005F 22D9  0302 	CALL  spi_init
           0303 			;	ledstrip_init();
0060 2158  0304 	CALL  ledstrip_init
           0305 			;	commandstorage_init();
0061 243B  0306 	CALL  commandstorage_init
           0307 			;	InitFET();
0062 0021  0308 	MOVLB 1
0063 100E  0309 	BCF   TRISC,0
           0310 			;	PowerOnLEDs();
0064 0020  0311 	MOVLB 0
0065 100E  0312 	BCF   PORTC,0
           0313 			;    
           0314 			;	ErrorInit();
0066 104C  0315 	BCF   gERROR,0
0067 10CC  0316 	BCF   gERROR,1
           0317 			;	ClearCmdBuf();	
0068 01CD  0318 	CLRF  gCmdBuf
0069 01CE  0319 	CLRF  gCmdBuf+1
           0320 			;	AllowInterrupts();
006A 0021  0321 	MOVLB 1
006B 1691  0322 	BSF   0x91,RCIE
006C 170B  0323 	BSF   0x0B,PEIE
006D 178B  0324 	BSF   0x0B,GIE
           0325 			;	
           0326 			;	// *** send ready after init
           0327 			;	USARTsend('R');
006E 3052  0328 	MOVLW 82
006F 2337  0329 	CALL  USARTsend
           0330 			;	USARTsend('D');
0070 3044  0331 	MOVLW 68
0071 2337  0332 	CALL  USARTsend
           0333 			;	USARTsend('Y');
0072 3059  0334 	MOVLW 89
0073 2B37  0335 	GOTO  USARTsend
           0336 			;}
           0337 
           0338   ; FILE crc.c
           0339 			; // Include-Datei zum Erstellen von CRC Prüfsummen
           0340 			; //
           0341 			; //
           0342 			; // Nils Weiß
           0343 			; // 14.04.2012
           0344 			; // Compiler CC5x
           0345 			;
           0346 			;// 16-bit CCIT CRC
           0347 			;
           0348 			;void addCRC(char byte, char* p_crcH, char* p_crcL)
           0349 			;{
           0350 addCRC
           0351 			;	char index;
           0352 			;	char crcH,crcL;
           0353 			;	crcH = *p_crcH;
0074 0185  0354 	CLRF  FSR0H
0075 0020  0355 	MOVLB 0
0076 0826  0356 	MOVF  p_crcH,W
0077 0084  0357 	MOVWF FSR0L
0078 0800  0358 	MOVF  INDF0,W
0079 00A9  0359 	MOVWF crcH
           0360 			;	crcL = *p_crcL;
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 7

ADDR CODE  LINE SOURCE

007A 0185  0361 	CLRF  FSR0H
007B 0827  0362 	MOVF  p_crcL,W
007C 0084  0363 	MOVWF FSR0L
007D 0800  0364 	MOVF  INDF0,W
007E 00AA  0365 	MOVWF crcL
           0366 			;
           0367 			;	MOVF(byte,0);
007F 0825  0368 	MOVF  byte,W
           0369 			;	
           0370 			;	XORWF(crcH,0);
0080 0629  0371 	XORWF crcH,W
           0372 			;	MOVWF(index);
0081 00A8  0373 	MOVWF index
           0374 			;	ANDLW(0xf0);
0082 39F0  0375 	ANDLW 240
           0376 			;	SWAPF(index,1);
0083 0EA8  0377 	SWAPF index,1
           0378 			;	XORWF(index,1);
0084 06A8  0379 	XORWF index,1
           0380 			;	
           0381 			;	MOVF(index,0);
0085 0828  0382 	MOVF  index,W
           0383 			;	ANDLW(0xf0);
0086 39F0  0384 	ANDLW 240
           0385 			;	XORWF(crcL,0);
0087 062A  0386 	XORWF crcL,W
           0387 			;	MOVWF(crcH);
0088 00A9  0388 	MOVWF crcH
           0389 			;	
           0390 			;	RLF(index,0);
0089 0D28  0391 	RLF   index,W
           0392 			;	RLF(index,0);
008A 0D28  0393 	RLF   index,W
           0394 			;	XORWF(crcH,1);
008B 06A9  0395 	XORWF crcH,1
           0396 			;	ANDLW(0xe0);
008C 39E0  0397 	ANDLW 224
           0398 			;	XORWF(crcH,1);
008D 06A9  0399 	XORWF crcH,1
           0400 			;		
           0401 			;	SWAPF(index,1);
008E 0EA8  0402 	SWAPF index,1
           0403 			;	XORWF(index,0);
008F 0628  0404 	XORWF index,W
           0405 			;	MOVWF(crcL);
0090 00AA  0406 	MOVWF crcL
           0407 			;
           0408 			;	*p_crcH = crcH;
0091 0185  0409 	CLRF  FSR0H
0092 0826  0410 	MOVF  p_crcH,W
0093 0084  0411 	MOVWF FSR0L
0094 0829  0412 	MOVF  crcH,W
0095 0080  0413 	MOVWF INDF0
           0414 			;	*p_crcL = crcL;
0096 0185  0415 	CLRF  FSR0H
0097 0827  0416 	MOVF  p_crcL,W
0098 0084  0417 	MOVWF FSR0L
0099 082A  0418 	MOVF  crcL,W
009A 0080  0419 	MOVWF INDF0
           0420 			;
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 8

ADDR CODE  LINE SOURCE

           0421 			;}
009B 0008  0422 	RETURN
           0423 			;
           0424 			;void CRC(char *data, char length, char* crcH_out, char* crcL_out)
           0425 			;{
           0426 CRC
           0427 			;	if(!crcH_out)return;
009C 08FF  0428 	MOVF  crcH_out,1
009D 1903  0429 	BTFSC 0x03,Zero_
009E 0008  0430 	RETURN
           0431 			;	if(!crcL_out)return;
009F 08FF  0432 	MOVF  crcL_out,1
00A0 1903  0433 	BTFSC 0x03,Zero_
00A1 0008  0434 	RETURN
           0435 			;	if(!data)return;
00A2 08FF  0436 	MOVF  data,1
00A3 1903  0437 	BTFSC 0x03,Zero_
00A4 0008  0438 	RETURN
           0439 			;	char crcH,crcL,i,byte;
           0440 			;	crcH=0xff;
00A5 30FF  0441 	MOVLW 255
00A6 00FF  0442 	MOVWF crcH_2
           0443 			;	crcL=0xff;
00A7 30FF  0444 	MOVLW 255
00A8 00FF  0445 	MOVWF crcL_2
           0446 			;
           0447 			;	for(i=0;i<length;i++)
00A9 01FF  0448 	CLRF  i
00AA 087F  0449 m005	MOVF  length,W
00AB 027F  0450 	SUBWF i,W
00AC 1803  0451 	BTFSC 0x03,Carry
00AD 28BE  0452 	GOTO  m006
           0453 			;	{
           0454 			;		byte = data[i];
00AE 087F  0455 	MOVF  i,W
00AF 077F  0456 	ADDWF data,W
00B0 0084  0457 	MOVWF FSR0L
00B1 0185  0458 	CLRF  FSR0H
00B2 0800  0459 	MOVF  INDF0,W
00B3 00FF  0460 	MOVWF byte_2
           0461 			;		addCRC(byte,&crcH,&crcL);
00B4 087F  0462 	MOVF  byte_2,W
00B5 0020  0463 	MOVLB 0
00B6 00A5  0464 	MOVWF byte
00B7 307F  0465 	MOVLW 127
00B8 00A6  0466 	MOVWF p_crcH
00B9 307F  0467 	MOVLW 127
00BA 00A7  0468 	MOVWF p_crcL
00BB 2074  0469 	CALL  addCRC
           0470 			;	}
00BC 0AFF  0471 	INCF  i,1
00BD 28AA  0472 	GOTO  m005
           0473 			;	
           0474 			;	*crcH_out = crcH;
00BE 0185  0475 m006	CLRF  FSR0H
00BF 087F  0476 	MOVF  crcH_out,W
00C0 0084  0477 	MOVWF FSR0L
00C1 087F  0478 	MOVF  crcH_2,W
00C2 0080  0479 	MOVWF INDF0
           0480 			;	*crcL_out = crcL;
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 9

ADDR CODE  LINE SOURCE

00C3 0185  0481 	CLRF  FSR0H
00C4 087F  0482 	MOVF  crcL_out,W
00C5 0084  0483 	MOVWF FSR0L
00C6 087F  0484 	MOVF  crcL_2,W
00C7 0080  0485 	MOVWF INDF0
           0486 			;}
00C8 0008  0487 	RETURN
           0488 			;
           0489 			;void newCRC(char* p_crcH, char* p_crcL)
           0490 			;{
           0491 newCRC
           0492 			;    if(!p_crcH) return;
00C9 0020  0493 	MOVLB 0
00CA 08A5  0494 	MOVF  p_crcH_2,1
00CB 1903  0495 	BTFSC 0x03,Zero_
00CC 0008  0496 	RETURN
           0497 			;    if(!p_crcL) return;
00CD 0020  0498 	MOVLB 0
00CE 08A6  0499 	MOVF  p_crcL_2,1
00CF 1903  0500 	BTFSC 0x03,Zero_
00D0 0008  0501 	RETURN
           0502 			;    *p_crcH = 0xff;
00D1 0185  0503 	CLRF  FSR0H
00D2 0020  0504 	MOVLB 0
00D3 0825  0505 	MOVF  p_crcH_2,W
00D4 0084  0506 	MOVWF FSR0L
00D5 30FF  0507 	MOVLW 255
00D6 0080  0508 	MOVWF INDF0
           0509 			;    *p_crcL = 0xff;
00D7 0185  0510 	CLRF  FSR0H
00D8 0826  0511 	MOVF  p_crcL_2,W
00D9 0084  0512 	MOVWF FSR0L
00DA 30FF  0513 	MOVLW 255
00DB 0080  0514 	MOVWF INDF0
           0515 			;}
00DC 0008  0516 	RETURN
           0517 
           0518   ; FILE eeprom.c
           0519 			;//Funktionen für EEPROM-Zugriffe
           0520 			;
           0521 			;//Nils Weiß 
           0522 			;//05.09.2011
           0523 			;//Compiler CC5x
           0524 			;
           0525 			;#ifndef X86
           0526 			;//*********************** EEPROM BYTE SCHREIBEN  **********************************************
           0527 			;
           0528 			;void EEPROM_WR(char adress, char data)
           0529 			;{
           0530 EEPROM_WR
00DD 0020  0531 	MOVLB 0
00DE 00B1  0532 	MOVWF data_2
           0533 			;	bit GIE_status; 
           0534 			;	//EEADRH = (char)(adress<<8);
           0535 			;    EEADRL = (char)adress;        // Adresse in Adressregister übertragen
00DF 0830  0536 	MOVF  adress,W
00E0 0023  0537 	MOVLB 3
00E1 0091  0538 	MOVWF EEADRL
           0539 			;	EEDATL = data;          // Daten in Datenregister übertragen
00E2 0020  0540 	MOVLB 0
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 10

ADDR CODE  LINE SOURCE

00E3 0831  0541 	MOVF  data_2,W
00E4 0023  0542 	MOVLB 3
00E5 0093  0543 	MOVWF EEDATL
           0544 			;    CFGS = 0;
00E6 1315  0545 	BCF   0x195,CFGS
           0546 			;	EEPGD = 0;                // Auswahl: Programmspeicher lesen oder EEPROM
00E7 1395  0547 	BCF   0x195,EEPGD
           0548 			;    WREN = 1;                 // Schreiben ins EEPROM erlauben
00E8 1515  0549 	BSF   0x195,WREN
           0550 			;	GIE_status=GIE;			
00E9 0020  0551 	MOVLB 0
00EA 1032  0552 	BCF   0x32,GIE_status
00EB 1B8B  0553 	BTFSC 0x0B,GIE
00EC 1432  0554 	BSF   0x32,GIE_status
           0555 			;    GIE=0;                  // Interrups verbieten
00ED 138B  0556 	BCF   0x0B,GIE
           0557 			;    EECON2 = 0x55;
00EE 3055  0558 	MOVLW 85
00EF 0023  0559 	MOVLB 3
00F0 0096  0560 	MOVWF EECON2
           0561 			;    EECON2 = 0xAA;
00F1 30AA  0562 	MOVLW 170
00F2 0096  0563 	MOVWF EECON2
           0564 			;	WR=1; 					// Starten des Schreibens
00F3 1495  0565 	BSF   0x195,WR
           0566 			;    GIE=GIE_status;                  // Interrups erlauben
00F4 0020  0567 	MOVLB 0
00F5 1C32  0568 	BTFSS 0x32,GIE_status
00F6 138B  0569 	BCF   0x0B,GIE
00F7 1832  0570 	BTFSC 0x32,GIE_status
00F8 178B  0571 	BSF   0x0B,GIE
           0572 			;	WREN=0;
00F9 0023  0573 	MOVLB 3
00FA 1115  0574 	BCF   0x195,WREN
           0575 			;	while(WR);
00FB 0023  0576 m007	MOVLB 3
00FC 1895  0577 	BTFSC 0x195,WR
00FD 28FB  0578 	GOTO  m007
           0579 			;}
00FE 0008  0580 	RETURN
           0581 			;
           0582 			;//*********************** EEPROM BYTE LESEN  **********************************************
           0583 			;
           0584 			;char EEPROM_RD(char adress)
           0585 			;{
           0586 EEPROM_RD
00FF 0020  0587 	MOVLB 0
0100 00B5  0588 	MOVWF adress_2
           0589 			;    char data;
           0590 			;    //EEADRH = (char)(adress<<8);        // Adresse in Adressregister übertragen
           0591 			;    EEADRL = (char)(adress);
0101 0835  0592 	MOVF  adress_2,W
0102 0023  0593 	MOVLB 3
0103 0091  0594 	MOVWF EEADRL
           0595 			;	CFGS=0;
0104 1315  0596 	BCF   0x195,CFGS
           0597 			;	EEPGD=0;                // Auswahl: Programmspeicher lesen oder EEPROM
0105 1395  0598 	BCF   0x195,EEPGD
           0599 			;    RD=1;                   // Starten des Lesesn
0106 1415  0600 	BSF   0x195,RD
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 11

ADDR CODE  LINE SOURCE

           0601 			;    data = EEDATL;       // Daten aus Datenregister auslesen
0107 0813  0602 	MOVF  EEDATL,W
0108 0020  0603 	MOVLB 0
0109 00B6  0604 	MOVWF data_3
           0605 			;    return data;
010A 0836  0606 	MOVF  data_3,W
010B 0008  0607 	RETURN
           0608 			;}
           0609 			;#endif /* #ifndef X86 */
           0610 			;
           0611 			;//*********************** EEPROM BYTEARRAY SCHREIBEN  **************************************
           0612 			;
           0613 			;void EEPROM_WR_BLK(char *array, char adress, char length)			//Zum Ausführen eines beliebigen Befehls durch den Programmcode
           0614 			;{
           0615 EEPROM_WR_BLK
010C 0020  0616 	MOVLB 0
010D 00AA  0617 	MOVWF length_2
           0618 			;	if(!array) return;
010E 08A8  0619 	MOVF  array,1
010F 1903  0620 	BTFSC 0x03,Zero_
0110 0008  0621 	RETURN
           0622 			;	char i;
           0623 			;	for(i=0;i<length;i++)
0111 0020  0624 	MOVLB 0
0112 01AB  0625 	CLRF  i_2
0113 0020  0626 m008	MOVLB 0
0114 082A  0627 	MOVF  length_2,W
0115 022B  0628 	SUBWF i_2,W
0116 1803  0629 	BTFSC 0x03,Carry
0117 2924  0630 	GOTO  m009
           0631 			;	{
           0632 			;		EEPROM_WR(adress,*array);
0118 0829  0633 	MOVF  adress_3,W
0119 00B0  0634 	MOVWF adress
011A 0185  0635 	CLRF  FSR0H
011B 0828  0636 	MOVF  array,W
011C 0084  0637 	MOVWF FSR0L
011D 0800  0638 	MOVF  INDF0,W
011E 20DD  0639 	CALL  EEPROM_WR
           0640 			;		adress++;
011F 0020  0641 	MOVLB 0
0120 0AA9  0642 	INCF  adress_3,1
           0643 			;		array++;
0121 0AA8  0644 	INCF  array,1
           0645 			;	}
0122 0AAB  0646 	INCF  i_2,1
0123 2913  0647 	GOTO  m008
           0648 			;}
0124 0008  0649 m009	RETURN
           0650 			;
           0651 			;//*********************** EEPROM BYTEARRAY LESEN  **************************************
           0652 			;
           0653 			;void EEPROM_RD_BLK(char *array, char adress, char length)			//Zum Ausführen eines beliebigen Befehls durch den Programmcode
           0654 			;{
           0655 EEPROM_RD_BLK
0125 0020  0656 	MOVLB 0
0126 00B2  0657 	MOVWF length_3
           0658 			;	if(!array) return;
0127 08B0  0659 	MOVF  array_2,1
0128 1903  0660 	BTFSC 0x03,Zero_
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 12

ADDR CODE  LINE SOURCE

0129 0008  0661 	RETURN
           0662 			;	char i, temp;
           0663 			;	for(i=0;i<length;i++)
012A 0020  0664 	MOVLB 0
012B 01B3  0665 	CLRF  i_3
012C 0020  0666 m010	MOVLB 0
012D 0832  0667 	MOVF  length_3,W
012E 0233  0668 	SUBWF i_3,W
012F 1803  0669 	BTFSC 0x03,Carry
0130 293E  0670 	GOTO  m011
           0671 			;	{
           0672 			;		temp = EEPROM_RD(adress);
0131 0831  0673 	MOVF  adress_4,W
0132 20FF  0674 	CALL  EEPROM_RD
0133 0020  0675 	MOVLB 0
0134 00B4  0676 	MOVWF temp_2
           0677 			;		array[i] = temp;
0135 0833  0678 	MOVF  i_3,W
0136 0730  0679 	ADDWF array_2,W
0137 0084  0680 	MOVWF FSR0L
0138 0185  0681 	CLRF  FSR0H
0139 0834  0682 	MOVF  temp_2,W
013A 0080  0683 	MOVWF INDF0
           0684 			;		adress++;
013B 0AB1  0685 	INCF  adress_4,1
           0686 			;	}
013C 0AB3  0687 	INCF  i_3,1
013D 292C  0688 	GOTO  m010
           0689 			;}
013E 0008  0690 m011	RETURN
           0691 
           0692   ; FILE error.c
           0693 			;
           0694 			;#include "commandstorage.h"
           0695 			;#include "error.h"
           0696 			;#include "RingBuf.h"
           0697 			;#include "usart.h"
           0698 			;
           0699 			;void throw_errors()
           0700 			;{
           0701 throw_errors
           0702 			;	if(RingBufHasError) 
013F 0020  0703 	MOVLB 0
0140 1C4B  0704 	BTFSS gRingBuf+18,0
0141 2947  0705 	GOTO  m012
           0706 			;	{
           0707 			;		// *** if a RingBufError occure, I have to throw away the current command,
           0708 			;		// *** because the last byte was not saved. Commandstring is inconsistent
           0709 			;		ClearCmdBuf();
0142 01CD  0710 	CLRF  gCmdBuf
0143 01CE  0711 	CLRF  gCmdBuf+1
           0712 			;		USARTsend_str(" ERROR: Receivebuffer full");
0144 01A2  0713 	CLRF  string
0145 2341  0714 	CALL  USARTsend_str
           0715 			;		// *** Re-init the Ringbuffer to get a consistent commandstring and reset error
           0716 			;		RingBufInit();
0146 22B3  0717 	CALL  RingBufInit
           0718 			;	}
           0719 			;	if(gERROR.crc_failure)
0147 0020  0720 m012	MOVLB 0
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 13

ADDR CODE  LINE SOURCE

0148 1C4C  0721 	BTFSS gERROR,0
0149 294F  0722 	GOTO  m013
           0723 			;	{
           0724 			;		USARTsend_str(" ERROR: CRC-Check failed");
014A 301B  0725 	MOVLW 27
014B 00A2  0726 	MOVWF string
014C 2341  0727 	CALL  USARTsend_str
           0728 			;		gERROR.crc_failure = 0;
014D 0020  0729 	MOVLB 0
014E 104C  0730 	BCF   gERROR,0
           0731 			;	}
           0732 			;	if(gERROR.eeprom_failure)
014F 0020  0733 m013	MOVLB 0
0150 1CCC  0734 	BTFSS gERROR,1
0151 2957  0735 	GOTO  m014
           0736 			;	{
           0737 			;		USARTsend_str(" ERROR: EEPROM is full");
0152 3034  0738 	MOVLW 52
0153 00A2  0739 	MOVWF string
0154 2341  0740 	CALL  USARTsend_str
           0741 			;		gERROR.eeprom_failure = 0;
0155 0020  0742 	MOVLB 0
0156 10CC  0743 	BCF   gERROR,1
           0744 			;	}
           0745 			;}
0157 0008  0746 m014	RETURN
           0747 
           0748   ; FILE MATH16.H
           0749 			;// SIZE
           0750 			;
           0751 			;#pragma library 1
           0752 			;/*
           0753 			;uns16 operator* _mult8x8( uns8 arg1, uns8 arg2);
           0754 			;int16 operator* _multS8x8( int8 arg1, int8 arg2);
           0755 			;uns16 operator* _multU16x8( uns16 arg1, uns8 arg2);
           0756 			;uns16 operator* _mult16x16( uns16 arg1, uns16 arg2);
           0757 			;uns16 operator/ _divU16_8( uns16 arg1, uns8 arg2);
           0758 			;uns16 operator/ _divU16_16( uns16 arg1, uns16 arg2);
           0759 			;int16 operator/ _divS16_8( int16 arg1, int8 arg2);
           0760 			;int16 operator/ _divS16_16( int16 arg1, int16 arg2);
           0761 			;uns8 operator% _remU16_8( uns16 arg1, uns8 arg2);
           0762 			;uns16 operator% _remU16_16( uns16 arg1, uns16 arg2);
           0763 			;int8 operator% _remS16_8( int16 arg1, int8 arg2);
           0764 			;int16 operator% _remS16_16( int16 arg1, int16 arg2);
           0765 			;*/
           0766 			;
           0767 			;#if __CoreSet__ < 1410
           0768 			; #define genAdd(r,a) W=a; btsc(Carry); W=incsz(a); r+=W
           0769 			; #define genSub(r,a) W=a; btss(Carry); W=incsz(a); r-=W
           0770 			; #define genAddW(r,a) W=a; btsc(Carry); W=incsz(a); W=r+W
           0771 			; #define genSubW(r,a) W=a; btss(Carry); W=incsz(a); W=r-W
           0772 			;#else
           0773 			; #define genAdd(r,a) W=a; r=addWFC(r)
           0774 			; #define genSub(r,a) W=a; r=subWFB(r)
           0775 			; #define genAddW(r,a) W=a; W=addWFC(r)
           0776 			; #define genSubW(r,a) W=a; W=subWFB(r)
           0777 			;#endif
           0778 			;
           0779 			;
           0780 			;int8 operator*( int8 arg1, int8 arg2)  @
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 14

ADDR CODE  LINE SOURCE

           0781 			;
           0782 			;uns16 operator* _mult8x8( uns8 arg1, uns8 arg2)
           0783 			;{
           0784 _mult8x8
           0785 			;    uns16 rval;
           0786 			;    char counter = sizeof(arg2)*8;
           0787 			;    rval.high8 = 0;
           0788 			;    W = arg1;
           0789 			;    do  {
           0790 			;        arg2 = rr( arg2);
           0791 			;        if (Carry)
           0792 			;            rval.high8 += W;
           0793 			;        rval = rr( rval);
           0794 			;        counter = decsz(counter);
           0795 			;    } while (1);
           0796 			;    return rval;
           0797 			;}
           0798 			;
           0799 			;
           0800 			;int16 operator* _multS8x8( int8 arg1, int8 arg2)
           0801 			;{
           0802 _multS8x8
           0803 			;    uns16 rval;
           0804 			;    char counter = sizeof(arg2)*8;
           0805 			;    int8 tmpArg2 = arg2;
           0806 			;    rval.high8 = 0;
           0807 			;    W = arg1;
           0808 			;    do  {
           0809 			;        tmpArg2 = rr( tmpArg2);
           0810 			;        if (Carry)
           0811 			;            rval.high8 += W;
           0812 			;        rval = rr( rval);
           0813 			;        counter = decsz(counter);
           0814 			;    } while (1);
           0815 			;    W = arg2;
           0816 			;    if (arg1 < 0)
           0817 			;        rval.high8 -= W;
           0818 			;    W = arg1;
           0819 			;    if (arg2 < 0)
           0820 			;        rval.high8 -= W;
           0821 			;    return rval;
           0822 			;}
           0823 			;
           0824 			;
           0825 			;uns16 operator*( uns8 arg1, uns16 arg2) exchangeArgs @
           0826 			;
           0827 			;uns16 operator* _multU16x8( uns16 arg1, uns8 arg2)
           0828 			;{
           0829 _multU16x8
           0830 			;    uns16 rval;
           0831 			;    uns8 rvalH = 0;
           0832 			;    char counter = sizeof(arg1)*8;
           0833 			;    W = arg2;
           0834 			;    do  {
           0835 			;        arg1 = rr( arg1);
           0836 			;        if (Carry)
           0837 			;            rvalH += W;
           0838 			;        rvalH = rr(rvalH);
           0839 			;        rval = rr(rval);
           0840 			;        counter = decsz(counter);
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 15

ADDR CODE  LINE SOURCE

           0841 			;    } while (1);
           0842 			;    return rval;
           0843 			;}
           0844 			;
           0845 			;
           0846 			;int16 operator*( int16 arg1, int16 arg2) @
           0847 			;
           0848 			;uns16 operator* _mult16x16( uns16 arg1, uns16 arg2)
           0849 			;{
           0850 _mult16x16
           0851 			;    uns16 rval;
           0852 			;    char counter = sizeof(arg1)*8;
           0853 			;    do  {
           0854 			;        Carry = 0;
           0855 			;        rval = rl( rval);
           0856 			;        arg1 = rl( arg1);
           0857 			;        if (Carry)
           0858 			;            rval += arg2;
           0859 			;        counter = decsz(counter);
           0860 			;    } while (1);
           0861 			;    return rval;
           0862 			;}
           0863 			;
           0864 			;
           0865 			;
           0866 			;uns16 operator/ _divU16_8( uns16 arg1, uns8 arg2)
           0867 			;{
           0868 _divU16_8
           0869 			;    uns8 rm = 0;
           0870 			;    char counter = sizeof(arg1)*8+1;
           0871 			;    goto ENTRY_ML;
           0872 			;    do  {
           0873 			;        rm = rl( rm);
           0874 			;        uns8 tmp = rl( tmp);
           0875 			;        W = rm - arg2;
           0876 			;        if (tmp&1)
           0877 			;            Carry = 1;
           0878 			;        if (Carry)
           0879 			;            rm = W;
           0880 			;       ENTRY_ML:
           0881 			;        arg1 = rl( arg1);
           0882 			;        counter = decsz(counter);
           0883 			;    } while (1);
           0884 			;    return arg1;
           0885 			;}
           0886 			;
           0887 			;
           0888 			;uns16 operator/ _divU16_16( uns16 arg1, uns16 arg2)
           0889 			;{
           0890 _divU16_16
           0891 			;    uns16 rm = 0;
           0892 			;    char counter = sizeof(arg1)*8+1;
           0893 			;    goto ENTRY_ML;
           0894 			;    do  {
           0895 			;        rm = rl( rm);
           0896 			;        W = rm.low8 - arg2.low8;
           0897 			;        genSubW( rm.high8, arg2.high8);
           0898 			;        if (!Carry)
           0899 			;            goto ENTRY_ML;
           0900 			;        rm.high8 = W;
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 16

ADDR CODE  LINE SOURCE

           0901 			;        rm.low8 -= arg2.low8;
           0902 			;        Carry = 1;
           0903 			;       ENTRY_ML:
           0904 			;        arg1 = rl( arg1);
           0905 			;        counter = decsz(counter);
           0906 			;    } while (1);
           0907 			;    return arg1;
           0908 			;}
           0909 			;
           0910 			;
           0911 			;int8  operator/ (int8 arg1, int8 arg2) @
           0912 			;
           0913 			;int16 operator/ _divS16_8( int16 arg1, int8 arg2)
           0914 			;{
           0915 _divS16_8
           0916 			;    uns8 rm = 0;
           0917 			;    char counter = 16+1;
           0918 			;    char sign = arg1.high8 ^ arg2.high8;
           0919 			;    if (arg1 < 0)  {
           0920 			;       INVERT_ML:
           0921 			;        arg1 = -arg1;
           0922 			;        if (!counter)
           0923 			;            return arg1;
           0924 			;    }
           0925 			;    if (arg2 < 0)
           0926 			;        arg2 = -arg2;
           0927 			;    goto ENTRY_ML;
           0928 			;    do  {
           0929 			;        rm = rl( rm);
           0930 			;        W = rm - arg2;
           0931 			;        if (Carry)
           0932 			;            rm = W;
           0933 			;       ENTRY_ML:
           0934 			;        arg1 = rl( arg1);
           0935 			;        counter = decsz(counter);
           0936 			;    } while (1);
           0937 			;    if (sign & 0x80)
           0938 			;        goto INVERT_ML;
           0939 			;    return arg1;
           0940 			;}
           0941 			;
           0942 			;
           0943 			;int16 operator/ _divS16_16( int16 arg1, int16 arg2)
           0944 			;{
           0945 _divS16_16
           0946 			;    uns16 rm = 0;
           0947 			;    char counter = sizeof(arg1)*8+1;
           0948 			;    char sign = arg1.high8 ^ arg2.high8;
           0949 			;    if (arg1 < 0)  {
           0950 			;       INVERT_ML:
           0951 			;        arg1 = -arg1;
           0952 			;        if (!counter)
           0953 			;            return arg1;
           0954 			;    }
           0955 			;    if (arg2 < 0)
           0956 			;        arg2 = -arg2;
           0957 			;    goto ENTRY_ML;
           0958 			;    do  {
           0959 			;        rm = rl( rm);
           0960 			;        W = rm.low8 - arg2.low8;
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 17

ADDR CODE  LINE SOURCE

           0961 			;        genSubW( rm.high8, arg2.high8);
           0962 			;        if (!Carry)
           0963 			;            goto ENTRY_ML;
           0964 			;        rm.high8 = W;
           0965 			;        rm.low8 -= arg2.low8;
           0966 			;        Carry = 1;
           0967 			;       ENTRY_ML:
           0968 			;        arg1 = rl( arg1);
           0969 			;        counter = decsz(counter);
           0970 			;    } while (1);
           0971 			;    if (sign & 0x80)
           0972 			;        goto INVERT_ML;
           0973 			;    return arg1;
           0974 			;}
           0975 			;
           0976 			;
           0977 			;uns8 operator% _remU16_8( uns16 arg1, uns8 arg2)
           0978 			;{
           0979 _remU16_8
           0980 			;    uns8 rm = 0;
           0981 			;    char counter = sizeof(arg1)*8;
           0982 			;    do  {
           0983 			;        arg1 = rl( arg1);
           0984 			;        rm = rl( rm);
           0985 			;        uns8 tmp = rl( tmp);
           0986 			;        W = rm - arg2;
           0987 			;        if (tmp&1)
           0988 			;            Carry = 1;
           0989 			;        if (Carry)
           0990 			;            rm = W;
           0991 			;        counter = decsz(counter);
           0992 			;    } while (1);
           0993 			;    return rm;
           0994 			;}
           0995 			;
           0996 			;
           0997 			;uns16 operator% _remU16_16( uns16 arg1, uns16 arg2)
           0998 			;{
           0999 _remU16_16
           1000 			;    uns16 rm = 0;
           1001 			;    char counter = sizeof(arg1)*8;
           1002 			;    do  {
           1003 			;        arg1 = rl( arg1);
           1004 			;        rm = rl( rm);
           1005 			;        W = rm.low8 - arg2.low8;
           1006 			;        genSubW( rm.high8, arg2.high8);
           1007 			;        if (!Carry)
           1008 			;            goto NOSUB;
           1009 			;        rm.high8 = W;
           1010 			;        rm.low8 -= arg2.low8;
           1011 			;      NOSUB:
           1012 			;        counter = decsz(counter);
           1013 			;    } while (1);
           1014 			;    return rm;
           1015 			;}
           1016 			;
           1017 			;
           1018 			;int8 operator% (int8 arg1, int8 arg2) @
           1019 			;
           1020 			;int8 operator% _remS16_8( int16 arg1, int8 arg2)
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 18

ADDR CODE  LINE SOURCE

           1021 			;{
           1022 _remS16_8
           1023 			;    int8 rm = 0;
           1024 			;    char counter = 16;
           1025 			;    char sign = arg1.high8;
           1026 			;    if (arg1 < 0)
           1027 			;        arg1 = -arg1;
           1028 			;    if (arg2 < 0)
           1029 			;        arg2 = -arg2;
           1030 			;    do  {
           1031 			;        arg1 = rl( arg1);
           1032 			;        rm = rl( rm);
           1033 			;        W = rm - arg2;
           1034 			;        if (Carry)
           1035 			;            rm = W;
           1036 			;        counter = decsz(counter);
           1037 			;    } while (1);
           1038 			;    if (sign & 0x80)
           1039 			;        rm = -rm;
           1040 			;    return rm;
           1041 			;}
           1042 			;
           1043 			;
           1044 			;int16 operator% _remS16_16( int16 arg1, int16 arg2)
           1045 			;{
           1046 _remS16_16
           1047 			;    int16 rm = 0;
           1048 			;    char counter = sizeof(arg1)*8;
           1049 			;    char sign = arg1.high8;
           1050 			;    if (arg1 < 0)
           1051 			;        arg1 = -arg1;
           1052 			;    if (arg2 < 0)
           1053 			;        arg2 = -arg2;
           1054 			;    do  {
           1055 			;        arg1 = rl( arg1);
           1056 			;        rm = rl( rm);
           1057 			;        W = rm.low8 - arg2.low8;
           1058 			;        genSubW( rm.high8, arg2.high8);
           1059 			;        if (!Carry)
           1060 			;            goto NOSUB;
           1061 			;        rm.high8 = W;
           1062 			;        rm.low8 -= arg2.low8;
           1063 			;      NOSUB:
           1064 			;        counter = decsz(counter);
           1065 			;    } while (1);
           1066 			;    if (sign & 0x80)
           1067 			;        rm = -rm;
           1068 			;    return rm;
           1069 
           1070   ; FILE ledstrip.c
           1071 			;//Nils Weiß 
           1072 			;//20.04.2012
           1073 			;//Compiler CC5x 
           1074 			;
           1075 			;#include "ledstrip.h"
           1076 			;#include "MATH16.H"
           1077 			;//private function
           1078 			;int8 ledstrip_get_vect(char destinationvalue, char currentvalue);
           1079 			;
           1080 			;void ledstrip_init(void)
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 19

ADDR CODE  LINE SOURCE

           1081 			;{
           1082 ledstrip_init
           1083 			;	char k;
           1084 			;	for(k = 0;k < (NUM_OF_LED * 3); k++)
0158 0020  1085 	MOVLB 0
0159 01A2  1086 	CLRF  k
015A 3060  1087 m015	MOVLW 96
015B 0020  1088 	MOVLB 0
015C 0222  1089 	SUBWF k,W
015D 1803  1090 	BTFSC 0x03,Carry
015E 2969  1091 	GOTO  m016
           1092 			;	{	
           1093 			;		gLedBuf.led_array[k] = 0;
015F 3020  1094 	MOVLW 32
0160 0085  1095 	MOVWF FSR0+1
0161 3040  1096 	MOVLW 64
0162 0722  1097 	ADDWF k,W
0163 0084  1098 	MOVWF FSR0
0164 1803  1099 	BTFSC 0x03,Carry
0165 0A85  1100 	INCF  FSR0+1,1
0166 0180  1101 	CLRF  INDF0
           1102 			;	}
0167 0AA2  1103 	INCF  k,1
0168 295A  1104 	GOTO  m015
           1105 			;}
0169 0008  1106 m016	RETURN
           1107 			;
           1108 			;/***
           1109 			;*** This funktion sets the values of the global LedBuffer
           1110 			;*** only Led's where the address bit is 1 will be set to the new color
           1111 			;***/
           1112 			;void ledstrip_set_color(struct cmd_set_color *pCmd)
           1113 			;{	
           1114 ledstrip_set_color
           1115 			;	char *address = pCmd->addr;
016A 0020  1116 	MOVLB 0
016B 082D  1117 	MOVF  pCmd,W
016C 00AE  1118 	MOVWF address
           1119 			;	char r = pCmd->red;
016D 3004  1120 	MOVLW 4
016E 072D  1121 	ADDWF pCmd,W
016F 0084  1122 	MOVWF FSR0L
0170 0185  1123 	CLRF  FSR0H
0171 0800  1124 	MOVF  INDF0,W
0172 00AF  1125 	MOVWF r
           1126 			;	char g = pCmd->green;
0173 3005  1127 	MOVLW 5
0174 072D  1128 	ADDWF pCmd,W
0175 0084  1129 	MOVWF FSR0L
0176 0185  1130 	CLRF  FSR0H
0177 0800  1131 	MOVF  INDF0,W
0178 00B0  1132 	MOVWF g
           1133 			;	char b = pCmd->blue;
0179 3006  1134 	MOVLW 6
017A 072D  1135 	ADDWF pCmd,W
017B 0084  1136 	MOVWF FSR0L
017C 0185  1137 	CLRF  FSR0H
017D 0800  1138 	MOVF  INDF0,W
017E 00B1  1139 	MOVWF b
           1140 			;	
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 20

ADDR CODE  LINE SOURCE

           1141 			;	char k,mask;
           1142 			;	mask = 0b00000001;
017F 3001  1143 	MOVLW 1
0180 00B3  1144 	MOVWF mask
           1145 			;	for(k = 0; k < (NUM_OF_LED * 3); k++)
0181 01B2  1146 	CLRF  k_2
0182 3060  1147 m017	MOVLW 96
0183 0020  1148 	MOVLB 0
0184 0232  1149 	SUBWF k_2,W
0185 1803  1150 	BTFSC 0x03,Carry
0186 29B9  1151 	GOTO  m021
           1152 			;	{	
           1153 			;		if(0 != (*address & mask))
0187 0185  1154 	CLRF  FSR0H
0188 082E  1155 	MOVF  address,W
0189 0084  1156 	MOVWF FSR0L
018A 0833  1157 	MOVF  mask,W
018B 0500  1158 	ANDWF INDF0,W
018C 1903  1159 	BTFSC 0x03,Zero_
018D 29AC  1160 	GOTO  m018
           1161 			;		{
           1162 			;			gLedBuf.led_array[k] = b;
018E 3020  1163 	MOVLW 32
018F 0085  1164 	MOVWF FSR0+1
0190 3040  1165 	MOVLW 64
0191 0732  1166 	ADDWF k_2,W
0192 0084  1167 	MOVWF FSR0
0193 1803  1168 	BTFSC 0x03,Carry
0194 0A85  1169 	INCF  FSR0+1,1
0195 0831  1170 	MOVF  b,W
0196 0080  1171 	MOVWF INDF0
           1172 			;			k++;
0197 0AB2  1173 	INCF  k_2,1
           1174 			;			gLedBuf.led_array[k] = g;
0198 3020  1175 	MOVLW 32
0199 0085  1176 	MOVWF FSR0+1
019A 3040  1177 	MOVLW 64
019B 0732  1178 	ADDWF k_2,W
019C 0084  1179 	MOVWF FSR0
019D 1803  1180 	BTFSC 0x03,Carry
019E 0A85  1181 	INCF  FSR0+1,1
019F 0830  1182 	MOVF  g,W
01A0 0080  1183 	MOVWF INDF0
           1184 			;			k++;
01A1 0AB2  1185 	INCF  k_2,1
           1186 			;			gLedBuf.led_array[k] = r;
01A2 3020  1187 	MOVLW 32
01A3 0085  1188 	MOVWF FSR0+1
01A4 3040  1189 	MOVLW 64
01A5 0732  1190 	ADDWF k_2,W
01A6 0084  1191 	MOVWF FSR0
01A7 1803  1192 	BTFSC 0x03,Carry
01A8 0A85  1193 	INCF  FSR0+1,1
01A9 082F  1194 	MOVF  r,W
01AA 0080  1195 	MOVWF INDF0
           1196 			;		}
           1197 			;		else 
01AB 29AF  1198 	GOTO  m019
           1199 			;		{
           1200 			;			k++;
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 21

ADDR CODE  LINE SOURCE

01AC 0020  1201 m018	MOVLB 0
01AD 0AB2  1202 	INCF  k_2,1
           1203 			;			k++;
01AE 0AB2  1204 	INCF  k_2,1
           1205 			;		}
           1206 			;#ifdef X86
           1207 			;		mask = mask << 1;
           1208 			;		if(0 == mask)
           1209 			;#else
           1210 			;		RLF(mask,1);
01AF 0020  1211 m019	MOVLB 0
01B0 0DB3  1212 	RLF   mask,1
           1213 			;		if(Carry == 1) 
01B1 1C03  1214 	BTFSS 0x03,Carry
01B2 29B6  1215 	GOTO  m020
           1216 			;#endif
           1217 			;		{
           1218 			;			address++;
01B3 0AAE  1219 	INCF  address,1
           1220 			;			mask= 0b00000001;
01B4 3001  1221 	MOVLW 1
01B5 00B3  1222 	MOVWF mask
           1223 			;		}
           1224 			;	}
01B6 0020  1225 m020	MOVLB 0
01B7 0AB2  1226 	INCF  k_2,1
01B8 2982  1227 	GOTO  m017
           1228 			;	spi_send_ledbuf(&gLedBuf.led_array[0]);
01B9 3040  1229 m021	MOVLW 64
01BA 0020  1230 	MOVLB 0
01BB 00B4  1231 	MOVWF array_4
01BC 3020  1232 	MOVLW 32
01BD 00B5  1233 	MOVWF array_4+1
01BE 2B01  1234 	GOTO  spi_send_ledbuf
           1235 			;}
           1236 			;/***
           1237 			;* This funktion sets the destination color, the vector and configurate
           1238 			;* the timer 1. 
           1239 			;**/
           1240 			;void ledstrip_set_fade(struct cmd_set_fade *pCmd)
           1241 			;{
           1242 ledstrip_set_fade
           1243 			;	char *address = pCmd->addr;
01BF 087F  1244 	MOVF  pCmd_2,W
01C0 00FF  1245 	MOVWF address_2
           1246 			;	char r = pCmd->red;
01C1 3004  1247 	MOVLW 4
01C2 077F  1248 	ADDWF pCmd_2,W
01C3 0084  1249 	MOVWF FSR0L
01C4 0185  1250 	CLRF  FSR0H
01C5 0800  1251 	MOVF  INDF0,W
01C6 00FF  1252 	MOVWF r_2
           1253 			;	char g = pCmd->green;
01C7 3005  1254 	MOVLW 5
01C8 077F  1255 	ADDWF pCmd_2,W
01C9 0084  1256 	MOVWF FSR0L
01CA 0185  1257 	CLRF  FSR0H
01CB 0800  1258 	MOVF  INDF0,W
01CC 00FF  1259 	MOVWF g_2
           1260 			;	char b = pCmd->blue;
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 22

ADDR CODE  LINE SOURCE

01CD 3006  1261 	MOVLW 6
01CE 077F  1262 	ADDWF pCmd_2,W
01CF 0084  1263 	MOVWF FSR0L
01D0 0185  1264 	CLRF  FSR0H
01D1 0800  1265 	MOVF  INDF0,W
01D2 00FF  1266 	MOVWF b_2
           1267 			;	timer_config(pCmd->timevalue);
01D3 3007  1268 	MOVLW 7
01D4 077F  1269 	ADDWF pCmd_2,W
01D5 0084  1270 	MOVWF FSR0L
01D6 0185  1271 	CLRF  FSR0H
01D7 0800  1272 	MOVF  INDF0,W
01D8 2322  1273 	CALL  timer_config
           1274 			;	
           1275 			;	char k,mask,temp;
           1276 			;	mask = 0b00000001;
01D9 3001  1277 	MOVLW 1
01DA 00FF  1278 	MOVWF mask_2
           1279 			;	for(k = 0; k < (NUM_OF_LED * 3); k++)
01DB 01FF  1280 	CLRF  k_3
01DC 3060  1281 m022	MOVLW 96
01DD 027F  1282 	SUBWF k_3,W
01DE 1803  1283 	BTFSC 0x03,Carry
01DF 2A93  1284 	GOTO  m026
           1285 			;	{	
           1286 			;		if(0 != (*address & mask))
01E0 0185  1287 	CLRF  FSR0H
01E1 087F  1288 	MOVF  address_2,W
01E2 0084  1289 	MOVWF FSR0L
01E3 087F  1290 	MOVF  mask_2,W
01E4 0500  1291 	ANDWF INDF0,W
01E5 1903  1292 	BTFSC 0x03,Zero_
01E6 2A44  1293 	GOTO  m023
           1294 			;		{
           1295 			;			temp = gLedBuf.led_array[k];
01E7 3020  1296 	MOVLW 32
01E8 0085  1297 	MOVWF FSR0+1
01E9 3040  1298 	MOVLW 64
01EA 077F  1299 	ADDWF k_3,W
01EB 0084  1300 	MOVWF FSR0
01EC 1803  1301 	BTFSC 0x03,Carry
01ED 0A85  1302 	INCF  FSR0+1,1
01EE 0800  1303 	MOVF  INDF0,W
01EF 00FF  1304 	MOVWF temp_3
           1305 			;			temp = ledstrip_get_vect(b,temp);
01F0 087F  1306 	MOVF  b_2,W
01F1 00FF  1307 	MOVWF destinationvalue
01F2 087F  1308 	MOVF  temp_3,W
01F3 2294  1309 	CALL  ledstrip_get_vect
01F4 087F  1310 	MOVF  C1tmp,W
01F5 00FF  1311 	MOVWF temp_3
           1312 			;			gLedBuf.led_vector[k] = temp;
01F6 3020  1313 	MOVLW 32
01F7 0085  1314 	MOVWF FSR0+1
01F8 30A0  1315 	MOVLW 160
01F9 077F  1316 	ADDWF k_3,W
01FA 0084  1317 	MOVWF FSR0
01FB 1803  1318 	BTFSC 0x03,Carry
01FC 0A85  1319 	INCF  FSR0+1,1
01FD 087F  1320 	MOVF  temp_3,W
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 23

ADDR CODE  LINE SOURCE

01FE 0080  1321 	MOVWF INDF0
           1322 			;			gLedBuf.led_destination[k] = b;
01FF 3021  1323 	MOVLW 33
0200 0085  1324 	MOVWF FSR0+1
0201 087F  1325 	MOVF  k_3,W
0202 0084  1326 	MOVWF FSR0
0203 087F  1327 	MOVF  b_2,W
0204 0080  1328 	MOVWF INDF0
           1329 			;			k++;
0205 0AFF  1330 	INCF  k_3,1
           1331 			;			temp = gLedBuf.led_array[k];
0206 3020  1332 	MOVLW 32
0207 0085  1333 	MOVWF FSR0+1
0208 3040  1334 	MOVLW 64
0209 077F  1335 	ADDWF k_3,W
020A 0084  1336 	MOVWF FSR0
020B 1803  1337 	BTFSC 0x03,Carry
020C 0A85  1338 	INCF  FSR0+1,1
020D 0800  1339 	MOVF  INDF0,W
020E 00FF  1340 	MOVWF temp_3
           1341 			;			temp = ledstrip_get_vect(g,temp);
020F 087F  1342 	MOVF  g_2,W
0210 00FF  1343 	MOVWF destinationvalue
0211 087F  1344 	MOVF  temp_3,W
0212 2294  1345 	CALL  ledstrip_get_vect
0213 087F  1346 	MOVF  C1tmp,W
0214 00FF  1347 	MOVWF temp_3
           1348 			;			gLedBuf.led_vector[k] = temp;
0215 3020  1349 	MOVLW 32
0216 0085  1350 	MOVWF FSR0+1
0217 30A0  1351 	MOVLW 160
0218 077F  1352 	ADDWF k_3,W
0219 0084  1353 	MOVWF FSR0
021A 1803  1354 	BTFSC 0x03,Carry
021B 0A85  1355 	INCF  FSR0+1,1
021C 087F  1356 	MOVF  temp_3,W
021D 0080  1357 	MOVWF INDF0
           1358 			;			gLedBuf.led_destination[k] = g;
021E 3021  1359 	MOVLW 33
021F 0085  1360 	MOVWF FSR0+1
0220 087F  1361 	MOVF  k_3,W
0221 0084  1362 	MOVWF FSR0
0222 087F  1363 	MOVF  g_2,W
0223 0080  1364 	MOVWF INDF0
           1365 			;			k++;
0224 0AFF  1366 	INCF  k_3,1
           1367 			;			temp = gLedBuf.led_array[k];
0225 3020  1368 	MOVLW 32
0226 0085  1369 	MOVWF FSR0+1
0227 3040  1370 	MOVLW 64
0228 077F  1371 	ADDWF k_3,W
0229 0084  1372 	MOVWF FSR0
022A 1803  1373 	BTFSC 0x03,Carry
022B 0A85  1374 	INCF  FSR0+1,1
022C 0800  1375 	MOVF  INDF0,W
022D 00FF  1376 	MOVWF temp_3
           1377 			;			temp = ledstrip_get_vect(r,temp);
022E 087F  1378 	MOVF  r_2,W
022F 00FF  1379 	MOVWF destinationvalue
0230 087F  1380 	MOVF  temp_3,W
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 24

ADDR CODE  LINE SOURCE

0231 2294  1381 	CALL  ledstrip_get_vect
0232 087F  1382 	MOVF  C1tmp,W
0233 00FF  1383 	MOVWF temp_3
           1384 			;			gLedBuf.led_vector[k] = temp;
0234 3020  1385 	MOVLW 32
0235 0085  1386 	MOVWF FSR0+1
0236 30A0  1387 	MOVLW 160
0237 077F  1388 	ADDWF k_3,W
0238 0084  1389 	MOVWF FSR0
0239 1803  1390 	BTFSC 0x03,Carry
023A 0A85  1391 	INCF  FSR0+1,1
023B 087F  1392 	MOVF  temp_3,W
023C 0080  1393 	MOVWF INDF0
           1394 			;			gLedBuf.led_destination[k] = r;
023D 3021  1395 	MOVLW 33
023E 0085  1396 	MOVWF FSR0+1
023F 087F  1397 	MOVF  k_3,W
0240 0084  1398 	MOVWF FSR0
0241 087F  1399 	MOVF  r_2,W
0242 0080  1400 	MOVWF INDF0
           1401 			;		}
           1402 			;		else 
0243 2A8B  1403 	GOTO  m024
           1404 			;		{ 
           1405 			;			temp = gLedBuf.led_array[k];
0244 3020  1406 m023	MOVLW 32
0245 0085  1407 	MOVWF FSR0+1
0246 3040  1408 	MOVLW 64
0247 077F  1409 	ADDWF k_3,W
0248 0084  1410 	MOVWF FSR0
0249 1803  1411 	BTFSC 0x03,Carry
024A 0A85  1412 	INCF  FSR0+1,1
024B 0800  1413 	MOVF  INDF0,W
024C 00FF  1414 	MOVWF temp_3
           1415 			;			gLedBuf.led_vector[k] = 0;
024D 3020  1416 	MOVLW 32
024E 0085  1417 	MOVWF FSR0+1
024F 30A0  1418 	MOVLW 160
0250 077F  1419 	ADDWF k_3,W
0251 0084  1420 	MOVWF FSR0
0252 1803  1421 	BTFSC 0x03,Carry
0253 0A85  1422 	INCF  FSR0+1,1
0254 0180  1423 	CLRF  INDF0
           1424 			;			gLedBuf.led_destination[k] = temp;
0255 3021  1425 	MOVLW 33
0256 0085  1426 	MOVWF FSR0+1
0257 087F  1427 	MOVF  k_3,W
0258 0084  1428 	MOVWF FSR0
0259 087F  1429 	MOVF  temp_3,W
025A 0080  1430 	MOVWF INDF0
           1431 			;			k++;
025B 0AFF  1432 	INCF  k_3,1
           1433 			;			temp = gLedBuf.led_array[k];
025C 3020  1434 	MOVLW 32
025D 0085  1435 	MOVWF FSR0+1
025E 3040  1436 	MOVLW 64
025F 077F  1437 	ADDWF k_3,W
0260 0084  1438 	MOVWF FSR0
0261 1803  1439 	BTFSC 0x03,Carry
0262 0A85  1440 	INCF  FSR0+1,1
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 25

ADDR CODE  LINE SOURCE

0263 0800  1441 	MOVF  INDF0,W
0264 00FF  1442 	MOVWF temp_3
           1443 			;			gLedBuf.led_vector[k] = 0;
0265 3020  1444 	MOVLW 32
0266 0085  1445 	MOVWF FSR0+1
0267 30A0  1446 	MOVLW 160
0268 077F  1447 	ADDWF k_3,W
0269 0084  1448 	MOVWF FSR0
026A 1803  1449 	BTFSC 0x03,Carry
026B 0A85  1450 	INCF  FSR0+1,1
026C 0180  1451 	CLRF  INDF0
           1452 			;			gLedBuf.led_destination[k] = temp;
026D 3021  1453 	MOVLW 33
026E 0085  1454 	MOVWF FSR0+1
026F 087F  1455 	MOVF  k_3,W
0270 0084  1456 	MOVWF FSR0
0271 087F  1457 	MOVF  temp_3,W
0272 0080  1458 	MOVWF INDF0
           1459 			;			k++;
0273 0AFF  1460 	INCF  k_3,1
           1461 			;			temp = gLedBuf.led_array[k];
0274 3020  1462 	MOVLW 32
0275 0085  1463 	MOVWF FSR0+1
0276 3040  1464 	MOVLW 64
0277 077F  1465 	ADDWF k_3,W
0278 0084  1466 	MOVWF FSR0
0279 1803  1467 	BTFSC 0x03,Carry
027A 0A85  1468 	INCF  FSR0+1,1
027B 0800  1469 	MOVF  INDF0,W
027C 00FF  1470 	MOVWF temp_3
           1471 			;			gLedBuf.led_vector[k] = 0;
027D 3020  1472 	MOVLW 32
027E 0085  1473 	MOVWF FSR0+1
027F 30A0  1474 	MOVLW 160
0280 077F  1475 	ADDWF k_3,W
0281 0084  1476 	MOVWF FSR0
0282 1803  1477 	BTFSC 0x03,Carry
0283 0A85  1478 	INCF  FSR0+1,1
0284 0180  1479 	CLRF  INDF0
           1480 			;			gLedBuf.led_destination[k] = temp;
0285 3021  1481 	MOVLW 33
0286 0085  1482 	MOVWF FSR0+1
0287 087F  1483 	MOVF  k_3,W
0288 0084  1484 	MOVWF FSR0
0289 087F  1485 	MOVF  temp_3,W
028A 0080  1486 	MOVWF INDF0
           1487 			;		}
           1488 			;#ifdef X86
           1489 			;		mask = mask << 1;
           1490 			;		if(0 == mask)
           1491 			;#else
           1492 			;		RLF(mask,1);
028B 0DFF  1493 m024	RLF   mask_2,1
           1494 			;		if(Carry == 1) 
028C 1C03  1495 	BTFSS 0x03,Carry
028D 2A91  1496 	GOTO  m025
           1497 			;#endif
           1498 			;		{
           1499 			;			address++;
028E 0AFF  1500 	INCF  address_2,1
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 26

ADDR CODE  LINE SOURCE

           1501 			;			mask= 0b00000001;
028F 3001  1502 	MOVLW 1
0290 00FF  1503 	MOVWF mask_2
           1504 			;		}
           1505 			;	}
0291 0AFF  1506 m025	INCF  k_3,1
0292 29DC  1507 	GOTO  m022
           1508 			;}
0293 0008  1509 m026	RETURN
           1510 			;//This funktion returns a value between 1 - 15 that indicates how fast the color
           1511 			;//from one led has to been changed during the fade operation
           1512 			;int8 ledstrip_get_vect(char destinationvalue, char currentvalue)
           1513 			;{
           1514 ledstrip_get_vect
0294 00FF  1515 	MOVWF currentvalue
           1516 			;	char temp;
           1517 			;	if(destinationvalue > currentvalue)
0295 087F  1518 	MOVF  destinationvalue,W
0296 027F  1519 	SUBWF currentvalue,W
0297 1803  1520 	BTFSC 0x03,Carry
0298 2AA4  1521 	GOTO  m027
           1522 			;	return temp = destinationvalue / currentvalue;
0299 087F  1523 	MOVF  destinationvalue,W
029A 00FF  1524 	MOVWF arg1_5
029B 01FF  1525 	CLRF  arg1_5+1
029C 087F  1526 	MOVF  currentvalue,W
029D 2158  1527 	CALL  _divU16_8
029E 087F  1528 	MOVF  arg1_5,W
029F 00FF  1529 	MOVWF temp_4
02A0 087F  1530 	MOVF  temp_4,W
02A1 00FF  1531 	MOVWF C1tmp
02A2 087F  1532 	MOVF  C1tmp,W
02A3 0008  1533 	RETURN
           1534 			;	else
           1535 			;	{
           1536 			;		temp = currentvalue / destinationvalue;
02A4 087F  1537 m027	MOVF  currentvalue,W
02A5 00FF  1538 	MOVWF arg1_5
02A6 01FF  1539 	CLRF  arg1_5+1
02A7 087F  1540 	MOVF  destinationvalue,W
02A8 2158  1541 	CALL  _divU16_8
02A9 087F  1542 	MOVF  arg1_5,W
02AA 00FF  1543 	MOVWF temp_4
           1544 			;		return (-1 * temp);
02AB 30FF  1545 	MOVLW 255
02AC 00FF  1546 	MOVWF arg1
02AD 087F  1547 	MOVF  temp_4,W
02AE 2158  1548 	CALL  _mult8x8
02AF 087F  1549 	MOVF  rval,W
02B0 00FF  1550 	MOVWF C1tmp
02B1 087F  1551 	MOVF  C1tmp,W
02B2 0008  1552 	RETURN
           1553 
           1554   ; FILE RingBuf.c
           1555 			;
           1556 			;#include "RingBuf.h"
           1557 			;
           1558 			;#ifndef X86
           1559 			;#message Global variables are defined in RingBuf.c
           1560 			;#endif /* #ifndef X86 */
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 27

ADDR CODE  LINE SOURCE

           1561 			;struct RingBuffer gRingBuf;
           1562 			;
           1563 			;void RingBufInit(void)
           1564 			;{
           1565 RingBufInit
           1566 			;	gRingBuf.read = 0;
02B3 0020  1567 	MOVLB 0
02B4 01C9  1568 	CLRF  gRingBuf+16
           1569 			;	gRingBuf.write = 0;
02B5 01CA  1570 	CLRF  gRingBuf+17
           1571 			;	gRingBuf.error_full = 0;
02B6 104B  1572 	BCF   gRingBuf+18,0
           1573 			;}
02B7 0008  1574 	RETURN
           1575 			;
           1576 			;char RingBufGet(void)
           1577 			;{
           1578 RingBufGet
           1579 			;	char result = gRingBuf.data[gRingBuf.read];
02B8 3039  1580 	MOVLW 57
02B9 0020  1581 	MOVLB 0
02BA 0749  1582 	ADDWF gRingBuf+16,W
02BB 0084  1583 	MOVWF FSR0L
02BC 0185  1584 	CLRF  FSR0H
02BD 0800  1585 	MOVF  INDF0,W
02BE 00A5  1586 	MOVWF result
           1587 			;	gRingBuf.read = RingBufInc(gRingBuf.read);
02BF 0A49  1588 	INCF  gRingBuf+16,W
02C0 390F  1589 	ANDLW 15
02C1 00C9  1590 	MOVWF gRingBuf+16
           1591 			;	return result;
02C2 0825  1592 	MOVF  result,W
02C3 0008  1593 	RETURN
           1594 			;}
           1595 			;
           1596 			;void RingBufPut(char value)
           1597 			;{
           1598 RingBufPut
02C4 0020  1599 	MOVLB 0
02C5 00A0  1600 	MOVWF value
           1601 			;	char writeNext = RingBufInc(gRingBuf.write);
02C6 0A4A  1602 	INCF  gRingBuf+17,W
02C7 390F  1603 	ANDLW 15
02C8 00A1  1604 	MOVWF writeNext
           1605 			;	if(writeNext != gRingBuf.read)
02C9 0821  1606 	MOVF  writeNext,W
02CA 0649  1607 	XORWF gRingBuf+16,W
02CB 1903  1608 	BTFSC 0x03,Zero_
02CC 2AD6  1609 	GOTO  m028
           1610 			;	{
           1611 			;		gRingBuf.data[gRingBuf.write] = value;
02CD 3039  1612 	MOVLW 57
02CE 074A  1613 	ADDWF gRingBuf+17,W
02CF 0084  1614 	MOVWF FSR0L
02D0 0185  1615 	CLRF  FSR0H
02D1 0820  1616 	MOVF  value,W
02D2 0080  1617 	MOVWF INDF0
           1618 			;		gRingBuf.write = writeNext;
02D3 0821  1619 	MOVF  writeNext,W
02D4 00CA  1620 	MOVWF gRingBuf+17
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 28

ADDR CODE  LINE SOURCE

           1621 			;	}
           1622 			;	else gRingBuf.error_full = 1;
02D5 2AD8  1623 	GOTO  m029
02D6 0020  1624 m028	MOVLB 0
02D7 144B  1625 	BSF   gRingBuf+18,0
           1626 			;}
02D8 0008  1627 m029	RETURN
           1628 
           1629   ; FILE spi.c
           1630 			;//Nils Weiß 
           1631 			;//20.04.2012
           1632 			;//Compiler CC5x
           1633 			;
           1634 			;#include "ledstrip.h"
           1635 			;
           1636 			;#ifndef X86
           1637 			;void spi_init()
           1638 			;{
           1639 spi_init
           1640 			;	TRISC.3 = 0;        // Make port RC3 an output(SPI Clock)
02D9 0021  1641 	MOVLB 1
02DA 118E  1642 	BCF   TRISC,3
           1643 			;    TRISC.4 = 1;        // Make port RC4 an input(SPI Data In)
02DB 160E  1644 	BSF   TRISC,4
           1645 			;    TRISC.5 = 0;        // Make port RC5 an output(SPI Data Out)
02DC 128E  1646 	BCF   TRISC,5
           1647 			;	SSPM1 = 0;
02DD 0024  1648 	MOVLB 4
02DE 1095  1649 	BCF   0x215,SSPM1
           1650 			;	SMP = 0;
02DF 1394  1651 	BCF   0x214,SMP
           1652 			;	CKP = 1;
02E0 1615  1653 	BSF   0x215,CKP
           1654 			;	CKE = 0;
02E1 1314  1655 	BCF   0x214,CKE
           1656 			;	SSPEN = 1;
02E2 1695  1657 	BSF   0x215,SSPEN
           1658 			;}
02E3 0008  1659 	RETURN
           1660 			;
           1661 			;char spi_send(char data)
           1662 			;{
           1663 spi_send
02E4 0020  1664 	MOVLB 0
02E5 00B8  1665 	MOVWF data_4
           1666 			;	SSPBUF = data;	
02E6 0838  1667 	MOVF  data_4,W
02E7 0024  1668 	MOVLB 4
02E8 0091  1669 	MOVWF SSPBUF
           1670 			;	while(SSPIF == 0);
02E9 0020  1671 m030	MOVLB 0
02EA 1D91  1672 	BTFSS 0x11,SSPIF
02EB 2AE9  1673 	GOTO  m030
           1674 			;	return SSPBUF;
02EC 0024  1675 	MOVLB 4
02ED 0811  1676 	MOVF  SSPBUF,W
02EE 0008  1677 	RETURN
           1678 			;}
           1679 			;#endif /* #ifndef X86 */
           1680 			;
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 29

ADDR CODE  LINE SOURCE

           1681 			;/***
           1682 			;**	This function sends the array to the LED controller(WS2801)
           1683 			;**  it starts with the last byte to get a correct output
           1684 			;***/
           1685 			;void spi_send_arr(char *array, char length)
           1686 			;{
           1687 spi_send_arr
02EF 00FF  1688 	MOVWF length_4
           1689 			;	if(array == 0) return;
02F0 08FF  1690 	MOVF  array_3,1
02F1 1903  1691 	BTFSC 0x03,Zero_
02F2 0008  1692 	RETURN
           1693 			;	char i;
           1694 			;	for(i = length; i == 0; i-- )
02F3 087F  1695 	MOVF  length_4,W
02F4 00FF  1696 	MOVWF i_4
02F5 08FF  1697 m031	MOVF  i_4,1
02F6 1D03  1698 	BTFSS 0x03,Zero_
02F7 2B00  1699 	GOTO  m032
           1700 			;	{
           1701 			;		spi_send(array[i]);
02F8 087F  1702 	MOVF  i_4,W
02F9 077F  1703 	ADDWF array_3,W
02FA 0084  1704 	MOVWF FSR0L
02FB 0185  1705 	CLRF  FSR0H
02FC 0800  1706 	MOVF  INDF0,W
02FD 22E4  1707 	CALL  spi_send
           1708 			;	} 
02FE 03FF  1709 	DECF  i_4,1
02FF 2AF5  1710 	GOTO  m031
           1711 			;}
0300 0008  1712 m032	RETURN
           1713 			;
           1714 			;void spi_send_ledbuf(char *array)//!!! CHECK if GIE=0 during the sendroutine improves the result
           1715 			;{
           1716 spi_send_ledbuf
           1717 			;	//array must be the address of the first byte
           1718 			;	char* end;
           1719 			;	//calculate where the end is
           1720 			;	end = array + (NUM_OF_LED * 3);
0301 0020  1721 	MOVLB 0
0302 0835  1722 	MOVF  array_4+1,W
0303 00B7  1723 	MOVWF end+1
0304 3060  1724 	MOVLW 96
0305 0734  1725 	ADDWF array_4,W
0306 00B6  1726 	MOVWF end
0307 1803  1727 	BTFSC 0x03,Carry
0308 0AB7  1728 	INCF  end+1,1
           1729 			;	//send all
           1730 			;	for(; array < end; array++)
0309 0020  1731 m033	MOVLB 0
030A 0837  1732 	MOVF  end+1,W
030B 0235  1733 	SUBWF array_4+1,W
030C 1C03  1734 	BTFSS 0x03,Carry
030D 2B14  1735 	GOTO  m034
030E 1D03  1736 	BTFSS 0x03,Zero_
030F 2B20  1737 	GOTO  m035
0310 0836  1738 	MOVF  end,W
0311 0234  1739 	SUBWF array_4,W
0312 1803  1740 	BTFSC 0x03,Carry
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 30

ADDR CODE  LINE SOURCE

0313 2B20  1741 	GOTO  m035
           1742 			;	{
           1743 			;		spi_send(*array);
0314 0020  1744 m034	MOVLB 0
0315 0835  1745 	MOVF  array_4+1,W
0316 0085  1746 	MOVWF FSR0H
0317 0834  1747 	MOVF  array_4,W
0318 0084  1748 	MOVWF FSR0L
0319 0800  1749 	MOVF  INDF0,W
031A 22E4  1750 	CALL  spi_send
           1751 			;	}
031B 0020  1752 	MOVLB 0
031C 0AB4  1753 	INCF  array_4,1
031D 1903  1754 	BTFSC 0x03,Zero_
031E 0AB5  1755 	INCF  array_4+1,1
031F 2B09  1756 	GOTO  m033
           1757 			;}
0320 0008  1758 m035	RETURN
           1759 
           1760   ; FILE timer.c
           1761 			;//Nils Weiß 
           1762 			;//08.05.2012
           1763 			;//Compiler CC5x 
           1764 			;
           1765 			;void timer_init()
           1766 			;{
           1767 timer_init
           1768 			;return;
0321 0008  1769 	RETURN
           1770 			;}
           1771 			;
           1772 			;void timer_config(char configvalues)
           1773 			;{
           1774 timer_config
0322 00FF  1775 	MOVWF configvalues
           1776 			;return;
0323 0008  1777 	RETURN
           1778 
           1779   ; FILE usart.c
           1780 			;// Include-Datei für Serielle Kommunikation über Hardwaremodul des Pic
           1781 			; //
           1782 			; //
           1783 			; // Nils Weiß
           1784 			; // 29.11.2010
           1785 			; // Compiler CC5x
           1786 			;
           1787 			;#ifndef X86
           1788 			;//*******  Initialisierungs-Funktion  *************************************************
           1789 			;void USARTinit()
           1790 			;{
           1791 USARTinit
           1792 			;	//USART TX Pin als Ausgang
           1793 			;	TRISC.6 = 0;
0324 0021  1794 	MOVLB 1
0325 130E  1795 	BCF   TRISC,6
           1796 			;
           1797 			;    BRGH=1;					// High Baudrate activated
0326 0023  1798 	MOVLB 3
0327 151E  1799 	BSF   0x19E,BRGH
           1800 			;	BRG16=0;
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 31

ADDR CODE  LINE SOURCE

0328 119F  1801 	BCF   0x19F,BRG16
           1802 			;	SPBRGL=25;				// 19200 Bps @ 8 MHz Clock
0329 3019  1803 	MOVLW 25
032A 009B  1804 	MOVWF SPBRGL
           1805 			;	SPBRGH=0;
032B 019C  1806 	CLRF  SPBRGH
           1807 			;    SPEN = 1;               // Set_Serial_Pins;
032C 179D  1808 	BSF   0x19D,SPEN
           1809 			;    SYNC = 0;               // Set_Async_Mode;
032D 121E  1810 	BCF   0x19E,SYNC
           1811 			;    TX9 = 0;                // Set_8bit_Tx;
032E 131E  1812 	BCF   0x19E,TX9
           1813 			;    RX9 = 0;                // Set_8bit_Rx;
032F 131D  1814 	BCF   0x19D,RX9
           1815 			;    CREN = 1;               // Enable_Rx;
0330 161D  1816 	BSF   0x19D,CREN
           1817 			;    TXEN = 1;               // Enable_Tx;
0331 169E  1818 	BSF   0x19E,TXEN
           1819 			;    RCIE=1;                 // Rx Interrupt aus
0332 0021  1820 	MOVLB 1
0333 1691  1821 	BSF   0x91,RCIE
           1822 			;	ADDEN=0;				// Disable Adressdetection
0334 0023  1823 	MOVLB 3
0335 119D  1824 	BCF   0x19D,ADDEN
           1825 			;}
0336 0008  1826 	RETURN
           1827 			;
           1828 			;//*******  Sende-char-Funktion  *************************************************
           1829 			;void USARTsend(unsigned char ch)
           1830 			;{
           1831 USARTsend
0337 0020  1832 	MOVLB 0
0338 00A5  1833 	MOVWF ch
           1834 			;	while(!TXIF);
0339 0020  1835 m036	MOVLB 0
033A 1E11  1836 	BTFSS 0x11,TXIF
033B 2B39  1837 	GOTO  m036
           1838 			;	TXREG=ch;
033C 0020  1839 	MOVLB 0
033D 0825  1840 	MOVF  ch,W
033E 0023  1841 	MOVLB 3
033F 009A  1842 	MOVWF TXREG
           1843 			;}
0340 0008  1844 	RETURN
           1845 			;#endif /* #ifndef X86 */
           1846 			;
           1847 			;//*******  Sende-String-Funktion  *************************************************
           1848 			;void USARTsend_str(const char *string)
           1849 			;{
           1850 USARTsend_str
           1851 			; char ps;
           1852 			; ps = *string;
0341 0020  1853 	MOVLB 0
0342 0822  1854 	MOVF  string,W
0343 2012  1855 	CALL  _const1
0344 0020  1856 	MOVLB 0
0345 00A3  1857 	MOVWF ps
           1858 			; while(ps > 0)
0346 0020  1859 m037	MOVLB 0
0347 08A3  1860 	MOVF  ps,1
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 32

ADDR CODE  LINE SOURCE

0348 1903  1861 	BTFSC 0x03,Zero_
0349 2B53  1862 	GOTO  m038
           1863 			;   {
           1864 			;    string++;
034A 0AA2  1865 	INCF  string,1
           1866 			;   	USARTsend(ps);
034B 0823  1867 	MOVF  ps,W
034C 2337  1868 	CALL  USARTsend
           1869 			;    ps = *string;
034D 0020  1870 	MOVLB 0
034E 0822  1871 	MOVF  string,W
034F 2012  1872 	CALL  _const1
0350 0020  1873 	MOVLB 0
0351 00A3  1874 	MOVWF ps
           1875 			;   }
0352 2B46  1876 	GOTO  m037
           1877 			;}
0353 0008  1878 m038	RETURN
           1879 			;
           1880 			;//*******  Sende-Array-Funktion  *************************************************
           1881 			;void USARTsend_arr(char *array, char length)
           1882 			;{
           1883 USARTsend_arr
0354 00FF  1884 	MOVWF length_5
           1885 			;	if(array == 0) return;
0355 08FF  1886 	MOVF  array_5,1
0356 1903  1887 	BTFSC 0x03,Zero_
0357 0008  1888 	RETURN
           1889 			;	char i;
           1890 			;	for(i=0;i<length;i++)
0358 01FF  1891 	CLRF  i_5
0359 087F  1892 m039	MOVF  length_5,W
035A 027F  1893 	SUBWF i_5,W
035B 1803  1894 	BTFSC 0x03,Carry
035C 2B65  1895 	GOTO  m040
           1896 			;	{
           1897 			;		USARTsend(*array);
035D 0185  1898 	CLRF  FSR0H
035E 087F  1899 	MOVF  array_5,W
035F 0084  1900 	MOVWF FSR0L
0360 0800  1901 	MOVF  INDF0,W
0361 2337  1902 	CALL  USARTsend
           1903 			;		array++;
0362 0AFF  1904 	INCF  array_5,1
           1905 			;	}
0363 0AFF  1906 	INCF  i_5,1
0364 2B59  1907 	GOTO  m039
           1908 			;}
0365 0008  1909 m040	RETURN
           1910 
           1911   ; FILE commandstorage.c
           1912 			;#include "platform.h"
           1913 			;#include "commandstorage.h"
           1914 			;
           1915 			;struct led_cmd* commandstorage_read(struct led_cmd *pDest, bit movePtr)
           1916 			;{
           1917 commandstorage_read
           1918 			;	//check parameter
           1919 			;	if(0 == pDest) return 0;
0366 0020  1920 	MOVLB 0
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 33

ADDR CODE  LINE SOURCE

0367 08AD  1921 	MOVF  pDest,1
0368 1903  1922 	BTFSC 0x03,Zero_
0369 3400  1923 	RETLW 0
           1924 			;
           1925 			;	//commands available in eeprom?
           1926 			;	char nextCmd = EEPROM_RD(CmdPointerAddr);
036A 30FF  1927 	MOVLW 255
036B 20FF  1928 	CALL  EEPROM_RD
036C 0020  1929 	MOVLB 0
036D 00AE  1930 	MOVWF nextCmd
           1931 			;	if(0 == nextCmd) return 0;
036E 08AE  1932 	MOVF  nextCmd,1
036F 1903  1933 	BTFSC 0x03,Zero_
0370 3400  1934 	RETLW 0
           1935 			;
           1936 			;	//read command from eeprom
           1937 			;	EEPROM_RD_BLK((char*)pDest, (nextCmd - CmdWidth), CmdWidth);
0371 0020  1938 	MOVLB 0
0372 082D  1939 	MOVF  pDest,W
0373 00B0  1940 	MOVWF array_2
0374 300A  1941 	MOVLW 10
0375 022E  1942 	SUBWF nextCmd,W
0376 00B1  1943 	MOVWF adress_4
0377 300A  1944 	MOVLW 10
0378 2125  1945 	CALL  EEPROM_RD_BLK
           1946 			;
           1947 			;	//do we have to update the CmdPointer?
           1948 			;	if(movePtr)
0379 0020  1949 	MOVLB 0
037A 1C2F  1950 	BTFSS 0x2F,movePtr
037B 2B81  1951 	GOTO  m041
           1952 			;	{		
           1953 			;		EEPROM_WR(CmdPointerAddr, nextCmd - CmdWidth);
037C 30FF  1954 	MOVLW 255
037D 00B0  1955 	MOVWF adress
037E 300A  1956 	MOVLW 10
037F 022E  1957 	SUBWF nextCmd,W
0380 20DD  1958 	CALL  EEPROM_WR
           1959 			;	}
           1960 			;	return pDest;
0381 0020  1961 m041	MOVLB 0
0382 082D  1962 	MOVF  pDest,W
0383 0008  1963 	RETURN
           1964 			;}
           1965 			;
           1966 			;bit commandstorage_write(char *pSrc, char length)
           1967 			;{
           1968 commandstorage_write
0384 0020  1969 	MOVLB 0
0385 00A6  1970 	MOVWF length_6
           1971 			;	//check parameter
           1972 			;	if(0 == pSrc) return FALSE;
0386 08A5  1973 	MOVF  pSrc,1
0387 1D03  1974 	BTFSS 0x03,Zero_
0388 2B8B  1975 	GOTO  m042
0389 1003  1976 	BCF   0x03,Carry
038A 0008  1977 	RETURN
           1978 			;	
           1979 			;	//enought free space in eeprom?
           1980 			;	char nextCmd = EEPROM_RD(CmdPointerAddr);
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 34

ADDR CODE  LINE SOURCE

038B 30FF  1981 m042	MOVLW 255
038C 20FF  1982 	CALL  EEPROM_RD
038D 0020  1983 	MOVLB 0
038E 00A7  1984 	MOVWF nextCmd_2
           1985 			;	if(nextCmd >= (CmdPointerAddr - CmdWidth)) return FALSE;
038F 30F5  1986 	MOVLW 245
0390 0227  1987 	SUBWF nextCmd_2,W
0391 1C03  1988 	BTFSS 0x03,Carry
0392 2B95  1989 	GOTO  m043
0393 1003  1990 	BCF   0x03,Carry
0394 0008  1991 	RETURN
           1992 			;
           1993 			;	//increase the command pointer in eeprom
           1994 			;	EEPROM_WR(CmdPointerAddr,(nextCmd + CmdWidth));
0395 30FF  1995 m043	MOVLW 255
0396 0020  1996 	MOVLB 0
0397 00B0  1997 	MOVWF adress
0398 300A  1998 	MOVLW 10
0399 0727  1999 	ADDWF nextCmd_2,W
039A 20DD  2000 	CALL  EEPROM_WR
           2001 			;		
           2002 			;	//write data to eeprom
           2003 			;	EEPROM_WR_BLK(pSrc, nextCmd, length);
039B 0020  2004 	MOVLB 0
039C 0825  2005 	MOVF  pSrc,W
039D 00A8  2006 	MOVWF array
039E 0827  2007 	MOVF  nextCmd_2,W
039F 00A9  2008 	MOVWF adress_3
03A0 0826  2009 	MOVF  length_6,W
03A1 210C  2010 	CALL  EEPROM_WR_BLK
           2011 			;		
           2012 			;	return TRUE;
03A2 1403  2013 	BSF   0x03,Carry
03A3 0008  2014 	RETURN
           2015 			;}
           2016 			;
           2017 			;void commandstorage_get_commands()
           2018 			;{	
           2019 commandstorage_get_commands
           2020 			;	if(RingBufHasError)
03A4 0020  2021 	MOVLB 0
03A5 1C4B  2022 	BTFSS gRingBuf+18,0
03A6 2BA9  2023 	GOTO  m044
           2024 			;	{
           2025 			;		// *** if a RingBufError occure, I have to throw away the current command,
           2026 			;		// *** because the last byte was not saved. Commandstring is inconsistent
           2027 			;		ClearCmdBuf();
03A7 01CD  2028 	CLRF  gCmdBuf
03A8 01CE  2029 	CLRF  gCmdBuf+1
           2030 			;	}
           2031 			;
           2032 			;	if(RingBufIsNotEmpty)
03A9 0020  2033 m044	MOVLB 0
03AA 084A  2034 	MOVF  gRingBuf+17,W
03AB 0649  2035 	XORWF gRingBuf+16,W
03AC 1903  2036 	BTFSC 0x03,Zero_
03AD 2C20  2037 	GOTO  m053
           2038 			;	{
           2039 			;		// *** preload variables and 
           2040 			;		// *** get new_byte from ringbuffer
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 35

ADDR CODE  LINE SOURCE

           2041 			;		char new_byte, temp, j;
           2042 			;		temp = 0;
03AE 01A3  2043 	CLRF  temp_5
           2044 			;		j = 0;
03AF 01A4  2045 	CLRF  j
           2046 			;		// *** get new byte
           2047 			;		new_byte = RingBufGet();	
03B0 22B8  2048 	CALL  RingBufGet
03B1 0020  2049 	MOVLB 0
03B2 00A2  2050 	MOVWF new_byte
           2051 			;		// *** do I wait for databytes?
           2052 			;		if(gCmdBuf.frame_counter == 0)
03B3 08CE  2053 	MOVF  gCmdBuf+1,1
03B4 1D03  2054 	BTFSS 0x03,Zero_
03B5 2BE1  2055 	GOTO  m046
           2056 			;		{
           2057 			;			// *** I don't wait for databytes
           2058 			;			// *** Do I receive a Start_of_Text sign
           2059 			;			if(new_byte == STX)
03B6 0F22  2060 	INCFSZ new_byte,W
03B7 2BCA  2061 	GOTO  m045
           2062 			;			{
           2063 			;				// *** increse the cmd_counter
           2064 			;				gCmdBuf.cmd_counter = 1;
03B8 3001  2065 	MOVLW 1
03B9 00CD  2066 	MOVWF gCmdBuf
           2067 			;				// *** Write the startsign at the begin of the buffer
           2068 			;				gCmdBuf.cmd_buf[0] = new_byte;
03BA 0822  2069 	MOVF  new_byte,W
03BB 00CF  2070 	MOVWF gCmdBuf+2
           2071 			;                // *** Reset crc Variables
           2072 			;                newCRC(&gCmdBuf.crcH, &gCmdBuf.crcL);
03BC 305E  2073 	MOVLW 94
03BD 00A5  2074 	MOVWF p_crcH_2
03BE 305F  2075 	MOVLW 95
03BF 00A6  2076 	MOVWF p_crcL_2
03C0 20C9  2077 	CALL  newCRC
           2078 			;                // *** add new_byte to crc checksum
           2079 			;                addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
03C1 0020  2080 	MOVLB 0
03C2 0822  2081 	MOVF  new_byte,W
03C3 00A5  2082 	MOVWF byte
03C4 305E  2083 	MOVLW 94
03C5 00A6  2084 	MOVWF p_crcH
03C6 305F  2085 	MOVLW 95
03C7 00A7  2086 	MOVWF p_crcL
03C8 2074  2087 	CALL  addCRC
           2088 			;			}
           2089 			;			else
03C9 2C20  2090 	GOTO  m053
           2091 			;			{	
           2092 			;				// *** to avoid arrayoverflow
           2093 			;				temp = FRAMELENGTH - 2;
03CA 300D  2094 m045	MOVLW 13
03CB 0020  2095 	MOVLB 0
03CC 00A3  2096 	MOVWF temp_5
           2097 			;				// *** check if I get the framelength byte
           2098 			;				if((new_byte < temp) && (gCmdBuf.cmd_counter == 1))
03CD 0823  2099 	MOVF  temp_5,W
03CE 0222  2100 	SUBWF new_byte,W
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 36

ADDR CODE  LINE SOURCE

03CF 1803  2101 	BTFSC 0x03,Carry
03D0 2C20  2102 	GOTO  m053
03D1 0B4D  2103 	DECFSZ gCmdBuf,W
03D2 2C20  2104 	GOTO  m053
           2105 			;				{
           2106 			;					gCmdBuf.frame_counter = new_byte;
03D3 0822  2107 	MOVF  new_byte,W
03D4 00CE  2108 	MOVWF gCmdBuf+1
           2109 			;					gCmdBuf.cmd_buf[1] = new_byte;
03D5 0822  2110 	MOVF  new_byte,W
03D6 00D0  2111 	MOVWF gCmdBuf+3
           2112 			;					gCmdBuf.cmd_counter = 2;
03D7 3002  2113 	MOVLW 2
03D8 00CD  2114 	MOVWF gCmdBuf
           2115 			;                    // *** add new_byte to crc checksum
           2116 			;                    addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
03D9 0822  2117 	MOVF  new_byte,W
03DA 00A5  2118 	MOVWF byte
03DB 305E  2119 	MOVLW 94
03DC 00A6  2120 	MOVWF p_crcH
03DD 305F  2121 	MOVLW 95
03DE 00A7  2122 	MOVWF p_crcL
03DF 2074  2123 	CALL  addCRC
           2124 			;				}
           2125 			;			}
           2126 			;		}
           2127 			;		else
03E0 2C20  2128 	GOTO  m053
           2129 			;		{
           2130 			;			// *** I wait for Databytes, so I save all bytes 
           2131 			;			// *** that I get until my framecounter is > 0
           2132 			;			gCmdBuf.cmd_buf[gCmdBuf.cmd_counter] = new_byte;
03E1 304F  2133 m046	MOVLW 79
03E2 0020  2134 	MOVLB 0
03E3 074D  2135 	ADDWF gCmdBuf,W
03E4 0084  2136 	MOVWF FSR0L
03E5 0185  2137 	CLRF  FSR0H
03E6 0822  2138 	MOVF  new_byte,W
03E7 0080  2139 	MOVWF INDF0
           2140 			;			gCmdBuf.cmd_counter++;
03E8 0ACD  2141 	INCF  gCmdBuf,1
           2142 			;			
           2143 			;            // *** add new_byte to crc checksum
           2144 			;			if(gCmdBuf.frame_counter > 2)
03E9 3003  2145 	MOVLW 3
03EA 024E  2146 	SUBWF gCmdBuf+1,W
03EB 1C03  2147 	BTFSS 0x03,Carry
03EC 2BF4  2148 	GOTO  m047
           2149 			;            addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
03ED 0822  2150 	MOVF  new_byte,W
03EE 00A5  2151 	MOVWF byte
03EF 305E  2152 	MOVLW 94
03F0 00A6  2153 	MOVWF p_crcH
03F1 305F  2154 	MOVLW 95
03F2 00A7  2155 	MOVWF p_crcL
03F3 2074  2156 	CALL  addCRC
           2157 			;			gCmdBuf.frame_counter--;
03F4 0020  2158 m047	MOVLB 0
03F5 0BCE  2159 	DECFSZ gCmdBuf+1,1
           2160 			;			// *** now I have to check if my framecounter is null.
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 37

ADDR CODE  LINE SOURCE

           2161 			;			// *** If it's null my string is complete 
           2162 			;			// *** and I can give the string to the crc check function.
           2163 			;			if(gCmdBuf.frame_counter == 0)
03F6 2C20  2164 	GOTO  m053
           2165 			;			{
           2166 			;#ifdef NO_CRC
           2167 			;				if(1==1)
           2168 			;#else
           2169 			;                // *** verify crc checksum
           2170 			;                if( (gCmdBuf.crcL == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 1]) &&
           2171 			;                    (gCmdBuf.crcH == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 2]) )
           2172 			;#endif
           2173 			;                {
           2174 			;					// *** Execute the simple Commands
           2175 			;					switch(gCmdBuf.cmd_buf[2])
03F7 0851  2176 	MOVF  gCmdBuf+4,W
03F8 3AF8  2177 	XORLW 248
03F9 1903  2178 	BTFSC 0x03,Zero_
03FA 2C02  2179 	GOTO  m048
03FB 3A02  2180 	XORLW 2
03FC 1903  2181 	BTFSC 0x03,Zero_
03FD 2C07  2182 	GOTO  m049
03FE 3A03  2183 	XORLW 3
03FF 1903  2184 	BTFSC 0x03,Zero_
0400 2C0A  2185 	GOTO  m050
0401 2C0D  2186 	GOTO  m051
           2187 			;					{
           2188 			;						case DELETE: 
           2189 			;							{
           2190 			;								EEPROM_WR(CmdPointerAddr,0);
0402 30FF  2191 m048	MOVLW 255
0403 0020  2192 	MOVLB 0
0404 00B0  2193 	MOVWF adress
0405 3000  2194 	MOVLW 0
0406 28DD  2195 	GOTO  EEPROM_WR
           2196 			;								return;
           2197 			;							}
           2198 			;#ifndef X86
           2199 			;						case SET_ON: 
           2200 			;							{
           2201 			;								PowerOnLEDs();
0407 0020  2202 m049	MOVLB 0
0408 100E  2203 	BCF   PORTC,0
           2204 			;								return;
0409 0008  2205 	RETURN
           2206 			;								}
           2207 			;						case SET_OFF: 
           2208 			;							{
           2209 			;								PowerOffLEDs();
040A 0020  2210 m050	MOVLB 0
040B 140E  2211 	BSF   PORTC,0
           2212 			;								return;
040C 0008  2213 	RETURN
           2214 			;							}
           2215 			;#endif /* #ifndef X86 */
           2216 			;					}			
           2217 			;					if( commandstorage_write(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4)))
040D 3051  2218 m051	MOVLW 81
040E 0020  2219 	MOVLB 0
040F 00A5  2220 	MOVWF pSrc
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 38

ADDR CODE  LINE SOURCE

0410 3004  2221 	MOVLW 4
0411 024D  2222 	SUBWF gCmdBuf,W
0412 2384  2223 	CALL  commandstorage_write
0413 1C03  2224 	BTFSS 0x03,Carry
0414 2C1A  2225 	GOTO  m052
           2226 			;					{
           2227 			;						USARTsend('G');
0415 3047  2228 	MOVLW 71
0416 2337  2229 	CALL  USARTsend
           2230 			;						USARTsend('C');
0417 3043  2231 	MOVLW 67
0418 2337  2232 	CALL  USARTsend
           2233 			;					}
           2234 			;					else 
0419 2C20  2235 	GOTO  m053
           2236 			;						gERROR.eeprom_failure = 1;
041A 0020  2237 m052	MOVLB 0
041B 14CC  2238 	BSF   gERROR,1
           2239 			;#ifdef TEST
           2240 			;					USARTsend_arr(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4));
           2241 			;#endif
           2242 			;                }
           2243 			;                else
041C 2C20  2244 	GOTO  m053
           2245 			;                {
           2246 			;                    // *** Do some error handling in case of an CRC failure here
           2247 			;					gERROR.crc_failure = 1;
041D 0020  2248 	MOVLB 0
041E 144C  2249 	BSF   gERROR,0
           2250 			;                    return;
041F 0008  2251 	RETURN
           2252 			;                }
           2253 			;			}
           2254 			;		}
           2255 			;	}
           2256 			;}
0420 0008  2257 m053	RETURN
           2258 			;
           2259 			;void commandstorage_execute_commands()
           2260 			;{
           2261 commandstorage_execute_commands
           2262 			;	// *** get the pointer to commands in the EEPROM
           2263 			;	struct led_cmd nextCmd;
           2264 			;
           2265 			;	// read next command from eeprom and move command pointer in eeprom to the next command (TRUE)
           2266 			;	struct led_cmd *result = commandstorage_read(&nextCmd, TRUE);
0421 3022  2267 	MOVLW 34
0422 0020  2268 	MOVLB 0
0423 00AD  2269 	MOVWF pDest
0424 142F  2270 	BSF   0x2F,movePtr
0425 2366  2271 	CALL  commandstorage_read
0426 0020  2272 	MOVLB 0
0427 00AC  2273 	MOVWF result_2
           2274 			;	if(0 != result)
0428 08AC  2275 	MOVF  result_2,1
0429 1903  2276 	BTFSC 0x03,Zero_
042A 2C3A  2277 	GOTO  m055
           2278 			;	{
           2279 			;		// *** commands available, check what to do
           2280 			;		switch(nextCmd.cmd) 
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 39

ADDR CODE  LINE SOURCE

042B 0822  2281 	MOVF  nextCmd_3,W
042C 3AFD  2282 	XORLW 253
042D 1903  2283 	BTFSC 0x03,Zero_
042E 2C36  2284 	GOTO  m054
042F 3A01  2285 	XORLW 1
0430 1903  2286 	BTFSC 0x03,Zero_
0431 2C3A  2287 	GOTO  m055
0432 3A07  2288 	XORLW 7
0433 1903  2289 	BTFSC 0x03,Zero_
0434 2C3A  2290 	GOTO  m055
0435 2C3A  2291 	GOTO  m055
           2292 			;		{	
           2293 			;			case SET_COLOR: 
           2294 			;			{
           2295 			;				ledstrip_set_color(&nextCmd.data.set_color);
0436 3023  2296 m054	MOVLW 35
0437 0020  2297 	MOVLB 0
0438 00AD  2298 	MOVWF pCmd
0439 216A  2299 	CALL  ledstrip_set_color
           2300 			;				break;
           2301 			;			}
           2302 			;			case SET_FADE: {break;}
           2303 			;			case SET_RUN: {break;}
           2304 			;		}
           2305 			;	}
           2306 			;}
043A 0008  2307 m055	RETURN
           2308 			;
           2309 			;void commandstorage_init()
           2310 			;{
           2311 commandstorage_init
           2312 			;	/** EEPROM contains FF in every cell after inital start,
           2313 			;	*** so I have to delete the pointer address
           2314 			;	*** otherwise the PIC thinks he has the EEPROM full with commands
           2315 			;	**/
           2316 			;	if (EEPROM_RD(CmdPointerAddr) == 0xff)
043B 30FF  2317 	MOVLW 255
043C 20FF  2318 	CALL  EEPROM_RD
043D 3AFF  2319 	XORLW 255
043E 1D03  2320 	BTFSS 0x03,Zero_
043F 2C45  2321 	GOTO  m056
           2322 			;		EEPROM_WR(CmdPointerAddr, 0);
0440 30FF  2323 	MOVLW 255
0441 0020  2324 	MOVLB 0
0442 00B0  2325 	MOVWF adress
0443 3000  2326 	MOVLW 0
0444 20DD  2327 	CALL  EEPROM_WR
           2328 			;
           2329 			;	// set loop pointer address to start
           2330 			;	EEPROM_WR(CmdLoopPointerAddr, 0);
0445 30FD  2331 m056	MOVLW 253
0446 0020  2332 	MOVLB 0
0447 00B0  2333 	MOVWF adress
0448 3000  2334 	MOVLW 0
0449 28DD  2335 	GOTO  EEPROM_WR
           2336 			;}
           2337 
           2338 	END
           2339 
           2340 
CC5X Version 3.4E,   File: main.c              28. May 2012  16:07   Page 40

ADDR CODE  LINE SOURCE

           2341 ; *** KEY INFO ***
           2342 
           2343 ; 0x02B3 P0    5 word(s)  0 % : RingBufInit
           2344 ; 0x02B8 P0   12 word(s)  0 % : RingBufGet
           2345 ; 0x02C4 P0   21 word(s)  1 % : RingBufPut
           2346 ; 0x0324 P0   19 word(s)  0 % : USARTinit
           2347 ; 0x0337 P0   10 word(s)  0 % : USARTsend
           2348 ; 0x0341 P0   19 word(s)  0 % : USARTsend_str
           2349 ; 0x0354 P0   18 word(s)  0 % : USARTsend_arr
           2350 ; 0x00DD P0   34 word(s)  1 % : EEPROM_WR
           2351 ; 0x00FF P0   13 word(s)  0 % : EEPROM_RD
           2352 ; 0x010C P0   25 word(s)  1 % : EEPROM_WR_BLK
           2353 ; 0x0125 P0   26 word(s)  1 % : EEPROM_RD_BLK
           2354 ; 0x0074 P0   40 word(s)  1 % : addCRC
           2355 ; 0x009C P0   45 word(s)  2 % : CRC
           2356 ; 0x00C9 P0   20 word(s)  0 % : newCRC
           2357 ; 0x013F P0   25 word(s)  1 % : throw_errors
           2358 ; 0x0366 P0   30 word(s)  1 % : commandstorage_read
           2359 ; 0x0384 P0   32 word(s)  1 % : commandstorage_write
           2360 ; 0x03A4 P0  125 word(s)  6 % : commandstorage_get_commands
           2361 ; 0x0421 P0   26 word(s)  1 % : commandstorage_execute_commands
           2362 ; 0x043B P0   15 word(s)  0 % : commandstorage_init
           2363 ; 0x02D9 P0   11 word(s)  0 % : spi_init
           2364 ; 0x02E4 P0   11 word(s)  0 % : spi_send
           2365 ; 0x02EF P0   18 word(s)  0 % : spi_send_arr
           2366 ; 0x0301 P0   32 word(s)  1 % : spi_send_ledbuf
           2367 ; 0x0158 P0   18 word(s)  0 % : ledstrip_init
           2368 ; 0x016A P0   85 word(s)  4 % : ledstrip_set_color
           2369 ; 0x01BF P0  213 word(s) 10 % : ledstrip_set_fade
           2370 ; 0x0321 P0    1 word(s)  0 % : timer_init
           2371 ; 0x0322 P0    2 word(s)  0 % : timer_config
           2372 ; 0x0004 P0   14 word(s)  0 % : InterruptRoutine
           2373 ; 0x005A P0   26 word(s)  1 % : init_all
           2374 ; 0x0055 P0    5 word(s)  0 % : main
           2375 ; 0x0294 P0   31 word(s)  1 % : ledstrip_get_vect
           2376 ; 0x0012 P0   67 word(s)  3 % : _const1
           2377 
           2378 ; RAM usage: 352 bytes (25 local), 160 bytes free
           2379 ; Maximum call level: 4 (+2 for interrupt)
           2380 ;  Codepage 0 has 1095 word(s) :  53 %
           2381 ;  Codepage 1 has    0 word(s) :   0 %
           2382 ;  Codepage 2 has    0 word(s) :   0 %
           2383 ;  Codepage 3 has    0 word(s) :   0 %
           2384 ; Total of 1095 code words (13 %)
