CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 1

ADDR CODE  LINE SOURCE

           0001 
           0002 ; CC5X Version 3.4E, Copyright (c) B Knudsen Data
           0003 ; C compiler for the PICmicro family
           0004 ; ************  17. May 2012  13:59  *************
           0005 
           0006 	processor  16F1936
           0007 	radix  DEC
           0008 
     0000  0009 INDF0       EQU   0x00
     0004  0010 FSR0        EQU   0x04
     0004  0011 FSR0L       EQU   0x04
     0005  0012 FSR0H       EQU   0x05
     0000  0013 Carry       EQU   0
     0002  0014 Zero_       EQU   2
     000E  0015 PORTC       EQU   0x0E
     008E  0016 TRISC       EQU   0x8E
     0099  0017 OSCCON      EQU   0x99
     0191  0018 EEADRL      EQU   0x191
     0192  0019 EEADRH      EQU   0x192
     0193  0020 EEDATL      EQU   0x193
     0194  0021 EEDATH      EQU   0x194
     0196  0022 EECON2      EQU   0x196
     0199  0023 RCREG       EQU   0x199
     019A  0024 TXREG       EQU   0x19A
     019B  0025 SPBRGL      EQU   0x19B
     019C  0026 SPBRGH      EQU   0x19C
     0211  0027 SSPBUF      EQU   0x211
     0006  0028 PEIE        EQU   6
     0007  0029 GIE         EQU   7
     0003  0030 SSPIF       EQU   3
     0004  0031 TXIF        EQU   4
     0005  0032 RCIF        EQU   5
     0005  0033 RCIE        EQU   5
     0000  0034 RD          EQU   0
     0001  0035 WR          EQU   1
     0002  0036 WREN        EQU   2
     0006  0037 CFGS        EQU   6
     0007  0038 EEPGD       EQU   7
     0003  0039 ADDEN       EQU   3
     0004  0040 CREN        EQU   4
     0006  0041 RX9         EQU   6
     0007  0042 SPEN        EQU   7
     0002  0043 BRGH        EQU   2
     0004  0044 SYNC        EQU   4
     0005  0045 TXEN        EQU   5
     0006  0046 TX9         EQU   6
     0003  0047 BRG16       EQU   3
     0006  0048 CKE         EQU   6
     0007  0049 SMP         EQU   7
     0001  0050 SSPM1       EQU   1
     0004  0051 CKP         EQU   4
     0005  0052 SSPEN       EQU   5
     0039  0053 gRingBuf    EQU   0x39
     004C  0054 gERROR      EQU   0x4C
     004D  0055 gCmdBuf     EQU   0x4D
     0020  0056 temp        EQU   0x20
     0025  0057 byte        EQU   0x25
     0026  0058 p_crcH      EQU   0x26
     0027  0059 p_crcL      EQU   0x27
     0028  0060 index       EQU   0x28
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 2

ADDR CODE  LINE SOURCE

     0029  0061 crcH        EQU   0x29
     002A  0062 crcL        EQU   0x2A
     007F  0063 data        EQU   0x7F
     007F  0064 length      EQU   0x7F
     007F  0065 crcH_out    EQU   0x7F
     007F  0066 crcL_out    EQU   0x7F
     007F  0067 crcH_2      EQU   0x7F
     007F  0068 crcL_2      EQU   0x7F
     007F  0069 i           EQU   0x7F
     007F  0070 byte_2      EQU   0x7F
     0025  0071 p_crcH_2    EQU   0x25
     0026  0072 p_crcL_2    EQU   0x26
     0030  0073 adress      EQU   0x30
     0031  0074 data_2      EQU   0x31
     0000  0075 GIE_status  EQU   0
     0035  0076 adress_2    EQU   0x35
     0036  0077 data_3      EQU   0x36
     0028  0078 array       EQU   0x28
     0029  0079 adress_3    EQU   0x29
     002A  0080 length_2    EQU   0x2A
     002B  0081 i_2         EQU   0x2B
     0030  0082 array_2     EQU   0x30
     0031  0083 adress_4    EQU   0x31
     0032  0084 length_3    EQU   0x32
     0033  0085 i_3         EQU   0x33
     0034  0086 temp_2      EQU   0x34
     0022  0087 k           EQU   0x22
     002D  0088 pCmd        EQU   0x2D
     002E  0089 address     EQU   0x2E
     002F  0090 r           EQU   0x2F
     0030  0091 g           EQU   0x30
     0031  0092 b           EQU   0x31
     0032  0093 k_2         EQU   0x32
     0033  0094 mask        EQU   0x33
     0025  0095 result      EQU   0x25
     0020  0096 value       EQU   0x20
     0021  0097 writeNext   EQU   0x21
     0038  0098 data_4      EQU   0x38
     007F  0099 array_3     EQU   0x7F
     007F  0100 length_4    EQU   0x7F
     007F  0101 i_4         EQU   0x7F
     0034  0102 array_4     EQU   0x34
     0036  0103 end         EQU   0x36
     0025  0104 ch          EQU   0x25
     0022  0105 string      EQU   0x22
     0023  0106 ps          EQU   0x23
     007F  0107 array_5     EQU   0x7F
     007F  0108 length_5    EQU   0x7F
     007F  0109 i_5         EQU   0x7F
     002D  0110 pDest       EQU   0x2D
     0000  0111 movePtr     EQU   0
     002E  0112 nextCmd     EQU   0x2E
     0025  0113 pSrc        EQU   0x25
     0026  0114 length_6    EQU   0x26
     0027  0115 nextCmd_2   EQU   0x27
     0022  0116 new_byte    EQU   0x22
     0023  0117 temp_3      EQU   0x23
     0024  0118 j           EQU   0x24
     0022  0119 nextCmd_3   EQU   0x22
     002C  0120 result_2    EQU   0x2C
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 3

ADDR CODE  LINE SOURCE

     0024  0121 ci          EQU   0x24
           0122 
0000 2863  0123 	GOTO main
           0124 
           0125   ; FILE main.c
           0126 			;//Nils Weiß 
           0127 			;//05.09.2011
           0128 			;//Compiler CC5x/
           0129 			;
           0130 			;#define NO_CRC
           0131 			;#pragma sharedAllocation
           0132 			;
           0133 			;//*********************** INCLUDEDATEIEN *********************************************
           0134 			;#include "platform.h"
           0135 			;#include "RingBuf.h"		//clean
           0136 			;#include "usart.h"			//clean
           0137 			;#include "eeprom.h"       	//clean 
           0138 			;#include "crc.h"			//clean
           0139 			;#include "commandstorage.h" //under construction
           0140 			;#include "ledstrip.h"		//clean
           0141 			;#include "spi.h"			//clean
           0142 			;#include "timer.h"			//under construction
           0143 			;#include "rn_171.h"
           0144 			;
           0145 			;//*********************** GLOBAL VARIABLES *******************************************
           0146 			;struct CommandBuffer gCmdBuf;
           0147 			;struct LedBuffer gLedBuf;
           0148 			;struct ErrorBits gERROR;
           0149 			;
           0150 			;#ifndef X86
           0151 			;//*********************** INTERRUPTSERVICEROUTINE ************************************
           0152 			;#pragma origin 4					//Adresse des Interrupts	
     0000  0153 	ORG 0x0004
           0154 			;interrupt InterruptRoutine(void)
           0155 			;{
           0156 InterruptRoutine
           0157 			;	if (RCIF)
0004 0020  0158 	MOVLB 0
0005 1E91  0159 	BTFSS 0x11,RCIF
0006 2811  0160 	GOTO  m002
           0161 			;	{
           0162 			;		if(!RingBufHasError) RingBufPut(RCREG);
0007 184B  0163 	BTFSC gRingBuf+18,0
0008 280D  0164 	GOTO  m001
0009 0023  0165 	MOVLB 3
000A 0819  0166 	MOVF  RCREG,W
000B 21DF  0167 	CALL  RingBufPut
           0168 			;		else 
000C 2811  0169 	GOTO  m002
           0170 			;		{
           0171 			;			//Register lesen um Schnittstellen Fehler zu vermeiden
           0172 			;			char temp = RCREG;
000D 0023  0173 m001	MOVLB 3
000E 0819  0174 	MOVF  RCREG,W
000F 0020  0175 	MOVLB 0
0010 00A0  0176 	MOVWF temp
           0177 			;		}
           0178 			;	}
           0179 			;}
0011 0009  0180 m002	RETFIE
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 4

ADDR CODE  LINE SOURCE

           0181 			;#endif /* #ifndef X86 */
           0182 			;
           0183 			;//*********************** FUNKTIONSPROTOTYPEN ****************************************
           0184 			;void init_all();
           0185 			;
           0186 			;//*********************** HAUPTPROGRAMM **********************************************
           0187 			;void main(void)
           0188 			;{
           0189 _const1
0012 0020  0190 	MOVLB 0
0013 00A4  0191 	MOVWF ci
0014 3000  0192 	MOVLW 0
0015 0023  0193 	MOVLB 3
0016 0092  0194 	MOVWF EEADRH
0017 0020  0195 	MOVLB 0
0018 0C24  0196 	RRF   ci,W
0019 397F  0197 	ANDLW 127
001A 3E2F  0198 	ADDLW 47
001B 0023  0199 	MOVLB 3
001C 0091  0200 	MOVWF EEADRL
001D 1803  0201 	BTFSC 0x03,Carry
001E 0A92  0202 	INCF  EEADRH,1
001F 0023  0203 	MOVLB 3
0020 1795  0204 	BSF   0x195,EEPGD
0021 1415  0205 	BSF   0x195,RD
0022 0000  0206 	NOP  
0023 0000  0207 	NOP  
0024 0020  0208 	MOVLB 0
0025 1824  0209 	BTFSC ci,0
0026 282B  0210 	GOTO  m003
0027 0023  0211 	MOVLB 3
0028 0813  0212 	MOVF  EEDATL,W
0029 397F  0213 	ANDLW 127
002A 0008  0214 	RETURN
002B 0023  0215 m003	MOVLB 3
002C 0D13  0216 	RLF   EEDATL,W
002D 0D14  0217 	RLF   EEDATH,W
002E 0008  0218 	RETURN
002F 22A0  0219 	DW    0x22A0
0030 2952  0220 	DW    0x2952
0031 294F  0221 	DW    0x294F
0032 103A  0222 	DW    0x103A
0033 32D2  0223 	DW    0x32D2
0034 32E3  0224 	DW    0x32E3
0035 3B69  0225 	DW    0x3B69
0036 3165  0226 	DW    0x3165
0037 3375  0227 	DW    0x3375
0038 32E6  0228 	DW    0x32E6
0039 1072  0229 	DW    0x1072
003A 3AE6  0230 	DW    0x3AE6
003B 366C  0231 	DW    0x366C
003C 1000  0232 	DW    0x1000
003D 2945  0233 	DW    0x2945
003E 27D2  0234 	DW    0x27D2
003F 1D52  0235 	DW    0x1D52
0040 21A0  0236 	DW    0x21A0
0041 21D2  0237 	DW    0x21D2
0042 21AD  0238 	DW    0x21AD
0043 32E8  0239 	DW    0x32E8
0044 35E3  0240 	DW    0x35E3
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 5

ADDR CODE  LINE SOURCE

0045 3320  0241 	DW    0x3320
0046 34E1  0242 	DW    0x34E1
0047 32EC  0243 	DW    0x32EC
0048 0064  0244 	DW    0x64
0049 22A0  0245 	DW    0x22A0
004A 2952  0246 	DW    0x2952
004B 294F  0247 	DW    0x294F
004C 103A  0248 	DW    0x103A
004D 22C5  0249 	DW    0x22C5
004E 2950  0250 	DW    0x2950
004F 26CF  0251 	DW    0x26CF
0050 34A0  0252 	DW    0x34A0
0051 1073  0253 	DW    0x1073
0052 3AE6  0254 	DW    0x3AE6
0053 366C  0255 	DW    0x366C
0054 3600  0256 	DW    0x3600
0055 30EF  0257 	DW    0x30EF
0056 1064  0258 	DW    0x1064
0057 37E3  0259 	DW    0x37E3
0058 336E  0260 	DW    0x336E
0059 33E9  0261 	DW    0x33E9
005A 375F  0262 	DW    0x375F
005B 3669  0263 	DW    0x3669
005C 0073  0264 	DW    0x73
005D 30F3  0265 	DW    0x30F3
005E 32F6  0266 	DW    0x32F6
005F 3900  0267 	DW    0x3900
0060 3165  0268 	DW    0x3165
0061 37EF  0269 	DW    0x37EF
0062 0074  0270 	DW    0x74
           0271 main
           0272 			;	init_all();
0063 2069  0273 	CALL  init_all
           0274 			;	//FactoryRestoreWLAN();
           0275 			;	Rn171FactoryRestore();
0064 2362  0276 	CALL  Rn171FactoryRestore
           0277 			;	while(1)
           0278 			;	{
           0279 			;		throw_errors();
0065 214E  0280 m004	CALL  throw_errors
           0281 			;		commandstorage_get_commands();
0066 22BC  0282 	CALL  commandstorage_get_commands
           0283 			;		commandstorage_execute_commands();
0067 2339  0284 	CALL  commandstorage_execute_commands
           0285 			;	}
0068 2865  0286 	GOTO  m004
           0287 			;}
           0288 			;//*********************** UNTERPROGRAMME **********************************************
           0289 			;
           0290 			;void init_all()
           0291 			;{
           0292 init_all
           0293 			;	OsciInit();
0069 3072  0294 	MOVLW 114
006A 0021  0295 	MOVLB 1
006B 0099  0296 	MOVWF OSCCON
           0297 			;	RingBufInit();
006C 21CE  0298 	CALL  RingBufInit
           0299 			;	USARTinit();
006D 223C  0300 	CALL  USARTinit
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 6

ADDR CODE  LINE SOURCE

           0301 			;	spi_init();
006E 21F4  0302 	CALL  spi_init
           0303 			;	ledstrip_init();
006F 2167  0304 	CALL  ledstrip_init
           0305 			;	commandstorage_init();
0070 2353  0306 	CALL  commandstorage_init
           0307 			;	InitFET();
0071 0021  0308 	MOVLB 1
0072 100E  0309 	BCF   TRISC,0
           0310 			;	PowerOnLEDs();
0073 0020  0311 	MOVLB 0
0074 100E  0312 	BCF   PORTC,0
           0313 			;    
           0314 			;	ErrorInit();
0075 104C  0315 	BCF   gERROR,0
0076 10CC  0316 	BCF   gERROR,1
           0317 			;	ClearCmdBuf();	
0077 01CD  0318 	CLRF  gCmdBuf
0078 01CE  0319 	CLRF  gCmdBuf+1
           0320 			;	AllowInterrupts();
0079 0021  0321 	MOVLB 1
007A 1691  0322 	BSF   0x91,RCIE
007B 170B  0323 	BSF   0x0B,PEIE
007C 178B  0324 	BSF   0x0B,GIE
           0325 			;	
           0326 			;	// *** send ready after init
           0327 			;	USARTsend('R');
007D 3052  0328 	MOVLW 82
007E 224F  0329 	CALL  USARTsend
           0330 			;	USARTsend('D');
007F 3044  0331 	MOVLW 68
0080 224F  0332 	CALL  USARTsend
           0333 			;	USARTsend('Y');
0081 3059  0334 	MOVLW 89
0082 2A4F  0335 	GOTO  USARTsend
           0336 			;}
           0337 
           0338   ; FILE crc.c
           0339 			; // Include-Datei zum Erstellen von CRC Prüfsummen
           0340 			; //
           0341 			; //
           0342 			; // Nils Weiß
           0343 			; // 14.04.2012
           0344 			; // Compiler CC5x
           0345 			;
           0346 			;// 16-bit CCIT CRC
           0347 			;
           0348 			;void addCRC(char byte, char* p_crcH, char* p_crcL)
           0349 			;{
           0350 addCRC
           0351 			;	char index;
           0352 			;	char crcH,crcL;
           0353 			;	crcH = *p_crcH;
0083 0185  0354 	CLRF  FSR0H
0084 0020  0355 	MOVLB 0
0085 0826  0356 	MOVF  p_crcH,W
0086 0084  0357 	MOVWF FSR0L
0087 0800  0358 	MOVF  INDF0,W
0088 00A9  0359 	MOVWF crcH
           0360 			;	crcL = *p_crcL;
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 7

ADDR CODE  LINE SOURCE

0089 0185  0361 	CLRF  FSR0H
008A 0827  0362 	MOVF  p_crcL,W
008B 0084  0363 	MOVWF FSR0L
008C 0800  0364 	MOVF  INDF0,W
008D 00AA  0365 	MOVWF crcL
           0366 			;
           0367 			;	MOVF(byte,0);
008E 0825  0368 	MOVF  byte,W
           0369 			;	
           0370 			;	XORWF(crcH,0);
008F 0629  0371 	XORWF crcH,W
           0372 			;	MOVWF(index);
0090 00A8  0373 	MOVWF index
           0374 			;	ANDLW(0xf0);
0091 39F0  0375 	ANDLW 240
           0376 			;	SWAPF(index,1);
0092 0EA8  0377 	SWAPF index,1
           0378 			;	XORWF(index,1);
0093 06A8  0379 	XORWF index,1
           0380 			;	
           0381 			;	MOVF(index,0);
0094 0828  0382 	MOVF  index,W
           0383 			;	ANDLW(0xf0);
0095 39F0  0384 	ANDLW 240
           0385 			;	XORWF(crcL,0);
0096 062A  0386 	XORWF crcL,W
           0387 			;	MOVWF(crcH);
0097 00A9  0388 	MOVWF crcH
           0389 			;	
           0390 			;	RLF(index,0);
0098 0D28  0391 	RLF   index,W
           0392 			;	RLF(index,0);
0099 0D28  0393 	RLF   index,W
           0394 			;	XORWF(crcH,1);
009A 06A9  0395 	XORWF crcH,1
           0396 			;	ANDLW(0xe0);
009B 39E0  0397 	ANDLW 224
           0398 			;	XORWF(crcH,1);
009C 06A9  0399 	XORWF crcH,1
           0400 			;		
           0401 			;	SWAPF(index,1);
009D 0EA8  0402 	SWAPF index,1
           0403 			;	XORWF(index,0);
009E 0628  0404 	XORWF index,W
           0405 			;	MOVWF(crcL);
009F 00AA  0406 	MOVWF crcL
           0407 			;
           0408 			;	*p_crcH = crcH;
00A0 0185  0409 	CLRF  FSR0H
00A1 0826  0410 	MOVF  p_crcH,W
00A2 0084  0411 	MOVWF FSR0L
00A3 0829  0412 	MOVF  crcH,W
00A4 0080  0413 	MOVWF INDF0
           0414 			;	*p_crcL = crcL;
00A5 0185  0415 	CLRF  FSR0H
00A6 0827  0416 	MOVF  p_crcL,W
00A7 0084  0417 	MOVWF FSR0L
00A8 082A  0418 	MOVF  crcL,W
00A9 0080  0419 	MOVWF INDF0
           0420 			;
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 8

ADDR CODE  LINE SOURCE

           0421 			;}
00AA 0008  0422 	RETURN
           0423 			;
           0424 			;void CRC(char *data, char length, char* crcH_out, char* crcL_out)
           0425 			;{
           0426 CRC
           0427 			;	if(!crcH_out)return;
00AB 08FF  0428 	MOVF  crcH_out,1
00AC 1903  0429 	BTFSC 0x03,Zero_
00AD 0008  0430 	RETURN
           0431 			;	if(!crcL_out)return;
00AE 08FF  0432 	MOVF  crcL_out,1
00AF 1903  0433 	BTFSC 0x03,Zero_
00B0 0008  0434 	RETURN
           0435 			;	if(!data)return;
00B1 08FF  0436 	MOVF  data,1
00B2 1903  0437 	BTFSC 0x03,Zero_
00B3 0008  0438 	RETURN
           0439 			;	char crcH,crcL,i,byte;
           0440 			;	crcH=0xff;
00B4 30FF  0441 	MOVLW 255
00B5 00FF  0442 	MOVWF crcH_2
           0443 			;	crcL=0xff;
00B6 30FF  0444 	MOVLW 255
00B7 00FF  0445 	MOVWF crcL_2
           0446 			;
           0447 			;	for(i=0;i<length;i++)
00B8 01FF  0448 	CLRF  i
00B9 087F  0449 m005	MOVF  length,W
00BA 027F  0450 	SUBWF i,W
00BB 1803  0451 	BTFSC 0x03,Carry
00BC 28CD  0452 	GOTO  m006
           0453 			;	{
           0454 			;		byte = data[i];
00BD 087F  0455 	MOVF  i,W
00BE 077F  0456 	ADDWF data,W
00BF 0084  0457 	MOVWF FSR0L
00C0 0185  0458 	CLRF  FSR0H
00C1 0800  0459 	MOVF  INDF0,W
00C2 00FF  0460 	MOVWF byte_2
           0461 			;		addCRC(byte,&crcH,&crcL);
00C3 087F  0462 	MOVF  byte_2,W
00C4 0020  0463 	MOVLB 0
00C5 00A5  0464 	MOVWF byte
00C6 307F  0465 	MOVLW 127
00C7 00A6  0466 	MOVWF p_crcH
00C8 307F  0467 	MOVLW 127
00C9 00A7  0468 	MOVWF p_crcL
00CA 2083  0469 	CALL  addCRC
           0470 			;	}
00CB 0AFF  0471 	INCF  i,1
00CC 28B9  0472 	GOTO  m005
           0473 			;	
           0474 			;	*crcH_out = crcH;
00CD 0185  0475 m006	CLRF  FSR0H
00CE 087F  0476 	MOVF  crcH_out,W
00CF 0084  0477 	MOVWF FSR0L
00D0 087F  0478 	MOVF  crcH_2,W
00D1 0080  0479 	MOVWF INDF0
           0480 			;	*crcL_out = crcL;
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 9

ADDR CODE  LINE SOURCE

00D2 0185  0481 	CLRF  FSR0H
00D3 087F  0482 	MOVF  crcL_out,W
00D4 0084  0483 	MOVWF FSR0L
00D5 087F  0484 	MOVF  crcL_2,W
00D6 0080  0485 	MOVWF INDF0
           0486 			;}
00D7 0008  0487 	RETURN
           0488 			;
           0489 			;void newCRC(char* p_crcH, char* p_crcL)
           0490 			;{
           0491 newCRC
           0492 			;    if(!p_crcH) return;
00D8 0020  0493 	MOVLB 0
00D9 08A5  0494 	MOVF  p_crcH_2,1
00DA 1903  0495 	BTFSC 0x03,Zero_
00DB 0008  0496 	RETURN
           0497 			;    if(!p_crcL) return;
00DC 0020  0498 	MOVLB 0
00DD 08A6  0499 	MOVF  p_crcL_2,1
00DE 1903  0500 	BTFSC 0x03,Zero_
00DF 0008  0501 	RETURN
           0502 			;    *p_crcH = 0xff;
00E0 0185  0503 	CLRF  FSR0H
00E1 0020  0504 	MOVLB 0
00E2 0825  0505 	MOVF  p_crcH_2,W
00E3 0084  0506 	MOVWF FSR0L
00E4 30FF  0507 	MOVLW 255
00E5 0080  0508 	MOVWF INDF0
           0509 			;    *p_crcL = 0xff;
00E6 0185  0510 	CLRF  FSR0H
00E7 0826  0511 	MOVF  p_crcL_2,W
00E8 0084  0512 	MOVWF FSR0L
00E9 30FF  0513 	MOVLW 255
00EA 0080  0514 	MOVWF INDF0
           0515 			;}
00EB 0008  0516 	RETURN
           0517 
           0518   ; FILE eeprom.c
           0519 			;//Funktionen für EEPROM-Zugriffe
           0520 			;
           0521 			;//Nils Weiß 
           0522 			;//05.09.2011
           0523 			;//Compiler CC5x
           0524 			;
           0525 			;#ifndef X86
           0526 			;//*********************** EEPROM BYTE SCHREIBEN  **********************************************
           0527 			;
           0528 			;void EEPROM_WR(char adress, char data)
           0529 			;{
           0530 EEPROM_WR
00EC 0020  0531 	MOVLB 0
00ED 00B1  0532 	MOVWF data_2
           0533 			;	bit GIE_status; 
           0534 			;	//EEADRH = (char)(adress<<8);
           0535 			;    EEADRL = (char)adress;        // Adresse in Adressregister übertragen
00EE 0830  0536 	MOVF  adress,W
00EF 0023  0537 	MOVLB 3
00F0 0091  0538 	MOVWF EEADRL
           0539 			;	EEDATL = data;          // Daten in Datenregister übertragen
00F1 0020  0540 	MOVLB 0
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 10

ADDR CODE  LINE SOURCE

00F2 0831  0541 	MOVF  data_2,W
00F3 0023  0542 	MOVLB 3
00F4 0093  0543 	MOVWF EEDATL
           0544 			;    CFGS = 0;
00F5 1315  0545 	BCF   0x195,CFGS
           0546 			;	EEPGD = 0;                // Auswahl: Programmspeicher lesen oder EEPROM
00F6 1395  0547 	BCF   0x195,EEPGD
           0548 			;    WREN = 1;                 // Schreiben ins EEPROM erlauben
00F7 1515  0549 	BSF   0x195,WREN
           0550 			;	GIE_status=GIE;			
00F8 0020  0551 	MOVLB 0
00F9 1032  0552 	BCF   0x32,GIE_status
00FA 1B8B  0553 	BTFSC 0x0B,GIE
00FB 1432  0554 	BSF   0x32,GIE_status
           0555 			;    GIE=0;                  // Interrups verbieten
00FC 138B  0556 	BCF   0x0B,GIE
           0557 			;    EECON2 = 0x55;
00FD 3055  0558 	MOVLW 85
00FE 0023  0559 	MOVLB 3
00FF 0096  0560 	MOVWF EECON2
           0561 			;    EECON2 = 0xAA;
0100 30AA  0562 	MOVLW 170
0101 0096  0563 	MOVWF EECON2
           0564 			;	WR=1; 					// Starten des Schreibens
0102 1495  0565 	BSF   0x195,WR
           0566 			;    GIE=GIE_status;                  // Interrups erlauben
0103 0020  0567 	MOVLB 0
0104 1C32  0568 	BTFSS 0x32,GIE_status
0105 138B  0569 	BCF   0x0B,GIE
0106 1832  0570 	BTFSC 0x32,GIE_status
0107 178B  0571 	BSF   0x0B,GIE
           0572 			;	WREN=0;
0108 0023  0573 	MOVLB 3
0109 1115  0574 	BCF   0x195,WREN
           0575 			;	while(WR);
010A 0023  0576 m007	MOVLB 3
010B 1895  0577 	BTFSC 0x195,WR
010C 290A  0578 	GOTO  m007
           0579 			;}
010D 0008  0580 	RETURN
           0581 			;
           0582 			;//*********************** EEPROM BYTE LESEN  **********************************************
           0583 			;
           0584 			;char EEPROM_RD(char adress)
           0585 			;{
           0586 EEPROM_RD
010E 0020  0587 	MOVLB 0
010F 00B5  0588 	MOVWF adress_2
           0589 			;    char data;
           0590 			;    //EEADRH = (char)(adress<<8);        // Adresse in Adressregister übertragen
           0591 			;    EEADRL = (char)(adress);
0110 0835  0592 	MOVF  adress_2,W
0111 0023  0593 	MOVLB 3
0112 0091  0594 	MOVWF EEADRL
           0595 			;	CFGS=0;
0113 1315  0596 	BCF   0x195,CFGS
           0597 			;	EEPGD=0;                // Auswahl: Programmspeicher lesen oder EEPROM
0114 1395  0598 	BCF   0x195,EEPGD
           0599 			;    RD=1;                   // Starten des Lesesn
0115 1415  0600 	BSF   0x195,RD
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 11

ADDR CODE  LINE SOURCE

           0601 			;    data = EEDATL;       // Daten aus Datenregister auslesen
0116 0813  0602 	MOVF  EEDATL,W
0117 0020  0603 	MOVLB 0
0118 00B6  0604 	MOVWF data_3
           0605 			;    return data;
0119 0836  0606 	MOVF  data_3,W
011A 0008  0607 	RETURN
           0608 			;}
           0609 			;#endif /* #ifndef X86 */
           0610 			;
           0611 			;//*********************** EEPROM BYTEARRAY SCHREIBEN  **************************************
           0612 			;
           0613 			;void EEPROM_WR_BLK(char *array, char adress, char length)			//Zum Ausführen eines beliebigen Befehls durch den Programmcode
           0614 			;{
           0615 EEPROM_WR_BLK
011B 0020  0616 	MOVLB 0
011C 00AA  0617 	MOVWF length_2
           0618 			;	if(!array) return;
011D 08A8  0619 	MOVF  array,1
011E 1903  0620 	BTFSC 0x03,Zero_
011F 0008  0621 	RETURN
           0622 			;	char i;
           0623 			;	for(i=0;i<length;i++)
0120 0020  0624 	MOVLB 0
0121 01AB  0625 	CLRF  i_2
0122 0020  0626 m008	MOVLB 0
0123 082A  0627 	MOVF  length_2,W
0124 022B  0628 	SUBWF i_2,W
0125 1803  0629 	BTFSC 0x03,Carry
0126 2933  0630 	GOTO  m009
           0631 			;	{
           0632 			;		EEPROM_WR(adress,*array);
0127 0829  0633 	MOVF  adress_3,W
0128 00B0  0634 	MOVWF adress
0129 0185  0635 	CLRF  FSR0H
012A 0828  0636 	MOVF  array,W
012B 0084  0637 	MOVWF FSR0L
012C 0800  0638 	MOVF  INDF0,W
012D 20EC  0639 	CALL  EEPROM_WR
           0640 			;		adress++;
012E 0020  0641 	MOVLB 0
012F 0AA9  0642 	INCF  adress_3,1
           0643 			;		array++;
0130 0AA8  0644 	INCF  array,1
           0645 			;	}
0131 0AAB  0646 	INCF  i_2,1
0132 2922  0647 	GOTO  m008
           0648 			;}
0133 0008  0649 m009	RETURN
           0650 			;
           0651 			;//*********************** EEPROM BYTEARRAY LESEN  **************************************
           0652 			;
           0653 			;void EEPROM_RD_BLK(char *array, char adress, char length)			//Zum Ausführen eines beliebigen Befehls durch den Programmcode
           0654 			;{
           0655 EEPROM_RD_BLK
0134 0020  0656 	MOVLB 0
0135 00B2  0657 	MOVWF length_3
           0658 			;	if(!array) return;
0136 08B0  0659 	MOVF  array_2,1
0137 1903  0660 	BTFSC 0x03,Zero_
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 12

ADDR CODE  LINE SOURCE

0138 0008  0661 	RETURN
           0662 			;	char i, temp;
           0663 			;	for(i=0;i<length;i++)
0139 0020  0664 	MOVLB 0
013A 01B3  0665 	CLRF  i_3
013B 0020  0666 m010	MOVLB 0
013C 0832  0667 	MOVF  length_3,W
013D 0233  0668 	SUBWF i_3,W
013E 1803  0669 	BTFSC 0x03,Carry
013F 294D  0670 	GOTO  m011
           0671 			;	{
           0672 			;		temp = EEPROM_RD(adress);
0140 0831  0673 	MOVF  adress_4,W
0141 210E  0674 	CALL  EEPROM_RD
0142 0020  0675 	MOVLB 0
0143 00B4  0676 	MOVWF temp_2
           0677 			;		array[i] = temp;
0144 0833  0678 	MOVF  i_3,W
0145 0730  0679 	ADDWF array_2,W
0146 0084  0680 	MOVWF FSR0L
0147 0185  0681 	CLRF  FSR0H
0148 0834  0682 	MOVF  temp_2,W
0149 0080  0683 	MOVWF INDF0
           0684 			;		adress++;
014A 0AB1  0685 	INCF  adress_4,1
           0686 			;	}
014B 0AB3  0687 	INCF  i_3,1
014C 293B  0688 	GOTO  m010
           0689 			;}
014D 0008  0690 m011	RETURN
           0691 
           0692   ; FILE error.c
           0693 			;
           0694 			;#include "commandstorage.h"
           0695 			;#include "error.h"
           0696 			;#include "RingBuf.h"
           0697 			;#include "usart.h"
           0698 			;
           0699 			;void throw_errors()
           0700 			;{
           0701 throw_errors
           0702 			;	if(RingBufHasError) 
014E 0020  0703 	MOVLB 0
014F 1C4B  0704 	BTFSS gRingBuf+18,0
0150 2956  0705 	GOTO  m012
           0706 			;	{
           0707 			;		// *** if a RingBufError occure, I have to throw away the current command,
           0708 			;		// *** because the last byte was not saved. Commandstring is inconsistent
           0709 			;		ClearCmdBuf();
0151 01CD  0710 	CLRF  gCmdBuf
0152 01CE  0711 	CLRF  gCmdBuf+1
           0712 			;		USARTsend_str(" ERROR: Receivebuffer full");
0153 01A2  0713 	CLRF  string
0154 2259  0714 	CALL  USARTsend_str
           0715 			;		// *** Re-init the Ringbuffer to get a consistent commandstring and reset error
           0716 			;		RingBufInit();
0155 21CE  0717 	CALL  RingBufInit
           0718 			;	}
           0719 			;	if(gERROR.crc_failure)
0156 0020  0720 m012	MOVLB 0
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 13

ADDR CODE  LINE SOURCE

0157 1C4C  0721 	BTFSS gERROR,0
0158 295E  0722 	GOTO  m013
           0723 			;	{
           0724 			;		USARTsend_str(" ERROR: CRC-Check failed");
0159 301B  0725 	MOVLW 27
015A 00A2  0726 	MOVWF string
015B 2259  0727 	CALL  USARTsend_str
           0728 			;		gERROR.crc_failure = 0;
015C 0020  0729 	MOVLB 0
015D 104C  0730 	BCF   gERROR,0
           0731 			;	}
           0732 			;	if(gERROR.eeprom_failure)
015E 0020  0733 m013	MOVLB 0
015F 1CCC  0734 	BTFSS gERROR,1
0160 2966  0735 	GOTO  m014
           0736 			;	{
           0737 			;		USARTsend_str(" ERROR: EEPROM is full");
0161 3034  0738 	MOVLW 52
0162 00A2  0739 	MOVWF string
0163 2259  0740 	CALL  USARTsend_str
           0741 			;		gERROR.eeprom_failure = 0;
0164 0020  0742 	MOVLB 0
0165 10CC  0743 	BCF   gERROR,1
           0744 			;	}
           0745 			;}
0166 0008  0746 m014	RETURN
           0747 
           0748   ; FILE ledstrip.c
           0749 			;//Nils Weiß 
           0750 			;//20.04.2012
           0751 			;//Compiler CC5x 
           0752 			;
           0753 			;#include "ledstrip.h"
           0754 			;
           0755 			;void ledstrip_init(void)
           0756 			;{
           0757 ledstrip_init
           0758 			;	char k;
           0759 			;	for(k = 0;k < (NUM_OF_LED * 3); k++)
0167 0020  0760 	MOVLB 0
0168 01A2  0761 	CLRF  k
0169 3060  0762 m015	MOVLW 96
016A 0020  0763 	MOVLB 0
016B 0222  0764 	SUBWF k,W
016C 1803  0765 	BTFSC 0x03,Carry
016D 2978  0766 	GOTO  m016
           0767 			;	{	
           0768 			;		gLedBuf.led_array[k] = 0;
016E 3020  0769 	MOVLW 32
016F 0085  0770 	MOVWF FSR0+1
0170 3040  0771 	MOVLW 64
0171 0722  0772 	ADDWF k,W
0172 0084  0773 	MOVWF FSR0
0173 1803  0774 	BTFSC 0x03,Carry
0174 0A85  0775 	INCF  FSR0+1,1
0175 0180  0776 	CLRF  INDF0
           0777 			;	}
0176 0AA2  0778 	INCF  k,1
0177 2969  0779 	GOTO  m015
           0780 			;}
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 14

ADDR CODE  LINE SOURCE

0178 0008  0781 m016	RETURN
           0782 			;
           0783 			;/***
           0784 			;*** This funktion sets the values of the global LedBuffer
           0785 			;*** only Led's where the address bit is 1 will be set to the new color
           0786 			;***/
           0787 			;void ledstrip_set_color(struct cmd_set_color *pCmd)
           0788 			;{	
           0789 ledstrip_set_color
           0790 			;	char *address = pCmd->addr;
0179 0020  0791 	MOVLB 0
017A 082D  0792 	MOVF  pCmd,W
017B 00AE  0793 	MOVWF address
           0794 			;	char r = pCmd->red;
017C 3004  0795 	MOVLW 4
017D 072D  0796 	ADDWF pCmd,W
017E 0084  0797 	MOVWF FSR0L
017F 0185  0798 	CLRF  FSR0H
0180 0800  0799 	MOVF  INDF0,W
0181 00AF  0800 	MOVWF r
           0801 			;	char g = pCmd->green;
0182 3005  0802 	MOVLW 5
0183 072D  0803 	ADDWF pCmd,W
0184 0084  0804 	MOVWF FSR0L
0185 0185  0805 	CLRF  FSR0H
0186 0800  0806 	MOVF  INDF0,W
0187 00B0  0807 	MOVWF g
           0808 			;	char b = pCmd->blue;
0188 3006  0809 	MOVLW 6
0189 072D  0810 	ADDWF pCmd,W
018A 0084  0811 	MOVWF FSR0L
018B 0185  0812 	CLRF  FSR0H
018C 0800  0813 	MOVF  INDF0,W
018D 00B1  0814 	MOVWF b
           0815 			;	
           0816 			;	char k,mask;
           0817 			;	mask = 0b00000001;
018E 3001  0818 	MOVLW 1
018F 00B3  0819 	MOVWF mask
           0820 			;	for(k = 0; k < (NUM_OF_LED * 3); k++)
0190 01B2  0821 	CLRF  k_2
0191 3060  0822 m017	MOVLW 96
0192 0020  0823 	MOVLB 0
0193 0232  0824 	SUBWF k_2,W
0194 1803  0825 	BTFSC 0x03,Carry
0195 29C8  0826 	GOTO  m021
           0827 			;	{	
           0828 			;		if(0 != (*address & mask))
0196 0185  0829 	CLRF  FSR0H
0197 082E  0830 	MOVF  address,W
0198 0084  0831 	MOVWF FSR0L
0199 0833  0832 	MOVF  mask,W
019A 0500  0833 	ANDWF INDF0,W
019B 1903  0834 	BTFSC 0x03,Zero_
019C 29BB  0835 	GOTO  m018
           0836 			;		{
           0837 			;			gLedBuf.led_array[k] = b;
019D 3020  0838 	MOVLW 32
019E 0085  0839 	MOVWF FSR0+1
019F 3040  0840 	MOVLW 64
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 15

ADDR CODE  LINE SOURCE

01A0 0732  0841 	ADDWF k_2,W
01A1 0084  0842 	MOVWF FSR0
01A2 1803  0843 	BTFSC 0x03,Carry
01A3 0A85  0844 	INCF  FSR0+1,1
01A4 0831  0845 	MOVF  b,W
01A5 0080  0846 	MOVWF INDF0
           0847 			;			k++;
01A6 0AB2  0848 	INCF  k_2,1
           0849 			;			gLedBuf.led_array[k] = g;
01A7 3020  0850 	MOVLW 32
01A8 0085  0851 	MOVWF FSR0+1
01A9 3040  0852 	MOVLW 64
01AA 0732  0853 	ADDWF k_2,W
01AB 0084  0854 	MOVWF FSR0
01AC 1803  0855 	BTFSC 0x03,Carry
01AD 0A85  0856 	INCF  FSR0+1,1
01AE 0830  0857 	MOVF  g,W
01AF 0080  0858 	MOVWF INDF0
           0859 			;			k++;
01B0 0AB2  0860 	INCF  k_2,1
           0861 			;			gLedBuf.led_array[k] = r;
01B1 3020  0862 	MOVLW 32
01B2 0085  0863 	MOVWF FSR0+1
01B3 3040  0864 	MOVLW 64
01B4 0732  0865 	ADDWF k_2,W
01B5 0084  0866 	MOVWF FSR0
01B6 1803  0867 	BTFSC 0x03,Carry
01B7 0A85  0868 	INCF  FSR0+1,1
01B8 082F  0869 	MOVF  r,W
01B9 0080  0870 	MOVWF INDF0
           0871 			;		}
           0872 			;		else 
01BA 29BE  0873 	GOTO  m019
           0874 			;		{
           0875 			;			k++;
01BB 0020  0876 m018	MOVLB 0
01BC 0AB2  0877 	INCF  k_2,1
           0878 			;			k++;
01BD 0AB2  0879 	INCF  k_2,1
           0880 			;		}
           0881 			;#ifdef X86
           0882 			;		mask = mask << 1;
           0883 			;		if(0 == mask)
           0884 			;#else
           0885 			;		RLF(mask,1);
01BE 0020  0886 m019	MOVLB 0
01BF 0DB3  0887 	RLF   mask,1
           0888 			;		if(Carry == 1) 
01C0 1C03  0889 	BTFSS 0x03,Carry
01C1 29C5  0890 	GOTO  m020
           0891 			;#endif
           0892 			;		{
           0893 			;			address++;
01C2 0AAE  0894 	INCF  address,1
           0895 			;			mask= 0b00000001;
01C3 3001  0896 	MOVLW 1
01C4 00B3  0897 	MOVWF mask
           0898 			;		}
           0899 			;	}
01C5 0020  0900 m020	MOVLB 0
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 16

ADDR CODE  LINE SOURCE

01C6 0AB2  0901 	INCF  k_2,1
01C7 2991  0902 	GOTO  m017
           0903 			;	spi_send_ledbuf(&gLedBuf.led_array[0]);
01C8 3040  0904 m021	MOVLW 64
01C9 0020  0905 	MOVLB 0
01CA 00B4  0906 	MOVWF array_4
01CB 3020  0907 	MOVLW 32
01CC 00B5  0908 	MOVWF array_4+1
01CD 2A1C  0909 	GOTO  spi_send_ledbuf
           0910 
           0911   ; FILE main.c
           0912 			;
           0913 			;// cc5xfree is a bit stupid so we include the other implementation files here
           0914 			;#ifndef X86
           0915 			;#include "crc.c"
           0916 			;#include "eeprom.c"
           0917 			;#include "error.c"
           0918 			;#include "ledstrip.c"
           0919 
           0920   ; FILE RingBuf.c
           0921 			;
           0922 			;#include "RingBuf.h"
           0923 			;
           0924 			;#ifndef X86
           0925 			;#message Global variables are defined in RingBuf.c
           0926 			;#endif /* #ifndef X86 */
           0927 			;struct RingBuffer gRingBuf;
           0928 			;
           0929 			;void RingBufInit(void)
           0930 			;{
           0931 RingBufInit
           0932 			;	gRingBuf.read = 0;
01CE 0020  0933 	MOVLB 0
01CF 01C9  0934 	CLRF  gRingBuf+16
           0935 			;	gRingBuf.write = 0;
01D0 01CA  0936 	CLRF  gRingBuf+17
           0937 			;	gRingBuf.error_full = 0;
01D1 104B  0938 	BCF   gRingBuf+18,0
           0939 			;}
01D2 0008  0940 	RETURN
           0941 			;
           0942 			;char RingBufGet(void)
           0943 			;{
           0944 RingBufGet
           0945 			;	char result = gRingBuf.data[gRingBuf.read];
01D3 3039  0946 	MOVLW 57
01D4 0020  0947 	MOVLB 0
01D5 0749  0948 	ADDWF gRingBuf+16,W
01D6 0084  0949 	MOVWF FSR0L
01D7 0185  0950 	CLRF  FSR0H
01D8 0800  0951 	MOVF  INDF0,W
01D9 00A5  0952 	MOVWF result
           0953 			;	gRingBuf.read = RingBufInc(gRingBuf.read);
01DA 0A49  0954 	INCF  gRingBuf+16,W
01DB 390F  0955 	ANDLW 15
01DC 00C9  0956 	MOVWF gRingBuf+16
           0957 			;	return result;
01DD 0825  0958 	MOVF  result,W
01DE 0008  0959 	RETURN
           0960 			;}
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 17

ADDR CODE  LINE SOURCE

           0961 			;
           0962 			;void RingBufPut(char value)
           0963 			;{
           0964 RingBufPut
01DF 0020  0965 	MOVLB 0
01E0 00A0  0966 	MOVWF value
           0967 			;	char writeNext = RingBufInc(gRingBuf.write);
01E1 0A4A  0968 	INCF  gRingBuf+17,W
01E2 390F  0969 	ANDLW 15
01E3 00A1  0970 	MOVWF writeNext
           0971 			;	if(writeNext != gRingBuf.read)
01E4 0821  0972 	MOVF  writeNext,W
01E5 0649  0973 	XORWF gRingBuf+16,W
01E6 1903  0974 	BTFSC 0x03,Zero_
01E7 29F1  0975 	GOTO  m022
           0976 			;	{
           0977 			;		gRingBuf.data[gRingBuf.write] = value;
01E8 3039  0978 	MOVLW 57
01E9 074A  0979 	ADDWF gRingBuf+17,W
01EA 0084  0980 	MOVWF FSR0L
01EB 0185  0981 	CLRF  FSR0H
01EC 0820  0982 	MOVF  value,W
01ED 0080  0983 	MOVWF INDF0
           0984 			;		gRingBuf.write = writeNext;
01EE 0821  0985 	MOVF  writeNext,W
01EF 00CA  0986 	MOVWF gRingBuf+17
           0987 			;	}
           0988 			;	else gRingBuf.error_full = 1;
01F0 29F3  0989 	GOTO  m023
01F1 0020  0990 m022	MOVLB 0
01F2 144B  0991 	BSF   gRingBuf+18,0
           0992 			;}
01F3 0008  0993 m023	RETURN
           0994 
           0995   ; FILE spi.c
           0996 			;//Nils Weiß 
           0997 			;//20.04.2012
           0998 			;//Compiler CC5x
           0999 			;
           1000 			;#include "ledstrip.h"
           1001 			;
           1002 			;#ifndef X86
           1003 			;void spi_init()
           1004 			;{
           1005 spi_init
           1006 			;	TRISC.3 = 0;        // Make port RC3 an output(SPI Clock)
01F4 0021  1007 	MOVLB 1
01F5 118E  1008 	BCF   TRISC,3
           1009 			;    TRISC.4 = 1;        // Make port RC4 an input(SPI Data In)
01F6 160E  1010 	BSF   TRISC,4
           1011 			;    TRISC.5 = 0;        // Make port RC5 an output(SPI Data Out)
01F7 128E  1012 	BCF   TRISC,5
           1013 			;	SSPM1 = 0;
01F8 0024  1014 	MOVLB 4
01F9 1095  1015 	BCF   0x215,SSPM1
           1016 			;	SMP = 0;
01FA 1394  1017 	BCF   0x214,SMP
           1018 			;	CKP = 1;
01FB 1615  1019 	BSF   0x215,CKP
           1020 			;	CKE = 0;
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 18

ADDR CODE  LINE SOURCE

01FC 1314  1021 	BCF   0x214,CKE
           1022 			;	SSPEN = 1;
01FD 1695  1023 	BSF   0x215,SSPEN
           1024 			;}
01FE 0008  1025 	RETURN
           1026 			;
           1027 			;char spi_send(char data)
           1028 			;{
           1029 spi_send
01FF 0020  1030 	MOVLB 0
0200 00B8  1031 	MOVWF data_4
           1032 			;	SSPBUF = data;	
0201 0838  1033 	MOVF  data_4,W
0202 0024  1034 	MOVLB 4
0203 0091  1035 	MOVWF SSPBUF
           1036 			;	while(SSPIF == 0);
0204 0020  1037 m024	MOVLB 0
0205 1D91  1038 	BTFSS 0x11,SSPIF
0206 2A04  1039 	GOTO  m024
           1040 			;	return SSPBUF;
0207 0024  1041 	MOVLB 4
0208 0811  1042 	MOVF  SSPBUF,W
0209 0008  1043 	RETURN
           1044 			;}
           1045 			;#endif /* #ifndef X86 */
           1046 			;
           1047 			;/***
           1048 			;**	This function sends the array to the LED controller(WS2801)
           1049 			;**  it starts with the last byte to get a correct output
           1050 			;***/
           1051 			;void spi_send_arr(char *array, char length)
           1052 			;{
           1053 spi_send_arr
020A 00FF  1054 	MOVWF length_4
           1055 			;	if(array == 0) return;
020B 08FF  1056 	MOVF  array_3,1
020C 1903  1057 	BTFSC 0x03,Zero_
020D 0008  1058 	RETURN
           1059 			;	char i;
           1060 			;	for(i = length; i == 0; i-- )
020E 087F  1061 	MOVF  length_4,W
020F 00FF  1062 	MOVWF i_4
0210 08FF  1063 m025	MOVF  i_4,1
0211 1D03  1064 	BTFSS 0x03,Zero_
0212 2A1B  1065 	GOTO  m026
           1066 			;	{
           1067 			;		spi_send(array[i]);
0213 087F  1068 	MOVF  i_4,W
0214 077F  1069 	ADDWF array_3,W
0215 0084  1070 	MOVWF FSR0L
0216 0185  1071 	CLRF  FSR0H
0217 0800  1072 	MOVF  INDF0,W
0218 21FF  1073 	CALL  spi_send
           1074 			;	} 
0219 03FF  1075 	DECF  i_4,1
021A 2A10  1076 	GOTO  m025
           1077 			;}
021B 0008  1078 m026	RETURN
           1079 			;
           1080 			;void spi_send_ledbuf(char *array)//!!! CHECK if GIE=0 during the sendroutine improves the result
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 19

ADDR CODE  LINE SOURCE

           1081 			;{
           1082 spi_send_ledbuf
           1083 			;	//array must be the address of the first byte
           1084 			;	char* end;
           1085 			;	//calculate where the end is
           1086 			;	end = array + (NUM_OF_LED * 3);
021C 0020  1087 	MOVLB 0
021D 0835  1088 	MOVF  array_4+1,W
021E 00B7  1089 	MOVWF end+1
021F 3060  1090 	MOVLW 96
0220 0734  1091 	ADDWF array_4,W
0221 00B6  1092 	MOVWF end
0222 1803  1093 	BTFSC 0x03,Carry
0223 0AB7  1094 	INCF  end+1,1
           1095 			;	//send all
           1096 			;	for(; array < end; array++)
0224 0020  1097 m027	MOVLB 0
0225 0837  1098 	MOVF  end+1,W
0226 0235  1099 	SUBWF array_4+1,W
0227 1C03  1100 	BTFSS 0x03,Carry
0228 2A2F  1101 	GOTO  m028
0229 1D03  1102 	BTFSS 0x03,Zero_
022A 2A3B  1103 	GOTO  m029
022B 0836  1104 	MOVF  end,W
022C 0234  1105 	SUBWF array_4,W
022D 1803  1106 	BTFSC 0x03,Carry
022E 2A3B  1107 	GOTO  m029
           1108 			;	{
           1109 			;		spi_send(*array);
022F 0020  1110 m028	MOVLB 0
0230 0835  1111 	MOVF  array_4+1,W
0231 0085  1112 	MOVWF FSR0H
0232 0834  1113 	MOVF  array_4,W
0233 0084  1114 	MOVWF FSR0L
0234 0800  1115 	MOVF  INDF0,W
0235 21FF  1116 	CALL  spi_send
           1117 			;	}
0236 0020  1118 	MOVLB 0
0237 0AB4  1119 	INCF  array_4,1
0238 1903  1120 	BTFSC 0x03,Zero_
0239 0AB5  1121 	INCF  array_4+1,1
023A 2A24  1122 	GOTO  m027
           1123 			;}
023B 0008  1124 m029	RETURN
           1125 
           1126   ; FILE usart.c
           1127 			;// Include-Datei für Serielle Kommunikation über Hardwaremodul des Pic
           1128 			; //
           1129 			; //
           1130 			; // Nils Weiß
           1131 			; // 29.11.2010
           1132 			; // Compiler CC5x
           1133 			;
           1134 			;#ifndef X86
           1135 			;//*******  Initialisierungs-Funktion  *************************************************
           1136 			;void USARTinit()
           1137 			;{
           1138 USARTinit
           1139 			;	//USART TX Pin als Ausgang
           1140 			;	TRISC.6 = 0;
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 20

ADDR CODE  LINE SOURCE

023C 0021  1141 	MOVLB 1
023D 130E  1142 	BCF   TRISC,6
           1143 			;
           1144 			;    BRGH=1;					// High Baudrate activated
023E 0023  1145 	MOVLB 3
023F 151E  1146 	BSF   0x19E,BRGH
           1147 			;	BRG16=0;
0240 119F  1148 	BCF   0x19F,BRG16
           1149 			;	SPBRGL=25;				// 19200 Bps @ 8 MHz Clock
0241 3019  1150 	MOVLW 25
0242 009B  1151 	MOVWF SPBRGL
           1152 			;	SPBRGH=0;
0243 019C  1153 	CLRF  SPBRGH
           1154 			;    SPEN = 1;               // Set_Serial_Pins;
0244 179D  1155 	BSF   0x19D,SPEN
           1156 			;    SYNC = 0;               // Set_Async_Mode;
0245 121E  1157 	BCF   0x19E,SYNC
           1158 			;    TX9 = 0;                // Set_8bit_Tx;
0246 131E  1159 	BCF   0x19E,TX9
           1160 			;    RX9 = 0;                // Set_8bit_Rx;
0247 131D  1161 	BCF   0x19D,RX9
           1162 			;    CREN = 1;               // Enable_Rx;
0248 161D  1163 	BSF   0x19D,CREN
           1164 			;    TXEN = 1;               // Enable_Tx;
0249 169E  1165 	BSF   0x19E,TXEN
           1166 			;    RCIE=1;                 // Rx Interrupt aus
024A 0021  1167 	MOVLB 1
024B 1691  1168 	BSF   0x91,RCIE
           1169 			;	ADDEN=0;				// Disable Adressdetection
024C 0023  1170 	MOVLB 3
024D 119D  1171 	BCF   0x19D,ADDEN
           1172 			;}
024E 0008  1173 	RETURN
           1174 			;
           1175 			;//*******  Sende-char-Funktion  *************************************************
           1176 			;void USARTsend(unsigned char ch)
           1177 			;{
           1178 USARTsend
024F 0020  1179 	MOVLB 0
0250 00A5  1180 	MOVWF ch
           1181 			;	while(!TXIF);
0251 0020  1182 m030	MOVLB 0
0252 1E11  1183 	BTFSS 0x11,TXIF
0253 2A51  1184 	GOTO  m030
           1185 			;	TXREG=ch;
0254 0020  1186 	MOVLB 0
0255 0825  1187 	MOVF  ch,W
0256 0023  1188 	MOVLB 3
0257 009A  1189 	MOVWF TXREG
           1190 			;}
0258 0008  1191 	RETURN
           1192 			;#endif /* #ifndef X86 */
           1193 			;
           1194 			;//*******  Sende-String-Funktion  *************************************************
           1195 			;void USARTsend_str(const char *string)
           1196 			;{
           1197 USARTsend_str
           1198 			; char ps;
           1199 			; ps = *string;
0259 0020  1200 	MOVLB 0
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 21

ADDR CODE  LINE SOURCE

025A 0822  1201 	MOVF  string,W
025B 2012  1202 	CALL  _const1
025C 0020  1203 	MOVLB 0
025D 00A3  1204 	MOVWF ps
           1205 			; while(ps > 0)
025E 0020  1206 m031	MOVLB 0
025F 08A3  1207 	MOVF  ps,1
0260 1903  1208 	BTFSC 0x03,Zero_
0261 2A6B  1209 	GOTO  m032
           1210 			;   {
           1211 			;    string++;
0262 0AA2  1212 	INCF  string,1
           1213 			;   	USARTsend(ps);
0263 0823  1214 	MOVF  ps,W
0264 224F  1215 	CALL  USARTsend
           1216 			;    ps = *string;
0265 0020  1217 	MOVLB 0
0266 0822  1218 	MOVF  string,W
0267 2012  1219 	CALL  _const1
0268 0020  1220 	MOVLB 0
0269 00A3  1221 	MOVWF ps
           1222 			;   }
026A 2A5E  1223 	GOTO  m031
           1224 			;}
026B 0008  1225 m032	RETURN
           1226 			;
           1227 			;//*******  Sende-Array-Funktion  *************************************************
           1228 			;void USARTsend_arr(char *array, char length)
           1229 			;{
           1230 USARTsend_arr
026C 00FF  1231 	MOVWF length_5
           1232 			;	if(array == 0) return;
026D 08FF  1233 	MOVF  array_5,1
026E 1903  1234 	BTFSC 0x03,Zero_
026F 0008  1235 	RETURN
           1236 			;	char i;
           1237 			;	for(i=0;i<length;i++)
0270 01FF  1238 	CLRF  i_5
0271 087F  1239 m033	MOVF  length_5,W
0272 027F  1240 	SUBWF i_5,W
0273 1803  1241 	BTFSC 0x03,Carry
0274 2A7D  1242 	GOTO  m034
           1243 			;	{
           1244 			;		USARTsend(*array);
0275 0185  1245 	CLRF  FSR0H
0276 087F  1246 	MOVF  array_5,W
0277 0084  1247 	MOVWF FSR0L
0278 0800  1248 	MOVF  INDF0,W
0279 224F  1249 	CALL  USARTsend
           1250 			;		array++;
027A 0AFF  1251 	INCF  array_5,1
           1252 			;	}
027B 0AFF  1253 	INCF  i_5,1
027C 2A71  1254 	GOTO  m033
           1255 			;}
027D 0008  1256 m034	RETURN
           1257 
           1258   ; FILE commandstorage.c
           1259 			;#include "platform.h"
           1260 			;#include "commandstorage.h"
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 22

ADDR CODE  LINE SOURCE

           1261 			;
           1262 			;struct led_cmd* commandstorage_read(struct led_cmd *pDest, bit movePtr)
           1263 			;{
           1264 commandstorage_read
           1265 			;	//check parameter
           1266 			;	if(0 == pDest) return 0;
027E 0020  1267 	MOVLB 0
027F 08AD  1268 	MOVF  pDest,1
0280 1903  1269 	BTFSC 0x03,Zero_
0281 3400  1270 	RETLW 0
           1271 			;
           1272 			;	//commands available in eeprom?
           1273 			;	char nextCmd = EEPROM_RD(CmdPointerAddr);
0282 30FF  1274 	MOVLW 255
0283 210E  1275 	CALL  EEPROM_RD
0284 0020  1276 	MOVLB 0
0285 00AE  1277 	MOVWF nextCmd
           1278 			;	if(0 == nextCmd) return 0;
0286 08AE  1279 	MOVF  nextCmd,1
0287 1903  1280 	BTFSC 0x03,Zero_
0288 3400  1281 	RETLW 0
           1282 			;
           1283 			;	//read command from eeprom
           1284 			;	EEPROM_RD_BLK((char*)pDest, (nextCmd - CmdWidth), CmdWidth);
0289 0020  1285 	MOVLB 0
028A 082D  1286 	MOVF  pDest,W
028B 00B0  1287 	MOVWF array_2
028C 300A  1288 	MOVLW 10
028D 022E  1289 	SUBWF nextCmd,W
028E 00B1  1290 	MOVWF adress_4
028F 300A  1291 	MOVLW 10
0290 2134  1292 	CALL  EEPROM_RD_BLK
           1293 			;
           1294 			;	//do we have to update the CmdPointer?
           1295 			;	if(movePtr)
0291 0020  1296 	MOVLB 0
0292 1C2F  1297 	BTFSS 0x2F,movePtr
0293 2A99  1298 	GOTO  m035
           1299 			;	{		
           1300 			;		EEPROM_WR(CmdPointerAddr, nextCmd - CmdWidth);
0294 30FF  1301 	MOVLW 255
0295 00B0  1302 	MOVWF adress
0296 300A  1303 	MOVLW 10
0297 022E  1304 	SUBWF nextCmd,W
0298 20EC  1305 	CALL  EEPROM_WR
           1306 			;	}
           1307 			;	return pDest;
0299 0020  1308 m035	MOVLB 0
029A 082D  1309 	MOVF  pDest,W
029B 0008  1310 	RETURN
           1311 			;}
           1312 			;
           1313 			;bit commandstorage_write(char *pSrc, char length)
           1314 			;{
           1315 commandstorage_write
029C 0020  1316 	MOVLB 0
029D 00A6  1317 	MOVWF length_6
           1318 			;	//check parameter
           1319 			;	if(0 == pSrc) return FALSE;
029E 08A5  1320 	MOVF  pSrc,1
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 23

ADDR CODE  LINE SOURCE

029F 1D03  1321 	BTFSS 0x03,Zero_
02A0 2AA3  1322 	GOTO  m036
02A1 1003  1323 	BCF   0x03,Carry
02A2 0008  1324 	RETURN
           1325 			;	
           1326 			;	//enought free space in eeprom?
           1327 			;	char nextCmd = EEPROM_RD(CmdPointerAddr);
02A3 30FF  1328 m036	MOVLW 255
02A4 210E  1329 	CALL  EEPROM_RD
02A5 0020  1330 	MOVLB 0
02A6 00A7  1331 	MOVWF nextCmd_2
           1332 			;	if(nextCmd >= (CmdPointerAddr - CmdWidth)) return FALSE;
02A7 30F5  1333 	MOVLW 245
02A8 0227  1334 	SUBWF nextCmd_2,W
02A9 1C03  1335 	BTFSS 0x03,Carry
02AA 2AAD  1336 	GOTO  m037
02AB 1003  1337 	BCF   0x03,Carry
02AC 0008  1338 	RETURN
           1339 			;
           1340 			;	//increase the command pointer in eeprom
           1341 			;	EEPROM_WR(CmdPointerAddr,(nextCmd + CmdWidth));
02AD 30FF  1342 m037	MOVLW 255
02AE 0020  1343 	MOVLB 0
02AF 00B0  1344 	MOVWF adress
02B0 300A  1345 	MOVLW 10
02B1 0727  1346 	ADDWF nextCmd_2,W
02B2 20EC  1347 	CALL  EEPROM_WR
           1348 			;		
           1349 			;	//write data to eeprom
           1350 			;	EEPROM_WR_BLK(pSrc, nextCmd, length);
02B3 0020  1351 	MOVLB 0
02B4 0825  1352 	MOVF  pSrc,W
02B5 00A8  1353 	MOVWF array
02B6 0827  1354 	MOVF  nextCmd_2,W
02B7 00A9  1355 	MOVWF adress_3
02B8 0826  1356 	MOVF  length_6,W
02B9 211B  1357 	CALL  EEPROM_WR_BLK
           1358 			;		
           1359 			;	return TRUE;
02BA 1403  1360 	BSF   0x03,Carry
02BB 0008  1361 	RETURN
           1362 			;}
           1363 			;
           1364 			;void commandstorage_get_commands()
           1365 			;{	
           1366 commandstorage_get_commands
           1367 			;	if(RingBufHasError)
02BC 0020  1368 	MOVLB 0
02BD 1C4B  1369 	BTFSS gRingBuf+18,0
02BE 2AC1  1370 	GOTO  m038
           1371 			;	{
           1372 			;		// *** if a RingBufError occure, I have to throw away the current command,
           1373 			;		// *** because the last byte was not saved. Commandstring is inconsistent
           1374 			;		ClearCmdBuf();
02BF 01CD  1375 	CLRF  gCmdBuf
02C0 01CE  1376 	CLRF  gCmdBuf+1
           1377 			;	}
           1378 			;
           1379 			;	if(RingBufIsNotEmpty)
02C1 0020  1380 m038	MOVLB 0
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 24

ADDR CODE  LINE SOURCE

02C2 084A  1381 	MOVF  gRingBuf+17,W
02C3 0649  1382 	XORWF gRingBuf+16,W
02C4 1903  1383 	BTFSC 0x03,Zero_
02C5 2B38  1384 	GOTO  m047
           1385 			;	{
           1386 			;		// *** preload variables and 
           1387 			;		// *** get new_byte from ringbuffer
           1388 			;		char new_byte, temp, j;
           1389 			;		temp = 0;
02C6 01A3  1390 	CLRF  temp_3
           1391 			;		j = 0;
02C7 01A4  1392 	CLRF  j
           1393 			;		// *** get new byte
           1394 			;		new_byte = RingBufGet();	
02C8 21D3  1395 	CALL  RingBufGet
02C9 0020  1396 	MOVLB 0
02CA 00A2  1397 	MOVWF new_byte
           1398 			;		// *** do I wait for databytes?
           1399 			;		if(gCmdBuf.frame_counter == 0)
02CB 08CE  1400 	MOVF  gCmdBuf+1,1
02CC 1D03  1401 	BTFSS 0x03,Zero_
02CD 2AF9  1402 	GOTO  m040
           1403 			;		{
           1404 			;			// *** I don't wait for databytes
           1405 			;			// *** Do I receive a Start_of_Text sign
           1406 			;			if(new_byte == STX)
02CE 0F22  1407 	INCFSZ new_byte,W
02CF 2AE2  1408 	GOTO  m039
           1409 			;			{
           1410 			;				// *** increse the cmd_counter
           1411 			;				gCmdBuf.cmd_counter = 1;
02D0 3001  1412 	MOVLW 1
02D1 00CD  1413 	MOVWF gCmdBuf
           1414 			;				// *** Write the startsign at the begin of the buffer
           1415 			;				gCmdBuf.cmd_buf[0] = new_byte;
02D2 0822  1416 	MOVF  new_byte,W
02D3 00CF  1417 	MOVWF gCmdBuf+2
           1418 			;                // *** Reset crc Variables
           1419 			;                newCRC(&gCmdBuf.crcH, &gCmdBuf.crcL);
02D4 305E  1420 	MOVLW 94
02D5 00A5  1421 	MOVWF p_crcH_2
02D6 305F  1422 	MOVLW 95
02D7 00A6  1423 	MOVWF p_crcL_2
02D8 20D8  1424 	CALL  newCRC
           1425 			;                // *** add new_byte to crc checksum
           1426 			;                addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
02D9 0020  1427 	MOVLB 0
02DA 0822  1428 	MOVF  new_byte,W
02DB 00A5  1429 	MOVWF byte
02DC 305E  1430 	MOVLW 94
02DD 00A6  1431 	MOVWF p_crcH
02DE 305F  1432 	MOVLW 95
02DF 00A7  1433 	MOVWF p_crcL
02E0 2083  1434 	CALL  addCRC
           1435 			;			}
           1436 			;			else
02E1 2B38  1437 	GOTO  m047
           1438 			;			{	
           1439 			;				// *** to avoid arrayoverflow
           1440 			;				temp = FRAMELENGTH - 2;
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 25

ADDR CODE  LINE SOURCE

02E2 300D  1441 m039	MOVLW 13
02E3 0020  1442 	MOVLB 0
02E4 00A3  1443 	MOVWF temp_3
           1444 			;				// *** check if I get the framelength byte
           1445 			;				if((new_byte < temp) && (gCmdBuf.cmd_counter == 1))
02E5 0823  1446 	MOVF  temp_3,W
02E6 0222  1447 	SUBWF new_byte,W
02E7 1803  1448 	BTFSC 0x03,Carry
02E8 2B38  1449 	GOTO  m047
02E9 0B4D  1450 	DECFSZ gCmdBuf,W
02EA 2B38  1451 	GOTO  m047
           1452 			;				{
           1453 			;					gCmdBuf.frame_counter = new_byte;
02EB 0822  1454 	MOVF  new_byte,W
02EC 00CE  1455 	MOVWF gCmdBuf+1
           1456 			;					gCmdBuf.cmd_buf[1] = new_byte;
02ED 0822  1457 	MOVF  new_byte,W
02EE 00D0  1458 	MOVWF gCmdBuf+3
           1459 			;					gCmdBuf.cmd_counter = 2;
02EF 3002  1460 	MOVLW 2
02F0 00CD  1461 	MOVWF gCmdBuf
           1462 			;                    // *** add new_byte to crc checksum
           1463 			;                    addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
02F1 0822  1464 	MOVF  new_byte,W
02F2 00A5  1465 	MOVWF byte
02F3 305E  1466 	MOVLW 94
02F4 00A6  1467 	MOVWF p_crcH
02F5 305F  1468 	MOVLW 95
02F6 00A7  1469 	MOVWF p_crcL
02F7 2083  1470 	CALL  addCRC
           1471 			;				}
           1472 			;			}
           1473 			;		}
           1474 			;		else
02F8 2B38  1475 	GOTO  m047
           1476 			;		{
           1477 			;			// *** I wait for Databytes, so I save all bytes 
           1478 			;			// *** that I get until my framecounter is > 0
           1479 			;			gCmdBuf.cmd_buf[gCmdBuf.cmd_counter] = new_byte;
02F9 304F  1480 m040	MOVLW 79
02FA 0020  1481 	MOVLB 0
02FB 074D  1482 	ADDWF gCmdBuf,W
02FC 0084  1483 	MOVWF FSR0L
02FD 0185  1484 	CLRF  FSR0H
02FE 0822  1485 	MOVF  new_byte,W
02FF 0080  1486 	MOVWF INDF0
           1487 			;			gCmdBuf.cmd_counter++;
0300 0ACD  1488 	INCF  gCmdBuf,1
           1489 			;			
           1490 			;            // *** add new_byte to crc checksum
           1491 			;			if(gCmdBuf.frame_counter > 2)
0301 3003  1492 	MOVLW 3
0302 024E  1493 	SUBWF gCmdBuf+1,W
0303 1C03  1494 	BTFSS 0x03,Carry
0304 2B0C  1495 	GOTO  m041
           1496 			;            addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
0305 0822  1497 	MOVF  new_byte,W
0306 00A5  1498 	MOVWF byte
0307 305E  1499 	MOVLW 94
0308 00A6  1500 	MOVWF p_crcH
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 26

ADDR CODE  LINE SOURCE

0309 305F  1501 	MOVLW 95
030A 00A7  1502 	MOVWF p_crcL
030B 2083  1503 	CALL  addCRC
           1504 			;			gCmdBuf.frame_counter--;
030C 0020  1505 m041	MOVLB 0
030D 0BCE  1506 	DECFSZ gCmdBuf+1,1
           1507 			;			// *** now I have to check if my framecounter is null.
           1508 			;			// *** If it's null my string is complete 
           1509 			;			// *** and I can give the string to the crc check function.
           1510 			;			if(gCmdBuf.frame_counter == 0)
030E 2B38  1511 	GOTO  m047
           1512 			;			{
           1513 			;#ifdef NO_CRC
           1514 			;				if(1==1)
           1515 			;#else
           1516 			;                // *** verify crc checksum
           1517 			;                if( (gCmdBuf.crcL == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 1]) &&
           1518 			;                    (gCmdBuf.crcH == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 2]) )
           1519 			;#endif
           1520 			;                {
           1521 			;					// *** Execute the simple Commands
           1522 			;					switch(gCmdBuf.cmd_buf[2])
030F 0851  1523 	MOVF  gCmdBuf+4,W
0310 3AF8  1524 	XORLW 248
0311 1903  1525 	BTFSC 0x03,Zero_
0312 2B1A  1526 	GOTO  m042
0313 3A02  1527 	XORLW 2
0314 1903  1528 	BTFSC 0x03,Zero_
0315 2B1F  1529 	GOTO  m043
0316 3A03  1530 	XORLW 3
0317 1903  1531 	BTFSC 0x03,Zero_
0318 2B22  1532 	GOTO  m044
0319 2B25  1533 	GOTO  m045
           1534 			;					{
           1535 			;						case DELETE: 
           1536 			;							{
           1537 			;								EEPROM_WR(CmdPointerAddr,0);
031A 30FF  1538 m042	MOVLW 255
031B 0020  1539 	MOVLB 0
031C 00B0  1540 	MOVWF adress
031D 3000  1541 	MOVLW 0
031E 28EC  1542 	GOTO  EEPROM_WR
           1543 			;								return;
           1544 			;							}
           1545 			;#ifndef X86
           1546 			;						case SET_ON: 
           1547 			;							{
           1548 			;								PowerOnLEDs();
031F 0020  1549 m043	MOVLB 0
0320 100E  1550 	BCF   PORTC,0
           1551 			;								return;
0321 0008  1552 	RETURN
           1553 			;								}
           1554 			;						case SET_OFF: 
           1555 			;							{
           1556 			;								PowerOffLEDs();
0322 0020  1557 m044	MOVLB 0
0323 140E  1558 	BSF   PORTC,0
           1559 			;								return;
0324 0008  1560 	RETURN
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 27

ADDR CODE  LINE SOURCE

           1561 			;							}
           1562 			;#endif /* #ifndef X86 */
           1563 			;					}			
           1564 			;					if( commandstorage_write(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4)))
0325 3051  1565 m045	MOVLW 81
0326 0020  1566 	MOVLB 0
0327 00A5  1567 	MOVWF pSrc
0328 3004  1568 	MOVLW 4
0329 024D  1569 	SUBWF gCmdBuf,W
032A 229C  1570 	CALL  commandstorage_write
032B 1C03  1571 	BTFSS 0x03,Carry
032C 2B32  1572 	GOTO  m046
           1573 			;					{
           1574 			;						USARTsend('G');
032D 3047  1575 	MOVLW 71
032E 224F  1576 	CALL  USARTsend
           1577 			;						USARTsend('C');
032F 3043  1578 	MOVLW 67
0330 224F  1579 	CALL  USARTsend
           1580 			;					}
           1581 			;					else 
0331 2B38  1582 	GOTO  m047
           1583 			;						gERROR.eeprom_failure = 1;
0332 0020  1584 m046	MOVLB 0
0333 14CC  1585 	BSF   gERROR,1
           1586 			;#ifdef TEST
           1587 			;					USARTsend_arr(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4));
           1588 			;#endif
           1589 			;                }
           1590 			;                else
0334 2B38  1591 	GOTO  m047
           1592 			;                {
           1593 			;                    // *** Do some error handling in case of an CRC failure here
           1594 			;					gERROR.crc_failure = 1;
0335 0020  1595 	MOVLB 0
0336 144C  1596 	BSF   gERROR,0
           1597 			;                    return;
0337 0008  1598 	RETURN
           1599 			;                }
           1600 			;			}
           1601 			;		}
           1602 			;	}
           1603 			;}
0338 0008  1604 m047	RETURN
           1605 			;
           1606 			;void commandstorage_execute_commands()
           1607 			;{
           1608 commandstorage_execute_commands
           1609 			;	// *** get the pointer to commands in the EEPROM
           1610 			;	struct led_cmd nextCmd;
           1611 			;
           1612 			;	// read next command from eeprom and move command pointer in eeprom to the next command (TRUE)
           1613 			;	struct led_cmd *result = commandstorage_read(&nextCmd, TRUE);
0339 3022  1614 	MOVLW 34
033A 0020  1615 	MOVLB 0
033B 00AD  1616 	MOVWF pDest
033C 142F  1617 	BSF   0x2F,movePtr
033D 227E  1618 	CALL  commandstorage_read
033E 0020  1619 	MOVLB 0
033F 00AC  1620 	MOVWF result_2
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 28

ADDR CODE  LINE SOURCE

           1621 			;	if(0 != result)
0340 08AC  1622 	MOVF  result_2,1
0341 1903  1623 	BTFSC 0x03,Zero_
0342 2B52  1624 	GOTO  m049
           1625 			;	{
           1626 			;		// *** commands available, check what to do
           1627 			;		switch(nextCmd.cmd) 
0343 0822  1628 	MOVF  nextCmd_3,W
0344 3AFD  1629 	XORLW 253
0345 1903  1630 	BTFSC 0x03,Zero_
0346 2B4E  1631 	GOTO  m048
0347 3A01  1632 	XORLW 1
0348 1903  1633 	BTFSC 0x03,Zero_
0349 2B52  1634 	GOTO  m049
034A 3A07  1635 	XORLW 7
034B 1903  1636 	BTFSC 0x03,Zero_
034C 2B52  1637 	GOTO  m049
034D 2B52  1638 	GOTO  m049
           1639 			;		{	
           1640 			;			case SET_COLOR: 
           1641 			;			{
           1642 			;				ledstrip_set_color(&nextCmd.data.set_color);
034E 3023  1643 m048	MOVLW 35
034F 0020  1644 	MOVLB 0
0350 00AD  1645 	MOVWF pCmd
0351 2179  1646 	CALL  ledstrip_set_color
           1647 			;				break;
           1648 			;			}
           1649 			;			case SET_FADE: {break;}
           1650 			;			case SET_RUN: {break;}
           1651 			;		}
           1652 			;	}
           1653 			;}
0352 0008  1654 m049	RETURN
           1655 			;
           1656 			;void commandstorage_init()
           1657 			;{
           1658 commandstorage_init
           1659 			;	/** EEPROM contains FF in every cell after inital start,
           1660 			;	*** so I have to delete the pointer address
           1661 			;	*** otherwise the PIC thinks he has the EEPROM full with commands
           1662 			;	**/
           1663 			;	if (EEPROM_RD(CmdPointerAddr) == 0xff)
0353 30FF  1664 	MOVLW 255
0354 210E  1665 	CALL  EEPROM_RD
0355 3AFF  1666 	XORLW 255
0356 1D03  1667 	BTFSS 0x03,Zero_
0357 2B5D  1668 	GOTO  m050
           1669 			;		EEPROM_WR(CmdPointerAddr, 0);
0358 30FF  1670 	MOVLW 255
0359 0020  1671 	MOVLB 0
035A 00B0  1672 	MOVWF adress
035B 3000  1673 	MOVLW 0
035C 20EC  1674 	CALL  EEPROM_WR
           1675 			;
           1676 			;	// set loop pointer address to start
           1677 			;	EEPROM_WR(CmdLoopPointerAddr, 0);
035D 30FD  1678 m050	MOVLW 253
035E 0020  1679 	MOVLB 0
035F 00B0  1680 	MOVWF adress
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 29

ADDR CODE  LINE SOURCE

0360 3000  1681 	MOVLW 0
0361 28EC  1682 	GOTO  EEPROM_WR
           1683 			;}
           1684 
           1685   ; FILE rn_171.c
           1686 			;#include "usart.h"
           1687 			;#include "rn_171.h"
           1688 			;
           1689 			;void Rn171FactoryRestore()
           1690 			;{
           1691 Rn171FactoryRestore
           1692 			;	USARTsend('$');
0362 3024  1693 	MOVLW 36
0363 224F  1694 	CALL  USARTsend
           1695 			;	USARTsend('$');
0364 3024  1696 	MOVLW 36
0365 224F  1697 	CALL  USARTsend
           1698 			;	USARTsend('$');
0366 3024  1699 	MOVLW 36
0367 224F  1700 	CALL  USARTsend
           1701 			;	
           1702 			;	USARTsend_str("load config_nils");
0368 304B  1703 	MOVLW 75
0369 0020  1704 	MOVLB 0
036A 00A2  1705 	MOVWF string
036B 2259  1706 	CALL  USARTsend_str
           1707 			;	USARTsend_str("save");
036C 305C  1708 	MOVLW 92
036D 0020  1709 	MOVLB 0
036E 00A2  1710 	MOVWF string
036F 2259  1711 	CALL  USARTsend_str
           1712 			;	USARTsend_str("reboot");
0370 3061  1713 	MOVLW 97
0371 0020  1714 	MOVLB 0
0372 00A2  1715 	MOVWF string
0373 2A59  1716 	GOTO  USARTsend_str
           1717 
           1718   ; FILE main.c
           1719 			;#include "RingBuf.c"
           1720 			;#include "spi.c"
           1721 			;#include "timer.c"
           1722 			;#include "usart.c"
           1723 			;#include "commandstorage.c"
           1724 			;#include "rn_171.c"
           1725 
           1726 	END
           1727 
           1728 
           1729 ; *** KEY INFO ***
           1730 
           1731 ; 0x01CE P0    5 word(s)  0 % : RingBufInit
           1732 ; 0x01D3 P0   12 word(s)  0 % : RingBufGet
           1733 ; 0x01DF P0   21 word(s)  1 % : RingBufPut
           1734 ; 0x023C P0   19 word(s)  0 % : USARTinit
           1735 ; 0x024F P0   10 word(s)  0 % : USARTsend
           1736 ; 0x0259 P0   19 word(s)  0 % : USARTsend_str
           1737 ; 0x026C P0   18 word(s)  0 % : USARTsend_arr
           1738 ; 0x00EC P0   34 word(s)  1 % : EEPROM_WR
           1739 ; 0x010E P0   13 word(s)  0 % : EEPROM_RD
           1740 ; 0x011B P0   25 word(s)  1 % : EEPROM_WR_BLK
CC5X Version 3.4E,   File: main.c              17. May 2012  13:59   Page 30

ADDR CODE  LINE SOURCE

           1741 ; 0x0134 P0   26 word(s)  1 % : EEPROM_RD_BLK
           1742 ; 0x0083 P0   40 word(s)  1 % : addCRC
           1743 ; 0x00AB P0   45 word(s)  2 % : CRC
           1744 ; 0x00D8 P0   20 word(s)  0 % : newCRC
           1745 ; 0x014E P0   25 word(s)  1 % : throw_errors
           1746 ; 0x027E P0   30 word(s)  1 % : commandstorage_read
           1747 ; 0x029C P0   32 word(s)  1 % : commandstorage_write
           1748 ; 0x02BC P0  125 word(s)  6 % : commandstorage_get_commands
           1749 ; 0x0339 P0   26 word(s)  1 % : commandstorage_execute_commands
           1750 ; 0x0353 P0   15 word(s)  0 % : commandstorage_init
           1751 ; 0x01F4 P0   11 word(s)  0 % : spi_init
           1752 ; 0x01FF P0   11 word(s)  0 % : spi_send
           1753 ; 0x020A P0   18 word(s)  0 % : spi_send_arr
           1754 ; 0x021C P0   32 word(s)  1 % : spi_send_ledbuf
           1755 ; 0x0167 P0   18 word(s)  0 % : ledstrip_init
           1756 ; 0x0179 P0   85 word(s)  4 % : ledstrip_set_color
           1757 ; 0x0362 P0   18 word(s)  0 % : Rn171FactoryRestore
           1758 ; 0x0004 P0   14 word(s)  0 % : InterruptRoutine
           1759 ; 0x0069 P0   26 word(s)  1 % : init_all
           1760 ; 0x0063 P0    6 word(s)  0 % : main
           1761 ; 0x0012 P0   81 word(s)  3 % : _const1
           1762 
           1763 ; RAM usage: 160 bytes (25 local), 352 bytes free
           1764 ; Maximum call level: 4 (+2 for interrupt)
           1765 ;  Codepage 0 has  881 word(s) :  43 %
           1766 ;  Codepage 1 has    0 word(s) :   0 %
           1767 ;  Codepage 2 has    0 word(s) :   0 %
           1768 ;  Codepage 3 has    0 word(s) :   0 %
           1769 ; Total of 881 code words (10 %)
