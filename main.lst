CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 1

ADDR CODE  LINE SOURCE

           0001 
           0002 ; CC5X Version 3.4E, Copyright (c) B Knudsen Data
           0003 ; C compiler for the PICmicro family
           0004 ; ************  10. Jun 2012  23:58  *************
           0005 
           0006 	processor  16F1936
           0007 	radix  DEC
           0008 
     0000  0009 INDF0       EQU   0x00
     0004  0010 FSR0        EQU   0x04
     0004  0011 FSR0L       EQU   0x04
     0005  0012 FSR0H       EQU   0x05
     0000  0013 Carry       EQU   0
     0002  0014 Zero_       EQU   2
     000E  0015 PORTC       EQU   0x0E
     001B  0016 PR2         EQU   0x1B
     001C  0017 T2CON       EQU   0x1C
     008E  0018 TRISC       EQU   0x8E
     0099  0019 OSCCON      EQU   0x99
     0191  0020 EEADRL      EQU   0x191
     0192  0021 EEADRH      EQU   0x192
     0193  0022 EEDATL      EQU   0x193
     0194  0023 EEDATH      EQU   0x194
     0196  0024 EECON2      EQU   0x196
     0199  0025 RCREG       EQU   0x199
     019A  0026 TXREG       EQU   0x19A
     019B  0027 SPBRGL      EQU   0x19B
     019C  0028 SPBRGH      EQU   0x19C
     0211  0029 SSPBUF      EQU   0x211
     0416  0030 PR4         EQU   0x416
     0417  0031 T4CON       EQU   0x417
     0006  0032 PEIE        EQU   6
     0007  0033 GIE         EQU   7
     0001  0034 TMR2IF      EQU   1
     0003  0035 SSPIF       EQU   3
     0004  0036 TXIF        EQU   4
     0005  0037 RCIF        EQU   5
     0001  0038 TMR4IF      EQU   1
     0001  0039 TMR2IE      EQU   1
     0005  0040 RCIE        EQU   5
     0001  0041 TMR4IE      EQU   1
     0000  0042 RD          EQU   0
     0001  0043 WR          EQU   1
     0002  0044 WREN        EQU   2
     0006  0045 CFGS        EQU   6
     0007  0046 EEPGD       EQU   7
     0003  0047 ADDEN       EQU   3
     0004  0048 CREN        EQU   4
     0006  0049 RX9         EQU   6
     0007  0050 SPEN        EQU   7
     0002  0051 BRGH        EQU   2
     0004  0052 SYNC        EQU   4
     0005  0053 TXEN        EQU   5
     0006  0054 TX9         EQU   6
     0003  0055 BRG16       EQU   3
     0006  0056 CKE         EQU   6
     0007  0057 SMP         EQU   7
     0001  0058 SSPM1       EQU   1
     0004  0059 CKP         EQU   4
     0005  0060 SSPEN       EQU   5
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 2

ADDR CODE  LINE SOURCE

     003A  0061 gRingBuf    EQU   0x3A
     004D  0062 gERROR      EQU   0x4D
     004E  0063 gTimecounter EQU   0x4E
     004F  0064 gCmdBuf     EQU   0x4F
     0065  0065 gLedBuf     EQU   0x65
     0020  0066 temp        EQU   0x20
     0025  0067 byte        EQU   0x25
     0026  0068 p_crcH      EQU   0x26
     0027  0069 p_crcL      EQU   0x27
     0028  0070 index       EQU   0x28
     0029  0071 crcH        EQU   0x29
     002A  0072 crcL        EQU   0x2A
     007F  0073 data        EQU   0x7F
     007F  0074 length      EQU   0x7F
     007F  0075 crcH_out    EQU   0x7F
     007F  0076 crcL_out    EQU   0x7F
     007F  0077 crcH_2      EQU   0x7F
     007F  0078 crcL_2      EQU   0x7F
     007F  0079 i           EQU   0x7F
     007F  0080 byte_2      EQU   0x7F
     0025  0081 p_crcH_2    EQU   0x25
     0026  0082 p_crcL_2    EQU   0x26
     002F  0083 adress      EQU   0x2F
     0030  0084 data_2      EQU   0x30
     0000  0085 GIE_status  EQU   0
     0034  0086 adress_2    EQU   0x34
     0035  0087 data_3      EQU   0x35
     0028  0088 array       EQU   0x28
     0029  0089 adress_3    EQU   0x29
     002A  0090 length_2    EQU   0x2A
     002B  0091 i_2         EQU   0x2B
     002F  0092 array_2     EQU   0x2F
     0030  0093 adress_4    EQU   0x30
     0031  0094 length_3    EQU   0x31
     0032  0095 i_3         EQU   0x32
     0033  0096 temp_2      EQU   0x33
     0034  0097 arg1        EQU   0x34
     0035  0098 arg2        EQU   0x35
     0036  0099 rval        EQU   0x36
     0038  0100 counter     EQU   0x38
     0034  0101 arg1_5      EQU   0x34
     0036  0102 arg2_5      EQU   0x36
     0037  0103 rm          EQU   0x37
     0038  0104 counter_5   EQU   0x38
     0039  0105 tmp         EQU   0x39
     0022  0106 k           EQU   0x22
     002D  0107 pCmd        EQU   0x2D
     002E  0108 address     EQU   0x2E
     002F  0109 r           EQU   0x2F
     0030  0110 g           EQU   0x30
     0031  0111 b           EQU   0x31
     0032  0112 k_2         EQU   0x32
     0033  0113 mask        EQU   0x33
     002D  0114 pCmd_2      EQU   0x2D
     002E  0115 address_2   EQU   0x2E
     002F  0116 r_2         EQU   0x2F
     0030  0117 g_2         EQU   0x30
     0031  0118 b_2         EQU   0x31
     0032  0119 k_3         EQU   0x32
     0033  0120 mask_2      EQU   0x33
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 3

ADDR CODE  LINE SOURCE

     0034  0121 temp_3      EQU   0x34
     0000  0122 fade_finish EQU   0
     0022  0123 temp_current EQU   0x22
     0023  0124 temp_destination EQU   0x23
     0024  0125 i_4         EQU   0x24
     0025  0126 result      EQU   0x25
     0020  0127 value       EQU   0x20
     0021  0128 writeNext   EQU   0x21
     0038  0129 data_4      EQU   0x38
     007F  0130 array_3     EQU   0x7F
     007F  0131 length_4    EQU   0x7F
     007F  0132 i_5         EQU   0x7F
     0034  0133 array_4     EQU   0x34
     0036  0134 end         EQU   0x36
     0035  0135 value_2     EQU   0x35
     0034  0136 ch          EQU   0x34
     002F  0137 string      EQU   0x2F
     0030  0138 ps          EQU   0x30
     007F  0139 array_5     EQU   0x7F
     007F  0140 length_5    EQU   0x7F
     007F  0141 i_6         EQU   0x7F
     002E  0142 input       EQU   0x2E
     002F  0143 sign_5      EQU   0x2F
     0030  0144 temp_4      EQU   0x30
     0031  0145 h           EQU   0x31
     0032  0146 z           EQU   0x32
     0033  0147 e           EQU   0x33
     002D  0148 pDest       EQU   0x2D
     002E  0149 nextCmd     EQU   0x2E
     0025  0150 pSrc        EQU   0x25
     0026  0151 length_6    EQU   0x26
     0027  0152 nextCmd_2   EQU   0x27
     0022  0153 new_byte    EQU   0x22
     0023  0154 temp_5      EQU   0x23
     0024  0155 j           EQU   0x24
     0022  0156 nextCmd_3   EQU   0x22
     002C  0157 result_2    EQU   0x2C
     002D  0158 pCmd_3      EQU   0x2D
     0031  0159 ci          EQU   0x31
           0160 
0000 286B  0161 	GOTO main
           0162 
           0163   ; FILE main.c
           0164 			;//Nils Weiß 
           0165 			;//05.09.2011
           0166 			;//Compiler CC5x/
           0167 			;
           0168 			;#define NO_CRC
           0169 			;#define TEST
           0170 			;#pragma sharedAllocation
           0171 			;
           0172 			;//*********************** INCLUDEDATEIEN *********************************************
           0173 			;#include "platform.h"
           0174 			;#include "RingBuf.h"		//clean
           0175 			;#include "usart.h"			//clean
           0176 			;#include "eeprom.h"       	//clean 
           0177 			;#include "crc.h"			//clean
           0178 			;#include "commandstorage.h" //under construction
           0179 			;#include "ledstrip.h"		//clean
           0180 			;#include "spi.h"			//clean
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 4

ADDR CODE  LINE SOURCE

           0181 			;#include "timer.h"			//under construction
           0182 			;
           0183 			;//*********************** GLOBAL VARIABLES *******************************************
           0184 			;struct CommandBuffer gCmdBuf;
           0185 			;struct LedBuffer gLedBuf;
           0186 			;struct ErrorBits gERROR;
           0187 			;char gTimecounter;
           0188 			;
           0189 			;#ifdef X86
           0190 			;void* gl_start(void* unused);
           0191 			;void* InterruptRoutine(void* unused)
           0192 			;{
           0193 			;
           0194 			;	char dummyData[] = {
           0195 			;		STX, (uns8)sizeof(struct cmd_set_color) + 2,
           0196 			;		SET_COLOR,
           0197 			;		0xff, 0xff, 0xff, 0xff,
           0198 			;		0, 128, 0,
           0199 			;		0, 0,
           0200 			;		0xDE, 0xAD};
           0201 			;
           0202 			;	uns8 i = 0;
           0203 			;	for(;;)
           0204 			;	{
           0205 			;		if(!RingBufHasError)
           0206 			;		{
           0207 			;			RingBufPut(dummyData[i]);
           0208 			;		}
           0209 			;	
           0210 			;		i++;
           0211 			;		if(i == sizeof(dummyData))
           0212 			;		{
           0213 			;			i = 0;
           0214 			;			char temp = dummyData[7];
           0215 			;			dummyData[7] = dummyData[8];
           0216 			;			dummyData[8] = dummyData[9];
           0217 			;			dummyData[9] = temp;
           0218 			;			sleep(1);//sleep a second
           0219 			;		}
           0220 			;	}
           0221 			;}
           0222 			;#else
           0223 			;//*********************** INTERRUPTSERVICEROUTINE ************************************
           0224 			;#pragma origin 4					//Adresse des Interrupts	
     0000  0225 	ORG 0x0004
           0226 			;interrupt InterruptRoutine(void)
           0227 			;{
           0228 InterruptRoutine
           0229 			;	if(RCIF)
0004 0020  0230 	MOVLB 0
0005 1E91  0231 	BTFSS 0x11,RCIF
0006 2811  0232 	GOTO  m002
           0233 			;	{
           0234 			;		if(!RingBufHasError) RingBufPut(RCREG);
0007 184C  0235 	BTFSC gRingBuf+18,0
0008 280D  0236 	GOTO  m001
0009 0023  0237 	MOVLB 3
000A 0819  0238 	MOVF  RCREG,W
000B 2300  0239 	CALL  RingBufPut
           0240 			;		else 
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 5

ADDR CODE  LINE SOURCE

000C 2811  0241 	GOTO  m002
           0242 			;		{
           0243 			;			//Register lesen um Schnittstellen Fehler zu vermeiden
           0244 			;			char temp = RCREG;
000D 0023  0245 m001	MOVLB 3
000E 0819  0246 	MOVF  RCREG,W
000F 0020  0247 	MOVLB 0
0010 00A0  0248 	MOVWF temp
           0249 			;		}
           0250 			;	}
           0251 			;	if(TMR2IF)
0011 0020  0252 m002	MOVLB 0
0012 1C91  0253 	BTFSS 0x11,TMR2IF
0013 2816  0254 	GOTO  m003
           0255 			;	{
           0256 			;		Timer2interrupt();
0014 1091  0257 	BCF   0x11,TMR2IF
0015 0ACE  0258 	INCF  gTimecounter,1
           0259 			;	}
           0260 			;	if(TMR4IF)
0016 0020  0261 m003	MOVLB 0
0017 1C93  0262 	BTFSS 0x13,TMR4IF
0018 281B  0263 	GOTO  m004
           0264 			;	{
           0265 			;		Timer4interrupt();
0019 1093  0266 	BCF   0x13,TMR4IF
           0267 			;		commandstorage_wait_interrupt();
001A 2538  0268 	CALL  commandstorage_wait_interrupt
           0269 			;	}
           0270 			;}
001B 0009  0271 m004	RETFIE
           0272 			;#endif /* #ifdef X86 */
           0273 			;
           0274 			;//*********************** FUNKTIONSPROTOTYPEN ****************************************
           0275 			;void init_all();
           0276 			;
           0277 			;//*********************** HAUPTPROGRAMM **********************************************
           0278 			;void main(void)
           0279 			;{
           0280 _const1
001C 0020  0281 	MOVLB 0
001D 00B1  0282 	MOVWF ci
001E 3000  0283 	MOVLW 0
001F 0023  0284 	MOVLB 3
0020 0092  0285 	MOVWF EEADRH
0021 0020  0286 	MOVLB 0
0022 0C31  0287 	RRF   ci,W
0023 397F  0288 	ANDLW 127
0024 3E39  0289 	ADDLW 57
0025 0023  0290 	MOVLB 3
0026 0091  0291 	MOVWF EEADRL
0027 1803  0292 	BTFSC 0x03,Carry
0028 0A92  0293 	INCF  EEADRH,1
0029 0023  0294 	MOVLB 3
002A 1795  0295 	BSF   0x195,EEPGD
002B 1415  0296 	BSF   0x195,RD
002C 0000  0297 	NOP  
002D 0000  0298 	NOP  
002E 0020  0299 	MOVLB 0
002F 1831  0300 	BTFSC ci,0
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 6

ADDR CODE  LINE SOURCE

0030 2835  0301 	GOTO  m005
0031 0023  0302 	MOVLB 3
0032 0813  0303 	MOVF  EEDATL,W
0033 397F  0304 	ANDLW 127
0034 0008  0305 	RETURN
0035 0023  0306 m005	MOVLB 3
0036 0D13  0307 	RLF   EEDATL,W
0037 0D14  0308 	RLF   EEDATH,W
0038 0008  0309 	RETURN
0039 22A0  0310 	DW    0x22A0
003A 2952  0311 	DW    0x2952
003B 294F  0312 	DW    0x294F
003C 103A  0313 	DW    0x103A
003D 32D2  0314 	DW    0x32D2
003E 32E3  0315 	DW    0x32E3
003F 3B69  0316 	DW    0x3B69
0040 3165  0317 	DW    0x3165
0041 3375  0318 	DW    0x3375
0042 32E6  0319 	DW    0x32E6
0043 1072  0320 	DW    0x1072
0044 3AE6  0321 	DW    0x3AE6
0045 366C  0322 	DW    0x366C
0046 1000  0323 	DW    0x1000
0047 2945  0324 	DW    0x2945
0048 27D2  0325 	DW    0x27D2
0049 1D52  0326 	DW    0x1D52
004A 21A0  0327 	DW    0x21A0
004B 21D2  0328 	DW    0x21D2
004C 21AD  0329 	DW    0x21AD
004D 32E8  0330 	DW    0x32E8
004E 35E3  0331 	DW    0x35E3
004F 3320  0332 	DW    0x3320
0050 34E1  0333 	DW    0x34E1
0051 32EC  0334 	DW    0x32EC
0052 0064  0335 	DW    0x64
0053 22A0  0336 	DW    0x22A0
0054 2952  0337 	DW    0x2952
0055 294F  0338 	DW    0x294F
0056 103A  0339 	DW    0x103A
0057 22C5  0340 	DW    0x22C5
0058 2950  0341 	DW    0x2950
0059 26CF  0342 	DW    0x26CF
005A 34A0  0343 	DW    0x34A0
005B 1073  0344 	DW    0x1073
005C 3AE6  0345 	DW    0x3AE6
005D 366C  0346 	DW    0x366C
005E 2900  0347 	DW    0x2900
005F 30E5  0348 	DW    0x30E5
0060 2FE4  0349 	DW    0x2FE4
0061 37C4  0350 	DW    0x37C4
0062 32EE  0351 	DW    0x32EE
0063 3280  0352 	DW    0x3280
0064 32F8  0353 	DW    0x32F8
0065 3AE3  0354 	DW    0x3AE3
0066 32F4  0355 	DW    0x32F4
0067 37C3  0356 	DW    0x37C3
0068 36ED  0357 	DW    0x36ED
0069 3761  0358 	DW    0x3761
006A 0064  0359 	DW    0x64
           0360 main
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 7

ADDR CODE  LINE SOURCE

           0361 			;	init_all();
006B 2078  0362 	CALL  init_all
           0363 			;
           0364 			;#ifdef X86
           0365 			;	#include <pthread.h>
           0366 			;	pthread_t isrThread;
           0367 			;	pthread_t glThread;
           0368 			;	
           0369 			;	pthread_create(&isrThread, 0, InterruptRoutine, 0);
           0370 			;	pthread_create(&glThread, 0, gl_start, 0);
           0371 			;#endif /* #ifdef X86 */
           0372 			;    
           0373 			;	while(1)
           0374 			;	{
           0375 			;		throw_errors();
006C 215E  0376 m006	CALL  throw_errors
           0377 			;		commandstorage_get_commands();
006D 245E  0378 	CALL  commandstorage_get_commands
           0379 			;		commandstorage_execute_commands();
006E 24F1  0380 	CALL  commandstorage_execute_commands
           0381 			;		if(gTimecounter == 0)
006F 0020  0382 	MOVLB 0
0070 08CE  0383 	MOVF  gTimecounter,1
0071 1D03  0384 	BTFSS 0x03,Zero_
0072 286C  0385 	GOTO  m006
           0386 			;		{
           0387 			;			if(gLedBuf.led_fade_operation)
0073 0023  0388 	MOVLB 3
0074 1C35  0389 	BTFSS gLedBuf+336,0
0075 286C  0390 	GOTO  m006
           0391 			;				ledstrip_do_fade();
0076 22A1  0392 	CALL  ledstrip_do_fade
           0393 			;		}	
           0394 			;	}
0077 286C  0395 	GOTO  m006
           0396 			;}
           0397 			;//*********************** UNTERPROGRAMME **********************************************
           0398 			;
           0399 			;void init_all()
           0400 			;{
           0401 init_all
           0402 			;	OsciInit();
0078 3072  0403 	MOVLW 114
0079 0021  0404 	MOVLB 1
007A 0099  0405 	MOVWF OSCCON
           0406 			;	RingBufInit();
007B 22EF  0407 	CALL  RingBufInit
           0408 			;	USARTinit();
007C 2370  0409 	CALL  USARTinit
           0410 			;	spi_init();
007D 2315  0411 	CALL  spi_init
           0412 			;	timer_init();
007E 235D  0413 	CALL  timer_init
           0414 			;	ledstrip_init();
007F 21A3  0415 	CALL  ledstrip_init
           0416 			;	commandstorage_init();
0080 2542  0417 	CALL  commandstorage_init
           0418 			;	
           0419 			;	InitFET();
0081 0021  0420 	MOVLB 1
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 8

ADDR CODE  LINE SOURCE

0082 100E  0421 	BCF   TRISC,0
           0422 			;	PowerOnLEDs();
0083 0020  0423 	MOVLB 0
0084 100E  0424 	BCF   PORTC,0
           0425 			;    
           0426 			;	ErrorInit();
0085 104D  0427 	BCF   gERROR,0
0086 10CD  0428 	BCF   gERROR,1
           0429 			;	ClearCmdBuf();	
0087 01CF  0430 	CLRF  gCmdBuf
0088 01D0  0431 	CLRF  gCmdBuf+1
           0432 			;	AllowInterrupts();
0089 0021  0433 	MOVLB 1
008A 1691  0434 	BSF   0x91,RCIE
008B 170B  0435 	BSF   0x0B,PEIE
008C 178B  0436 	BSF   0x0B,GIE
           0437 			;	
           0438 			;	// *** send ready after init
           0439 			;	USARTsend('R');
008D 3052  0440 	MOVLW 82
008E 2383  0441 	CALL  USARTsend
           0442 			;	USARTsend('D');
008F 3044  0443 	MOVLW 68
0090 2383  0444 	CALL  USARTsend
           0445 			;	USARTsend('Y');
0091 3059  0446 	MOVLW 89
0092 2B83  0447 	GOTO  USARTsend
           0448 			;}
           0449 
           0450   ; FILE crc.c
           0451 			; // Include-Datei zum Erstellen von CRC Prüfsummen
           0452 			; //
           0453 			; //
           0454 			; // Nils Weiß
           0455 			; // 14.04.2012
           0456 			; // Compiler CC5x
           0457 			;
           0458 			;// 16-bit CCIT CRC
           0459 			;
           0460 			;void addCRC(char byte, char* p_crcH, char* p_crcL)
           0461 			;{
           0462 addCRC
           0463 			;	char index;
           0464 			;	char crcH,crcL;
           0465 			;	crcH = *p_crcH;
0093 0185  0466 	CLRF  FSR0H
0094 0020  0467 	MOVLB 0
0095 0826  0468 	MOVF  p_crcH,W
0096 0084  0469 	MOVWF FSR0L
0097 0800  0470 	MOVF  INDF0,W
0098 00A9  0471 	MOVWF crcH
           0472 			;	crcL = *p_crcL;
0099 0185  0473 	CLRF  FSR0H
009A 0827  0474 	MOVF  p_crcL,W
009B 0084  0475 	MOVWF FSR0L
009C 0800  0476 	MOVF  INDF0,W
009D 00AA  0477 	MOVWF crcL
           0478 			;
           0479 			;	MOVF(byte,0);
009E 0825  0480 	MOVF  byte,W
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 9

ADDR CODE  LINE SOURCE

           0481 			;	
           0482 			;	XORWF(crcH,0);
009F 0629  0483 	XORWF crcH,W
           0484 			;	MOVWF(index);
00A0 00A8  0485 	MOVWF index
           0486 			;	ANDLW(0xf0);
00A1 39F0  0487 	ANDLW 240
           0488 			;	SWAPF(index,1);
00A2 0EA8  0489 	SWAPF index,1
           0490 			;	XORWF(index,1);
00A3 06A8  0491 	XORWF index,1
           0492 			;	
           0493 			;	MOVF(index,0);
00A4 0828  0494 	MOVF  index,W
           0495 			;	ANDLW(0xf0);
00A5 39F0  0496 	ANDLW 240
           0497 			;	XORWF(crcL,0);
00A6 062A  0498 	XORWF crcL,W
           0499 			;	MOVWF(crcH);
00A7 00A9  0500 	MOVWF crcH
           0501 			;	
           0502 			;	RLF(index,0);
00A8 0D28  0503 	RLF   index,W
           0504 			;	RLF(index,0);
00A9 0D28  0505 	RLF   index,W
           0506 			;	XORWF(crcH,1);
00AA 06A9  0507 	XORWF crcH,1
           0508 			;	ANDLW(0xe0);
00AB 39E0  0509 	ANDLW 224
           0510 			;	XORWF(crcH,1);
00AC 06A9  0511 	XORWF crcH,1
           0512 			;		
           0513 			;	SWAPF(index,1);
00AD 0EA8  0514 	SWAPF index,1
           0515 			;	XORWF(index,0);
00AE 0628  0516 	XORWF index,W
           0517 			;	MOVWF(crcL);
00AF 00AA  0518 	MOVWF crcL
           0519 			;
           0520 			;	*p_crcH = crcH;
00B0 0185  0521 	CLRF  FSR0H
00B1 0826  0522 	MOVF  p_crcH,W
00B2 0084  0523 	MOVWF FSR0L
00B3 0829  0524 	MOVF  crcH,W
00B4 0080  0525 	MOVWF INDF0
           0526 			;	*p_crcL = crcL;
00B5 0185  0527 	CLRF  FSR0H
00B6 0827  0528 	MOVF  p_crcL,W
00B7 0084  0529 	MOVWF FSR0L
00B8 082A  0530 	MOVF  crcL,W
00B9 0080  0531 	MOVWF INDF0
           0532 			;
           0533 			;}
00BA 0008  0534 	RETURN
           0535 			;
           0536 			;void CRC(char *data, char length, char* crcH_out, char* crcL_out)
           0537 			;{
           0538 CRC
           0539 			;	if(!crcH_out)return;
00BB 08FF  0540 	MOVF  crcH_out,1
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 10

ADDR CODE  LINE SOURCE

00BC 1903  0541 	BTFSC 0x03,Zero_
00BD 0008  0542 	RETURN
           0543 			;	if(!crcL_out)return;
00BE 08FF  0544 	MOVF  crcL_out,1
00BF 1903  0545 	BTFSC 0x03,Zero_
00C0 0008  0546 	RETURN
           0547 			;	if(!data)return;
00C1 08FF  0548 	MOVF  data,1
00C2 1903  0549 	BTFSC 0x03,Zero_
00C3 0008  0550 	RETURN
           0551 			;	char crcH,crcL,i,byte;
           0552 			;	crcH=0xff;
00C4 30FF  0553 	MOVLW 255
00C5 00FF  0554 	MOVWF crcH_2
           0555 			;	crcL=0xff;
00C6 30FF  0556 	MOVLW 255
00C7 00FF  0557 	MOVWF crcL_2
           0558 			;
           0559 			;	for(i=0;i<length;i++)
00C8 01FF  0560 	CLRF  i
00C9 087F  0561 m007	MOVF  length,W
00CA 027F  0562 	SUBWF i,W
00CB 1803  0563 	BTFSC 0x03,Carry
00CC 28DD  0564 	GOTO  m008
           0565 			;	{
           0566 			;		byte = data[i];
00CD 087F  0567 	MOVF  i,W
00CE 077F  0568 	ADDWF data,W
00CF 0084  0569 	MOVWF FSR0L
00D0 0185  0570 	CLRF  FSR0H
00D1 0800  0571 	MOVF  INDF0,W
00D2 00FF  0572 	MOVWF byte_2
           0573 			;		addCRC(byte,&crcH,&crcL);
00D3 087F  0574 	MOVF  byte_2,W
00D4 0020  0575 	MOVLB 0
00D5 00A5  0576 	MOVWF byte
00D6 307F  0577 	MOVLW 127
00D7 00A6  0578 	MOVWF p_crcH
00D8 307F  0579 	MOVLW 127
00D9 00A7  0580 	MOVWF p_crcL
00DA 2093  0581 	CALL  addCRC
           0582 			;	}
00DB 0AFF  0583 	INCF  i,1
00DC 28C9  0584 	GOTO  m007
           0585 			;	
           0586 			;	*crcH_out = crcH;
00DD 0185  0587 m008	CLRF  FSR0H
00DE 087F  0588 	MOVF  crcH_out,W
00DF 0084  0589 	MOVWF FSR0L
00E0 087F  0590 	MOVF  crcH_2,W
00E1 0080  0591 	MOVWF INDF0
           0592 			;	*crcL_out = crcL;
00E2 0185  0593 	CLRF  FSR0H
00E3 087F  0594 	MOVF  crcL_out,W
00E4 0084  0595 	MOVWF FSR0L
00E5 087F  0596 	MOVF  crcL_2,W
00E6 0080  0597 	MOVWF INDF0
           0598 			;}
00E7 0008  0599 	RETURN
           0600 			;
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 11

ADDR CODE  LINE SOURCE

           0601 			;void newCRC(char* p_crcH, char* p_crcL)
           0602 			;{
           0603 newCRC
           0604 			;    if(!p_crcH) return;
00E8 0020  0605 	MOVLB 0
00E9 08A5  0606 	MOVF  p_crcH_2,1
00EA 1903  0607 	BTFSC 0x03,Zero_
00EB 0008  0608 	RETURN
           0609 			;    if(!p_crcL) return;
00EC 0020  0610 	MOVLB 0
00ED 08A6  0611 	MOVF  p_crcL_2,1
00EE 1903  0612 	BTFSC 0x03,Zero_
00EF 0008  0613 	RETURN
           0614 			;    *p_crcH = 0xff;
00F0 0185  0615 	CLRF  FSR0H
00F1 0020  0616 	MOVLB 0
00F2 0825  0617 	MOVF  p_crcH_2,W
00F3 0084  0618 	MOVWF FSR0L
00F4 30FF  0619 	MOVLW 255
00F5 0080  0620 	MOVWF INDF0
           0621 			;    *p_crcL = 0xff;
00F6 0185  0622 	CLRF  FSR0H
00F7 0826  0623 	MOVF  p_crcL_2,W
00F8 0084  0624 	MOVWF FSR0L
00F9 30FF  0625 	MOVLW 255
00FA 0080  0626 	MOVWF INDF0
           0627 			;}
00FB 0008  0628 	RETURN
           0629 
           0630   ; FILE eeprom.c
           0631 			;//Funktionen für EEPROM-Zugriffe
           0632 			;
           0633 			;//Nils Weiß 
           0634 			;//05.09.2011
           0635 			;//Compiler CC5x
           0636 			;
           0637 			;#ifndef X86
           0638 			;//*********************** EEPROM BYTE SCHREIBEN  **********************************************
           0639 			;
           0640 			;void EEPROM_WR(char adress, char data)
           0641 			;{
           0642 EEPROM_WR
00FC 0020  0643 	MOVLB 0
00FD 00B0  0644 	MOVWF data_2
           0645 			;	bit GIE_status; 
           0646 			;	//EEADRH = (char)(adress<<8);
           0647 			;    EEADRL = (char)adress;        // Adresse in Adressregister übertragen
00FE 082F  0648 	MOVF  adress,W
00FF 0023  0649 	MOVLB 3
0100 0091  0650 	MOVWF EEADRL
           0651 			;	EEDATL = data;          // Daten in Datenregister übertragen
0101 0020  0652 	MOVLB 0
0102 0830  0653 	MOVF  data_2,W
0103 0023  0654 	MOVLB 3
0104 0093  0655 	MOVWF EEDATL
           0656 			;    CFGS = 0;
0105 1315  0657 	BCF   0x195,CFGS
           0658 			;	EEPGD = 0;                // Auswahl: Programmspeicher lesen oder EEPROM
0106 1395  0659 	BCF   0x195,EEPGD
           0660 			;    WREN = 1;                 // Schreiben ins EEPROM erlauben
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 12

ADDR CODE  LINE SOURCE

0107 1515  0661 	BSF   0x195,WREN
           0662 			;	GIE_status=GIE;			
0108 0020  0663 	MOVLB 0
0109 1031  0664 	BCF   0x31,GIE_status
010A 1B8B  0665 	BTFSC 0x0B,GIE
010B 1431  0666 	BSF   0x31,GIE_status
           0667 			;    GIE=0;                  // Interrups verbieten
010C 138B  0668 	BCF   0x0B,GIE
           0669 			;    EECON2 = 0x55;
010D 3055  0670 	MOVLW 85
010E 0023  0671 	MOVLB 3
010F 0096  0672 	MOVWF EECON2
           0673 			;    EECON2 = 0xAA;
0110 30AA  0674 	MOVLW 170
0111 0096  0675 	MOVWF EECON2
           0676 			;	WR=1; 					// Starten des Schreibens
0112 1495  0677 	BSF   0x195,WR
           0678 			;    GIE=GIE_status;                  // Interrups erlauben
0113 0020  0679 	MOVLB 0
0114 1C31  0680 	BTFSS 0x31,GIE_status
0115 138B  0681 	BCF   0x0B,GIE
0116 1831  0682 	BTFSC 0x31,GIE_status
0117 178B  0683 	BSF   0x0B,GIE
           0684 			;	WREN=0;
0118 0023  0685 	MOVLB 3
0119 1115  0686 	BCF   0x195,WREN
           0687 			;	while(WR);
011A 0023  0688 m009	MOVLB 3
011B 1895  0689 	BTFSC 0x195,WR
011C 291A  0690 	GOTO  m009
           0691 			;}
011D 0008  0692 	RETURN
           0693 			;
           0694 			;//*********************** EEPROM BYTE LESEN  **********************************************
           0695 			;
           0696 			;char EEPROM_RD(char adress)
           0697 			;{
           0698 EEPROM_RD
011E 0020  0699 	MOVLB 0
011F 00B4  0700 	MOVWF adress_2
           0701 			;    char data;
           0702 			;    //EEADRH = (char)(adress<<8);        // Adresse in Adressregister übertragen
           0703 			;    EEADRL = (char)(adress);
0120 0834  0704 	MOVF  adress_2,W
0121 0023  0705 	MOVLB 3
0122 0091  0706 	MOVWF EEADRL
           0707 			;	CFGS=0;
0123 1315  0708 	BCF   0x195,CFGS
           0709 			;	EEPGD=0;                // Auswahl: Programmspeicher lesen oder EEPROM
0124 1395  0710 	BCF   0x195,EEPGD
           0711 			;    RD=1;                   // Starten des Lesesn
0125 1415  0712 	BSF   0x195,RD
           0713 			;    data = EEDATL;       // Daten aus Datenregister auslesen
0126 0813  0714 	MOVF  EEDATL,W
0127 0020  0715 	MOVLB 0
0128 00B5  0716 	MOVWF data_3
           0717 			;    return data;
0129 0835  0718 	MOVF  data_3,W
012A 0008  0719 	RETURN
           0720 			;}
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 13

ADDR CODE  LINE SOURCE

           0721 			;#endif /* #ifndef X86 */
           0722 			;
           0723 			;//*********************** EEPROM BYTEARRAY SCHREIBEN  **************************************
           0724 			;
           0725 			;void EEPROM_WR_BLK(char *array, char adress, char length)			//Zum Ausführen eines beliebigen Befehls durch den Programmcode
           0726 			;{
           0727 EEPROM_WR_BLK
012B 0020  0728 	MOVLB 0
012C 00AA  0729 	MOVWF length_2
           0730 			;	if(!array) return;
012D 08A8  0731 	MOVF  array,1
012E 1903  0732 	BTFSC 0x03,Zero_
012F 0008  0733 	RETURN
           0734 			;	char i;
           0735 			;	for(i=0;i<length;i++)
0130 0020  0736 	MOVLB 0
0131 01AB  0737 	CLRF  i_2
0132 0020  0738 m010	MOVLB 0
0133 082A  0739 	MOVF  length_2,W
0134 022B  0740 	SUBWF i_2,W
0135 1803  0741 	BTFSC 0x03,Carry
0136 2943  0742 	GOTO  m011
           0743 			;	{
           0744 			;		EEPROM_WR(adress,*array);
0137 0829  0745 	MOVF  adress_3,W
0138 00AF  0746 	MOVWF adress
0139 0185  0747 	CLRF  FSR0H
013A 0828  0748 	MOVF  array,W
013B 0084  0749 	MOVWF FSR0L
013C 0800  0750 	MOVF  INDF0,W
013D 20FC  0751 	CALL  EEPROM_WR
           0752 			;		adress++;
013E 0020  0753 	MOVLB 0
013F 0AA9  0754 	INCF  adress_3,1
           0755 			;		array++;
0140 0AA8  0756 	INCF  array,1
           0757 			;	}
0141 0AAB  0758 	INCF  i_2,1
0142 2932  0759 	GOTO  m010
           0760 			;}
0143 0008  0761 m011	RETURN
           0762 			;
           0763 			;//*********************** EEPROM BYTEARRAY LESEN  **************************************
           0764 			;
           0765 			;void EEPROM_RD_BLK(char *array, char adress, char length)			//Zum Ausführen eines beliebigen Befehls durch den Programmcode
           0766 			;{
           0767 EEPROM_RD_BLK
0144 0020  0768 	MOVLB 0
0145 00B1  0769 	MOVWF length_3
           0770 			;	if(!array) return;
0146 08AF  0771 	MOVF  array_2,1
0147 1903  0772 	BTFSC 0x03,Zero_
0148 0008  0773 	RETURN
           0774 			;	char i, temp;
           0775 			;	for(i=0;i<length;i++)
0149 0020  0776 	MOVLB 0
014A 01B2  0777 	CLRF  i_3
014B 0020  0778 m012	MOVLB 0
014C 0831  0779 	MOVF  length_3,W
014D 0232  0780 	SUBWF i_3,W
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 14

ADDR CODE  LINE SOURCE

014E 1803  0781 	BTFSC 0x03,Carry
014F 295D  0782 	GOTO  m013
           0783 			;	{
           0784 			;		temp = EEPROM_RD(adress);
0150 0830  0785 	MOVF  adress_4,W
0151 211E  0786 	CALL  EEPROM_RD
0152 0020  0787 	MOVLB 0
0153 00B3  0788 	MOVWF temp_2
           0789 			;		array[i] = temp;
0154 0832  0790 	MOVF  i_3,W
0155 072F  0791 	ADDWF array_2,W
0156 0084  0792 	MOVWF FSR0L
0157 0185  0793 	CLRF  FSR0H
0158 0833  0794 	MOVF  temp_2,W
0159 0080  0795 	MOVWF INDF0
           0796 			;		adress++;
015A 0AB0  0797 	INCF  adress_4,1
           0798 			;	}
015B 0AB2  0799 	INCF  i_3,1
015C 294B  0800 	GOTO  m012
           0801 			;}
015D 0008  0802 m013	RETURN
           0803 
           0804   ; FILE error.c
           0805 			;
           0806 			;#include "commandstorage.h"
           0807 			;#include "error.h"
           0808 			;#include "RingBuf.h"
           0809 			;#include "usart.h"
           0810 			;
           0811 			;void throw_errors()
           0812 			;{
           0813 throw_errors
           0814 			;	if(RingBufHasError) 
015E 0020  0815 	MOVLB 0
015F 1C4C  0816 	BTFSS gRingBuf+18,0
0160 2969  0817 	GOTO  m014
           0818 			;	{
           0819 			;		// *** if a RingBufError occure, I have to throw away the current command,
           0820 			;		// *** because the last byte was not saved. Commandstring is inconsistent
           0821 			;		ClearCmdBuf();
0161 01CF  0822 	CLRF  gCmdBuf
0162 01D0  0823 	CLRF  gCmdBuf+1
           0824 			;USARTsend('x');
0163 3078  0825 	MOVLW 120
0164 2383  0826 	CALL  USARTsend
           0827 			;		USARTsend_str(" ERROR: Receivebuffer full");
0165 0020  0828 	MOVLB 0
0166 01AF  0829 	CLRF  string
0167 238D  0830 	CALL  USARTsend_str
           0831 			;		// *** Re-init the Ringbuffer to get a consistent commandstring and reset error
           0832 			;		RingBufInit();
0168 22EF  0833 	CALL  RingBufInit
           0834 			;	}
           0835 			;	if(gERROR.crc_failure)
0169 0020  0836 m014	MOVLB 0
016A 1C4D  0837 	BTFSS gERROR,0
016B 2971  0838 	GOTO  m015
           0839 			;	{
           0840 			;		USARTsend_str(" ERROR: CRC-Check failed");
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 15

ADDR CODE  LINE SOURCE

016C 301B  0841 	MOVLW 27
016D 00AF  0842 	MOVWF string
016E 238D  0843 	CALL  USARTsend_str
           0844 			;		gERROR.crc_failure = 0;
016F 0020  0845 	MOVLB 0
0170 104D  0846 	BCF   gERROR,0
           0847 			;	}
           0848 			;	if(gERROR.eeprom_failure)
0171 0020  0849 m015	MOVLB 0
0172 1CCD  0850 	BTFSS gERROR,1
0173 2979  0851 	GOTO  m016
           0852 			;	{
           0853 			;		USARTsend_str(" ERROR: EEPROM is full");
0174 3034  0854 	MOVLW 52
0175 00AF  0855 	MOVWF string
0176 238D  0856 	CALL  USARTsend_str
           0857 			;		gERROR.eeprom_failure = 0;
0177 0020  0858 	MOVLB 0
0178 10CD  0859 	BCF   gERROR,1
           0860 			;	}
           0861 			;}
0179 0008  0862 m016	RETURN
           0863 
           0864   ; FILE MATH16.H
           0865 			;// SIZE
           0866 			;
           0867 			;#pragma library 1
           0868 			;/*
           0869 			;uns16 operator* _mult8x8( uns8 arg1, uns8 arg2);
           0870 			;int16 operator* _multS8x8( int8 arg1, int8 arg2);
           0871 			;uns16 operator* _multU16x8( uns16 arg1, uns8 arg2);
           0872 			;uns16 operator* _mult16x16( uns16 arg1, uns16 arg2);
           0873 			;uns16 operator/ _divU16_8( uns16 arg1, uns8 arg2);
           0874 			;uns16 operator/ _divU16_16( uns16 arg1, uns16 arg2);
           0875 			;int16 operator/ _divS16_8( int16 arg1, int8 arg2);
           0876 			;int16 operator/ _divS16_16( int16 arg1, int16 arg2);
           0877 			;uns8 operator% _remU16_8( uns16 arg1, uns8 arg2);
           0878 			;uns16 operator% _remU16_16( uns16 arg1, uns16 arg2);
           0879 			;int8 operator% _remS16_8( int16 arg1, int8 arg2);
           0880 			;int16 operator% _remS16_16( int16 arg1, int16 arg2);
           0881 			;*/
           0882 			;
           0883 			;#if __CoreSet__ < 1410
           0884 			; #define genAdd(r,a) W=a; btsc(Carry); W=incsz(a); r+=W
           0885 			; #define genSub(r,a) W=a; btss(Carry); W=incsz(a); r-=W
           0886 			; #define genAddW(r,a) W=a; btsc(Carry); W=incsz(a); W=r+W
           0887 			; #define genSubW(r,a) W=a; btss(Carry); W=incsz(a); W=r-W
           0888 			;#else
           0889 			; #define genAdd(r,a) W=a; r=addWFC(r)
           0890 			; #define genSub(r,a) W=a; r=subWFB(r)
           0891 			; #define genAddW(r,a) W=a; W=addWFC(r)
           0892 			; #define genSubW(r,a) W=a; W=subWFB(r)
           0893 			;#endif
           0894 			;
           0895 			;
           0896 			;int8 operator*( int8 arg1, int8 arg2)  @
           0897 			;
           0898 			;uns16 operator* _mult8x8( uns8 arg1, uns8 arg2)
           0899 			;{
           0900 _mult8x8
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 16

ADDR CODE  LINE SOURCE

017A 0020  0901 	MOVLB 0
017B 00B5  0902 	MOVWF arg2
           0903 			;    uns16 rval;
           0904 			;    char counter = sizeof(arg2)*8;
017C 3008  0905 	MOVLW 8
017D 00B8  0906 	MOVWF counter
           0907 			;    rval.high8 = 0;
017E 01B7  0908 	CLRF  rval+1
           0909 			;    W = arg1;
017F 0834  0910 	MOVF  arg1,W
           0911 			;    do  {
           0912 			;        arg2 = rr( arg2);
0180 0020  0913 m017	MOVLB 0
0181 0CB5  0914 	RRF   arg2,1
           0915 			;        if (Carry)
0182 1803  0916 	BTFSC 0x03,Carry
           0917 			;            rval.high8 += W;
0183 07B7  0918 	ADDWF rval+1,1
           0919 			;        rval = rr( rval);
0184 0020  0920 	MOVLB 0
0185 0CB7  0921 	RRF   rval+1,1
0186 0CB6  0922 	RRF   rval,1
           0923 			;        counter = decsz(counter);
0187 0BB8  0924 	DECFSZ counter,1
           0925 			;    } while (1);
0188 2980  0926 	GOTO  m017
           0927 			;    return rval;
0189 0836  0928 	MOVF  rval,W
018A 0008  0929 	RETURN
           0930 			;}
           0931 			;
           0932 			;
           0933 			;int16 operator* _multS8x8( int8 arg1, int8 arg2)
           0934 			;{
           0935 _multS8x8
           0936 			;    uns16 rval;
           0937 			;    char counter = sizeof(arg2)*8;
           0938 			;    int8 tmpArg2 = arg2;
           0939 			;    rval.high8 = 0;
           0940 			;    W = arg1;
           0941 			;    do  {
           0942 			;        tmpArg2 = rr( tmpArg2);
           0943 			;        if (Carry)
           0944 			;            rval.high8 += W;
           0945 			;        rval = rr( rval);
           0946 			;        counter = decsz(counter);
           0947 			;    } while (1);
           0948 			;    W = arg2;
           0949 			;    if (arg1 < 0)
           0950 			;        rval.high8 -= W;
           0951 			;    W = arg1;
           0952 			;    if (arg2 < 0)
           0953 			;        rval.high8 -= W;
           0954 			;    return rval;
           0955 			;}
           0956 			;
           0957 			;
           0958 			;uns16 operator*( uns8 arg1, uns16 arg2) exchangeArgs @
           0959 			;
           0960 			;uns16 operator* _multU16x8( uns16 arg1, uns8 arg2)
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 17

ADDR CODE  LINE SOURCE

           0961 			;{
           0962 _multU16x8
           0963 			;    uns16 rval;
           0964 			;    uns8 rvalH = 0;
           0965 			;    char counter = sizeof(arg1)*8;
           0966 			;    W = arg2;
           0967 			;    do  {
           0968 			;        arg1 = rr( arg1);
           0969 			;        if (Carry)
           0970 			;            rvalH += W;
           0971 			;        rvalH = rr(rvalH);
           0972 			;        rval = rr(rval);
           0973 			;        counter = decsz(counter);
           0974 			;    } while (1);
           0975 			;    return rval;
           0976 			;}
           0977 			;
           0978 			;
           0979 			;int16 operator*( int16 arg1, int16 arg2) @
           0980 			;
           0981 			;uns16 operator* _mult16x16( uns16 arg1, uns16 arg2)
           0982 			;{
           0983 _mult16x16
           0984 			;    uns16 rval;
           0985 			;    char counter = sizeof(arg1)*8;
           0986 			;    do  {
           0987 			;        Carry = 0;
           0988 			;        rval = rl( rval);
           0989 			;        arg1 = rl( arg1);
           0990 			;        if (Carry)
           0991 			;            rval += arg2;
           0992 			;        counter = decsz(counter);
           0993 			;    } while (1);
           0994 			;    return rval;
           0995 			;}
           0996 			;
           0997 			;
           0998 			;
           0999 			;uns16 operator/ _divU16_8( uns16 arg1, uns8 arg2)
           1000 			;{
           1001 _divU16_8
018B 0020  1002 	MOVLB 0
018C 00B6  1003 	MOVWF arg2_5
           1004 			;    uns8 rm = 0;
018D 01B7  1005 	CLRF  rm
           1006 			;    char counter = sizeof(arg1)*8+1;
018E 3011  1007 	MOVLW 17
018F 00B8  1008 	MOVWF counter_5
           1009 			;    goto ENTRY_ML;
0190 299C  1010 	GOTO  m019
           1011 			;    do  {
           1012 			;        rm = rl( rm);
0191 0020  1013 m018	MOVLB 0
0192 0DB7  1014 	RLF   rm,1
           1015 			;        uns8 tmp = rl( tmp);
0193 0DB9  1016 	RLF   tmp,1
           1017 			;        W = rm - arg2;
0194 0836  1018 	MOVF  arg2_5,W
0195 0237  1019 	SUBWF rm,W
           1020 			;        if (tmp&1)
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 18

ADDR CODE  LINE SOURCE

0196 1839  1021 	BTFSC tmp,0
           1022 			;            Carry = 1;
0197 1403  1023 	BSF   0x03,Carry
           1024 			;        if (Carry)
0198 1C03  1025 	BTFSS 0x03,Carry
0199 299C  1026 	GOTO  m019
           1027 			;            rm = W;
019A 0020  1028 	MOVLB 0
019B 00B7  1029 	MOVWF rm
           1030 			;       ENTRY_ML:
           1031 			;        arg1 = rl( arg1);
019C 0020  1032 m019	MOVLB 0
019D 0DB4  1033 	RLF   arg1_5,1
019E 0DB5  1034 	RLF   arg1_5+1,1
           1035 			;        counter = decsz(counter);
019F 0BB8  1036 	DECFSZ counter_5,1
           1037 			;    } while (1);
01A0 2991  1038 	GOTO  m018
           1039 			;    return arg1;
01A1 0834  1040 	MOVF  arg1_5,W
01A2 0008  1041 	RETURN
           1042 			;}
           1043 			;
           1044 			;
           1045 			;uns16 operator/ _divU16_16( uns16 arg1, uns16 arg2)
           1046 			;{
           1047 _divU16_16
           1048 			;    uns16 rm = 0;
           1049 			;    char counter = sizeof(arg1)*8+1;
           1050 			;    goto ENTRY_ML;
           1051 			;    do  {
           1052 			;        rm = rl( rm);
           1053 			;        W = rm.low8 - arg2.low8;
           1054 			;        genSubW( rm.high8, arg2.high8);
           1055 			;        if (!Carry)
           1056 			;            goto ENTRY_ML;
           1057 			;        rm.high8 = W;
           1058 			;        rm.low8 -= arg2.low8;
           1059 			;        Carry = 1;
           1060 			;       ENTRY_ML:
           1061 			;        arg1 = rl( arg1);
           1062 			;        counter = decsz(counter);
           1063 			;    } while (1);
           1064 			;    return arg1;
           1065 			;}
           1066 			;
           1067 			;
           1068 			;int8  operator/ (int8 arg1, int8 arg2) @
           1069 			;
           1070 			;int16 operator/ _divS16_8( int16 arg1, int8 arg2)
           1071 			;{
           1072 _divS16_8
           1073 			;    uns8 rm = 0;
           1074 			;    char counter = 16+1;
           1075 			;    char sign = arg1.high8 ^ arg2.high8;
           1076 			;    if (arg1 < 0)  {
           1077 			;       INVERT_ML:
           1078 			;        arg1 = -arg1;
           1079 			;        if (!counter)
           1080 			;            return arg1;
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 19

ADDR CODE  LINE SOURCE

           1081 			;    }
           1082 			;    if (arg2 < 0)
           1083 			;        arg2 = -arg2;
           1084 			;    goto ENTRY_ML;
           1085 			;    do  {
           1086 			;        rm = rl( rm);
           1087 			;        W = rm - arg2;
           1088 			;        if (Carry)
           1089 			;            rm = W;
           1090 			;       ENTRY_ML:
           1091 			;        arg1 = rl( arg1);
           1092 			;        counter = decsz(counter);
           1093 			;    } while (1);
           1094 			;    if (sign & 0x80)
           1095 			;        goto INVERT_ML;
           1096 			;    return arg1;
           1097 			;}
           1098 			;
           1099 			;
           1100 			;int16 operator/ _divS16_16( int16 arg1, int16 arg2)
           1101 			;{
           1102 _divS16_16
           1103 			;    uns16 rm = 0;
           1104 			;    char counter = sizeof(arg1)*8+1;
           1105 			;    char sign = arg1.high8 ^ arg2.high8;
           1106 			;    if (arg1 < 0)  {
           1107 			;       INVERT_ML:
           1108 			;        arg1 = -arg1;
           1109 			;        if (!counter)
           1110 			;            return arg1;
           1111 			;    }
           1112 			;    if (arg2 < 0)
           1113 			;        arg2 = -arg2;
           1114 			;    goto ENTRY_ML;
           1115 			;    do  {
           1116 			;        rm = rl( rm);
           1117 			;        W = rm.low8 - arg2.low8;
           1118 			;        genSubW( rm.high8, arg2.high8);
           1119 			;        if (!Carry)
           1120 			;            goto ENTRY_ML;
           1121 			;        rm.high8 = W;
           1122 			;        rm.low8 -= arg2.low8;
           1123 			;        Carry = 1;
           1124 			;       ENTRY_ML:
           1125 			;        arg1 = rl( arg1);
           1126 			;        counter = decsz(counter);
           1127 			;    } while (1);
           1128 			;    if (sign & 0x80)
           1129 			;        goto INVERT_ML;
           1130 			;    return arg1;
           1131 			;}
           1132 			;
           1133 			;
           1134 			;uns8 operator% _remU16_8( uns16 arg1, uns8 arg2)
           1135 			;{
           1136 _remU16_8
           1137 			;    uns8 rm = 0;
           1138 			;    char counter = sizeof(arg1)*8;
           1139 			;    do  {
           1140 			;        arg1 = rl( arg1);
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 20

ADDR CODE  LINE SOURCE

           1141 			;        rm = rl( rm);
           1142 			;        uns8 tmp = rl( tmp);
           1143 			;        W = rm - arg2;
           1144 			;        if (tmp&1)
           1145 			;            Carry = 1;
           1146 			;        if (Carry)
           1147 			;            rm = W;
           1148 			;        counter = decsz(counter);
           1149 			;    } while (1);
           1150 			;    return rm;
           1151 			;}
           1152 			;
           1153 			;
           1154 			;uns16 operator% _remU16_16( uns16 arg1, uns16 arg2)
           1155 			;{
           1156 _remU16_16
           1157 			;    uns16 rm = 0;
           1158 			;    char counter = sizeof(arg1)*8;
           1159 			;    do  {
           1160 			;        arg1 = rl( arg1);
           1161 			;        rm = rl( rm);
           1162 			;        W = rm.low8 - arg2.low8;
           1163 			;        genSubW( rm.high8, arg2.high8);
           1164 			;        if (!Carry)
           1165 			;            goto NOSUB;
           1166 			;        rm.high8 = W;
           1167 			;        rm.low8 -= arg2.low8;
           1168 			;      NOSUB:
           1169 			;        counter = decsz(counter);
           1170 			;    } while (1);
           1171 			;    return rm;
           1172 			;}
           1173 			;
           1174 			;
           1175 			;int8 operator% (int8 arg1, int8 arg2) @
           1176 			;
           1177 			;int8 operator% _remS16_8( int16 arg1, int8 arg2)
           1178 			;{
           1179 _remS16_8
           1180 			;    int8 rm = 0;
           1181 			;    char counter = 16;
           1182 			;    char sign = arg1.high8;
           1183 			;    if (arg1 < 0)
           1184 			;        arg1 = -arg1;
           1185 			;    if (arg2 < 0)
           1186 			;        arg2 = -arg2;
           1187 			;    do  {
           1188 			;        arg1 = rl( arg1);
           1189 			;        rm = rl( rm);
           1190 			;        W = rm - arg2;
           1191 			;        if (Carry)
           1192 			;            rm = W;
           1193 			;        counter = decsz(counter);
           1194 			;    } while (1);
           1195 			;    if (sign & 0x80)
           1196 			;        rm = -rm;
           1197 			;    return rm;
           1198 			;}
           1199 			;
           1200 			;
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 21

ADDR CODE  LINE SOURCE

           1201 			;int16 operator% _remS16_16( int16 arg1, int16 arg2)
           1202 			;{
           1203 _remS16_16
           1204 			;    int16 rm = 0;
           1205 			;    char counter = sizeof(arg1)*8;
           1206 			;    char sign = arg1.high8;
           1207 			;    if (arg1 < 0)
           1208 			;        arg1 = -arg1;
           1209 			;    if (arg2 < 0)
           1210 			;        arg2 = -arg2;
           1211 			;    do  {
           1212 			;        arg1 = rl( arg1);
           1213 			;        rm = rl( rm);
           1214 			;        W = rm.low8 - arg2.low8;
           1215 			;        genSubW( rm.high8, arg2.high8);
           1216 			;        if (!Carry)
           1217 			;            goto NOSUB;
           1218 			;        rm.high8 = W;
           1219 			;        rm.low8 -= arg2.low8;
           1220 			;      NOSUB:
           1221 			;        counter = decsz(counter);
           1222 			;    } while (1);
           1223 			;    if (sign & 0x80)
           1224 			;        rm = -rm;
           1225 			;    return rm;
           1226 
           1227   ; FILE ledstrip.c
           1228 			;//Nils Weiß 
           1229 			;//20.04.2012
           1230 			;//Compiler CC5x 
           1231 			;
           1232 			;#include "ledstrip.h"
           1233 			;#include "MATH16.H"
           1234 			;
           1235 			;void ledstrip_init(void)
           1236 			;{
           1237 ledstrip_init
           1238 			;	char k;
           1239 			;	for(k = 0;k < (NUM_OF_LED * 3); k++)
01A3 0020  1240 	MOVLB 0
01A4 01A2  1241 	CLRF  k
01A5 3060  1242 m020	MOVLW 96
01A6 0020  1243 	MOVLB 0
01A7 0222  1244 	SUBWF k,W
01A8 1803  1245 	BTFSC 0x03,Carry
01A9 29B4  1246 	GOTO  m021
           1247 			;	{	
           1248 			;		gLedBuf.led_array[k] = 0;
01AA 3020  1249 	MOVLW 32
01AB 0085  1250 	MOVWF FSR0+1
01AC 3045  1251 	MOVLW 69
01AD 0722  1252 	ADDWF k,W
01AE 0084  1253 	MOVWF FSR0
01AF 1803  1254 	BTFSC 0x03,Carry
01B0 0A85  1255 	INCF  FSR0+1,1
01B1 0180  1256 	CLRF  INDF0
           1257 			;	}
01B2 0AA2  1258 	INCF  k,1
01B3 29A5  1259 	GOTO  m020
           1260 			;}
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 22

ADDR CODE  LINE SOURCE

01B4 0008  1261 m021	RETURN
           1262 			;
           1263 			;/***
           1264 			;*** This funktion sets the values of the global LedBuffer
           1265 			;*** only Led's where the address bit is 1 will be set to the new color
           1266 			;***/
           1267 			;void ledstrip_set_color(struct cmd_set_color *pCmd)
           1268 			;{	
           1269 ledstrip_set_color
           1270 			;	char *address = pCmd->addr;
01B5 0020  1271 	MOVLB 0
01B6 082D  1272 	MOVF  pCmd,W
01B7 00AE  1273 	MOVWF address
           1274 			;	char r = pCmd->red;
01B8 3004  1275 	MOVLW 4
01B9 072D  1276 	ADDWF pCmd,W
01BA 0084  1277 	MOVWF FSR0L
01BB 0185  1278 	CLRF  FSR0H
01BC 0800  1279 	MOVF  INDF0,W
01BD 00AF  1280 	MOVWF r
           1281 			;	char g = pCmd->green;
01BE 3005  1282 	MOVLW 5
01BF 072D  1283 	ADDWF pCmd,W
01C0 0084  1284 	MOVWF FSR0L
01C1 0185  1285 	CLRF  FSR0H
01C2 0800  1286 	MOVF  INDF0,W
01C3 00B0  1287 	MOVWF g
           1288 			;	char b = pCmd->blue;
01C4 3006  1289 	MOVLW 6
01C5 072D  1290 	ADDWF pCmd,W
01C6 0084  1291 	MOVWF FSR0L
01C7 0185  1292 	CLRF  FSR0H
01C8 0800  1293 	MOVF  INDF0,W
01C9 00B1  1294 	MOVWF b
           1295 			;	
           1296 			;	char k,mask;
           1297 			;	mask = 0b00000001;
01CA 3001  1298 	MOVLW 1
01CB 00B3  1299 	MOVWF mask
           1300 			;	for(k = 0; k < (NUM_OF_LED * 3); k++)
01CC 01B2  1301 	CLRF  k_2
01CD 3060  1302 m022	MOVLW 96
01CE 0020  1303 	MOVLB 0
01CF 0232  1304 	SUBWF k_2,W
01D0 1803  1305 	BTFSC 0x03,Carry
01D1 2A21  1306 	GOTO  m026
           1307 			;	{	
           1308 			;		if(0 != (*address & mask))
01D2 0185  1309 	CLRF  FSR0H
01D3 082E  1310 	MOVF  address,W
01D4 0084  1311 	MOVWF FSR0L
01D5 0833  1312 	MOVF  mask,W
01D6 0500  1313 	ANDWF INDF0,W
01D7 1903  1314 	BTFSC 0x03,Zero_
01D8 2A12  1315 	GOTO  m023
           1316 			;		{
           1317 			;			gLedBuf.led_array[k] = b;
01D9 3020  1318 	MOVLW 32
01DA 0085  1319 	MOVWF FSR0+1
01DB 3045  1320 	MOVLW 69
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 23

ADDR CODE  LINE SOURCE

01DC 0732  1321 	ADDWF k_2,W
01DD 0084  1322 	MOVWF FSR0
01DE 1803  1323 	BTFSC 0x03,Carry
01DF 0A85  1324 	INCF  FSR0+1,1
01E0 0831  1325 	MOVF  b,W
01E1 0080  1326 	MOVWF INDF0
           1327 			;			gLedBuf.led_destination[k] = b;
01E2 3020  1328 	MOVLW 32
01E3 0085  1329 	MOVWF FSR0+1
01E4 30A5  1330 	MOVLW 165
01E5 0732  1331 	ADDWF k_2,W
01E6 0084  1332 	MOVWF FSR0
01E7 1803  1333 	BTFSC 0x03,Carry
01E8 0A85  1334 	INCF  FSR0+1,1
01E9 0831  1335 	MOVF  b,W
01EA 0080  1336 	MOVWF INDF0
           1337 			;			k++;
01EB 0AB2  1338 	INCF  k_2,1
           1339 			;			
           1340 			;			gLedBuf.led_array[k] = g;
01EC 3020  1341 	MOVLW 32
01ED 0085  1342 	MOVWF FSR0+1
01EE 3045  1343 	MOVLW 69
01EF 0732  1344 	ADDWF k_2,W
01F0 0084  1345 	MOVWF FSR0
01F1 1803  1346 	BTFSC 0x03,Carry
01F2 0A85  1347 	INCF  FSR0+1,1
01F3 0830  1348 	MOVF  g,W
01F4 0080  1349 	MOVWF INDF0
           1350 			;			gLedBuf.led_destination[k] = g;
01F5 3020  1351 	MOVLW 32
01F6 0085  1352 	MOVWF FSR0+1
01F7 30A5  1353 	MOVLW 165
01F8 0732  1354 	ADDWF k_2,W
01F9 0084  1355 	MOVWF FSR0
01FA 1803  1356 	BTFSC 0x03,Carry
01FB 0A85  1357 	INCF  FSR0+1,1
01FC 0830  1358 	MOVF  g,W
01FD 0080  1359 	MOVWF INDF0
           1360 			;			k++;
01FE 0AB2  1361 	INCF  k_2,1
           1362 			;			
           1363 			;			gLedBuf.led_array[k] = r;
01FF 3020  1364 	MOVLW 32
0200 0085  1365 	MOVWF FSR0+1
0201 3045  1366 	MOVLW 69
0202 0732  1367 	ADDWF k_2,W
0203 0084  1368 	MOVWF FSR0
0204 1803  1369 	BTFSC 0x03,Carry
0205 0A85  1370 	INCF  FSR0+1,1
0206 082F  1371 	MOVF  r,W
0207 0080  1372 	MOVWF INDF0
           1373 			;			gLedBuf.led_destination[k] = r;
0208 3020  1374 	MOVLW 32
0209 0085  1375 	MOVWF FSR0+1
020A 30A5  1376 	MOVLW 165
020B 0732  1377 	ADDWF k_2,W
020C 0084  1378 	MOVWF FSR0
020D 1803  1379 	BTFSC 0x03,Carry
020E 0A85  1380 	INCF  FSR0+1,1
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 24

ADDR CODE  LINE SOURCE

020F 082F  1381 	MOVF  r,W
0210 0080  1382 	MOVWF INDF0
           1383 			;		}
           1384 			;		else 
0211 2A15  1385 	GOTO  m024
           1386 			;		{
           1387 			;			k++;
0212 0020  1388 m023	MOVLB 0
0213 0AB2  1389 	INCF  k_2,1
           1390 			;			k++;
0214 0AB2  1391 	INCF  k_2,1
           1392 			;		}
           1393 			;		mask = mask << 1;
0215 1003  1394 m024	BCF   0x03,Carry
0216 0020  1395 	MOVLB 0
0217 0DB3  1396 	RLF   mask,1
           1397 			;		if(0 == mask)
0218 08B3  1398 	MOVF  mask,1
0219 1D03  1399 	BTFSS 0x03,Zero_
021A 2A1E  1400 	GOTO  m025
           1401 			;		{
           1402 			;			address++;
021B 0AAE  1403 	INCF  address,1
           1404 			;			mask= 0b00000001;
021C 3001  1405 	MOVLW 1
021D 00B3  1406 	MOVWF mask
           1407 			;		}
           1408 			;	}
021E 0020  1409 m025	MOVLB 0
021F 0AB2  1410 	INCF  k_2,1
0220 29CD  1411 	GOTO  m022
           1412 			;	spi_send_ledbuf(&gLedBuf.led_array[0]);
0221 3045  1413 m026	MOVLW 69
0222 0020  1414 	MOVLB 0
0223 00B4  1415 	MOVWF array_4
0224 3020  1416 	MOVLW 32
0225 00B5  1417 	MOVWF array_4+1
0226 233D  1418 	CALL  spi_send_ledbuf
           1419 			;	// Laufende Operationen ausschalten
           1420 			;	gLedBuf.led_fade_operation = 0;
0227 0023  1421 	MOVLB 3
0228 1035  1422 	BCF   gLedBuf+336,0
           1423 			;	gLedBuf.led_run_operation = 0;
0229 10B5  1424 	BCF   gLedBuf+336,1
           1425 			;}
022A 0008  1426 	RETURN
           1427 			;/***
           1428 			;* This funktion sets the destination color configurates
           1429 			;* the timer 2 PR2 Register. If the settings are done, the bit led_fade_operation is 1.
           1430 			;* 
           1431 			;**/
           1432 			;void ledstrip_set_fade(struct cmd_set_fade *pCmd)
           1433 			;{
           1434 ledstrip_set_fade
           1435 			;	char *address = pCmd->addr;
022B 0020  1436 	MOVLB 0
022C 082D  1437 	MOVF  pCmd_2,W
022D 00AE  1438 	MOVWF address_2
           1439 			;	char r = pCmd->red;
022E 3004  1440 	MOVLW 4
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 25

ADDR CODE  LINE SOURCE

022F 072D  1441 	ADDWF pCmd_2,W
0230 0084  1442 	MOVWF FSR0L
0231 0185  1443 	CLRF  FSR0H
0232 0800  1444 	MOVF  INDF0,W
0233 00AF  1445 	MOVWF r_2
           1446 			;	char g = pCmd->green;
0234 3005  1447 	MOVLW 5
0235 072D  1448 	ADDWF pCmd_2,W
0236 0084  1449 	MOVWF FSR0L
0237 0185  1450 	CLRF  FSR0H
0238 0800  1451 	MOVF  INDF0,W
0239 00B0  1452 	MOVWF g_2
           1453 			;	char b = pCmd->blue;
023A 3006  1454 	MOVLW 6
023B 072D  1455 	ADDWF pCmd_2,W
023C 0084  1456 	MOVWF FSR0L
023D 0185  1457 	CLRF  FSR0H
023E 0800  1458 	MOVF  INDF0,W
023F 00B1  1459 	MOVWF b_2
           1460 			;	
           1461 			;	char k,mask,temp;
           1462 			;	mask = 0b00000001;
0240 3001  1463 	MOVLW 1
0241 00B3  1464 	MOVWF mask_2
           1465 			;	
           1466 			;	for(k = 0; k < (NUM_OF_LED * 3); k++)
0242 01B2  1467 	CLRF  k_3
0243 3060  1468 m027	MOVLW 96
0244 0020  1469 	MOVLB 0
0245 0232  1470 	SUBWF k_3,W
0246 1803  1471 	BTFSC 0x03,Carry
0247 2A97  1472 	GOTO  m031
           1473 			;	{	
           1474 			;		if(0 != (*address & mask))
0248 0185  1475 	CLRF  FSR0H
0249 082E  1476 	MOVF  address_2,W
024A 0084  1477 	MOVWF FSR0L
024B 0833  1478 	MOVF  mask_2,W
024C 0500  1479 	ANDWF INDF0,W
024D 1903  1480 	BTFSC 0x03,Zero_
024E 2A88  1481 	GOTO  m028
           1482 			;		{
           1483 			;			temp = gLedBuf.led_array[k];
024F 3020  1484 	MOVLW 32
0250 0085  1485 	MOVWF FSR0+1
0251 3045  1486 	MOVLW 69
0252 0732  1487 	ADDWF k_3,W
0253 0084  1488 	MOVWF FSR0
0254 1803  1489 	BTFSC 0x03,Carry
0255 0A85  1490 	INCF  FSR0+1,1
0256 0800  1491 	MOVF  INDF0,W
0257 00B4  1492 	MOVWF temp_3
           1493 			;			gLedBuf.led_destination[k] = b;
0258 3020  1494 	MOVLW 32
0259 0085  1495 	MOVWF FSR0+1
025A 30A5  1496 	MOVLW 165
025B 0732  1497 	ADDWF k_3,W
025C 0084  1498 	MOVWF FSR0
025D 1803  1499 	BTFSC 0x03,Carry
025E 0A85  1500 	INCF  FSR0+1,1
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 26

ADDR CODE  LINE SOURCE

025F 0831  1501 	MOVF  b_2,W
0260 0080  1502 	MOVWF INDF0
           1503 			;			k++;
0261 0AB2  1504 	INCF  k_3,1
           1505 			;			
           1506 			;			temp = gLedBuf.led_array[k];
0262 3020  1507 	MOVLW 32
0263 0085  1508 	MOVWF FSR0+1
0264 3045  1509 	MOVLW 69
0265 0732  1510 	ADDWF k_3,W
0266 0084  1511 	MOVWF FSR0
0267 1803  1512 	BTFSC 0x03,Carry
0268 0A85  1513 	INCF  FSR0+1,1
0269 0800  1514 	MOVF  INDF0,W
026A 00B4  1515 	MOVWF temp_3
           1516 			;			gLedBuf.led_destination[k] = g;
026B 3020  1517 	MOVLW 32
026C 0085  1518 	MOVWF FSR0+1
026D 30A5  1519 	MOVLW 165
026E 0732  1520 	ADDWF k_3,W
026F 0084  1521 	MOVWF FSR0
0270 1803  1522 	BTFSC 0x03,Carry
0271 0A85  1523 	INCF  FSR0+1,1
0272 0830  1524 	MOVF  g_2,W
0273 0080  1525 	MOVWF INDF0
           1526 			;			k++;
0274 0AB2  1527 	INCF  k_3,1
           1528 			;			
           1529 			;			temp = gLedBuf.led_array[k];
0275 3020  1530 	MOVLW 32
0276 0085  1531 	MOVWF FSR0+1
0277 3045  1532 	MOVLW 69
0278 0732  1533 	ADDWF k_3,W
0279 0084  1534 	MOVWF FSR0
027A 1803  1535 	BTFSC 0x03,Carry
027B 0A85  1536 	INCF  FSR0+1,1
027C 0800  1537 	MOVF  INDF0,W
027D 00B4  1538 	MOVWF temp_3
           1539 			;			gLedBuf.led_destination[k] = r;
027E 3020  1540 	MOVLW 32
027F 0085  1541 	MOVWF FSR0+1
0280 30A5  1542 	MOVLW 165
0281 0732  1543 	ADDWF k_3,W
0282 0084  1544 	MOVWF FSR0
0283 1803  1545 	BTFSC 0x03,Carry
0284 0A85  1546 	INCF  FSR0+1,1
0285 082F  1547 	MOVF  r_2,W
0286 0080  1548 	MOVWF INDF0
           1549 			;		}
           1550 			;		else 
0287 2A8B  1551 	GOTO  m029
           1552 			;		{ 
           1553 			;			k++;
0288 0020  1554 m028	MOVLB 0
0289 0AB2  1555 	INCF  k_3,1
           1556 			;			k++;
028A 0AB2  1557 	INCF  k_3,1
           1558 			;		}
           1559 			;		mask = mask << 1;
028B 1003  1560 m029	BCF   0x03,Carry
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 27

ADDR CODE  LINE SOURCE

028C 0020  1561 	MOVLB 0
028D 0DB3  1562 	RLF   mask_2,1
           1563 			;		if(0 == mask)
028E 08B3  1564 	MOVF  mask_2,1
028F 1D03  1565 	BTFSS 0x03,Zero_
0290 2A94  1566 	GOTO  m030
           1567 			;		{
           1568 			;			address++;
0291 0AAE  1569 	INCF  address_2,1
           1570 			;			mask= 0b00000001;
0292 3001  1571 	MOVLW 1
0293 00B3  1572 	MOVWF mask_2
           1573 			;		}
           1574 			;	}
0294 0020  1575 m030	MOVLB 0
0295 0AB2  1576 	INCF  k_3,1
0296 2A43  1577 	GOTO  m027
           1578 			;	timer_set_for_fade(pCmd->timevalue);
0297 3007  1579 m031	MOVLW 7
0298 0020  1580 	MOVLB 0
0299 072D  1581 	ADDWF pCmd_2,W
029A 0084  1582 	MOVWF FSR0L
029B 0185  1583 	CLRF  FSR0H
029C 0800  1584 	MOVF  INDF0,W
029D 236B  1585 	CALL  timer_set_for_fade
           1586 			;	gLedBuf.led_fade_operation = 1;
029E 0023  1587 	MOVLB 3
029F 1435  1588 	BSF   gLedBuf+336,0
           1589 			;}
02A0 0008  1590 	RETURN
           1591 			;
           1592 			;
           1593 			;void ledstrip_do_fade()
           1594 			;{
           1595 ledstrip_do_fade
           1596 			;	char fade_finish:1;
           1597 			;	fade_finish = 1;
02A1 0020  1598 	MOVLB 0
02A2 1425  1599 	BSF   0x25,fade_finish
           1600 			;	char temp_current,temp_destination;
           1601 			;	
           1602 			;	char i;
           1603 			;	for(i = 0; i < (NUM_OF_LED*3);i++)
02A3 01A4  1604 	CLRF  i_4
02A4 3060  1605 m032	MOVLW 96
02A5 0020  1606 	MOVLB 0
02A6 0224  1607 	SUBWF i_4,W
02A7 1803  1608 	BTFSC 0x03,Carry
02A8 2ADE  1609 	GOTO  m035
           1610 			;	{
           1611 			;		temp_current = gLedBuf.led_array[i];
02A9 3020  1612 	MOVLW 32
02AA 0085  1613 	MOVWF FSR0+1
02AB 3045  1614 	MOVLW 69
02AC 0724  1615 	ADDWF i_4,W
02AD 0084  1616 	MOVWF FSR0
02AE 1803  1617 	BTFSC 0x03,Carry
02AF 0A85  1618 	INCF  FSR0+1,1
02B0 0800  1619 	MOVF  INDF0,W
02B1 00A2  1620 	MOVWF temp_current
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 28

ADDR CODE  LINE SOURCE

           1621 			;		temp_destination = gLedBuf.led_destination[i];
02B2 3020  1622 	MOVLW 32
02B3 0085  1623 	MOVWF FSR0+1
02B4 30A5  1624 	MOVLW 165
02B5 0724  1625 	ADDWF i_4,W
02B6 0084  1626 	MOVWF FSR0
02B7 1803  1627 	BTFSC 0x03,Carry
02B8 0A85  1628 	INCF  FSR0+1,1
02B9 0800  1629 	MOVF  INDF0,W
02BA 00A3  1630 	MOVWF temp_destination
           1631 			;		
           1632 			;		if(temp_current > temp_destination)
02BB 0822  1633 	MOVF  temp_current,W
02BC 0223  1634 	SUBWF temp_destination,W
02BD 1803  1635 	BTFSC 0x03,Carry
02BE 2ACB  1636 	GOTO  m033
           1637 			;		{
           1638 			;			gLedBuf.led_array[i] = --temp_current;
02BF 03A2  1639 	DECF  temp_current,1
02C0 3020  1640 	MOVLW 32
02C1 0085  1641 	MOVWF FSR0+1
02C2 3045  1642 	MOVLW 69
02C3 0724  1643 	ADDWF i_4,W
02C4 0084  1644 	MOVWF FSR0
02C5 1803  1645 	BTFSC 0x03,Carry
02C6 0A85  1646 	INCF  FSR0+1,1
02C7 0822  1647 	MOVF  temp_current,W
02C8 0080  1648 	MOVWF INDF0
           1649 			;			fade_finish = 0;
02C9 1025  1650 	BCF   0x25,fade_finish
           1651 			;		}
           1652 			;		else if(temp_current < temp_destination)	
02CA 2ADB  1653 	GOTO  m034
02CB 0020  1654 m033	MOVLB 0
02CC 0823  1655 	MOVF  temp_destination,W
02CD 0222  1656 	SUBWF temp_current,W
02CE 1803  1657 	BTFSC 0x03,Carry
02CF 2ADB  1658 	GOTO  m034
           1659 			;		{
           1660 			;			gLedBuf.led_array[i] = ++temp_current;
02D0 0AA2  1661 	INCF  temp_current,1
02D1 3020  1662 	MOVLW 32
02D2 0085  1663 	MOVWF FSR0+1
02D3 3045  1664 	MOVLW 69
02D4 0724  1665 	ADDWF i_4,W
02D5 0084  1666 	MOVWF FSR0
02D6 1803  1667 	BTFSC 0x03,Carry
02D7 0A85  1668 	INCF  FSR0+1,1
02D8 0822  1669 	MOVF  temp_current,W
02D9 0080  1670 	MOVWF INDF0
           1671 			;			fade_finish = 0;
02DA 1025  1672 	BCF   0x25,fade_finish
           1673 			;		}		
           1674 			;	}	
02DB 0020  1675 m034	MOVLB 0
02DC 0AA4  1676 	INCF  i_4,1
02DD 2AA4  1677 	GOTO  m032
           1678 			;	if(fade_finish) 
02DE 0020  1679 m035	MOVLB 0
02DF 1C25  1680 	BTFSS 0x25,fade_finish
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 29

ADDR CODE  LINE SOURCE

02E0 2AE8  1681 	GOTO  m036
           1682 			;	{
           1683 			;		gLedBuf.led_fade_operation = 0;
02E1 0023  1684 	MOVLB 3
02E2 1035  1685 	BCF   gLedBuf+336,0
           1686 			;		//send Fade Done
           1687 			;		USARTsend('F');
02E3 3046  1688 	MOVLW 70
02E4 2383  1689 	CALL  USARTsend
           1690 			;		USARTsend('D');
02E5 3044  1691 	MOVLW 68
02E6 2383  1692 	CALL  USARTsend
           1693 			;	}
           1694 			;	else 
02E7 2AEE  1695 	GOTO  m037
           1696 			;		spi_send_ledbuf(&gLedBuf.led_array[0]);
02E8 3045  1697 m036	MOVLW 69
02E9 0020  1698 	MOVLB 0
02EA 00B4  1699 	MOVWF array_4
02EB 3020  1700 	MOVLW 32
02EC 00B5  1701 	MOVWF array_4+1
02ED 2B3D  1702 	GOTO  spi_send_ledbuf
           1703 			;}
02EE 0008  1704 m037	RETURN
           1705 
           1706   ; FILE RingBuf.c
           1707 			;
           1708 			;#include "RingBuf.h"
           1709 			;
           1710 			;#ifndef X86
           1711 			;#message Global variables are defined in RingBuf.c
           1712 			;#endif /* #ifndef X86 */
           1713 			;struct RingBuffer gRingBuf;
           1714 			;
           1715 			;void RingBufInit(void)
           1716 			;{
           1717 RingBufInit
           1718 			;	gRingBuf.read = 0;
02EF 0020  1719 	MOVLB 0
02F0 01CA  1720 	CLRF  gRingBuf+16
           1721 			;	gRingBuf.write = 0;
02F1 01CB  1722 	CLRF  gRingBuf+17
           1723 			;	gRingBuf.error_full = 0;
02F2 104C  1724 	BCF   gRingBuf+18,0
           1725 			;}
02F3 0008  1726 	RETURN
           1727 			;
           1728 			;char RingBufGet(void)
           1729 			;{
           1730 RingBufGet
           1731 			;	char result = gRingBuf.data[gRingBuf.read];
02F4 303A  1732 	MOVLW 58
02F5 0020  1733 	MOVLB 0
02F6 074A  1734 	ADDWF gRingBuf+16,W
02F7 0084  1735 	MOVWF FSR0L
02F8 0185  1736 	CLRF  FSR0H
02F9 0800  1737 	MOVF  INDF0,W
02FA 00A5  1738 	MOVWF result
           1739 			;	gRingBuf.read = RingBufInc(gRingBuf.read);
02FB 0A4A  1740 	INCF  gRingBuf+16,W
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 30

ADDR CODE  LINE SOURCE

02FC 390F  1741 	ANDLW 15
02FD 00CA  1742 	MOVWF gRingBuf+16
           1743 			;	return result;
02FE 0825  1744 	MOVF  result,W
02FF 0008  1745 	RETURN
           1746 			;}
           1747 			;
           1748 			;void RingBufPut(char value)
           1749 			;{
           1750 RingBufPut
0300 0020  1751 	MOVLB 0
0301 00A0  1752 	MOVWF value
           1753 			;	char writeNext = RingBufInc(gRingBuf.write);
0302 0A4B  1754 	INCF  gRingBuf+17,W
0303 390F  1755 	ANDLW 15
0304 00A1  1756 	MOVWF writeNext
           1757 			;	if(writeNext != gRingBuf.read)
0305 0821  1758 	MOVF  writeNext,W
0306 064A  1759 	XORWF gRingBuf+16,W
0307 1903  1760 	BTFSC 0x03,Zero_
0308 2B12  1761 	GOTO  m038
           1762 			;	{
           1763 			;		gRingBuf.data[gRingBuf.write] = value;
0309 303A  1764 	MOVLW 58
030A 074B  1765 	ADDWF gRingBuf+17,W
030B 0084  1766 	MOVWF FSR0L
030C 0185  1767 	CLRF  FSR0H
030D 0820  1768 	MOVF  value,W
030E 0080  1769 	MOVWF INDF0
           1770 			;		gRingBuf.write = writeNext;
030F 0821  1771 	MOVF  writeNext,W
0310 00CB  1772 	MOVWF gRingBuf+17
           1773 			;	}
           1774 			;	else gRingBuf.error_full = 1;
0311 2B14  1775 	GOTO  m039
0312 0020  1776 m038	MOVLB 0
0313 144C  1777 	BSF   gRingBuf+18,0
           1778 			;}
0314 0008  1779 m039	RETURN
           1780 
           1781   ; FILE spi.c
           1782 			;//Nils Weiß 
           1783 			;//20.04.2012
           1784 			;//Compiler CC5x
           1785 			;
           1786 			;#include "ledstrip.h"
           1787 			;
           1788 			;#ifndef X86
           1789 			;void spi_init()
           1790 			;{
           1791 spi_init
           1792 			;	TRISC.3 = 0;        // Make port RC3 an output(SPI Clock)
0315 0021  1793 	MOVLB 1
0316 118E  1794 	BCF   TRISC,3
           1795 			;    TRISC.4 = 1;        // Make port RC4 an input(SPI Data In)
0317 160E  1796 	BSF   TRISC,4
           1797 			;    TRISC.5 = 0;        // Make port RC5 an output(SPI Data Out)
0318 128E  1798 	BCF   TRISC,5
           1799 			;	SSPM1 = 0;
0319 0024  1800 	MOVLB 4
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 31

ADDR CODE  LINE SOURCE

031A 1095  1801 	BCF   0x215,SSPM1
           1802 			;	SMP = 1;
031B 1794  1803 	BSF   0x214,SMP
           1804 			;	CKP = 0;
031C 1215  1805 	BCF   0x215,CKP
           1806 			;	CKE = 1;
031D 1714  1807 	BSF   0x214,CKE
           1808 			;	SSPEN = 1;
031E 1695  1809 	BSF   0x215,SSPEN
           1810 			;}
031F 0008  1811 	RETURN
           1812 			;
           1813 			;char spi_send(char data)
           1814 			;{
           1815 spi_send
0320 0020  1816 	MOVLB 0
0321 00B8  1817 	MOVWF data_4
           1818 			;	SSPBUF = data;	
0322 0838  1819 	MOVF  data_4,W
0323 0024  1820 	MOVLB 4
0324 0091  1821 	MOVWF SSPBUF
           1822 			;	while(SSPIF == 0);
0325 0020  1823 m040	MOVLB 0
0326 1D91  1824 	BTFSS 0x11,SSPIF
0327 2B25  1825 	GOTO  m040
           1826 			;	return SSPBUF;
0328 0024  1827 	MOVLB 4
0329 0811  1828 	MOVF  SSPBUF,W
032A 0008  1829 	RETURN
           1830 			;}
           1831 			;#endif /* #ifndef X86 */
           1832 			;
           1833 			;/***
           1834 			;**	This function sends the array to the LED controller(WS2801)
           1835 			;**  it starts with the last byte to get a correct output
           1836 			;***/
           1837 			;void spi_send_arr(char *array, char length)
           1838 			;{
           1839 spi_send_arr
032B 00FF  1840 	MOVWF length_4
           1841 			;	if(array == 0) return;
032C 08FF  1842 	MOVF  array_3,1
032D 1903  1843 	BTFSC 0x03,Zero_
032E 0008  1844 	RETURN
           1845 			;	char i;
           1846 			;	for(i = length; i == 0; i-- )
032F 087F  1847 	MOVF  length_4,W
0330 00FF  1848 	MOVWF i_5
0331 08FF  1849 m041	MOVF  i_5,1
0332 1D03  1850 	BTFSS 0x03,Zero_
0333 2B3C  1851 	GOTO  m042
           1852 			;	{
           1853 			;		spi_send(array[i]);
0334 087F  1854 	MOVF  i_5,W
0335 077F  1855 	ADDWF array_3,W
0336 0084  1856 	MOVWF FSR0L
0337 0185  1857 	CLRF  FSR0H
0338 0800  1858 	MOVF  INDF0,W
0339 2320  1859 	CALL  spi_send
           1860 			;	} 
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 32

ADDR CODE  LINE SOURCE

033A 03FF  1861 	DECF  i_5,1
033B 2B31  1862 	GOTO  m041
           1863 			;}
033C 0008  1864 m042	RETURN
           1865 			;
           1866 			;void spi_send_ledbuf(char *array)//!!! CHECK if GIE=0 during the sendroutine improves the result
           1867 			;{
           1868 spi_send_ledbuf
           1869 			;	//array must be the address of the first byte
           1870 			;	char* end;
           1871 			;	//calculate where the end is
           1872 			;	end = array + (NUM_OF_LED * 3);
033D 0020  1873 	MOVLB 0
033E 0835  1874 	MOVF  array_4+1,W
033F 00B7  1875 	MOVWF end+1
0340 3060  1876 	MOVLW 96
0341 0734  1877 	ADDWF array_4,W
0342 00B6  1878 	MOVWF end
0343 1803  1879 	BTFSC 0x03,Carry
0344 0AB7  1880 	INCF  end+1,1
           1881 			;	//send all
           1882 			;	for(; array < end; array++)
0345 0020  1883 m043	MOVLB 0
0346 0837  1884 	MOVF  end+1,W
0347 0235  1885 	SUBWF array_4+1,W
0348 1C03  1886 	BTFSS 0x03,Carry
0349 2B50  1887 	GOTO  m044
034A 1D03  1888 	BTFSS 0x03,Zero_
034B 2B5C  1889 	GOTO  m045
034C 0836  1890 	MOVF  end,W
034D 0234  1891 	SUBWF array_4,W
034E 1803  1892 	BTFSC 0x03,Carry
034F 2B5C  1893 	GOTO  m045
           1894 			;	{
           1895 			;		spi_send(*array);
0350 0020  1896 m044	MOVLB 0
0351 0835  1897 	MOVF  array_4+1,W
0352 0085  1898 	MOVWF FSR0H
0353 0834  1899 	MOVF  array_4,W
0354 0084  1900 	MOVWF FSR0L
0355 0800  1901 	MOVF  INDF0,W
0356 2320  1902 	CALL  spi_send
           1903 			;	}
0357 0020  1904 	MOVLB 0
0358 0AB4  1905 	INCF  array_4,1
0359 1903  1906 	BTFSC 0x03,Zero_
035A 0AB5  1907 	INCF  array_4+1,1
035B 2B45  1908 	GOTO  m043
           1909 			;}
035C 0008  1910 m045	RETURN
           1911 
           1912   ; FILE timer.c
           1913 			;//Nils Weiß 
           1914 			;//08.05.2012
           1915 			;//Compiler CC5x 
           1916 			;
           1917 			;void timer_init()
           1918 			;{
           1919 timer_init
           1920 			;	T2CON = 0b01111101;
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 33

ADDR CODE  LINE SOURCE

035D 307D  1921 	MOVLW 125
035E 0020  1922 	MOVLB 0
035F 009C  1923 	MOVWF T2CON
           1924 			;	TMR2IE = 1;
0360 0021  1925 	MOVLB 1
0361 1491  1926 	BSF   0x91,TMR2IE
           1927 			;	
           1928 			;	T4CON = 0b01111111;
0362 307F  1929 	MOVLW 127
0363 0028  1930 	MOVLB 8
0364 0097  1931 	MOVWF T4CON
           1932 			;	TMR4IE = 1;
0365 0021  1933 	MOVLB 1
0366 1493  1934 	BSF   0x93,TMR4IE
           1935 			;	
           1936 			;	PR4 = 0xff;
0367 30FF  1937 	MOVLW 255
0368 0028  1938 	MOVLB 8
0369 0096  1939 	MOVWF PR4
           1940 			;}
036A 0008  1941 	RETURN
           1942 			;
           1943 			;void timer_set_for_fade(char value)
           1944 			;{
           1945 timer_set_for_fade
036B 0020  1946 	MOVLB 0
036C 00B5  1947 	MOVWF value_2
           1948 			;	PR2 = value;
036D 0835  1949 	MOVF  value_2,W
036E 009B  1950 	MOVWF PR2
           1951 			;}
036F 0008  1952 	RETURN
           1953 
           1954   ; FILE usart.c
           1955 			;// Include-Datei für Serielle Kommunikation über Hardwaremodul des Pic
           1956 			; //
           1957 			; //
           1958 			; // Nils Weiß
           1959 			; // 29.11.2010
           1960 			; // Compiler CC5x
           1961 			;
           1962 			;#ifndef X86
           1963 			;//*******  Initialisierungs-Funktion  *************************************************
           1964 			;void USARTinit()
           1965 			;{
           1966 USARTinit
           1967 			;	//USART TX Pin als Ausgang
           1968 			;	TRISC.6 = 0;
0370 0021  1969 	MOVLB 1
0371 130E  1970 	BCF   TRISC,6
           1971 			;
           1972 			;    BRGH=1;					// High Baudrate activated
0372 0023  1973 	MOVLB 3
0373 151E  1974 	BSF   0x19E,BRGH
           1975 			;	BRG16=0;
0374 119F  1976 	BCF   0x19F,BRG16
           1977 			;	SPBRGL=25;				// 19200 Bps @ 8 MHz Clock
0375 3019  1978 	MOVLW 25
0376 009B  1979 	MOVWF SPBRGL
           1980 			;	SPBRGH=0;
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 34

ADDR CODE  LINE SOURCE

0377 019C  1981 	CLRF  SPBRGH
           1982 			;    SPEN = 1;               // Set_Serial_Pins;
0378 179D  1983 	BSF   0x19D,SPEN
           1984 			;    SYNC = 0;               // Set_Async_Mode;
0379 121E  1985 	BCF   0x19E,SYNC
           1986 			;    TX9 = 0;                // Set_8bit_Tx;
037A 131E  1987 	BCF   0x19E,TX9
           1988 			;    RX9 = 0;                // Set_8bit_Rx;
037B 131D  1989 	BCF   0x19D,RX9
           1990 			;    CREN = 1;               // Enable_Rx;
037C 161D  1991 	BSF   0x19D,CREN
           1992 			;    TXEN = 1;               // Enable_Tx;
037D 169E  1993 	BSF   0x19E,TXEN
           1994 			;    RCIE=1;                 // Rx Interrupt aus
037E 0021  1995 	MOVLB 1
037F 1691  1996 	BSF   0x91,RCIE
           1997 			;	ADDEN=0;				// Disable Adressdetection
0380 0023  1998 	MOVLB 3
0381 119D  1999 	BCF   0x19D,ADDEN
           2000 			;}
0382 0008  2001 	RETURN
           2002 			;
           2003 			;//*******  Sende-char-Funktion  *************************************************
           2004 			;void USARTsend(unsigned char ch)
           2005 			;{
           2006 USARTsend
0383 0020  2007 	MOVLB 0
0384 00B4  2008 	MOVWF ch
           2009 			;	while(!TXIF);
0385 0020  2010 m046	MOVLB 0
0386 1E11  2011 	BTFSS 0x11,TXIF
0387 2B85  2012 	GOTO  m046
           2013 			;	TXREG=ch;
0388 0020  2014 	MOVLB 0
0389 0834  2015 	MOVF  ch,W
038A 0023  2016 	MOVLB 3
038B 009A  2017 	MOVWF TXREG
           2018 			;}
038C 0008  2019 	RETURN
           2020 			;#endif /* #ifndef X86 */
           2021 			;
           2022 			;//*******  Sende-String-Funktion  *************************************************
           2023 			;void USARTsend_str(const char *string)
           2024 			;{
           2025 USARTsend_str
           2026 			; char ps;
           2027 			; ps = *string;
038D 0020  2028 	MOVLB 0
038E 082F  2029 	MOVF  string,W
038F 201C  2030 	CALL  _const1
0390 0020  2031 	MOVLB 0
0391 00B0  2032 	MOVWF ps
           2033 			; while(ps > 0)
0392 0020  2034 m047	MOVLB 0
0393 08B0  2035 	MOVF  ps,1
0394 1903  2036 	BTFSC 0x03,Zero_
0395 2B9F  2037 	GOTO  m048
           2038 			;   {
           2039 			;    string++;
0396 0AAF  2040 	INCF  string,1
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 35

ADDR CODE  LINE SOURCE

           2041 			;   	USARTsend(ps);
0397 0830  2042 	MOVF  ps,W
0398 2383  2043 	CALL  USARTsend
           2044 			;    ps = *string;
0399 0020  2045 	MOVLB 0
039A 082F  2046 	MOVF  string,W
039B 201C  2047 	CALL  _const1
039C 0020  2048 	MOVLB 0
039D 00B0  2049 	MOVWF ps
           2050 			;   }
039E 2B92  2051 	GOTO  m047
           2052 			;}
039F 0008  2053 m048	RETURN
           2054 			;
           2055 			;//*******  Sende-Array-Funktion  *************************************************
           2056 			;void USARTsend_arr(char *array, char length)
           2057 			;{
           2058 USARTsend_arr
03A0 00FF  2059 	MOVWF length_5
           2060 			;	if(array == 0) return;
03A1 08FF  2061 	MOVF  array_5,1
03A2 1903  2062 	BTFSC 0x03,Zero_
03A3 0008  2063 	RETURN
           2064 			;	char i;
           2065 			;	for(i=0;i<length;i++)
03A4 01FF  2066 	CLRF  i_6
03A5 087F  2067 m049	MOVF  length_5,W
03A6 027F  2068 	SUBWF i_6,W
03A7 1803  2069 	BTFSC 0x03,Carry
03A8 2BB1  2070 	GOTO  m050
           2071 			;	{
           2072 			;		USARTsend(*array);
03A9 0185  2073 	CLRF  FSR0H
03AA 087F  2074 	MOVF  array_5,W
03AB 0084  2075 	MOVWF FSR0L
03AC 0800  2076 	MOVF  INDF0,W
03AD 2383  2077 	CALL  USARTsend
           2078 			;		array++;
03AE 0AFF  2079 	INCF  array_5,1
           2080 			;	}
03AF 0AFF  2081 	INCF  i_6,1
03B0 2BA5  2082 	GOTO  m049
           2083 			;}
03B1 0008  2084 m050	RETURN
           2085 			;
           2086 			;#ifdef TEST
           2087 			;//*******  Sende-Zahl-als-String-Funktion  *************************************************
           2088 			;void USARTsend_num(char input, char sign)
           2089 			;{
           2090 USARTsend_num
03B2 0020  2091 	MOVLB 0
03B3 00AF  2092 	MOVWF sign_5
           2093 			;   char temp;
           2094 			;   char h,z,e;
           2095 			; 
           2096 			;   h=0;
03B4 01B1  2097 	CLRF  h
           2098 			;   z=0;
03B5 01B2  2099 	CLRF  z
           2100 			;   e=0; 
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 36

ADDR CODE  LINE SOURCE

03B6 01B3  2101 	CLRF  e
           2102 			;   
           2103 			;   if (input>99)
03B7 3064  2104 	MOVLW 100
03B8 022E  2105 	SUBWF input,W
03B9 1C03  2106 	BTFSS 0x03,Carry
03BA 2BCD  2107 	GOTO  m051
           2108 			;   {
           2109 			;      h=input/100;
03BB 082E  2110 	MOVF  input,W
03BC 00B4  2111 	MOVWF arg1_5
03BD 01B5  2112 	CLRF  arg1_5+1
03BE 3064  2113 	MOVLW 100
03BF 218B  2114 	CALL  _divU16_8
03C0 0020  2115 	MOVLB 0
03C1 0834  2116 	MOVF  arg1_5,W
03C2 00B1  2117 	MOVWF h
           2118 			;      temp=0;
03C3 01B0  2119 	CLRF  temp_4
           2120 			;      temp=100*h;
03C4 3064  2121 	MOVLW 100
03C5 00B4  2122 	MOVWF arg1
03C6 0831  2123 	MOVF  h,W
03C7 217A  2124 	CALL  _mult8x8
03C8 0020  2125 	MOVLB 0
03C9 0836  2126 	MOVF  rval,W
03CA 00B0  2127 	MOVWF temp_4
           2128 			;      input=input-temp; 
03CB 0830  2129 	MOVF  temp_4,W
03CC 02AE  2130 	SUBWF input,1
           2131 			;   }
           2132 			;
           2133 			;   if (input>9)
03CD 300A  2134 m051	MOVLW 10
03CE 0020  2135 	MOVLB 0
03CF 022E  2136 	SUBWF input,W
03D0 1C03  2137 	BTFSS 0x03,Carry
03D1 2BE4  2138 	GOTO  m052
           2139 			;   {
           2140 			;      z=input/10;
03D2 082E  2141 	MOVF  input,W
03D3 00B4  2142 	MOVWF arg1_5
03D4 01B5  2143 	CLRF  arg1_5+1
03D5 300A  2144 	MOVLW 10
03D6 218B  2145 	CALL  _divU16_8
03D7 0020  2146 	MOVLB 0
03D8 0834  2147 	MOVF  arg1_5,W
03D9 00B2  2148 	MOVWF z
           2149 			;      temp=0;
03DA 01B0  2150 	CLRF  temp_4
           2151 			;      temp=z*10;
03DB 0832  2152 	MOVF  z,W
03DC 00B4  2153 	MOVWF arg1
03DD 300A  2154 	MOVLW 10
03DE 217A  2155 	CALL  _mult8x8
03DF 0020  2156 	MOVLB 0
03E0 0836  2157 	MOVF  rval,W
03E1 00B0  2158 	MOVWF temp_4
           2159 			;      input=input-temp;      
03E2 0830  2160 	MOVF  temp_4,W
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 37

ADDR CODE  LINE SOURCE

03E3 02AE  2161 	SUBWF input,1
           2162 			;   }
           2163 			;
           2164 			;   if (input<=9)
03E4 300A  2165 m052	MOVLW 10
03E5 0020  2166 	MOVLB 0
03E6 022E  2167 	SUBWF input,W
03E7 1803  2168 	BTFSC 0x03,Carry
03E8 2BEB  2169 	GOTO  m053
           2170 			;   {
           2171 			;      e=input;
03E9 082E  2172 	MOVF  input,W
03EA 00B3  2173 	MOVWF e
           2174 			;   }
           2175 			;   if(h!=0)USARTsend(h+0x30);
03EB 0020  2176 m053	MOVLB 0
03EC 08B1  2177 	MOVF  h,1
03ED 1903  2178 	BTFSC 0x03,Zero_
03EE 2BF2  2179 	GOTO  m054
03EF 3030  2180 	MOVLW 48
03F0 0731  2181 	ADDWF h,W
03F1 2383  2182 	CALL  USARTsend
           2183 			;   USARTsend(z+0x30);
03F2 3030  2184 m054	MOVLW 48
03F3 0020  2185 	MOVLB 0
03F4 0732  2186 	ADDWF z,W
03F5 2383  2187 	CALL  USARTsend
           2188 			;   USARTsend(e+0x30);
03F6 3030  2189 	MOVLW 48
03F7 0020  2190 	MOVLB 0
03F8 0733  2191 	ADDWF e,W
03F9 2383  2192 	CALL  USARTsend
           2193 			;   USARTsend(sign); 	//Zeichen senden
03FA 0020  2194 	MOVLB 0
03FB 082F  2195 	MOVF  sign_5,W
03FC 2B83  2196 	GOTO  USARTsend
           2197 			;}
           2198 
           2199   ; FILE commandstorage.c
           2200 			;#include "platform.h"
           2201 			;#include "commandstorage.h"
           2202 			;
           2203 			;struct led_cmd* commandstorage_read(struct led_cmd *pDest)
           2204 			;{
           2205 commandstorage_read
           2206 			;	// if the commandstorage is waiting
           2207 			;	if(gCmdBuf.WaitValue == 0) 
03FD 0020  2208 	MOVLB 0
03FE 0863  2209 	MOVF  gCmdBuf+20,W
03FF 0464  2210 	IORWF gCmdBuf+21,W
0400 1D03  2211 	BTFSS 0x03,Zero_
0401 2C3D  2212 	GOTO  m059
           2213 			;	{
           2214 			;		//check parameter
           2215 			;		if(0 == pDest) return 0;
0402 08AD  2216 	MOVF  pDest,1
0403 1903  2217 	BTFSC 0x03,Zero_
0404 3400  2218 	RETLW 0
           2219 			;
           2220 			;		//commands available in eeprom?
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 38

ADDR CODE  LINE SOURCE

           2221 			;		char nextCmd = EEPROM_RD(CmdPointerAddr);
0405 30FF  2222 	MOVLW 255
0406 211E  2223 	CALL  EEPROM_RD
0407 0020  2224 	MOVLB 0
0408 00AE  2225 	MOVWF nextCmd
           2226 			;		if(0 == nextCmd) return 0;
0409 08AE  2227 	MOVF  nextCmd,1
040A 1903  2228 	BTFSC 0x03,Zero_
040B 3400  2229 	RETLW 0
           2230 			;	
           2231 			;		if(gCmdBuf.LoopMode)
040C 0020  2232 	MOVLB 0
040D 1C62  2233 	BTFSS gCmdBuf+19,0
040E 2C1F  2234 	GOTO  m056
           2235 			;		{
           2236 			;			nextCmd = EEPROM_RD(CmdLoopPointerAddr);
040F 30FE  2237 	MOVLW 254
0410 211E  2238 	CALL  EEPROM_RD
0411 0020  2239 	MOVLB 0
0412 00AE  2240 	MOVWF nextCmd
           2241 			;			if(0 == nextCmd)
0413 08AE  2242 	MOVF  nextCmd,1
0414 1D03  2243 	BTFSS 0x03,Zero_
0415 2C1A  2244 	GOTO  m055
           2245 			;				nextCmd = EEPROM_RD(CmdPointerAddr);
0416 30FF  2246 	MOVLW 255
0417 211E  2247 	CALL  EEPROM_RD
0418 0020  2248 	MOVLB 0
0419 00AE  2249 	MOVWF nextCmd
           2250 			;				EEPROM_WR(CmdLoopPointerAddr, nextCmd);
041A 30FE  2251 m055	MOVLW 254
041B 0020  2252 	MOVLB 0
041C 00AF  2253 	MOVWF adress
041D 082E  2254 	MOVF  nextCmd,W
041E 20FC  2255 	CALL  EEPROM_WR
           2256 			;		}
           2257 			;
           2258 			;		//read command from eeprom
           2259 			;		EEPROM_RD_BLK((char*)pDest, (nextCmd - CmdWidth), CmdWidth);
041F 0020  2260 m056	MOVLB 0
0420 082D  2261 	MOVF  pDest,W
0421 00AF  2262 	MOVWF array_2
0422 300A  2263 	MOVLW 10
0423 022E  2264 	SUBWF nextCmd,W
0424 00B0  2265 	MOVWF adress_4
0425 300A  2266 	MOVLW 10
0426 2144  2267 	CALL  EEPROM_RD_BLK
           2268 			;
           2269 			;		//update the CmdPointer?
           2270 			;		if(gCmdBuf.LoopMode)
0427 0020  2271 	MOVLB 0
0428 1C62  2272 	BTFSS gCmdBuf+19,0
0429 2C30  2273 	GOTO  m057
           2274 			;			EEPROM_WR(CmdLoopPointerAddr, nextCmd - CmdWidth);		
042A 30FE  2275 	MOVLW 254
042B 00AF  2276 	MOVWF adress
042C 300A  2277 	MOVLW 10
042D 022E  2278 	SUBWF nextCmd,W
042E 20FC  2279 	CALL  EEPROM_WR
           2280 			;		else
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 39

ADDR CODE  LINE SOURCE

042F 2C36  2281 	GOTO  m058
           2282 			;			EEPROM_WR(CmdPointerAddr, nextCmd - CmdWidth);
0430 30FF  2283 m057	MOVLW 255
0431 0020  2284 	MOVLB 0
0432 00AF  2285 	MOVWF adress
0433 300A  2286 	MOVLW 10
0434 022E  2287 	SUBWF nextCmd,W
0435 20FC  2288 	CALL  EEPROM_WR
           2289 			;			
           2290 			;#ifdef TEST
           2291 			;		USARTsend_str("Read_Done");
0436 304B  2292 m058	MOVLW 75
0437 0020  2293 	MOVLB 0
0438 00AF  2294 	MOVWF string
0439 238D  2295 	CALL  USARTsend_str
           2296 			;#endif 
           2297 			;		return pDest;
043A 0020  2298 	MOVLB 0
043B 082D  2299 	MOVF  pDest,W
043C 0008  2300 	RETURN
           2301 			;	}
           2302 			;	else return 0;
043D 3400  2303 m059	RETLW 0
           2304 			;}
           2305 			;
           2306 			;bit commandstorage_write(char *pSrc, char length)
           2307 			;{
           2308 commandstorage_write
043E 0020  2309 	MOVLB 0
043F 00A6  2310 	MOVWF length_6
           2311 			;	//check parameter
           2312 			;	if(0 == pSrc) return FALSE;
0440 08A5  2313 	MOVF  pSrc,1
0441 1D03  2314 	BTFSS 0x03,Zero_
0442 2C45  2315 	GOTO  m060
0443 1003  2316 	BCF   0x03,Carry
0444 0008  2317 	RETURN
           2318 			;	
           2319 			;	//enought free space in eeprom?
           2320 			;	char nextCmd = EEPROM_RD(CmdPointerAddr);
0445 30FF  2321 m060	MOVLW 255
0446 211E  2322 	CALL  EEPROM_RD
0447 0020  2323 	MOVLB 0
0448 00A7  2324 	MOVWF nextCmd_2
           2325 			;	if(nextCmd >= (CmdPointerAddr - CmdWidth)) return FALSE;
0449 30F5  2326 	MOVLW 245
044A 0227  2327 	SUBWF nextCmd_2,W
044B 1C03  2328 	BTFSS 0x03,Carry
044C 2C4F  2329 	GOTO  m061
044D 1003  2330 	BCF   0x03,Carry
044E 0008  2331 	RETURN
           2332 			;
           2333 			;	//increase the command pointer in eeprom
           2334 			;	EEPROM_WR(CmdPointerAddr,(nextCmd + CmdWidth));
044F 30FF  2335 m061	MOVLW 255
0450 0020  2336 	MOVLB 0
0451 00AF  2337 	MOVWF adress
0452 300A  2338 	MOVLW 10
0453 0727  2339 	ADDWF nextCmd_2,W
0454 20FC  2340 	CALL  EEPROM_WR
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 40

ADDR CODE  LINE SOURCE

           2341 			;		
           2342 			;	//write data to eeprom
           2343 			;	EEPROM_WR_BLK(pSrc, nextCmd, length);
0455 0020  2344 	MOVLB 0
0456 0825  2345 	MOVF  pSrc,W
0457 00A8  2346 	MOVWF array
0458 0827  2347 	MOVF  nextCmd_2,W
0459 00A9  2348 	MOVWF adress_3
045A 0826  2349 	MOVF  length_6,W
045B 212B  2350 	CALL  EEPROM_WR_BLK
           2351 			;		
           2352 			;	return TRUE;
045C 1403  2353 	BSF   0x03,Carry
045D 0008  2354 	RETURN
           2355 			;}
           2356 			;
           2357 			;void commandstorage_get_commands()
           2358 			;{	
           2359 commandstorage_get_commands
           2360 			;	if(RingBufHasError)
045E 0020  2361 	MOVLB 0
045F 1C4C  2362 	BTFSS gRingBuf+18,0
0460 2C63  2363 	GOTO  m062
           2364 			;	{
           2365 			;		// *** if a RingBufError occure, I have to throw away the current command,
           2366 			;		// *** because the last byte was not saved. Commandstring is inconsistent
           2367 			;		ClearCmdBuf();
0461 01CF  2368 	CLRF  gCmdBuf
0462 01D0  2369 	CLRF  gCmdBuf+1
           2370 			;	}
           2371 			;
           2372 			;	if(RingBufIsNotEmpty)
0463 0020  2373 m062	MOVLB 0
0464 084B  2374 	MOVF  gRingBuf+17,W
0465 064A  2375 	XORWF gRingBuf+16,W
0466 1903  2376 	BTFSC 0x03,Zero_
0467 2CF0  2377 	GOTO  m073
           2378 			;	{
           2379 			;		// *** preload variables and 
           2380 			;		// *** get new_byte from ringbuffer
           2381 			;		char new_byte, temp, j;
           2382 			;		temp = 0;
0468 01A3  2383 	CLRF  temp_5
           2384 			;		j = 0;
0469 01A4  2385 	CLRF  j
           2386 			;		// *** get new byte
           2387 			;		new_byte = RingBufGet();	
046A 22F4  2388 	CALL  RingBufGet
046B 0020  2389 	MOVLB 0
046C 00A2  2390 	MOVWF new_byte
           2391 			;		// *** do I wait for databytes?
           2392 			;		if(gCmdBuf.frame_counter == 0)
046D 08D0  2393 	MOVF  gCmdBuf+1,1
046E 1D03  2394 	BTFSS 0x03,Zero_
046F 2C9B  2395 	GOTO  m064
           2396 			;		{
           2397 			;			// *** I don't wait for databytes
           2398 			;			// *** Do I receive a Start_of_Text sign
           2399 			;			if((uns8)new_byte == STX)
0470 0F22  2400 	INCFSZ new_byte,W
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 41

ADDR CODE  LINE SOURCE

0471 2C84  2401 	GOTO  m063
           2402 			;			{
           2403 			;				// *** increse the cmd_counter
           2404 			;				gCmdBuf.cmd_counter = 1;
0472 3001  2405 	MOVLW 1
0473 00CF  2406 	MOVWF gCmdBuf
           2407 			;				// *** Write the startsign at the begin of the buffer
           2408 			;				gCmdBuf.cmd_buf[0] = new_byte;
0474 0822  2409 	MOVF  new_byte,W
0475 00D1  2410 	MOVWF gCmdBuf+2
           2411 			;                // *** Reset crc Variables
           2412 			;                newCRC(&gCmdBuf.crcH, &gCmdBuf.crcL);
0476 3060  2413 	MOVLW 96
0477 00A5  2414 	MOVWF p_crcH_2
0478 3061  2415 	MOVLW 97
0479 00A6  2416 	MOVWF p_crcL_2
047A 20E8  2417 	CALL  newCRC
           2418 			;                // *** add new_byte to crc checksum
           2419 			;                addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
047B 0020  2420 	MOVLB 0
047C 0822  2421 	MOVF  new_byte,W
047D 00A5  2422 	MOVWF byte
047E 3060  2423 	MOVLW 96
047F 00A6  2424 	MOVWF p_crcH
0480 3061  2425 	MOVLW 97
0481 00A7  2426 	MOVWF p_crcL
0482 2093  2427 	CALL  addCRC
           2428 			;			}
           2429 			;			else
0483 2CF0  2430 	GOTO  m073
           2431 			;			{	
           2432 			;				// *** to avoid arrayoverflow
           2433 			;				temp = FRAMELENGTH - 2;
0484 300D  2434 m063	MOVLW 13
0485 0020  2435 	MOVLB 0
0486 00A3  2436 	MOVWF temp_5
           2437 			;				// *** check if I get the framelength byte
           2438 			;				if((new_byte < temp) && (gCmdBuf.cmd_counter == 1))
0487 0823  2439 	MOVF  temp_5,W
0488 0222  2440 	SUBWF new_byte,W
0489 1803  2441 	BTFSC 0x03,Carry
048A 2CF0  2442 	GOTO  m073
048B 0B4F  2443 	DECFSZ gCmdBuf,W
048C 2CF0  2444 	GOTO  m073
           2445 			;				{
           2446 			;					gCmdBuf.frame_counter = new_byte;
048D 0822  2447 	MOVF  new_byte,W
048E 00D0  2448 	MOVWF gCmdBuf+1
           2449 			;					gCmdBuf.cmd_buf[1] = new_byte;
048F 0822  2450 	MOVF  new_byte,W
0490 00D2  2451 	MOVWF gCmdBuf+3
           2452 			;					gCmdBuf.cmd_counter = 2;
0491 3002  2453 	MOVLW 2
0492 00CF  2454 	MOVWF gCmdBuf
           2455 			;                    // *** add new_byte to crc checksum
           2456 			;                    addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
0493 0822  2457 	MOVF  new_byte,W
0494 00A5  2458 	MOVWF byte
0495 3060  2459 	MOVLW 96
0496 00A6  2460 	MOVWF p_crcH
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 42

ADDR CODE  LINE SOURCE

0497 3061  2461 	MOVLW 97
0498 00A7  2462 	MOVWF p_crcL
0499 2093  2463 	CALL  addCRC
           2464 			;				}
           2465 			;			}
           2466 			;		}
           2467 			;		else
049A 2CF0  2468 	GOTO  m073
           2469 			;		{
           2470 			;			// *** I wait for Databytes, so I save all bytes 
           2471 			;			// *** that I get until my framecounter is > 0
           2472 			;			gCmdBuf.cmd_buf[gCmdBuf.cmd_counter] = new_byte;
049B 3051  2473 m064	MOVLW 81
049C 0020  2474 	MOVLB 0
049D 074F  2475 	ADDWF gCmdBuf,W
049E 0084  2476 	MOVWF FSR0L
049F 0185  2477 	CLRF  FSR0H
04A0 0822  2478 	MOVF  new_byte,W
04A1 0080  2479 	MOVWF INDF0
           2480 			;			gCmdBuf.cmd_counter++;
04A2 0ACF  2481 	INCF  gCmdBuf,1
           2482 			;			
           2483 			;            // *** add new_byte to crc checksum
           2484 			;			if(gCmdBuf.frame_counter > 2)
04A3 3003  2485 	MOVLW 3
04A4 0250  2486 	SUBWF gCmdBuf+1,W
04A5 1C03  2487 	BTFSS 0x03,Carry
04A6 2CAE  2488 	GOTO  m065
           2489 			;            addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
04A7 0822  2490 	MOVF  new_byte,W
04A8 00A5  2491 	MOVWF byte
04A9 3060  2492 	MOVLW 96
04AA 00A6  2493 	MOVWF p_crcH
04AB 3061  2494 	MOVLW 97
04AC 00A7  2495 	MOVWF p_crcL
04AD 2093  2496 	CALL  addCRC
           2497 			;			gCmdBuf.frame_counter--;
04AE 0020  2498 m065	MOVLB 0
04AF 0BD0  2499 	DECFSZ gCmdBuf+1,1
           2500 			;			// *** now I have to check if my framecounter is null.
           2501 			;			// *** If it's null my string is complete 
           2502 			;			// *** and I can give the string to the crc check function.
           2503 			;			if(gCmdBuf.frame_counter == 0)
04B0 2CF0  2504 	GOTO  m073
           2505 			;			{
           2506 			;#ifdef NO_CRC
           2507 			;				if(1==1)
           2508 			;#else
           2509 			;                // *** verify crc checksum
           2510 			;                if( (gCmdBuf.crcL == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 1]) &&
           2511 			;                    (gCmdBuf.crcH == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 2]) )
           2512 			;#endif
           2513 			;                {
           2514 			;					// *** Execute the simple Commands
           2515 			;					switch(gCmdBuf.cmd_buf[2])
04B1 0853  2516 	MOVF  gCmdBuf+4,W
04B2 3AF8  2517 	XORLW 248
04B3 1903  2518 	BTFSC 0x03,Zero_
04B4 2CC2  2519 	GOTO  m066
04B5 3A02  2520 	XORLW 2
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 43

ADDR CODE  LINE SOURCE

04B6 1903  2521 	BTFSC 0x03,Zero_
04B7 2CC9  2522 	GOTO  m067
04B8 3A03  2523 	XORLW 3
04B9 1903  2524 	BTFSC 0x03,Zero_
04BA 2CCC  2525 	GOTO  m068
04BB 3A0E  2526 	XORLW 14
04BC 1903  2527 	BTFSC 0x03,Zero_
04BD 2CCF  2528 	GOTO  m069
04BE 3A01  2529 	XORLW 1
04BF 1903  2530 	BTFSC 0x03,Zero_
04C0 2CD5  2531 	GOTO  m070
04C1 2CDD  2532 	GOTO  m071
           2533 			;					{
           2534 			;						case DELETE: 
           2535 			;							{
           2536 			;								EEPROM_WR(CmdPointerAddr,0);
04C2 30FF  2537 m066	MOVLW 255
04C3 0020  2538 	MOVLB 0
04C4 00AF  2539 	MOVWF adress
04C5 3000  2540 	MOVLW 0
04C6 20FC  2541 	CALL  EEPROM_WR
           2542 			;								USARTsend('D');
04C7 3044  2543 	MOVLW 68
04C8 2B83  2544 	GOTO  USARTsend
           2545 			;								return;
           2546 			;							}
           2547 			;						case SET_ON: 
           2548 			;							{
           2549 			;								PowerOnLEDs();
04C9 0020  2550 m067	MOVLB 0
04CA 100E  2551 	BCF   PORTC,0
           2552 			;								return;
04CB 0008  2553 	RETURN
           2554 			;							}
           2555 			;						case SET_OFF: 
           2556 			;							{
           2557 			;								PowerOffLEDs();
04CC 0020  2558 m068	MOVLB 0
04CD 140E  2559 	BSF   PORTC,0
           2560 			;								return;
04CE 0008  2561 	RETURN
           2562 			;							}
           2563 			;						case LOOP_ON:
           2564 			;							{	
           2565 			;								gCmdBuf.LoopMode = 1;
04CF 0020  2566 m069	MOVLB 0
04D0 1462  2567 	BSF   gCmdBuf+19,0
           2568 			;								USARTsend('L');
04D1 304C  2569 	MOVLW 76
04D2 2383  2570 	CALL  USARTsend
           2571 			;								USARTsend('1');
04D3 3031  2572 	MOVLW 49
04D4 2B83  2573 	GOTO  USARTsend
           2574 			;								return;
           2575 			;							}
           2576 			;						case LOOP_OFF:
           2577 			;							{	
           2578 			;								gCmdBuf.LoopMode = 0;
04D5 0020  2579 m070	MOVLB 0
04D6 1062  2580 	BCF   gCmdBuf+19,0
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 44

ADDR CODE  LINE SOURCE

           2581 			;								gCmdBuf.WaitValue = 0;
04D7 01E3  2582 	CLRF  gCmdBuf+20
04D8 01E4  2583 	CLRF  gCmdBuf+21
           2584 			;								USARTsend('L');
04D9 304C  2585 	MOVLW 76
04DA 2383  2586 	CALL  USARTsend
           2587 			;								USARTsend('0');
04DB 3030  2588 	MOVLW 48
04DC 2B83  2589 	GOTO  USARTsend
           2590 			;								return;
           2591 			;							}
           2592 			;						default:
           2593 			;							{
           2594 			;								if( commandstorage_write(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4)))
04DD 3053  2595 m071	MOVLW 83
04DE 0020  2596 	MOVLB 0
04DF 00A5  2597 	MOVWF pSrc
04E0 3004  2598 	MOVLW 4
04E1 024F  2599 	SUBWF gCmdBuf,W
04E2 243E  2600 	CALL  commandstorage_write
04E3 1C03  2601 	BTFSS 0x03,Carry
04E4 2CEA  2602 	GOTO  m072
           2603 			;								{
           2604 			;									USARTsend('G');
04E5 3047  2605 	MOVLW 71
04E6 2383  2606 	CALL  USARTsend
           2607 			;									USARTsend('C');
04E7 3043  2608 	MOVLW 67
04E8 2383  2609 	CALL  USARTsend
           2610 			;								}
           2611 			;								else 
04E9 2CF0  2612 	GOTO  m073
           2613 			;									gERROR.eeprom_failure = 1;
04EA 0020  2614 m072	MOVLB 0
04EB 14CD  2615 	BSF   gERROR,1
           2616 			;							}
           2617 			;					}							
           2618 			;					
           2619 			;                }
           2620 			;                else
04EC 2CF0  2621 	GOTO  m073
           2622 			;                {
           2623 			;                    // *** Do some error handling in case of an CRC failure here
           2624 			;					gERROR.crc_failure = 1;
04ED 0020  2625 	MOVLB 0
04EE 144D  2626 	BSF   gERROR,0
           2627 			;                    return;
04EF 0008  2628 	RETURN
           2629 			;                }
           2630 			;			}
           2631 			;		}
           2632 			;	}
           2633 			;}
04F0 0008  2634 m073	RETURN
           2635 			;
           2636 			;void commandstorage_execute_commands()
           2637 			;{
           2638 commandstorage_execute_commands
           2639 			;	// *** get the pointer to commands in the EEPROM
           2640 			;	struct led_cmd nextCmd;
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 45

ADDR CODE  LINE SOURCE

           2641 			;
           2642 			;	// read next command from eeprom and move command pointer in eeprom to the next command (TRUE)
           2643 			;	struct led_cmd *result = commandstorage_read(&nextCmd);
04F1 3022  2644 	MOVLW 34
04F2 0020  2645 	MOVLB 0
04F3 00AD  2646 	MOVWF pDest
04F4 23FD  2647 	CALL  commandstorage_read
04F5 0020  2648 	MOVLB 0
04F6 00AC  2649 	MOVWF result_2
           2650 			;		
           2651 			;	if(0 != result)
04F7 08AC  2652 	MOVF  result_2,1
04F8 1903  2653 	BTFSC 0x03,Zero_
04F9 2D37  2654 	GOTO  m077
           2655 			;	{
           2656 			;#ifdef TEST
           2657 			;USARTsend_str("executeCommand");
04FA 3055  2658 	MOVLW 85
04FB 00AF  2659 	MOVWF string
04FC 238D  2660 	CALL  USARTsend_str
           2661 			;#endif
           2662 			;		// *** commands available, check what to do
           2663 			;		switch(nextCmd.cmd) 
04FD 0020  2664 	MOVLB 0
04FE 0822  2665 	MOVF  nextCmd_3,W
04FF 3AFD  2666 	XORLW 253
0500 1903  2667 	BTFSC 0x03,Zero_
0501 2D0C  2668 	GOTO  m074
0502 3A01  2669 	XORLW 1
0503 1903  2670 	BTFSC 0x03,Zero_
0504 2D11  2671 	GOTO  m075
0505 3A02  2672 	XORLW 2
0506 1903  2673 	BTFSC 0x03,Zero_
0507 2D16  2674 	GOTO  m076
0508 3A05  2675 	XORLW 5
0509 1903  2676 	BTFSC 0x03,Zero_
050A 2D37  2677 	GOTO  m077
050B 2D37  2678 	GOTO  m077
           2679 			;		{	
           2680 			;			case SET_COLOR: 
           2681 			;			{
           2682 			;				ledstrip_set_color(&nextCmd.data.set_color);
050C 3023  2683 m074	MOVLW 35
050D 0020  2684 	MOVLB 0
050E 00AD  2685 	MOVWF pCmd
050F 21B5  2686 	CALL  ledstrip_set_color
           2687 			;				break;
0510 2D37  2688 	GOTO  m077
           2689 			;			}
           2690 			;			case SET_FADE:
           2691 			;			{
           2692 			;				ledstrip_set_fade(&nextCmd.data.set_fade);
0511 3023  2693 m075	MOVLW 35
0512 0020  2694 	MOVLB 0
0513 00AD  2695 	MOVWF pCmd_2
0514 222B  2696 	CALL  ledstrip_set_fade
           2697 			;				break;
0515 2D37  2698 	GOTO  m077
           2699 			;			}
           2700 			;			case WAIT:
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 46

ADDR CODE  LINE SOURCE

           2701 			;			{
           2702 			;				struct cmd_wait *pCmd = &nextCmd.data;
0516 3023  2703 m076	MOVLW 35
0517 0020  2704 	MOVLB 0
0518 00AD  2705 	MOVWF pCmd_3
           2706 			;#ifdef TEST
           2707 			;				USARTsend_num(pCmd->valueH,'H');
0519 0185  2708 	CLRF  FSR0H
051A 082D  2709 	MOVF  pCmd_3,W
051B 0084  2710 	MOVWF FSR0L
051C 0800  2711 	MOVF  INDF0,W
051D 00AE  2712 	MOVWF input
051E 3048  2713 	MOVLW 72
051F 23B2  2714 	CALL  USARTsend_num
           2715 			;				USARTsend_num(pCmd->valueL,'L');
0520 0020  2716 	MOVLB 0
0521 0A2D  2717 	INCF  pCmd_3,W
0522 0084  2718 	MOVWF FSR0L
0523 0185  2719 	CLRF  FSR0H
0524 0800  2720 	MOVF  INDF0,W
0525 00AE  2721 	MOVWF input
0526 304C  2722 	MOVLW 76
0527 23B2  2723 	CALL  USARTsend_num
           2724 			;#endif
           2725 			;				
           2726 			;				gCmdBuf.WaitValue = pCmd->valueH;
0528 0185  2727 	CLRF  FSR0H
0529 0020  2728 	MOVLB 0
052A 082D  2729 	MOVF  pCmd_3,W
052B 0084  2730 	MOVWF FSR0L
052C 0800  2731 	MOVF  INDF0,W
052D 00E3  2732 	MOVWF gCmdBuf+20
052E 01E4  2733 	CLRF  gCmdBuf+21
           2734 			;				gCmdBuf.WaitValue = gCmdBuf.WaitValue << 8;
052F 0863  2735 	MOVF  gCmdBuf+20,W
0530 00E4  2736 	MOVWF gCmdBuf+21
0531 01E3  2737 	CLRF  gCmdBuf+20
           2738 			;				gCmdBuf.WaitValue |= pCmd->valueL;
0532 0A2D  2739 	INCF  pCmd_3,W
0533 0084  2740 	MOVWF FSR0L
0534 0185  2741 	CLRF  FSR0H
0535 0800  2742 	MOVF  INDF0,W
0536 04E3  2743 	IORWF gCmdBuf+20,1
           2744 			;				break;
           2745 			;			}
           2746 			;			case SET_RUN: {break;}
           2747 			;		}
           2748 			;	}
           2749 			;}
0537 0008  2750 m077	RETURN
           2751 			;
           2752 			;void commandstorage_wait_interrupt()
           2753 			;{
           2754 commandstorage_wait_interrupt
           2755 			;	if(gCmdBuf.WaitValue != 0) 
0538 0020  2756 	MOVLB 0
0539 0863  2757 	MOVF  gCmdBuf+20,W
053A 0464  2758 	IORWF gCmdBuf+21,W
053B 1903  2759 	BTFSC 0x03,Zero_
053C 2D41  2760 	GOTO  m078
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 47

ADDR CODE  LINE SOURCE

           2761 			;		gCmdBuf.WaitValue = --gCmdBuf.WaitValue;					
053D 03E3  2762 	DECF  gCmdBuf+20,1
053E 0A63  2763 	INCF  gCmdBuf+20,W
053F 1903  2764 	BTFSC 0x03,Zero_
0540 03E4  2765 	DECF  gCmdBuf+21,1
           2766 			;}	
0541 0008  2767 m078	RETURN
           2768 			;
           2769 			;void commandstorage_init()
           2770 			;{
           2771 commandstorage_init
           2772 			;	/** EEPROM contains FF in every cell after inital start,
           2773 			;	*** so I have to delete the pointer address
           2774 			;	*** otherwise the PIC thinks he has the EEPROM full with commands
           2775 			;	**/
           2776 			;	if (EEPROM_RD(CmdPointerAddr) == 0xff)
0542 30FF  2777 	MOVLW 255
0543 211E  2778 	CALL  EEPROM_RD
0544 3AFF  2779 	XORLW 255
0545 1D03  2780 	BTFSS 0x03,Zero_
0546 2D4C  2781 	GOTO  m079
           2782 			;		EEPROM_WR(CmdPointerAddr, 0);
0547 30FF  2783 	MOVLW 255
0548 0020  2784 	MOVLB 0
0549 00AF  2785 	MOVWF adress
054A 3000  2786 	MOVLW 0
054B 20FC  2787 	CALL  EEPROM_WR
           2788 			;	gCmdBuf.LoopMode = 0;
054C 0020  2789 m079	MOVLB 0
054D 1062  2790 	BCF   gCmdBuf+19,0
           2791 			;	gCmdBuf.WaitValue = 0;
054E 01E3  2792 	CLRF  gCmdBuf+20
054F 01E4  2793 	CLRF  gCmdBuf+21
           2794 			;
           2795 			;	// set loop pointer address to start
           2796 			;	EEPROM_WR(CmdLoopPointerAddr, 0);
0550 30FE  2797 	MOVLW 254
0551 00AF  2798 	MOVWF adress
0552 3000  2799 	MOVLW 0
0553 28FC  2800 	GOTO  EEPROM_WR
           2801 			;}
           2802 
           2803 	END
           2804 
           2805 
           2806 ; *** KEY INFO ***
           2807 
           2808 ; 0x02EF P0    5 word(s)  0 % : RingBufInit
           2809 ; 0x02F4 P0   12 word(s)  0 % : RingBufGet
           2810 ; 0x0300 P0   21 word(s)  1 % : RingBufPut
           2811 ; 0x0370 P0   19 word(s)  0 % : USARTinit
           2812 ; 0x0383 P0   10 word(s)  0 % : USARTsend
           2813 ; 0x038D P0   19 word(s)  0 % : USARTsend_str
           2814 ; 0x03A0 P0   18 word(s)  0 % : USARTsend_arr
           2815 ; 0x03B2 P0   75 word(s)  3 % : USARTsend_num
           2816 ; 0x00FC P0   34 word(s)  1 % : EEPROM_WR
           2817 ; 0x011E P0   13 word(s)  0 % : EEPROM_RD
           2818 ; 0x012B P0   25 word(s)  1 % : EEPROM_WR_BLK
           2819 ; 0x0144 P0   26 word(s)  1 % : EEPROM_RD_BLK
           2820 ; 0x0093 P0   40 word(s)  1 % : addCRC
CC5X Version 3.4E,   File: main.c              10. Jun 2012  23:58   Page 48

ADDR CODE  LINE SOURCE

           2821 ; 0x00BB P0   45 word(s)  2 % : CRC
           2822 ; 0x00E8 P0   20 word(s)  0 % : newCRC
           2823 ; 0x015E P0   28 word(s)  1 % : throw_errors
           2824 ; 0x035D P0   14 word(s)  0 % : timer_init
           2825 ; 0x036B P0    5 word(s)  0 % : timer_set_for_fade
           2826 ; 0x03FD P0   65 word(s)  3 % : commandstorage_read
           2827 ; 0x043E P0   32 word(s)  1 % : commandstorage_write
           2828 ; 0x045E P0  147 word(s)  7 % : commandstorage_get_commands
           2829 ; 0x04F1 P0   71 word(s)  3 % : commandstorage_execute_commands
           2830 ; 0x0542 P0   18 word(s)  0 % : commandstorage_init
           2831 ; 0x0538 P0   10 word(s)  0 % : commandstorage_wait_interrupt
           2832 ; 0x0315 P0   11 word(s)  0 % : spi_init
           2833 ; 0x0320 P0   11 word(s)  0 % : spi_send
           2834 ; 0x032B P0   18 word(s)  0 % : spi_send_arr
           2835 ; 0x033D P0   32 word(s)  1 % : spi_send_ledbuf
           2836 ; 0x01A3 P0   18 word(s)  0 % : ledstrip_init
           2837 ; 0x01B5 P0  118 word(s)  5 % : ledstrip_set_color
           2838 ; 0x022B P0  118 word(s)  5 % : ledstrip_set_fade
           2839 ; 0x02A1 P0   78 word(s)  3 % : ledstrip_do_fade
           2840 ; 0x0004 P0   24 word(s)  1 % : InterruptRoutine
           2841 ; 0x0078 P0   27 word(s)  1 % : init_all
           2842 ; 0x006B P0   13 word(s)  0 % : main
           2843 ; 0x017A P0   17 word(s)  0 % : _mult8x8
           2844 ; 0x018B P0   24 word(s)  1 % : _divU16_8
           2845 ; 0x001C P0   79 word(s)  3 % : _const1
           2846 
           2847 ; RAM usage: 262 bytes (26 local), 250 bytes free
           2848 ; Maximum call level: 4 (+2 for interrupt)
           2849 ;  Codepage 0 has 1361 word(s) :  66 %
           2850 ;  Codepage 1 has    0 word(s) :   0 %
           2851 ;  Codepage 2 has    0 word(s) :   0 %
           2852 ;  Codepage 3 has    0 word(s) :   0 %
           2853 ; Total of 1361 code words (16 %)
