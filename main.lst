CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 1

ADDR CODE  LINE SOURCE

           0001 
           0002 ; CC5X Version 3.4E, Copyright (c) B Knudsen Data
           0003 ; C compiler for the PICmicro family
           0004 ; ************   9. May 2012  21:39  *************
           0005 
           0006 	processor  16F1936
           0007 	radix  DEC
           0008 
     0000  0009 INDF0       EQU   0x00
     0004  0010 FSR0        EQU   0x04
     0004  0011 FSR0L       EQU   0x04
     0005  0012 FSR0H       EQU   0x05
     0000  0013 Carry       EQU   0
     0002  0014 Zero_       EQU   2
     000E  0015 PORTC       EQU   0x0E
     008E  0016 TRISC       EQU   0x8E
     0099  0017 OSCCON      EQU   0x99
     0191  0018 EEADRL      EQU   0x191
     0192  0019 EEADRH      EQU   0x192
     0193  0020 EEDATL      EQU   0x193
     0194  0021 EEDATH      EQU   0x194
     0196  0022 EECON2      EQU   0x196
     0199  0023 RCREG       EQU   0x199
     019A  0024 TXREG       EQU   0x19A
     019B  0025 SPBRGL      EQU   0x19B
     019C  0026 SPBRGH      EQU   0x19C
     0211  0027 SSPBUF      EQU   0x211
     0006  0028 PEIE        EQU   6
     0007  0029 GIE         EQU   7
     0003  0030 SSPIF       EQU   3
     0004  0031 TXIF        EQU   4
     0005  0032 RCIF        EQU   5
     0005  0033 RCIE        EQU   5
     0000  0034 RD          EQU   0
     0001  0035 WR          EQU   1
     0002  0036 WREN        EQU   2
     0006  0037 CFGS        EQU   6
     0007  0038 EEPGD       EQU   7
     0003  0039 ADDEN       EQU   3
     0004  0040 CREN        EQU   4
     0006  0041 RX9         EQU   6
     0007  0042 SPEN        EQU   7
     0002  0043 BRGH        EQU   2
     0004  0044 SYNC        EQU   4
     0005  0045 TXEN        EQU   5
     0006  0046 TX9         EQU   6
     0003  0047 BRG16       EQU   3
     0006  0048 CKE         EQU   6
     0007  0049 SMP         EQU   7
     0001  0050 SSPM1       EQU   1
     0004  0051 CKP         EQU   4
     0005  0052 SSPEN       EQU   5
     0039  0053 gRingBuf    EQU   0x39
     0025  0054 result      EQU   0x25
     0020  0055 value       EQU   0x20
     0021  0056 writeNext   EQU   0x21
     0026  0057 ch          EQU   0x26
     0022  0058 string      EQU   0x22
     0023  0059 ps          EQU   0x23
     007F  0060 array       EQU   0x7F
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 2

ADDR CODE  LINE SOURCE

     007F  0061 length      EQU   0x7F
     007F  0062 i           EQU   0x7F
     002A  0063 adress      EQU   0x2A
     002B  0064 data        EQU   0x2B
     0000  0065 GIE_status  EQU   0
     002E  0066 adress_2    EQU   0x2E
     002F  0067 data_2      EQU   0x2F
     0026  0068 array_2     EQU   0x26
     0027  0069 adress_3    EQU   0x27
     0028  0070 length_2    EQU   0x28
     0029  0071 i_2         EQU   0x29
     007F  0072 array_3     EQU   0x7F
     007F  0073 adress_4    EQU   0x7F
     007F  0074 length_3    EQU   0x7F
     007F  0075 i_3         EQU   0x7F
     007F  0076 temp        EQU   0x7F
     0025  0077 byte        EQU   0x25
     0026  0078 p_crcH      EQU   0x26
     0027  0079 p_crcL      EQU   0x27
     0028  0080 index       EQU   0x28
     0029  0081 crcH        EQU   0x29
     002A  0082 crcL        EQU   0x2A
     007F  0083 data_3      EQU   0x7F
     007F  0084 length_4    EQU   0x7F
     007F  0085 crcH_out    EQU   0x7F
     007F  0086 crcL_out    EQU   0x7F
     007F  0087 crcH_2      EQU   0x7F
     007F  0088 crcL_2      EQU   0x7F
     007F  0089 i_4         EQU   0x7F
     007F  0090 byte_2      EQU   0x7F
     0025  0091 p_crcH_2    EQU   0x25
     0026  0092 p_crcL_2    EQU   0x26
     0038  0093 data_4      EQU   0x38
     007F  0094 array_4     EQU   0x7F
     007F  0095 length_5    EQU   0x7F
     007F  0096 i_5         EQU   0x7F
     0034  0097 array_5     EQU   0x34
     0036  0098 end         EQU   0x36
     0023  0099 k           EQU   0x23
     002E  0100 address     EQU   0x2E
     002F  0101 r           EQU   0x2F
     0030  0102 g           EQU   0x30
     0031  0103 b           EQU   0x31
     0032  0104 k_2         EQU   0x32
     0033  0105 mask        EQU   0x33
     0023  0106 cmdPointer  EQU   0x23
     0024  0107 r_2         EQU   0x24
     0025  0108 g_2         EQU   0x25
     0026  0109 b_2         EQU   0x26
     0027  0110 i_6         EQU   0x27
     0028  0111 temp_2      EQU   0x28
     0029  0112 temp1       EQU   0x29
     004C  0113 gCmdBuf     EQU   0x4C
     0060  0114 gERROR      EQU   0x60
     0020  0115 temp_3      EQU   0x20
     0022  0116 i_7         EQU   0x22
     0022  0117 new_byte    EQU   0x22
     0023  0118 temp_4      EQU   0x23
     0024  0119 j           EQU   0x24
     0025  0120 CmdPointer  EQU   0x25
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 3

ADDR CODE  LINE SOURCE

     0022  0121 pointer     EQU   0x22
     0024  0122 ci          EQU   0x24
           0123 
0000 2814  0124 	GOTO main
           0125 
           0126   ; FILE main.c
           0127 			;//Nils Weiß 
           0128 			;//05.09.2011
           0129 			;//Compiler CC5x/
           0130 			;//#define TEST
           0131 			;
           0132 			;#define NO_CRC
           0133 			;
           0134 			;#pragma sharedAllocation
           0135 			;
           0136 			;//*********************** ENUMERATIONS *********************************************
           0137 			;#define TRUE  1
           0138 			;#define FALSE 0
           0139 			;
           0140 			;#define STX 0xFF
           0141 			;#define SET_COLOR 0xFD
           0142 			;#define SET_FADE 0xFC
           0143 			;#define SET_RUN 0xFB
           0144 			;#define WAIT 0xFE
           0145 			;#define SET_ON 0xFA
           0146 			;#define SET_OFF 0xF9
           0147 			;#define DELETE 0xF8
           0148 			;
           0149 			;// *** ERRORBITS
           0150 			;#define crc_failure 0
           0151 			;#define eeprom_failure 1
           0152 			;
           0153 			;#define CmdPointerAddr 0xff		// *** Address at EERPOM. Commandpointer indicates the nummer of commands
           0154 			;#define CmdLoopPointerAddr 0xfd // *** Address at EEPROM. CommandLoopPointer indicates the next command. Used in Loop-Mode
           0155 			;#define CmdWidth 10				// *** Number of Bytes for one command
           0156 			;
           0157 			;//*********************** INCLUDEDATEIEN *********************************************
           0158 			;#pragma codepage 1
     0000  0159 	ORG 0x0800
           0160 
           0161   ; FILE include_files\RingBuf.c
           0162 			;#message Global variables are defined in RingBuf.c
           0163 			;
           0164 			;struct RingBuffer gRingBuf;
           0165 			;
           0166 			;void RingBufInit(void)
           0167 			;{
           0168 _const1
0800 0020  0169 	MOVLB 0
0801 00A4  0170 	MOVWF ci
0802 3008  0171 	MOVLW 8
0803 0023  0172 	MOVLB 3
0804 0092  0173 	MOVWF EEADRH
0805 0020  0174 	MOVLB 0
0806 0C24  0175 	RRF   ci,W
0807 397F  0176 	ANDLW 127
0808 3E1D  0177 	ADDLW 29
0809 0023  0178 	MOVLB 3
080A 0091  0179 	MOVWF EEADRL
080B 1803  0180 	BTFSC 0x03,Carry
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 4

ADDR CODE  LINE SOURCE

080C 0A92  0181 	INCF  EEADRH,1
080D 0023  0182 	MOVLB 3
080E 1795  0183 	BSF   0x195,EEPGD
080F 1415  0184 	BSF   0x195,RD
0810 0000  0185 	NOP  
0811 0000  0186 	NOP  
0812 0020  0187 	MOVLB 0
0813 1824  0188 	BTFSC ci,0
0814 2819  0189 	GOTO  m001
0815 0023  0190 	MOVLB 3
0816 0813  0191 	MOVF  EEDATL,W
0817 397F  0192 	ANDLW 127
0818 0008  0193 	RETURN
0819 0023  0194 m001	MOVLB 3
081A 0D13  0195 	RLF   EEDATL,W
081B 0D14  0196 	RLF   EEDATH,W
081C 0008  0197 	RETURN
081D 22A0  0198 	DW    0x22A0
081E 2952  0199 	DW    0x2952
081F 294F  0200 	DW    0x294F
0820 103A  0201 	DW    0x103A
0821 32D2  0202 	DW    0x32D2
0822 32E3  0203 	DW    0x32E3
0823 3B69  0204 	DW    0x3B69
0824 3165  0205 	DW    0x3165
0825 3375  0206 	DW    0x3375
0826 32E6  0207 	DW    0x32E6
0827 1072  0208 	DW    0x1072
0828 3AE6  0209 	DW    0x3AE6
0829 366C  0210 	DW    0x366C
082A 1000  0211 	DW    0x1000
082B 2945  0212 	DW    0x2945
082C 27D2  0213 	DW    0x27D2
082D 1D52  0214 	DW    0x1D52
082E 21A0  0215 	DW    0x21A0
082F 21D2  0216 	DW    0x21D2
0830 21AD  0217 	DW    0x21AD
0831 32E8  0218 	DW    0x32E8
0832 35E3  0219 	DW    0x35E3
0833 3320  0220 	DW    0x3320
0834 34E1  0221 	DW    0x34E1
0835 32EC  0222 	DW    0x32EC
0836 0064  0223 	DW    0x64
0837 22A0  0224 	DW    0x22A0
0838 2952  0225 	DW    0x2952
0839 294F  0226 	DW    0x294F
083A 103A  0227 	DW    0x103A
083B 22C5  0228 	DW    0x22C5
083C 2950  0229 	DW    0x2950
083D 26CF  0230 	DW    0x26CF
083E 34A0  0231 	DW    0x34A0
083F 1073  0232 	DW    0x1073
0840 3AE6  0233 	DW    0x3AE6
0841 366C  0234 	DW    0x366C
0842 0000  0235 	DW    0x0
           0236 RingBufInit
           0237 			;	gRingBuf.read = 0;
0843 0020  0238 	MOVLB 0
0844 01C9  0239 	CLRF  gRingBuf+16
           0240 			;	gRingBuf.write = 0;
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 5

ADDR CODE  LINE SOURCE

0845 01CA  0241 	CLRF  gRingBuf+17
           0242 			;	gRingBuf.error_full = 0;
0846 104B  0243 	BCF   gRingBuf+18,0
           0244 			;}
0847 0008  0245 	RETURN
           0246 			;
           0247 			;char RingBufGet(void)
           0248 			;{
           0249 RingBufGet
           0250 			;	char result = gRingBuf.data[gRingBuf.read];
0848 3039  0251 	MOVLW 57
0849 0020  0252 	MOVLB 0
084A 0749  0253 	ADDWF gRingBuf+16,W
084B 0084  0254 	MOVWF FSR0L
084C 0185  0255 	CLRF  FSR0H
084D 0800  0256 	MOVF  INDF0,W
084E 00A5  0257 	MOVWF result
           0258 			;	gRingBuf.read = RingBufInc(gRingBuf.read);
084F 0A49  0259 	INCF  gRingBuf+16,W
0850 390F  0260 	ANDLW 15
0851 00C9  0261 	MOVWF gRingBuf+16
           0262 			;	return result;
0852 0825  0263 	MOVF  result,W
0853 0008  0264 	RETURN
           0265 			;}
           0266 			;
           0267 			;void RingBufPut(char value)
           0268 			;{
           0269 RingBufPut
0854 0020  0270 	MOVLB 0
0855 00A0  0271 	MOVWF value
           0272 			;	char writeNext = RingBufInc(gRingBuf.write);
0856 0A4A  0273 	INCF  gRingBuf+17,W
0857 390F  0274 	ANDLW 15
0858 00A1  0275 	MOVWF writeNext
           0276 			;	if(writeNext != gRingBuf.read)
0859 0821  0277 	MOVF  writeNext,W
085A 0649  0278 	XORWF gRingBuf+16,W
085B 1903  0279 	BTFSC 0x03,Zero_
085C 2866  0280 	GOTO  m002
           0281 			;	{
           0282 			;		gRingBuf.data[gRingBuf.write] = value;
085D 3039  0283 	MOVLW 57
085E 074A  0284 	ADDWF gRingBuf+17,W
085F 0084  0285 	MOVWF FSR0L
0860 0185  0286 	CLRF  FSR0H
0861 0820  0287 	MOVF  value,W
0862 0080  0288 	MOVWF INDF0
           0289 			;		gRingBuf.write = writeNext;
0863 0821  0290 	MOVF  writeNext,W
0864 00CA  0291 	MOVWF gRingBuf+17
           0292 			;	}
           0293 			;	else gRingBuf.error_full = 1;
0865 2868  0294 	GOTO  m003
0866 0020  0295 m002	MOVLB 0
0867 144B  0296 	BSF   gRingBuf+18,0
           0297 			;}
0868 0008  0298 m003	RETURN
           0299 
           0300   ; FILE include_files\usart.c
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 6

ADDR CODE  LINE SOURCE

           0301 			;// Include-Datei für Serielle Kommunikation über Hardwaremodul des Pic
           0302 			; //
           0303 			; //
           0304 			; // Nils Weiß
           0305 			; // 29.11.2010
           0306 			; // Compiler CC5x
           0307 			;
           0308 			;//*******  Initialisierungs-Funktion  *************************************************
           0309 			;void USARTinit()
           0310 			;{
           0311 USARTinit
           0312 			;	//USART TX Pin als Ausgang
           0313 			;	TRISC.6 = 0;
0869 0021  0314 	MOVLB 1
086A 130E  0315 	BCF   TRISC,6
           0316 			;
           0317 			;    BRGH=1;					// High Baudrate activated
086B 0023  0318 	MOVLB 3
086C 151E  0319 	BSF   0x19E,BRGH
           0320 			;	BRG16=0;
086D 119F  0321 	BCF   0x19F,BRG16
           0322 			;	SPBRGL=25;				// 19200 Bps @ 8 MHz Clock
086E 3019  0323 	MOVLW 25
086F 009B  0324 	MOVWF SPBRGL
           0325 			;	SPBRGH=0;
0870 019C  0326 	CLRF  SPBRGH
           0327 			;    SPEN = 1;               // Set_Serial_Pins;
0871 179D  0328 	BSF   0x19D,SPEN
           0329 			;    SYNC = 0;               // Set_Async_Mode;
0872 121E  0330 	BCF   0x19E,SYNC
           0331 			;    TX9 = 0;                // Set_8bit_Tx;
0873 131E  0332 	BCF   0x19E,TX9
           0333 			;    RX9 = 0;                // Set_8bit_Rx;
0874 131D  0334 	BCF   0x19D,RX9
           0335 			;    CREN = 1;               // Enable_Rx;
0875 161D  0336 	BSF   0x19D,CREN
           0337 			;    TXEN = 1;               // Enable_Tx;
0876 169E  0338 	BSF   0x19E,TXEN
           0339 			;    RCIE=1;                 // Rx Interrupt aus
0877 0021  0340 	MOVLB 1
0878 1691  0341 	BSF   0x91,RCIE
           0342 			;	ADDEN=0;				// Disable Adressdetection
0879 0023  0343 	MOVLB 3
087A 119D  0344 	BCF   0x19D,ADDEN
           0345 			;}
087B 0008  0346 	RETURN
           0347 			;
           0348 			;//*******  Sende-char-Funktion  *************************************************
           0349 			;void USARTsend(unsigned char ch)
           0350 			;{
           0351 USARTsend
087C 0020  0352 	MOVLB 0
087D 00A6  0353 	MOVWF ch
           0354 			;	while(!TXIF);
087E 0020  0355 m004	MOVLB 0
087F 1E11  0356 	BTFSS 0x11,TXIF
0880 287E  0357 	GOTO  m004
           0358 			;	TXREG=ch;
0881 0020  0359 	MOVLB 0
0882 0826  0360 	MOVF  ch,W
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 7

ADDR CODE  LINE SOURCE

0883 0023  0361 	MOVLB 3
0884 009A  0362 	MOVWF TXREG
           0363 			;}
0885 0008  0364 	RETURN
           0365 			;
           0366 			;//*******  Sende-String-Funktion  *************************************************
           0367 			;void USARTsend_str(const char *string)
           0368 			;{
           0369 USARTsend_str
           0370 			; char ps;
           0371 			; ps = *string;
0886 0020  0372 	MOVLB 0
0887 0822  0373 	MOVF  string,W
0888 2000  0374 	CALL  _const1
0889 0020  0375 	MOVLB 0
088A 00A3  0376 	MOVWF ps
           0377 			; while(ps > 0)
088B 0020  0378 m005	MOVLB 0
088C 08A3  0379 	MOVF  ps,1
088D 1903  0380 	BTFSC 0x03,Zero_
088E 2898  0381 	GOTO  m006
           0382 			;   {
           0383 			;    string++;
088F 0AA2  0384 	INCF  string,1
           0385 			;   	USARTsend(ps);
0890 0823  0386 	MOVF  ps,W
0891 207C  0387 	CALL  USARTsend
           0388 			;    ps = *string;
0892 0020  0389 	MOVLB 0
0893 0822  0390 	MOVF  string,W
0894 2000  0391 	CALL  _const1
0895 0020  0392 	MOVLB 0
0896 00A3  0393 	MOVWF ps
           0394 			;   }
0897 288B  0395 	GOTO  m005
           0396 			;}
0898 0008  0397 m006	RETURN
           0398 			;
           0399 			;//*******  Sende-Array-Funktion  *************************************************
           0400 			;void USARTsend_arr(char *array, char length)
           0401 			;{
           0402 USARTsend_arr
0899 00FF  0403 	MOVWF length
           0404 			;	if(array == 0) return;
089A 08FF  0405 	MOVF  array,1
089B 1903  0406 	BTFSC 0x03,Zero_
089C 0008  0407 	RETURN
           0408 			;	char i;
           0409 			;	for(i=0;i<length;i++)
089D 01FF  0410 	CLRF  i
089E 087F  0411 m007	MOVF  length,W
089F 027F  0412 	SUBWF i,W
08A0 1803  0413 	BTFSC 0x03,Carry
08A1 28AA  0414 	GOTO  m008
           0415 			;	{
           0416 			;		USARTsend(*array);
08A2 0185  0417 	CLRF  FSR0H
08A3 087F  0418 	MOVF  array,W
08A4 0084  0419 	MOVWF FSR0L
08A5 0800  0420 	MOVF  INDF0,W
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 8

ADDR CODE  LINE SOURCE

08A6 207C  0421 	CALL  USARTsend
           0422 			;		array++;
08A7 0AFF  0423 	INCF  array,1
           0424 			;	}
08A8 0AFF  0425 	INCF  i,1
08A9 289E  0426 	GOTO  m007
           0427 			;}
08AA 0008  0428 m008	RETURN
           0429 
           0430   ; FILE include_files\eeprom.c
           0431 			;//Funktionen für EEPROM-Zugriffe
           0432 			;
           0433 			;//Nils Weiß 
           0434 			;//05.09.2011
           0435 			;//Compiler CC5x
           0436 			;
           0437 			;//*********************** EEPROM BYTE SCHREIBEN  **********************************************
           0438 			;
           0439 			;void EEPROM_WR(char adress, char data)
           0440 			;{
           0441 EEPROM_WR
08AB 0020  0442 	MOVLB 0
08AC 00AB  0443 	MOVWF data
           0444 			;	bit GIE_status; 
           0445 			;	//EEADRH = (char)(adress<<8);
           0446 			;    EEADRL = (char)adress;        // Adresse in Adressregister übertragen
08AD 082A  0447 	MOVF  adress,W
08AE 0023  0448 	MOVLB 3
08AF 0091  0449 	MOVWF EEADRL
           0450 			;	EEDATL = data;          // Daten in Datenregister übertragen
08B0 0020  0451 	MOVLB 0
08B1 082B  0452 	MOVF  data,W
08B2 0023  0453 	MOVLB 3
08B3 0093  0454 	MOVWF EEDATL
           0455 			;    CFGS = 0;
08B4 1315  0456 	BCF   0x195,CFGS
           0457 			;	EEPGD = 0;                // Auswahl: Programmspeicher lesen oder EEPROM
08B5 1395  0458 	BCF   0x195,EEPGD
           0459 			;    WREN = 1;                 // Schreiben ins EEPROM erlauben
08B6 1515  0460 	BSF   0x195,WREN
           0461 			;	GIE_status=GIE;			
08B7 0020  0462 	MOVLB 0
08B8 102C  0463 	BCF   0x2C,GIE_status
08B9 1B8B  0464 	BTFSC 0x0B,GIE
08BA 142C  0465 	BSF   0x2C,GIE_status
           0466 			;    GIE=0;                  // Interrups verbieten
08BB 138B  0467 	BCF   0x0B,GIE
           0468 			;    EECON2 = 0x55;
08BC 3055  0469 	MOVLW 85
08BD 0023  0470 	MOVLB 3
08BE 0096  0471 	MOVWF EECON2
           0472 			;    EECON2 = 0xAA;
08BF 30AA  0473 	MOVLW 170
08C0 0096  0474 	MOVWF EECON2
           0475 			;	WR=1; 					// Starten des Schreibens
08C1 1495  0476 	BSF   0x195,WR
           0477 			;    GIE=GIE_status;                  // Interrups erlauben
08C2 0020  0478 	MOVLB 0
08C3 1C2C  0479 	BTFSS 0x2C,GIE_status
08C4 138B  0480 	BCF   0x0B,GIE
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 9

ADDR CODE  LINE SOURCE

08C5 182C  0481 	BTFSC 0x2C,GIE_status
08C6 178B  0482 	BSF   0x0B,GIE
           0483 			;	WREN=0;
08C7 0023  0484 	MOVLB 3
08C8 1115  0485 	BCF   0x195,WREN
           0486 			;	while(WR);
08C9 0023  0487 m009	MOVLB 3
08CA 1895  0488 	BTFSC 0x195,WR
08CB 28C9  0489 	GOTO  m009
           0490 			;}
08CC 0008  0491 	RETURN
           0492 			;
           0493 			;//*********************** EEPROM BYTE LESEN  **********************************************
           0494 			;
           0495 			;char EEPROM_RD(char adress)
           0496 			;{
           0497 EEPROM_RD
08CD 0020  0498 	MOVLB 0
08CE 00AE  0499 	MOVWF adress_2
           0500 			;    char data;
           0501 			;    //EEADRH = (char)(adress<<8);        // Adresse in Adressregister übertragen
           0502 			;    EEADRL = (char)(adress);
08CF 082E  0503 	MOVF  adress_2,W
08D0 0023  0504 	MOVLB 3
08D1 0091  0505 	MOVWF EEADRL
           0506 			;	CFGS=0;
08D2 1315  0507 	BCF   0x195,CFGS
           0508 			;	EEPGD=0;                // Auswahl: Programmspeicher lesen oder EEPROM
08D3 1395  0509 	BCF   0x195,EEPGD
           0510 			;    RD=1;                   // Starten des Lesesn
08D4 1415  0511 	BSF   0x195,RD
           0512 			;    data = EEDATL;       // Daten aus Datenregister auslesen
08D5 0813  0513 	MOVF  EEDATL,W
08D6 0020  0514 	MOVLB 0
08D7 00AF  0515 	MOVWF data_2
           0516 			;    return data;
08D8 082F  0517 	MOVF  data_2,W
08D9 0008  0518 	RETURN
           0519 			;}
           0520 			;
           0521 			;//*********************** EEPROM BYTEARRAY SCHREIBEN  **************************************
           0522 			;
           0523 			;void EEPROM_WR_BLK(char *array, char adress, char length)			//Zum Ausführen eines beliebigen Befehls durch den Programmcode
           0524 			;{
           0525 EEPROM_WR_BLK
08DA 0020  0526 	MOVLB 0
08DB 00A8  0527 	MOVWF length_2
           0528 			;	if(!array) return;
08DC 08A6  0529 	MOVF  array_2,1
08DD 1903  0530 	BTFSC 0x03,Zero_
08DE 0008  0531 	RETURN
           0532 			;	char i;
           0533 			;	for(i=0;i<length;i++)
08DF 0020  0534 	MOVLB 0
08E0 01A9  0535 	CLRF  i_2
08E1 0020  0536 m010	MOVLB 0
08E2 0828  0537 	MOVF  length_2,W
08E3 0229  0538 	SUBWF i_2,W
08E4 1803  0539 	BTFSC 0x03,Carry
08E5 28F2  0540 	GOTO  m011
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 10

ADDR CODE  LINE SOURCE

           0541 			;	{
           0542 			;		EEPROM_WR(adress,*array);
08E6 0827  0543 	MOVF  adress_3,W
08E7 00AA  0544 	MOVWF adress
08E8 0185  0545 	CLRF  FSR0H
08E9 0826  0546 	MOVF  array_2,W
08EA 0084  0547 	MOVWF FSR0L
08EB 0800  0548 	MOVF  INDF0,W
08EC 20AB  0549 	CALL  EEPROM_WR
           0550 			;		adress++;
08ED 0020  0551 	MOVLB 0
08EE 0AA7  0552 	INCF  adress_3,1
           0553 			;		array++;
08EF 0AA6  0554 	INCF  array_2,1
           0555 			;	}
08F0 0AA9  0556 	INCF  i_2,1
08F1 28E1  0557 	GOTO  m010
           0558 			;}
08F2 0008  0559 m011	RETURN
           0560 			;
           0561 			;//*********************** EEPROM BYTEARRAY LESEN  **************************************
           0562 			;
           0563 			;void EEPROM_RD_BLK(char *array, char adress, char length)			//Zum Ausführen eines beliebigen Befehls durch den Programmcode
           0564 			;{
           0565 EEPROM_RD_BLK
08F3 00FF  0566 	MOVWF length_3
           0567 			;	if(!array) return;
08F4 08FF  0568 	MOVF  array_3,1
08F5 1903  0569 	BTFSC 0x03,Zero_
08F6 0008  0570 	RETURN
           0571 			;	char i, temp;
           0572 			;	for(i=0;i<length;i++)
08F7 01FF  0573 	CLRF  i_3
08F8 087F  0574 m012	MOVF  length_3,W
08F9 027F  0575 	SUBWF i_3,W
08FA 1803  0576 	BTFSC 0x03,Carry
08FB 2908  0577 	GOTO  m013
           0578 			;	{
           0579 			;		temp = EEPROM_RD(adress);
08FC 087F  0580 	MOVF  adress_4,W
08FD 20CD  0581 	CALL  EEPROM_RD
08FE 00FF  0582 	MOVWF temp
           0583 			;		array[i] = temp;
08FF 087F  0584 	MOVF  i_3,W
0900 077F  0585 	ADDWF array_3,W
0901 0084  0586 	MOVWF FSR0L
0902 0185  0587 	CLRF  FSR0H
0903 087F  0588 	MOVF  temp,W
0904 0080  0589 	MOVWF INDF0
           0590 			;		adress++;
0905 0AFF  0591 	INCF  adress_4,1
           0592 			;	}
0906 0AFF  0593 	INCF  i_3,1
0907 28F8  0594 	GOTO  m012
           0595 
           0596   ; FILE include_files\eeprom.h
           0597 			;#ifndef _EEPROM_H_
           0598 			;#define _EEPROM_H_
           0599 			;
           0600 			;//Funktionen fÂ¸r EEPROM-Zugriffe
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 11

ADDR CODE  LINE SOURCE

           0601 			;
           0602 			;//Nils Weiï¬‚ 
           0603 			;//05.09.2011
           0604 			;//Compiler CC5x
           0605 			;
           0606 			;void EEPROM_WR(char adress, char data);
           0607 			;char EEPROM_RD(char adress);
           0608 			;void EEPROM_WR_BLK(char *array, char adress, char length);
           0609 			;void EEPROM_RD_BLK(char *array, char adress, char length);
           0610 			;
           0611 			;#include "include_files\eeprom.c"
0908 0008  0612 m013	RETURN
           0613 
           0614   ; FILE include_files\crc.c
           0615 			; // Include-Datei zum Erstellen von CRC Prüfsummen
           0616 			; //
           0617 			; //
           0618 			; // Nils Weiß
           0619 			; // 14.04.2012
           0620 			; // Compiler CC5x
           0621 			;
           0622 			;// 16-bit CCIT CRC
           0623 			;
           0624 			;void addCRC(char byte, char* p_crcH, char* p_crcL)
           0625 			;{
           0626 addCRC
           0627 			;	char index;
           0628 			;	char crcH,crcL;
           0629 			;	crcH = *p_crcH;
0909 0185  0630 	CLRF  FSR0H
090A 0020  0631 	MOVLB 0
090B 0826  0632 	MOVF  p_crcH,W
090C 0084  0633 	MOVWF FSR0L
090D 0800  0634 	MOVF  INDF0,W
090E 00A9  0635 	MOVWF crcH
           0636 			;	crcL = *p_crcL;
090F 0185  0637 	CLRF  FSR0H
0910 0827  0638 	MOVF  p_crcL,W
0911 0084  0639 	MOVWF FSR0L
0912 0800  0640 	MOVF  INDF0,W
0913 00AA  0641 	MOVWF crcL
           0642 			;
           0643 			;	MOVF(byte,0);
0914 0825  0644 	MOVF  byte,W
           0645 			;	
           0646 			;	XORWF(crcH,0);
0915 0629  0647 	XORWF crcH,W
           0648 			;	MOVWF(index);
0916 00A8  0649 	MOVWF index
           0650 			;	ANDLW(0xf0);
0917 39F0  0651 	ANDLW 240
           0652 			;	SWAPF(index,1);
0918 0EA8  0653 	SWAPF index,1
           0654 			;	XORWF(index,1);
0919 06A8  0655 	XORWF index,1
           0656 			;	
           0657 			;	MOVF(index,0);
091A 0828  0658 	MOVF  index,W
           0659 			;	ANDLW(0xf0);
091B 39F0  0660 	ANDLW 240
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 12

ADDR CODE  LINE SOURCE

           0661 			;	XORWF(crcL,0);
091C 062A  0662 	XORWF crcL,W
           0663 			;	MOVWF(crcH);
091D 00A9  0664 	MOVWF crcH
           0665 			;	
           0666 			;	RLF(index,0);
091E 0D28  0667 	RLF   index,W
           0668 			;	RLF(index,0);
091F 0D28  0669 	RLF   index,W
           0670 			;	XORWF(crcH,1);
0920 06A9  0671 	XORWF crcH,1
           0672 			;	ANDLW(0xe0);
0921 39E0  0673 	ANDLW 224
           0674 			;	XORWF(crcH,1);
0922 06A9  0675 	XORWF crcH,1
           0676 			;		
           0677 			;	SWAPF(index,1);
0923 0EA8  0678 	SWAPF index,1
           0679 			;	XORWF(index,0);
0924 0628  0680 	XORWF index,W
           0681 			;	MOVWF(crcL);
0925 00AA  0682 	MOVWF crcL
           0683 			;
           0684 			;	*p_crcH = crcH;
0926 0185  0685 	CLRF  FSR0H
0927 0826  0686 	MOVF  p_crcH,W
0928 0084  0687 	MOVWF FSR0L
0929 0829  0688 	MOVF  crcH,W
092A 0080  0689 	MOVWF INDF0
           0690 			;	*p_crcL = crcL;
092B 0185  0691 	CLRF  FSR0H
092C 0827  0692 	MOVF  p_crcL,W
092D 0084  0693 	MOVWF FSR0L
092E 082A  0694 	MOVF  crcL,W
092F 0080  0695 	MOVWF INDF0
           0696 			;
           0697 			;}
0930 0008  0698 	RETURN
           0699 			;
           0700 			;void CRC(char *data, char length, char* crcH_out, char* crcL_out)
           0701 			;{
           0702 CRC
           0703 			;	if(!crcH_out)return;
0931 08FF  0704 	MOVF  crcH_out,1
0932 1903  0705 	BTFSC 0x03,Zero_
0933 0008  0706 	RETURN
           0707 			;	if(!crcL_out)return;
0934 08FF  0708 	MOVF  crcL_out,1
0935 1903  0709 	BTFSC 0x03,Zero_
0936 0008  0710 	RETURN
           0711 			;	if(!data)return;
0937 08FF  0712 	MOVF  data_3,1
0938 1903  0713 	BTFSC 0x03,Zero_
0939 0008  0714 	RETURN
           0715 			;	char crcH,crcL,i,byte;
           0716 			;	crcH=0xff;
093A 30FF  0717 	MOVLW 255
093B 00FF  0718 	MOVWF crcH_2
           0719 			;	crcL=0xff;
093C 30FF  0720 	MOVLW 255
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 13

ADDR CODE  LINE SOURCE

093D 00FF  0721 	MOVWF crcL_2
           0722 			;
           0723 			;	for(i=0;i<length;i++)
093E 01FF  0724 	CLRF  i_4
093F 087F  0725 m014	MOVF  length_4,W
0940 027F  0726 	SUBWF i_4,W
0941 1803  0727 	BTFSC 0x03,Carry
0942 2953  0728 	GOTO  m015
           0729 			;	{
           0730 			;		byte = data[i];
0943 087F  0731 	MOVF  i_4,W
0944 077F  0732 	ADDWF data_3,W
0945 0084  0733 	MOVWF FSR0L
0946 0185  0734 	CLRF  FSR0H
0947 0800  0735 	MOVF  INDF0,W
0948 00FF  0736 	MOVWF byte_2
           0737 			;		addCRC(byte,&crcH,&crcL);
0949 087F  0738 	MOVF  byte_2,W
094A 0020  0739 	MOVLB 0
094B 00A5  0740 	MOVWF byte
094C 307F  0741 	MOVLW 127
094D 00A6  0742 	MOVWF p_crcH
094E 307F  0743 	MOVLW 127
094F 00A7  0744 	MOVWF p_crcL
0950 2109  0745 	CALL  addCRC
           0746 			;	}
0951 0AFF  0747 	INCF  i_4,1
0952 293F  0748 	GOTO  m014
           0749 			;	
           0750 			;	*crcH_out = crcH;
0953 0185  0751 m015	CLRF  FSR0H
0954 087F  0752 	MOVF  crcH_out,W
0955 0084  0753 	MOVWF FSR0L
0956 087F  0754 	MOVF  crcH_2,W
0957 0080  0755 	MOVWF INDF0
           0756 			;	*crcL_out = crcL;
0958 0185  0757 	CLRF  FSR0H
0959 087F  0758 	MOVF  crcL_out,W
095A 0084  0759 	MOVWF FSR0L
095B 087F  0760 	MOVF  crcL_2,W
095C 0080  0761 	MOVWF INDF0
           0762 			;}
095D 0008  0763 	RETURN
           0764 			;
           0765 			;void newCRC(char* p_crcH, char* p_crcL)
           0766 			;{
           0767 newCRC
           0768 			;    if(!p_crcH) return;
095E 0020  0769 	MOVLB 0
095F 08A5  0770 	MOVF  p_crcH_2,1
0960 1903  0771 	BTFSC 0x03,Zero_
0961 0008  0772 	RETURN
           0773 			;    if(!p_crcL) return;
0962 0020  0774 	MOVLB 0
0963 08A6  0775 	MOVF  p_crcL_2,1
0964 1903  0776 	BTFSC 0x03,Zero_
0965 0008  0777 	RETURN
           0778 			;    *p_crcH = 0xff;
0966 0185  0779 	CLRF  FSR0H
0967 0020  0780 	MOVLB 0
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 14

ADDR CODE  LINE SOURCE

0968 0825  0781 	MOVF  p_crcH_2,W
0969 0084  0782 	MOVWF FSR0L
096A 30FF  0783 	MOVLW 255
096B 0080  0784 	MOVWF INDF0
           0785 			;    *p_crcL = 0xff;
096C 0185  0786 	CLRF  FSR0H
096D 0826  0787 	MOVF  p_crcL_2,W
096E 0084  0788 	MOVWF FSR0L
096F 30FF  0789 	MOVLW 255
0970 0080  0790 	MOVWF INDF0
           0791 			;}
0971 0008  0792 	RETURN
           0793 
           0794   ; FILE include_files\spi.c
           0795 			;//Nils Weiß 
           0796 			;//20.04.2012
           0797 			;//Compiler CC5x
           0798 			;void spi_init()
           0799 			;{
           0800 spi_init
           0801 			;	TRISC.3 = 0;        // Make port RC3 an output(SPI Clock)
0972 0021  0802 	MOVLB 1
0973 118E  0803 	BCF   TRISC,3
           0804 			;    TRISC.4 = 1;        // Make port RC4 an input(SPI Data In)
0974 160E  0805 	BSF   TRISC,4
           0806 			;    TRISC.5 = 0;        // Make port RC5 an output(SPI Data Out)
0975 128E  0807 	BCF   TRISC,5
           0808 			;	SSPM1 = 0;
0976 0024  0809 	MOVLB 4
0977 1095  0810 	BCF   0x215,SSPM1
           0811 			;	SMP = 0;
0978 1394  0812 	BCF   0x214,SMP
           0813 			;	CKP = 1;
0979 1615  0814 	BSF   0x215,CKP
           0815 			;	CKE = 0;
097A 1314  0816 	BCF   0x214,CKE
           0817 			;	SSPEN = 1;
097B 1695  0818 	BSF   0x215,SSPEN
           0819 			;}
097C 0008  0820 	RETURN
           0821 			;
           0822 			;char spi_send(char data)
           0823 			;{
           0824 spi_send
097D 0020  0825 	MOVLB 0
097E 00B8  0826 	MOVWF data_4
           0827 			;	SSPBUF = data;	
097F 0838  0828 	MOVF  data_4,W
0980 0024  0829 	MOVLB 4
0981 0091  0830 	MOVWF SSPBUF
           0831 			;	while(SSPIF == 0);
0982 0020  0832 m016	MOVLB 0
0983 1D91  0833 	BTFSS 0x11,SSPIF
0984 2982  0834 	GOTO  m016
           0835 			;	return SSPBUF;
0985 0024  0836 	MOVLB 4
0986 0811  0837 	MOVF  SSPBUF,W
0987 0008  0838 	RETURN
           0839 			;}
           0840 			;/***
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 15

ADDR CODE  LINE SOURCE

           0841 			;**	This function sends the array to the LED controller(WS2801)
           0842 			;**  it starts with the last byte to get a correct output
           0843 			;***/
           0844 			;void spi_send_arr(char *array, char length)
           0845 			;{
           0846 spi_send_arr
0988 00FF  0847 	MOVWF length_5
           0848 			;	if(array == 0) return;
0989 08FF  0849 	MOVF  array_4,1
098A 1903  0850 	BTFSC 0x03,Zero_
098B 0008  0851 	RETURN
           0852 			;	char i;
           0853 			;	for(i = length; i == 0; i-- )
098C 087F  0854 	MOVF  length_5,W
098D 00FF  0855 	MOVWF i_5
098E 08FF  0856 m017	MOVF  i_5,1
098F 1D03  0857 	BTFSS 0x03,Zero_
0990 2999  0858 	GOTO  m018
           0859 			;	{
           0860 			;		spi_send(array[i]);
0991 087F  0861 	MOVF  i_5,W
0992 077F  0862 	ADDWF array_4,W
0993 0084  0863 	MOVWF FSR0L
0994 0185  0864 	CLRF  FSR0H
0995 0800  0865 	MOVF  INDF0,W
0996 217D  0866 	CALL  spi_send
           0867 			;	} 
0997 03FF  0868 	DECF  i_5,1
0998 298E  0869 	GOTO  m017
           0870 			;}
0999 0008  0871 m018	RETURN
           0872 			;
           0873 			;void spi_send_ledbuf(char *array)//!!! CHECK if GIE=0 during the sendroutine improves the result
           0874 			;{
           0875 spi_send_ledbuf
           0876 			;	//array must be the address of the first byte
           0877 			;	char* end;
           0878 			;	//calculate where the end is
           0879 			;	end = array + (NUM_OF_LED * 3);
099A 0020  0880 	MOVLB 0
099B 0835  0881 	MOVF  array_5+1,W
099C 00B7  0882 	MOVWF end+1
099D 3060  0883 	MOVLW 96
099E 0734  0884 	ADDWF array_5,W
099F 00B6  0885 	MOVWF end
09A0 1803  0886 	BTFSC 0x03,Carry
09A1 0AB7  0887 	INCF  end+1,1
           0888 			;	//send all
           0889 			;	for(; array < end; array++)
09A2 0020  0890 m019	MOVLB 0
09A3 0837  0891 	MOVF  end+1,W
09A4 0235  0892 	SUBWF array_5+1,W
09A5 1C03  0893 	BTFSS 0x03,Carry
09A6 29AD  0894 	GOTO  m020
09A7 1D03  0895 	BTFSS 0x03,Zero_
09A8 29B9  0896 	GOTO  m021
09A9 0836  0897 	MOVF  end,W
09AA 0234  0898 	SUBWF array_5,W
09AB 1803  0899 	BTFSC 0x03,Carry
09AC 29B9  0900 	GOTO  m021
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 16

ADDR CODE  LINE SOURCE

           0901 			;	{
           0902 			;		spi_send(*array);
09AD 0020  0903 m020	MOVLB 0
09AE 0835  0904 	MOVF  array_5+1,W
09AF 0085  0905 	MOVWF FSR0H
09B0 0834  0906 	MOVF  array_5,W
09B1 0084  0907 	MOVWF FSR0L
09B2 0800  0908 	MOVF  INDF0,W
09B3 217D  0909 	CALL  spi_send
           0910 			;	}
09B4 0020  0911 	MOVLB 0
09B5 0AB4  0912 	INCF  array_5,1
09B6 1903  0913 	BTFSC 0x03,Zero_
09B7 0AB5  0914 	INCF  array_5+1,1
09B8 29A2  0915 	GOTO  m019
           0916 			;}
09B9 0008  0917 m021	RETURN
           0918 
           0919   ; FILE include_files\ledstrip.c
           0920 			;//Nils Weiß 
           0921 			;//20.04.2012
           0922 			;//Compiler CC5x 
           0923 			;
           0924 			;struct LedBuffer gLedBuf;
           0925 			;
           0926 			;void ledstrip_init(void)
           0927 			;{
           0928 ledstrip_init
           0929 			;	char k;
           0930 			;	for(k = 0;k < (NUM_OF_LED * 3); k++)
09BA 0020  0931 	MOVLB 0
09BB 01A3  0932 	CLRF  k
09BC 3060  0933 m022	MOVLW 96
09BD 0020  0934 	MOVLB 0
09BE 0223  0935 	SUBWF k,W
09BF 1803  0936 	BTFSC 0x03,Carry
09C0 29CB  0937 	GOTO  m023
           0938 			;	{	
           0939 			;		gLedBuf.led_array[k] = 0;
09C1 3020  0940 	MOVLW 32
09C2 0085  0941 	MOVWF FSR0+1
09C3 3041  0942 	MOVLW 65
09C4 0723  0943 	ADDWF k,W
09C5 0084  0944 	MOVWF FSR0
09C6 1803  0945 	BTFSC 0x03,Carry
09C7 0A85  0946 	INCF  FSR0+1,1
09C8 0180  0947 	CLRF  INDF0
           0948 			;	}
09C9 0AA3  0949 	INCF  k,1
09CA 29BC  0950 	GOTO  m022
           0951 			;}
09CB 0008  0952 m023	RETURN
           0953 			;
           0954 			;/***
           0955 			;*** This funktion sets the values of the global LedBuffer
           0956 			;*** only Led's where the address bit is 1 will be set to the new color
           0957 			;***/
           0958 			;
           0959 			;void ledstrip_set_color(char *address, char r, char g, char b)
           0960 			;{	
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 17

ADDR CODE  LINE SOURCE

           0961 ledstrip_set_color
09CC 0020  0962 	MOVLB 0
09CD 00B1  0963 	MOVWF b
           0964 			;	char k,mask;
           0965 			;	mask = 0b00000001;
09CE 3001  0966 	MOVLW 1
09CF 00B3  0967 	MOVWF mask
           0968 			;	for(k = 0; k < (NUM_OF_LED * 3); k++)
09D0 01B2  0969 	CLRF  k_2
09D1 3060  0970 m024	MOVLW 96
09D2 0020  0971 	MOVLB 0
09D3 0232  0972 	SUBWF k_2,W
09D4 1803  0973 	BTFSC 0x03,Carry
09D5 2A08  0974 	GOTO  m028
           0975 			;	{	
           0976 			;		if(0 != (*address & mask))
09D6 0185  0977 	CLRF  FSR0H
09D7 082E  0978 	MOVF  address,W
09D8 0084  0979 	MOVWF FSR0L
09D9 0833  0980 	MOVF  mask,W
09DA 0500  0981 	ANDWF INDF0,W
09DB 1903  0982 	BTFSC 0x03,Zero_
09DC 29FB  0983 	GOTO  m025
           0984 			;		{
           0985 			;			gLedBuf.led_array[k] = b;
09DD 3020  0986 	MOVLW 32
09DE 0085  0987 	MOVWF FSR0+1
09DF 3041  0988 	MOVLW 65
09E0 0732  0989 	ADDWF k_2,W
09E1 0084  0990 	MOVWF FSR0
09E2 1803  0991 	BTFSC 0x03,Carry
09E3 0A85  0992 	INCF  FSR0+1,1
09E4 0831  0993 	MOVF  b,W
09E5 0080  0994 	MOVWF INDF0
           0995 			;			k++;
09E6 0AB2  0996 	INCF  k_2,1
           0997 			;			gLedBuf.led_array[k] = g;
09E7 3020  0998 	MOVLW 32
09E8 0085  0999 	MOVWF FSR0+1
09E9 3041  1000 	MOVLW 65
09EA 0732  1001 	ADDWF k_2,W
09EB 0084  1002 	MOVWF FSR0
09EC 1803  1003 	BTFSC 0x03,Carry
09ED 0A85  1004 	INCF  FSR0+1,1
09EE 0830  1005 	MOVF  g,W
09EF 0080  1006 	MOVWF INDF0
           1007 			;			k++;
09F0 0AB2  1008 	INCF  k_2,1
           1009 			;			gLedBuf.led_array[k] = r;
09F1 3020  1010 	MOVLW 32
09F2 0085  1011 	MOVWF FSR0+1
09F3 3041  1012 	MOVLW 65
09F4 0732  1013 	ADDWF k_2,W
09F5 0084  1014 	MOVWF FSR0
09F6 1803  1015 	BTFSC 0x03,Carry
09F7 0A85  1016 	INCF  FSR0+1,1
09F8 082F  1017 	MOVF  r,W
09F9 0080  1018 	MOVWF INDF0
           1019 			;		}
           1020 			;		else 
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 18

ADDR CODE  LINE SOURCE

09FA 29FE  1021 	GOTO  m026
           1022 			;		{
           1023 			;			k++;
09FB 0020  1024 m025	MOVLB 0
09FC 0AB2  1025 	INCF  k_2,1
           1026 			;			k++;
09FD 0AB2  1027 	INCF  k_2,1
           1028 			;		}
           1029 			;		RLF(mask,1);
09FE 0020  1030 m026	MOVLB 0
09FF 0DB3  1031 	RLF   mask,1
           1032 			;		if(Carry == 1) 
0A00 1C03  1033 	BTFSS 0x03,Carry
0A01 2A05  1034 	GOTO  m027
           1035 			;		{
           1036 			;			address++;
0A02 0AAE  1037 	INCF  address,1
           1038 			;			mask= 0b00000001;
0A03 3001  1039 	MOVLW 1
0A04 00B3  1040 	MOVWF mask
           1041 			;		}
           1042 			;	}
0A05 0020  1043 m027	MOVLB 0
0A06 0AB2  1044 	INCF  k_2,1
0A07 29D1  1045 	GOTO  m024
           1046 			;	spi_send_ledbuf(&gLedBuf.led_array[0]);
0A08 3041  1047 m028	MOVLW 65
0A09 0020  1048 	MOVLB 0
0A0A 00B4  1049 	MOVWF array_5
0A0B 3020  1050 	MOVLW 32
0A0C 00B5  1051 	MOVWF array_5+1
0A0D 299A  1052 	GOTO  spi_send_ledbuf
           1053 			;}
           1054 			;
           1055 			;/** This function extracts the parameters for the set_color command
           1056 			;*** from the EEPROM in relation to the CmdWidth and give the values 
           1057 			;*** to the next function with controls the led's
           1058 			;
           1059 			;*** BYTES according to Pointer: x=Commandpointer w=Commandwith
           1060 			;							   x-w     x-w+1   x-w+2   x-w+3  x-w+4     x-w+5         x-w+6        x-w+7                            
                                     x
           1061 			;*** Example: EEPROM DATA: <SET_COLOR> <ADDR0> <ADDR1> <ADDR2> <ADDR3> <RED_VALUE> <GREEN_VALUE> <BLUE_VALUE> <not important> <not important> <SET_COLOR(nextCom
                   mand)>
           1062 			;*/ 
           1063 			;void sub_func_set_color(char *cmdPointer)
           1064 			;{
           1065 sub_func_set_color
           1066 			;	char r,g,b,i, temp,temp1,address[4];
           1067 			;	
           1068 			;	r = EEPROM_RD(*cmdPointer - CmdWidth + 5);
0A0E 0185  1069 	CLRF  FSR0H
0A0F 0020  1070 	MOVLB 0
0A10 0823  1071 	MOVF  cmdPointer,W
0A11 0084  1072 	MOVWF FSR0L
0A12 3005  1073 	MOVLW 5
0A13 0200  1074 	SUBWF INDF0,W
0A14 20CD  1075 	CALL  EEPROM_RD
0A15 0020  1076 	MOVLB 0
0A16 00A4  1077 	MOVWF r_2
           1078 			;	g = EEPROM_RD(*cmdPointer - CmdWidth + 6);
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 19

ADDR CODE  LINE SOURCE

0A17 0185  1079 	CLRF  FSR0H
0A18 0823  1080 	MOVF  cmdPointer,W
0A19 0084  1081 	MOVWF FSR0L
0A1A 3004  1082 	MOVLW 4
0A1B 0200  1083 	SUBWF INDF0,W
0A1C 20CD  1084 	CALL  EEPROM_RD
0A1D 0020  1085 	MOVLB 0
0A1E 00A5  1086 	MOVWF g_2
           1087 			;	b = EEPROM_RD(*cmdPointer - CmdWidth + 7);
0A1F 0185  1088 	CLRF  FSR0H
0A20 0823  1089 	MOVF  cmdPointer,W
0A21 0084  1090 	MOVWF FSR0L
0A22 3003  1091 	MOVLW 3
0A23 0200  1092 	SUBWF INDF0,W
0A24 20CD  1093 	CALL  EEPROM_RD
0A25 0020  1094 	MOVLB 0
0A26 00A6  1095 	MOVWF b_2
           1096 			;	for(i=0;i<4;i++)
0A27 01A7  1097 	CLRF  i_6
0A28 3004  1098 m029	MOVLW 4
0A29 0020  1099 	MOVLB 0
0A2A 0227  1100 	SUBWF i_6,W
0A2B 1803  1101 	BTFSC 0x03,Carry
0A2C 2A42  1102 	GOTO  m030
           1103 			;	{
           1104 			;		temp1 = *cmdPointer;
0A2D 0185  1105 	CLRF  FSR0H
0A2E 0823  1106 	MOVF  cmdPointer,W
0A2F 0084  1107 	MOVWF FSR0L
0A30 0800  1108 	MOVF  INDF0,W
0A31 00A9  1109 	MOVWF temp1
           1110 			;		temp1 = temp1 - CmdWidth + 1 + i;
0A32 3009  1111 	MOVLW 9
0A33 0229  1112 	SUBWF temp1,W
0A34 0727  1113 	ADDWF i_6,W
0A35 00A9  1114 	MOVWF temp1
           1115 			;		temp = EEPROM_RD(temp1);
0A36 0829  1116 	MOVF  temp1,W
0A37 20CD  1117 	CALL  EEPROM_RD
0A38 0020  1118 	MOVLB 0
0A39 00A8  1119 	MOVWF temp_2
           1120 			;		address[i] = temp;
0A3A 302A  1121 	MOVLW 42
0A3B 0727  1122 	ADDWF i_6,W
0A3C 0084  1123 	MOVWF FSR0L
0A3D 0185  1124 	CLRF  FSR0H
0A3E 0828  1125 	MOVF  temp_2,W
0A3F 0080  1126 	MOVWF INDF0
           1127 			;	}
0A40 0AA7  1128 	INCF  i_6,1
0A41 2A28  1129 	GOTO  m029
           1130 			;	
           1131 			;#ifdef TEST
           1132 			;	USARTsend_str("Command:");
           1133 			;	USARTsend_num(address[0],'#');
           1134 			;	USARTsend_num(address[1],'#');
           1135 			;	USARTsend_num(address[2],'#');
           1136 			;	USARTsend_num(address[3],'#');
           1137 			;	USARTsend_num(r,'R');
           1138 			;	USARTsend_num(g,'G');
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 20

ADDR CODE  LINE SOURCE

           1139 			;	USARTsend_num(b,'B');
           1140 			;#endif	
           1141 			;	ledstrip_set_color(&address[0],r,g,b);
0A42 302A  1142 m030	MOVLW 42
0A43 0020  1143 	MOVLB 0
0A44 00AE  1144 	MOVWF address
0A45 0824  1145 	MOVF  r_2,W
0A46 00AF  1146 	MOVWF r
0A47 0825  1147 	MOVF  g_2,W
0A48 00B0  1148 	MOVWF g
0A49 0826  1149 	MOVF  b_2,W
0A4A 29CC  1150 	GOTO  ledstrip_set_color
           1151 
           1152   ; FILE include_files\ledstrip.h
           1153 			;#ifndef _LEDSTRIP_H_
           1154 			;#define _LEDSTRIP_H_
           1155 			;
           1156 			;//Nils Weiß 
           1157 			;//20.04.2012
           1158 			;//Compiler CC5x
           1159 			;
           1160 			;#define NUM_OF_LED 32
           1161 			;
           1162 			;struct LedBuffer{
           1163 			;	char led_array[NUM_OF_LED*3];
           1164 			;	};
           1165 			;
           1166 			;extern struct LedBuffer gLedBuf;
           1167 			;
           1168 			;void ledstrip_init(void);
           1169 			;void ledstrip_set_color(char *address,char r,char g,char b);
           1170 			;void sub_func_set_color(char *cmdPointer);
           1171 			;
           1172 			;#ifndef _SPI_H_
           1173 			;#message !!! LEDSTRIP.H needs SPI.H --> SPI.H is include automatically now
           1174 			;#include "include_files\spi.h"
           1175 			;#endif
           1176 			;
           1177 			;#ifndef _EEPROM_H_
           1178 			;#message !!! LEDSTRIP:H needs EEPROM.H --> EEPROM.H is include automatically now
           1179 			;#include "include_files\eeprom.h"
           1180 			;#endif
           1181 			;
           1182 			;#include "include_files\ledstrip.c"
           1183 
           1184   ; FILE main.c
           1185 			;#include "inline.h"
           1186 			;#include "include_files\Ringbuf.h"		//clean
           1187 			;#include "include_files\usart.h"		//clean
           1188 			;#include "include_files\eeprom.h"       //clean 
           1189 			;#include "include_files\crc.c"			//clean
           1190 			;#include "include_files\ledstrip.h"		//under construction
           1191 			;#include "include_files\spi.h"			//clean
           1192 			;#include "include_files\timer.h"
           1193 			;//*********************** GLOBAL VARIABLES *******************************************
           1194 			;#define FRAMELENGTH 16			// *** max length of one commandframe
           1195 			;struct CommandBuffer{
           1196 			;    char cmd_counter;
           1197 			;    char frame_counter;
           1198 			;    char cmd_buf[FRAMELENGTH];
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 21

ADDR CODE  LINE SOURCE

           1199 			;    char crcH;
           1200 			;    char crcL;
           1201 			;};
           1202 			;static struct CommandBuffer gCmdBuf;
           1203 			;static char gERROR;
           1204 			;
           1205 			;//*********************** INTERRUPTSERVICEROUTINE ************************************
           1206 			;#pragma origin 4					//Adresse des Interrupts	
     0000  1207 	ORG 0x0004
           1208 			;interrupt InterruptRoutine(void)
           1209 			;{
           1210 InterruptRoutine
           1211 			;	if (RCIF)
0004 0020  1212 	MOVLB 0
0005 1E91  1213 	BTFSS 0x11,RCIF
0006 2813  1214 	GOTO  m032
           1215 			;	{
           1216 			;		if(!RingBufHasError) RingBufPut(RCREG);
0007 184B  1217 	BTFSC gRingBuf+18,0
0008 280F  1218 	GOTO  m031
0009 0023  1219 	MOVLB 3
000A 0819  1220 	MOVF  RCREG,W
000B 3188  1221 	MOVLP 8
000C 2054  1222 	CALL  RingBufPut
000D 3180  1223 	MOVLP 0
           1224 			;		else 
000E 2813  1225 	GOTO  m032
           1226 			;		{
           1227 			;			//Register lesen um Schnittstellen Fehler zu vermeiden
           1228 			;			char temp = RCREG;
000F 0023  1229 m031	MOVLB 3
0010 0819  1230 	MOVF  RCREG,W
0011 0020  1231 	MOVLB 0
0012 00A0  1232 	MOVWF temp_3
           1233 			;		}
           1234 			;	}
           1235 			;}
0013 0009  1236 m032	RETFIE
           1237 			;
           1238 			;//*********************** FUNKTIONSPROTOTYPEN ****************************************
           1239 			;void init_all();
           1240 			;void throw_errors();
           1241 			;void get_commands();
           1242 			;void execute_commands();
           1243 			;
           1244 			;//*********************** HAUPTPROGRAMM **********************************************
           1245 			;void main(void)
           1246 			;{
           1247 main
           1248 			;	init_all();
0014 2019  1249 	CALL  init_all
           1250 			;    while(1)
           1251 			;    {	
           1252 			;        throw_errors();
0015 2062  1253 m033	CALL  throw_errors
           1254 			;		get_commands();
0016 207E  1255 	CALL  get_commands
           1256 			;		execute_commands();
0017 211B  1257 	CALL  execute_commands
           1258 			;    }
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 22

ADDR CODE  LINE SOURCE

0018 2815  1259 	GOTO  m033
           1260 			;}
           1261 			;//*********************** UNTERPROGRAMME **********************************************
           1262 			;
           1263 			;void init_all()
           1264 			;{
           1265 init_all
           1266 			;	
           1267 			;	//OSZILLATOR initialisieren: 4xPLL deactivated;INTOSC 16MHz
           1268 			;	OSCCON = 0b01110010;
0019 3072  1269 	MOVLW 114
001A 0021  1270 	MOVLB 1
001B 0099  1271 	MOVWF OSCCON
           1272 			;	RingBufInit();
001C 3188  1273 	MOVLP 8
001D 2043  1274 	CALL  RingBufInit
001E 3180  1275 	MOVLP 0
           1276 			;	//initialise UART interface
           1277 			;	USARTinit();
001F 3188  1278 	MOVLP 8
0020 2069  1279 	CALL  USARTinit
0021 3180  1280 	MOVLP 0
           1281 			;	spi_init();
0022 3188  1282 	MOVLP 8
0023 2172  1283 	CALL  spi_init
0024 3180  1284 	MOVLP 0
           1285 			;	ledstrip_init();
0025 3188  1286 	MOVLP 8
0026 21BA  1287 	CALL  ledstrip_init
0027 3180  1288 	MOVLP 0
           1289 			;
           1290 			;/** EEPROM contains FF in every Cell after inital start,
           1291 			;*** so I have to delet the pointer address
           1292 			;*** otherwise the PIC thinks he has the EEPROM full with commands
           1293 			;**/
           1294 			;	if (EEPROM_RD(CmdPointerAddr) == 0xff)
0028 30FF  1295 	MOVLW 255
0029 3188  1296 	MOVLP 8
002A 20CD  1297 	CALL  EEPROM_RD
002B 3180  1298 	MOVLP 0
002C 3AFF  1299 	XORLW 255
002D 1D03  1300 	BTFSS 0x03,Zero_
002E 2836  1301 	GOTO  m034
           1302 			;	EEPROM_WR(CmdPointerAddr, 0);
002F 30FF  1303 	MOVLW 255
0030 0020  1304 	MOVLB 0
0031 00AA  1305 	MOVWF adress
0032 3000  1306 	MOVLW 0
0033 3188  1307 	MOVLP 8
0034 20AB  1308 	CALL  EEPROM_WR
0035 3180  1309 	MOVLP 0
           1310 			;	EEPROM_WR(CmdLoopPointerAddr, 0);
0036 30FD  1311 m034	MOVLW 253
0037 0020  1312 	MOVLB 0
0038 00AA  1313 	MOVWF adress
0039 3000  1314 	MOVLW 0
003A 3188  1315 	MOVLP 8
003B 20AB  1316 	CALL  EEPROM_WR
003C 3180  1317 	MOVLP 0
           1318 			;	
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 23

ADDR CODE  LINE SOURCE

           1319 			;	//Ausgang für FET initalisieren
           1320 			;	TRISC.0 = 0;
003D 0021  1321 	MOVLB 1
003E 100E  1322 	BCF   TRISC,0
           1323 			;	//Spannungsversorgung für LED's einschalten
           1324 			;	PORTC.0 = 0;
003F 0020  1325 	MOVLB 0
0040 100E  1326 	BCF   PORTC,0
           1327 			;
           1328 			;	//To Factory Restore WLAN Modul
           1329 			;	//TRISA.0=0;
           1330 			;	//PORTA.0 = 1;
           1331 			;    
           1332 			;    // *** load globals variables
           1333 			;    gERROR = 0;
0041 01E0  1334 	CLRF  gERROR
           1335 			;    gCmdBuf.cmd_counter = 0;
0042 01CC  1336 	CLRF  gCmdBuf
           1337 			;    gCmdBuf.frame_counter = 0;
0043 01CD  1338 	CLRF  gCmdBuf+1
           1339 			;	
           1340 			;	char i;
           1341 			;	for(i=0;i<FRAMELENGTH;i++)
0044 01A2  1342 	CLRF  i_7
0045 3010  1343 m035	MOVLW 16
0046 0020  1344 	MOVLB 0
0047 0222  1345 	SUBWF i_7,W
0048 1803  1346 	BTFSC 0x03,Carry
0049 2851  1347 	GOTO  m036
           1348 			;	{
           1349 			;        gCmdBuf.cmd_buf[i] = 0;
004A 304E  1350 	MOVLW 78
004B 0722  1351 	ADDWF i_7,W
004C 0084  1352 	MOVWF FSR0L
004D 0185  1353 	CLRF  FSR0H
004E 0180  1354 	CLRF  INDF0
           1355 			;	}
004F 0AA2  1356 	INCF  i_7,1
0050 2845  1357 	GOTO  m035
           1358 			;    
           1359 			;	// *** allow interrupts
           1360 			;	RCIE=1;
0051 0021  1361 m036	MOVLB 1
0052 1691  1362 	BSF   0x91,RCIE
           1363 			;	PEIE=1;
0053 170B  1364 	BSF   0x0B,PEIE
           1365 			;	GIE=1;
0054 178B  1366 	BSF   0x0B,GIE
           1367 			;	// *** send ready after init
           1368 			;	USARTsend('R');
0055 3052  1369 	MOVLW 82
0056 3188  1370 	MOVLP 8
0057 207C  1371 	CALL  USARTsend
0058 3180  1372 	MOVLP 0
           1373 			;	USARTsend('D');
0059 3044  1374 	MOVLW 68
005A 3188  1375 	MOVLP 8
005B 207C  1376 	CALL  USARTsend
005C 3180  1377 	MOVLP 0
           1378 			;	USARTsend('Y');
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 24

ADDR CODE  LINE SOURCE

005D 3059  1379 	MOVLW 89
005E 3188  1380 	MOVLP 8
005F 207C  1381 	CALL  USARTsend
0060 3180  1382 	MOVLP 0
           1383 			;
           1384 			;	
           1385 			;}
0061 0008  1386 	RETURN
           1387 			;
           1388 			;void throw_errors()
           1389 			;{
           1390 throw_errors
           1391 			;	if(RingBufHasError) 
0062 0020  1392 	MOVLB 0
0063 1C4B  1393 	BTFSS gRingBuf+18,0
0064 2869  1394 	GOTO  m037
           1395 			;	{
           1396 			;		USARTsend_str(" ERROR: Receivebuffer full");
0065 01A2  1397 	CLRF  string
0066 3188  1398 	MOVLP 8
0067 2086  1399 	CALL  USARTsend_str
0068 3180  1400 	MOVLP 0
           1401 			;	}
           1402 			;	if(gERROR.crc_failure)
0069 0020  1403 m037	MOVLB 0
006A 1C60  1404 	BTFSS gERROR,0
006B 2873  1405 	GOTO  m038
           1406 			;	{
           1407 			;		USARTsend_str(" ERROR: CRC-Check failed");
006C 301B  1408 	MOVLW 27
006D 00A2  1409 	MOVWF string
006E 3188  1410 	MOVLP 8
006F 2086  1411 	CALL  USARTsend_str
0070 3180  1412 	MOVLP 0
           1413 			;		gERROR.crc_failure = 0;
0071 0020  1414 	MOVLB 0
0072 1060  1415 	BCF   gERROR,0
           1416 			;	}
           1417 			;	if(gERROR.eeprom_failure)
0073 0020  1418 m038	MOVLB 0
0074 1CE0  1419 	BTFSS gERROR,1
0075 287D  1420 	GOTO  m039
           1421 			;	{
           1422 			;		USARTsend_str(" ERROR: EEPROM is full");
0076 3034  1423 	MOVLW 52
0077 00A2  1424 	MOVWF string
0078 3188  1425 	MOVLP 8
0079 2086  1426 	CALL  USARTsend_str
007A 3180  1427 	MOVLP 0
           1428 			;		gERROR.eeprom_failure = 0;
007B 0020  1429 	MOVLB 0
007C 10E0  1430 	BCF   gERROR,1
           1431 			;	}
           1432 			;}
007D 0008  1433 m039	RETURN
           1434 			;
           1435 			;/** This function reads one byte from the ringbuffer and check
           1436 			;*** for framestart, framelength, or databyte 
           1437 			;*** if a frame is complete, the function save the frame as a new
           1438 			;*** command in the internal EEPROM and calculate the Pointer for the next Command
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 25

ADDR CODE  LINE SOURCE

           1439 			;**/
           1440 			;void get_commands()
           1441 			;{	
           1442 get_commands
           1443 			;	if(RingBufIsNotEmpty)
007E 0020  1444 	MOVLB 0
007F 084A  1445 	MOVF  gRingBuf+17,W
0080 0649  1446 	XORWF gRingBuf+16,W
0081 1903  1447 	BTFSC 0x03,Zero_
0082 291A  1448 	GOTO  m049
           1449 			;	{
           1450 			;		// *** preload variables and 
           1451 			;		// *** get new_byte from ringbuffer
           1452 			;		char new_byte, temp, j;
           1453 			;		temp = 0;
0083 01A3  1454 	CLRF  temp_4
           1455 			;		j = 0;
0084 01A4  1456 	CLRF  j
           1457 			;		// *** get new byte
           1458 			;		new_byte = RingBufGet();	
0085 3188  1459 	MOVLP 8
0086 2048  1460 	CALL  RingBufGet
0087 3180  1461 	MOVLP 0
0088 0020  1462 	MOVLB 0
0089 00A2  1463 	MOVWF new_byte
           1464 			;		// *** do I wait for databytes?
           1465 			;		if(gCmdBuf.frame_counter == 0)
008A 08CD  1466 	MOVF  gCmdBuf+1,1
008B 1D03  1467 	BTFSS 0x03,Zero_
008C 28BE  1468 	GOTO  m041
           1469 			;		{
           1470 			;			// *** I don't wait for databytes
           1471 			;			// *** Do I receive a Start_of_Text sign
           1472 			;			if(new_byte == STX)
008D 0F22  1473 	INCFSZ new_byte,W
008E 28A5  1474 	GOTO  m040
           1475 			;			{
           1476 			;				// *** increse the cmd_counter
           1477 			;				gCmdBuf.cmd_counter = 1;
008F 3001  1478 	MOVLW 1
0090 00CC  1479 	MOVWF gCmdBuf
           1480 			;				// *** Write the startsign at the begin of the buffer
           1481 			;				gCmdBuf.cmd_buf[0] = new_byte;
0091 0822  1482 	MOVF  new_byte,W
0092 00CE  1483 	MOVWF gCmdBuf+2
           1484 			;                // *** Reset crc Variables
           1485 			;                newCRC(&gCmdBuf.crcH, &gCmdBuf.crcL);
0093 305E  1486 	MOVLW 94
0094 00A5  1487 	MOVWF p_crcH_2
0095 305F  1488 	MOVLW 95
0096 00A6  1489 	MOVWF p_crcL_2
0097 3188  1490 	MOVLP 8
0098 215E  1491 	CALL  newCRC
0099 3180  1492 	MOVLP 0
           1493 			;                // *** add new_byte to crc checksum
           1494 			;                addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
009A 0020  1495 	MOVLB 0
009B 0822  1496 	MOVF  new_byte,W
009C 00A5  1497 	MOVWF byte
009D 305E  1498 	MOVLW 94
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 26

ADDR CODE  LINE SOURCE

009E 00A6  1499 	MOVWF p_crcH
009F 305F  1500 	MOVLW 95
00A0 00A7  1501 	MOVWF p_crcL
00A1 3188  1502 	MOVLP 8
00A2 2109  1503 	CALL  addCRC
00A3 3180  1504 	MOVLP 0
           1505 			;			}
           1506 			;			else
00A4 291A  1507 	GOTO  m049
           1508 			;			{	
           1509 			;				// *** to avoid arrayoverflow
           1510 			;				temp = FRAMELENGTH - 2;
00A5 300E  1511 m040	MOVLW 14
00A6 0020  1512 	MOVLB 0
00A7 00A3  1513 	MOVWF temp_4
           1514 			;				// *** check if I get the framelength byte
           1515 			;				if((new_byte < temp) && (gCmdBuf.cmd_counter == 1))
00A8 0823  1516 	MOVF  temp_4,W
00A9 0222  1517 	SUBWF new_byte,W
00AA 1803  1518 	BTFSC 0x03,Carry
00AB 291A  1519 	GOTO  m049
00AC 0B4C  1520 	DECFSZ gCmdBuf,W
00AD 291A  1521 	GOTO  m049
           1522 			;				{
           1523 			;					gCmdBuf.frame_counter = new_byte;
00AE 0822  1524 	MOVF  new_byte,W
00AF 00CD  1525 	MOVWF gCmdBuf+1
           1526 			;					gCmdBuf.cmd_buf[1] = new_byte;
00B0 0822  1527 	MOVF  new_byte,W
00B1 00CF  1528 	MOVWF gCmdBuf+3
           1529 			;					gCmdBuf.cmd_counter = 2;
00B2 3002  1530 	MOVLW 2
00B3 00CC  1531 	MOVWF gCmdBuf
           1532 			;                    // *** add new_byte to crc checksum
           1533 			;                    addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
00B4 0822  1534 	MOVF  new_byte,W
00B5 00A5  1535 	MOVWF byte
00B6 305E  1536 	MOVLW 94
00B7 00A6  1537 	MOVWF p_crcH
00B8 305F  1538 	MOVLW 95
00B9 00A7  1539 	MOVWF p_crcL
00BA 3188  1540 	MOVLP 8
00BB 2109  1541 	CALL  addCRC
00BC 3180  1542 	MOVLP 0
           1543 			;				}
           1544 			;			}
           1545 			;		}
           1546 			;		else
00BD 291A  1547 	GOTO  m049
           1548 			;		{
           1549 			;			// *** I wait for Databytes, so I save all bytes 
           1550 			;			// *** that I get until my framecounter is > 0
           1551 			;			gCmdBuf.cmd_buf[gCmdBuf.cmd_counter] = new_byte;
00BE 304E  1552 m041	MOVLW 78
00BF 0020  1553 	MOVLB 0
00C0 074C  1554 	ADDWF gCmdBuf,W
00C1 0084  1555 	MOVWF FSR0L
00C2 0185  1556 	CLRF  FSR0H
00C3 0822  1557 	MOVF  new_byte,W
00C4 0080  1558 	MOVWF INDF0
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 27

ADDR CODE  LINE SOURCE

           1559 			;			gCmdBuf.cmd_counter++;
00C5 0ACC  1560 	INCF  gCmdBuf,1
           1561 			;			
           1562 			;            // *** add new_byte to crc checksum
           1563 			;			if(gCmdBuf.frame_counter > 2)
00C6 3003  1564 	MOVLW 3
00C7 024D  1565 	SUBWF gCmdBuf+1,W
00C8 1C03  1566 	BTFSS 0x03,Carry
00C9 28D3  1567 	GOTO  m042
           1568 			;            addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
00CA 0822  1569 	MOVF  new_byte,W
00CB 00A5  1570 	MOVWF byte
00CC 305E  1571 	MOVLW 94
00CD 00A6  1572 	MOVWF p_crcH
00CE 305F  1573 	MOVLW 95
00CF 00A7  1574 	MOVWF p_crcL
00D0 3188  1575 	MOVLP 8
00D1 2109  1576 	CALL  addCRC
00D2 3180  1577 	MOVLP 0
           1578 			;			gCmdBuf.frame_counter--;
00D3 0020  1579 m042	MOVLB 0
00D4 0BCD  1580 	DECFSZ gCmdBuf+1,1
           1581 			;			// *** now I have to check if my framecounter is null.
           1582 			;			// *** If it's null my string is complete 
           1583 			;			// *** and I can give the string to the crc check function.
           1584 			;			if(gCmdBuf.frame_counter == 0)
00D5 291A  1585 	GOTO  m049
           1586 			;			{
           1587 			;#ifdef NO_CRC
           1588 			;				if(1==1)
           1589 			;#else
           1590 			;                // *** verify crc checksum
           1591 			;                if( (gCmdBuf.crcL == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 1]) &&
           1592 			;                    (gCmdBuf.crcH == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 2]) )
           1593 			;#endif
           1594 			;                {
           1595 			;					// *** Execute the simple Commands
           1596 			;					switch(gCmdBuf.cmd_buf[2])
00D6 0850  1597 	MOVF  gCmdBuf+4,W
00D7 3AF8  1598 	XORLW 248
00D8 1903  1599 	BTFSC 0x03,Zero_
00D9 28E1  1600 	GOTO  m043
00DA 3A02  1601 	XORLW 2
00DB 1903  1602 	BTFSC 0x03,Zero_
00DC 28E9  1603 	GOTO  m044
00DD 3A03  1604 	XORLW 3
00DE 1903  1605 	BTFSC 0x03,Zero_
00DF 28EC  1606 	GOTO  m045
00E0 28EF  1607 	GOTO  m046
           1608 			;					{
           1609 			;						case DELETE: 
           1610 			;							{
           1611 			;								EEPROM_WR(CmdPointerAddr,0);
00E1 30FF  1612 m043	MOVLW 255
00E2 0020  1613 	MOVLB 0
00E3 00AA  1614 	MOVWF adress
00E4 3000  1615 	MOVLW 0
00E5 3188  1616 	MOVLP 8
00E6 20AB  1617 	CALL  EEPROM_WR
00E7 3180  1618 	MOVLP 0
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 28

ADDR CODE  LINE SOURCE

           1619 			;								return;
00E8 0008  1620 	RETURN
           1621 			;							}
           1622 			;						case SET_ON: 
           1623 			;							{
           1624 			;								BCF(PORTC.0); 
00E9 0020  1625 m044	MOVLB 0
00EA 100E  1626 	BCF   PORTC,0
           1627 			;								return;
00EB 0008  1628 	RETURN
           1629 			;								}
           1630 			;						case SET_OFF: 
           1631 			;							{
           1632 			;								BSF(PORTC.0); 
00EC 0020  1633 m045	MOVLB 0
00ED 140E  1634 	BSF   PORTC,0
           1635 			;								return;
00EE 0008  1636 	RETURN
           1637 			;							}
           1638 			;					}
           1639 			;                    char CmdPointer = EEPROM_RD(CmdPointerAddr);
00EF 30FF  1640 m046	MOVLW 255
00F0 3188  1641 	MOVLP 8
00F1 20CD  1642 	CALL  EEPROM_RD
00F2 3180  1643 	MOVLP 0
00F3 0020  1644 	MOVLB 0
00F4 00A5  1645 	MOVWF CmdPointer
           1646 			;					// *** check if there is enough space in the EEPROM for the next command
           1647 			;                    if(CmdPointer < (CmdPointerAddr - CmdWidth))
00F5 30F5  1648 	MOVLW 245
00F6 0225  1649 	SUBWF CmdPointer,W
00F7 1803  1650 	BTFSC 0x03,Carry
00F8 2901  1651 	GOTO  m047
           1652 			;                    {
           1653 			;                        // *** calculate the next address for EEPROM write
           1654 			;                        EEPROM_WR(CmdPointerAddr,(CmdPointer + CmdWidth));
00F9 30FF  1655 	MOVLW 255
00FA 00AA  1656 	MOVWF adress
00FB 300A  1657 	MOVLW 10
00FC 0725  1658 	ADDWF CmdPointer,W
00FD 3188  1659 	MOVLP 8
00FE 20AB  1660 	CALL  EEPROM_WR
00FF 3180  1661 	MOVLP 0
           1662 			;                    }
           1663 			;                    else 
0100 2904  1664 	GOTO  m048
           1665 			;                    {
           1666 			;                        // *** EEPROM is full with commands
           1667 			;                        // *** Some errorhandling should be here
           1668 			;						gERROR.eeprom_failure = 1;
0101 0020  1669 m047	MOVLB 0
0102 14E0  1670 	BSF   gERROR,1
           1671 			;                        return;
0103 0008  1672 	RETURN
           1673 			;                    } 
           1674 			;					// *** Write the new command without STX and CRC
           1675 			;					EEPROM_WR_BLK(&gCmdBuf.cmd_buf[2], CmdPointer, (gCmdBuf.cmd_counter -4));
0104 3050  1676 m048	MOVLW 80
0105 0020  1677 	MOVLB 0
0106 00A6  1678 	MOVWF array_2
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 29

ADDR CODE  LINE SOURCE

0107 0825  1679 	MOVF  CmdPointer,W
0108 00A7  1680 	MOVWF adress_3
0109 3004  1681 	MOVLW 4
010A 024C  1682 	SUBWF gCmdBuf,W
010B 3188  1683 	MOVLP 8
010C 20DA  1684 	CALL  EEPROM_WR_BLK
010D 3180  1685 	MOVLP 0
           1686 			;					// *** Send a Message('G'et 'C'ommand) when a new Command is received successfull
           1687 			;					USARTsend('G');
010E 3047  1688 	MOVLW 71
010F 3188  1689 	MOVLP 8
0110 207C  1690 	CALL  USARTsend
0111 3180  1691 	MOVLP 0
           1692 			;					USARTsend('C');
0112 3043  1693 	MOVLW 67
0113 3188  1694 	MOVLP 8
0114 207C  1695 	CALL  USARTsend
0115 3180  1696 	MOVLP 0
           1697 			;#ifdef TEST
           1698 			;					USARTsend_arr(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4));
           1699 			;#endif
           1700 			;                }
           1701 			;                else
0116 291A  1702 	GOTO  m049
           1703 			;                {
           1704 			;                    // *** Do some error handling in case of an CRC failure here
           1705 			;					gERROR.crc_failure = 1;
0117 0020  1706 	MOVLB 0
0118 1460  1707 	BSF   gERROR,0
           1708 			;                    return;
0119 0008  1709 	RETURN
           1710 			;                }
           1711 			;			}
           1712 			;		}
           1713 			;	}
           1714 			;}
011A 0008  1715 m049	RETURN
           1716 			;
           1717 			;/** This function reads the pointer for commands in the EEPROM from a defined address 
           1718 			;*** in the EEPROM. After this one by one command is executed by this function. 
           1719 			;**/ 
           1720 			;void execute_commands()
           1721 			;{
           1722 execute_commands
           1723 			;	// *** get the pointer to commands in the EEPROM
           1724 			;	char pointer = EEPROM_RD(CmdPointerAddr);
011B 30FF  1725 	MOVLW 255
011C 3188  1726 	MOVLP 8
011D 20CD  1727 	CALL  EEPROM_RD
011E 3180  1728 	MOVLP 0
011F 0020  1729 	MOVLB 0
0120 00A2  1730 	MOVWF pointer
           1731 			;	// *** are there commands to execute?
           1732 			;	if(pointer != 0)
0121 08A2  1733 	MOVF  pointer,1
0122 1903  1734 	BTFSC 0x03,Zero_
0123 2941  1735 	GOTO  m052
           1736 			;	{
           1737 			;		// *** commands available, check what to do
           1738 			;		switch(EEPROM_RD(pointer - CmdWidth)) 
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 30

ADDR CODE  LINE SOURCE

0124 300A  1739 	MOVLW 10
0125 0222  1740 	SUBWF pointer,W
0126 3188  1741 	MOVLP 8
0127 20CD  1742 	CALL  EEPROM_RD
0128 3180  1743 	MOVLP 0
0129 3AFD  1744 	XORLW 253
012A 1903  1745 	BTFSC 0x03,Zero_
012B 2933  1746 	GOTO  m050
012C 3A01  1747 	XORLW 1
012D 1903  1748 	BTFSC 0x03,Zero_
012E 2939  1749 	GOTO  m051
012F 3A07  1750 	XORLW 7
0130 1903  1751 	BTFSC 0x03,Zero_
0131 2939  1752 	GOTO  m051
0132 2939  1753 	GOTO  m051
           1754 			;		{	
           1755 			;			case SET_COLOR: 
           1756 			;			{
           1757 			;				sub_func_set_color(&pointer);
0133 3022  1758 m050	MOVLW 34
0134 0020  1759 	MOVLB 0
0135 00A3  1760 	MOVWF cmdPointer
0136 3188  1761 	MOVLP 8
0137 220E  1762 	CALL  sub_func_set_color
0138 3180  1763 	MOVLP 0
           1764 			;				break;
           1765 			;			}
           1766 			;			case SET_FADE: {break;}
           1767 			;			case SET_RUN: {break;}
           1768 			;		}
           1769 			;		// *** set commandpointer to the next command
           1770 			;		EEPROM_WR(CmdPointerAddr, (pointer - CmdWidth));
0139 30FF  1771 m051	MOVLW 255
013A 0020  1772 	MOVLB 0
013B 00AA  1773 	MOVWF adress
013C 300A  1774 	MOVLW 10
013D 0222  1775 	SUBWF pointer,W
013E 3188  1776 	MOVLP 8
013F 20AB  1777 	CALL  EEPROM_WR
0140 3180  1778 	MOVLP 0
           1779 			;	}
           1780 			;}
0141 0008  1781 m052	RETURN
           1782 
           1783 	END
           1784 
           1785 
           1786 ; *** KEY INFO ***
           1787 
           1788 ; 0x0004 P0   16 word(s)  0 % : InterruptRoutine
           1789 ; 0x0019 P0   73 word(s)  3 % : init_all
           1790 ; 0x0062 P0   28 word(s)  1 % : throw_errors
           1791 ; 0x007E P0  157 word(s)  7 % : get_commands
           1792 ; 0x011B P0   39 word(s)  1 % : execute_commands
           1793 ; 0x0014 P0    5 word(s)  0 % : main
           1794 
           1795 ; 0x0843 P1    5 word(s)  0 % : RingBufInit
           1796 ; 0x0848 P1   12 word(s)  0 % : RingBufGet
           1797 ; 0x0854 P1   21 word(s)  1 % : RingBufPut
           1798 ; 0x0869 P1   19 word(s)  0 % : USARTinit
CC5X Version 3.4E,   File: main.c               9. May 2012  21:39   Page 31

ADDR CODE  LINE SOURCE

           1799 ; 0x087C P1   10 word(s)  0 % : USARTsend
           1800 ; 0x0886 P1   19 word(s)  0 % : USARTsend_str
           1801 ; 0x0899 P1   18 word(s)  0 % : USARTsend_arr
           1802 ; 0x0800 P1   67 word(s)  3 % : _const1
           1803 ; 0x08AB P1   34 word(s)  1 % : EEPROM_WR
           1804 ; 0x08CD P1   13 word(s)  0 % : EEPROM_RD
           1805 ; 0x08DA P1   25 word(s)  1 % : EEPROM_WR_BLK
           1806 ; 0x08F3 P1   22 word(s)  1 % : EEPROM_RD_BLK
           1807 ; 0x0909 P1   40 word(s)  1 % : addCRC
           1808 ; 0x0931 P1   45 word(s)  2 % : CRC
           1809 ; 0x095E P1   20 word(s)  0 % : newCRC
           1810 ; 0x09BA P1   18 word(s)  0 % : ledstrip_init
           1811 ; 0x09CC P1   66 word(s)  3 % : ledstrip_set_color
           1812 ; 0x0A0E P1   61 word(s)  2 % : sub_func_set_color
           1813 ; 0x0972 P1   11 word(s)  0 % : spi_init
           1814 ; 0x097D P1   11 word(s)  0 % : spi_send
           1815 ; 0x0988 P1   18 word(s)  0 % : spi_send_arr
           1816 ; 0x099A P1   32 word(s)  1 % : spi_send_ledbuf
           1817 
           1818 ; RAM usage: 161 bytes (25 local), 351 bytes free
           1819 ; Maximum call level: 3 (+2 for interrupt)
           1820 ;  Codepage 0 has  319 word(s) :  15 %
           1821 ;  Codepage 1 has  587 word(s) :  28 %
           1822 ;  Codepage 2 has    0 word(s) :   0 %
           1823 ;  Codepage 3 has    0 word(s) :   0 %
           1824 ; Total of 906 code words (11 %)
