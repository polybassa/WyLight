<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>Wifly_Light: intelhex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Wifly_Light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classintelhex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">intelhex Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to decode, encode and manipulate Intel HEX format files.  
 <a href="classintelhex.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="intelhexclass_8h_source.html">intelhexclass.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae1efd0ed1f56546f8f5f5af87c6cbdd5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#ae1efd0ed1f56546f8f5f5af87c6cbdd5">intelhex</a> ()</td></tr>
<tr class="memdesc:ae1efd0ed1f56546f8f5f5af87c6cbdd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">intelhex Class Constructor.  <a href="#ae1efd0ed1f56546f8f5f5af87c6cbdd5"></a><br/></td></tr>
<tr class="separator:ae1efd0ed1f56546f8f5f5af87c6cbdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031ce4582899f5263fdcc2fa92cc3e45"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a031ce4582899f5263fdcc2fa92cc3e45">~intelhex</a> ()</td></tr>
<tr class="memdesc:a031ce4582899f5263fdcc2fa92cc3e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">intelhex Class Deconstructor.  <a href="#a031ce4582899f5263fdcc2fa92cc3e45"></a><br/></td></tr>
<tr class="separator:a031ce4582899f5263fdcc2fa92cc3e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b4c3b7851461b9240fdef90bc62768"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a41b4c3b7851461b9240fdef90bc62768">intelhex</a> (const <a class="el" href="classintelhex.html">intelhex</a> &amp;ihSource)</td></tr>
<tr class="memdesc:a41b4c3b7851461b9240fdef90bc62768"><td class="mdescLeft">&#160;</td><td class="mdescRight">intelhex Class Copy Constructor.  <a href="#a41b4c3b7851461b9240fdef90bc62768"></a><br/></td></tr>
<tr class="separator:a41b4c3b7851461b9240fdef90bc62768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6408cc3141862454e846378abfad8ecc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classintelhex.html">intelhex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a6408cc3141862454e846378abfad8ecc">operator=</a> (const <a class="el" href="classintelhex.html">intelhex</a> &amp;ihSource)</td></tr>
<tr class="memdesc:a6408cc3141862454e846378abfad8ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">intelhex Class Assignment Operator.  <a href="#a6408cc3141862454e846378abfad8ecc"></a><br/></td></tr>
<tr class="separator:a6408cc3141862454e846378abfad8ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044d6ab5b10a38ffa40a0b1f55b7e808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classintelhex.html">intelhex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a044d6ab5b10a38ffa40a0b1f55b7e808">operator++</a> ()</td></tr>
<tr class="memdesc:a044d6ab5b10a38ffa40a0b1f55b7e808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded prefix increment operator.  <a href="#a044d6ab5b10a38ffa40a0b1f55b7e808"></a><br/></td></tr>
<tr class="separator:a044d6ab5b10a38ffa40a0b1f55b7e808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54337b9681fc0b50e3fdb18ed1714fa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classintelhex.html">intelhex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#ab54337b9681fc0b50e3fdb18ed1714fa">operator++</a> (int)</td></tr>
<tr class="memdesc:ab54337b9681fc0b50e3fdb18ed1714fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded postfix increment operator.  <a href="#ab54337b9681fc0b50e3fdb18ed1714fa"></a><br/></td></tr>
<tr class="separator:ab54337b9681fc0b50e3fdb18ed1714fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85cbeafe9cc6adcec79f1bc709addca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classintelhex.html">intelhex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#ab85cbeafe9cc6adcec79f1bc709addca">operator--</a> ()</td></tr>
<tr class="memdesc:ab85cbeafe9cc6adcec79f1bc709addca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded prefix decrement operator.  <a href="#ab85cbeafe9cc6adcec79f1bc709addca"></a><br/></td></tr>
<tr class="separator:ab85cbeafe9cc6adcec79f1bc709addca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90562846d95b5573923f129b82aeceec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classintelhex.html">intelhex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a90562846d95b5573923f129b82aeceec">operator--</a> (int)</td></tr>
<tr class="memdesc:a90562846d95b5573923f129b82aeceec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded postfix decrement operator.  <a href="#a90562846d95b5573923f129b82aeceec"></a><br/></td></tr>
<tr class="separator:a90562846d95b5573923f129b82aeceec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b1119e14a960ea2b356967244aafb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#ab2b1119e14a960ea2b356967244aafb3">begin</a> ()</td></tr>
<tr class="memdesc:ab2b1119e14a960ea2b356967244aafb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the address pointer to the first available address.  <a href="#ab2b1119e14a960ea2b356967244aafb3"></a><br/></td></tr>
<tr class="separator:ab2b1119e14a960ea2b356967244aafb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7759926596cfcffec94e391fff4298e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a7759926596cfcffec94e391fff4298e9">end</a> ()</td></tr>
<tr class="memdesc:a7759926596cfcffec94e391fff4298e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the address pointer to the last available address.  <a href="#a7759926596cfcffec94e391fff4298e9"></a><br/></td></tr>
<tr class="separator:a7759926596cfcffec94e391fff4298e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa757932ec420f977d33bb9a2d5a0a69"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#afa757932ec420f977d33bb9a2d5a0a69">size</a> ()</td></tr>
<tr class="memdesc:afa757932ec420f977d33bb9a2d5a0a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if we have reached end of available data.  <a href="#afa757932ec420f977d33bb9a2d5a0a69"></a><br/></td></tr>
<tr class="separator:afa757932ec420f977d33bb9a2d5a0a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff915b320f5a4c2d84340fa57c99499c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#aff915b320f5a4c2d84340fa57c99499c">endOfData</a> ()</td></tr>
<tr class="memdesc:aff915b320f5a4c2d84340fa57c99499c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if we have reached end of available data.  <a href="#aff915b320f5a4c2d84340fa57c99499c"></a><br/></td></tr>
<tr class="separator:aff915b320f5a4c2d84340fa57c99499c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd5b567207303d4d9f4322e6262d6d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a2bd5b567207303d4d9f4322e6262d6d6">empty</a> ()</td></tr>
<tr class="separator:a2bd5b567207303d4d9f4322e6262d6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b54457c121b0f35b21b78fa2ecd712"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a83b54457c121b0f35b21b78fa2ecd712">jumpTo</a> (unsigned long address)</td></tr>
<tr class="memdesc:a83b54457c121b0f35b21b78fa2ecd712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the address pointer to the desired address.  <a href="#a83b54457c121b0f35b21b78fa2ecd712"></a><br/></td></tr>
<tr class="separator:a83b54457c121b0f35b21b78fa2ecd712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c6e296e5053fe8378e79445cf480cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#af9c6e296e5053fe8378e79445cf480cb">incrementAddress</a> ()</td></tr>
<tr class="memdesc:af9c6e296e5053fe8378e79445cf480cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments to next piece of data.  <a href="#af9c6e296e5053fe8378e79445cf480cb"></a><br/></td></tr>
<tr class="separator:af9c6e296e5053fe8378e79445cf480cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f6d93f1ac2bdf5ddad8be4e1827ce9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a51f6d93f1ac2bdf5ddad8be4e1827ce9">decrementAddress</a> ()</td></tr>
<tr class="memdesc:a51f6d93f1ac2bdf5ddad8be4e1827ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements to next piece of data.  <a href="#a51f6d93f1ac2bdf5ddad8be4e1827ce9"></a><br/></td></tr>
<tr class="separator:a51f6d93f1ac2bdf5ddad8be4e1827ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631d8930daeaf04bf0d9ad9c25679a0b"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a631d8930daeaf04bf0d9ad9c25679a0b">currentAddress</a> ()</td></tr>
<tr class="memdesc:a631d8930daeaf04bf0d9ad9c25679a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current address being pointed to.  <a href="#a631d8930daeaf04bf0d9ad9c25679a0b"></a><br/></td></tr>
<tr class="separator:a631d8930daeaf04bf0d9ad9c25679a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8833665b99f0b6ac64fcef7d2116c42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#aa8833665b99f0b6ac64fcef7d2116c42">startAddress</a> (unsigned long *address)</td></tr>
<tr class="memdesc:aa8833665b99f0b6ac64fcef7d2116c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest address currently available.  <a href="#aa8833665b99f0b6ac64fcef7d2116c42"></a><br/></td></tr>
<tr class="separator:aa8833665b99f0b6ac64fcef7d2116c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b159bea81eb832e37f6cf88a57ca659"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a9b159bea81eb832e37f6cf88a57ca659">endAddress</a> (unsigned long *address)</td></tr>
<tr class="memdesc:a9b159bea81eb832e37f6cf88a57ca659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest address currently available.  <a href="#a9b159bea81eb832e37f6cf88a57ca659"></a><br/></td></tr>
<tr class="separator:a9b159bea81eb832e37f6cf88a57ca659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f7799f7a86e45c28b713e9472a8a5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a01f7799f7a86e45c28b713e9472a8a5a">getData</a> (unsigned char *data)</td></tr>
<tr class="memdesc:a01f7799f7a86e45c28b713e9472a8a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data to which the iterator is currently pointing.  <a href="#a01f7799f7a86e45c28b713e9472a8a5a"></a><br/></td></tr>
<tr class="separator:a01f7799f7a86e45c28b713e9472a8a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6596b518a9a832ed8e6ba21a0e07861c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a6596b518a9a832ed8e6ba21a0e07861c">getData</a> (unsigned char *data, unsigned long address)</td></tr>
<tr class="memdesc:a6596b518a9a832ed8e6ba21a0e07861c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data for desired address.  <a href="#a6596b518a9a832ed8e6ba21a0e07861c"></a><br/></td></tr>
<tr class="separator:a6596b518a9a832ed8e6ba21a0e07861c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71096983db3c24a5ac9b95663937a4ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a71096983db3c24a5ac9b95663937a4ce">insertData</a> (unsigned char data)</td></tr>
<tr class="memdesc:a71096983db3c24a5ac9b95663937a4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts desired byte at the current address pointer.  <a href="#a71096983db3c24a5ac9b95663937a4ce"></a><br/></td></tr>
<tr class="separator:a71096983db3c24a5ac9b95663937a4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ff4c491fabc5ef207071358e1b9298"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a00ff4c491fabc5ef207071358e1b9298">insertData</a> (unsigned char data, unsigned long address)</td></tr>
<tr class="separator:a00ff4c491fabc5ef207071358e1b9298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fc2715f4c63d3f31e8d2b0533583e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#ab4fc2715f4c63d3f31e8d2b0533583e5">overwriteData</a> (unsigned char data)</td></tr>
<tr class="separator:ab4fc2715f4c63d3f31e8d2b0533583e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83edcd2329cb52a4bab6bb46463184d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a83edcd2329cb52a4bab6bb46463184d7">overwriteData</a> (unsigned char data, unsigned long address)</td></tr>
<tr class="separator:a83edcd2329cb52a4bab6bb46463184d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de5cf10103fc307127f9017f3e5cd76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a5de5cf10103fc307127f9017f3e5cd76">blankFill</a> (unsigned char data)</td></tr>
<tr class="separator:a5de5cf10103fc307127f9017f3e5cd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bbd449bb55e218b62ea73e2b399196"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a84bbd449bb55e218b62ea73e2b399196">blankFill</a> (unsigned char *const data, unsigned long sizeOfData)</td></tr>
<tr class="separator:a84bbd449bb55e218b62ea73e2b399196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6f77af7a82623ef16471f105ac3fe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#aaf6f77af7a82623ef16471f105ac3fe7">blankFill</a> (unsigned char *const data, unsigned long sizeOfData, unsigned long <a class="el" href="classintelhex.html#a9b159bea81eb832e37f6cf88a57ca659">endAddress</a>)</td></tr>
<tr class="separator:aaf6f77af7a82623ef16471f105ac3fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c26ba3dc9dd4f3021bb6c7f6983388f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a9c26ba3dc9dd4f3021bb6c7f6983388f">blankFillRandom</a> ()</td></tr>
<tr class="separator:a9c26ba3dc9dd4f3021bb6c7f6983388f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1dbcbf3df1aaafd518882c882f43f76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#aa1dbcbf3df1aaafd518882c882f43f76">blankFillRandom</a> (unsigned long <a class="el" href="classintelhex.html#a9b159bea81eb832e37f6cf88a57ca659">endAddress</a>)</td></tr>
<tr class="separator:aa1dbcbf3df1aaafd518882c882f43f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5c67fccc34c78e6dbd28f4b795fb0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a2e5c67fccc34c78e6dbd28f4b795fb0f">blankFillAddressLowByte</a> ()</td></tr>
<tr class="separator:a2e5c67fccc34c78e6dbd28f4b795fb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b16f457563da93569b9812fafb9e7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#ab7b16f457563da93569b9812fafb9e7d">blankFillAddressLowByte</a> (unsigned long <a class="el" href="classintelhex.html#a9b159bea81eb832e37f6cf88a57ca659">endAddress</a>)</td></tr>
<tr class="separator:ab7b16f457563da93569b9812fafb9e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a19e1e9f1eb493a8d0bc29db88683f"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a05a19e1e9f1eb493a8d0bc29db88683f">getNoWarnings</a> ()</td></tr>
<tr class="memdesc:a05a19e1e9f1eb493a8d0bc29db88683f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of unread warning messages.  <a href="#a05a19e1e9f1eb493a8d0bc29db88683f"></a><br/></td></tr>
<tr class="separator:a05a19e1e9f1eb493a8d0bc29db88683f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77cddd46c3f97692b4d89f138bdabb72"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a77cddd46c3f97692b4d89f138bdabb72">getNoErrors</a> ()</td></tr>
<tr class="memdesc:a77cddd46c3f97692b4d89f138bdabb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of unread error messages.  <a href="#a77cddd46c3f97692b4d89f138bdabb72"></a><br/></td></tr>
<tr class="separator:a77cddd46c3f97692b4d89f138bdabb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab881b8cb0fe665395a29e4375db8f7c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#ab881b8cb0fe665395a29e4375db8f7c4">popNextWarning</a> (string &amp;warning)</td></tr>
<tr class="memdesc:ab881b8cb0fe665395a29e4375db8f7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop next warning message from the list of warnings.  <a href="#ab881b8cb0fe665395a29e4375db8f7c4"></a><br/></td></tr>
<tr class="separator:ab881b8cb0fe665395a29e4375db8f7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6609fd1c57a650c45a1961f6318d643e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a6609fd1c57a650c45a1961f6318d643e">popNextError</a> (string &amp;error)</td></tr>
<tr class="memdesc:a6609fd1c57a650c45a1961f6318d643e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop next error message from the list of errors.  <a href="#a6609fd1c57a650c45a1961f6318d643e"></a><br/></td></tr>
<tr class="separator:a6609fd1c57a650c45a1961f6318d643e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d6d17ba22263a4775d80b2a0e6e95f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a94d6d17ba22263a4775d80b2a0e6e95f">getStartSegmentAddress</a> (unsigned short *<a class="el" href="classintelhex.html#acf63100ba6ba58da893f29596560efbd">ipRegister</a>, unsigned short *<a class="el" href="classintelhex.html#aabbf5689bc667734dca7f23a11d3df68">csRegister</a>)</td></tr>
<tr class="memdesc:a94d6d17ba22263a4775d80b2a0e6e95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns segment start address for the IP and ES registers.  <a href="#a94d6d17ba22263a4775d80b2a0e6e95f"></a><br/></td></tr>
<tr class="separator:a94d6d17ba22263a4775d80b2a0e6e95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc61f72756d37509e768906733ba10b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a7bc61f72756d37509e768906733ba10b">getStartLinearAddress</a> (unsigned long *<a class="el" href="classintelhex.html#abedd6ca388d3cad1d2525abc5939d27e">eipRegister</a>)</td></tr>
<tr class="memdesc:a7bc61f72756d37509e768906733ba10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns segment linear address for the EIP register.  <a href="#a7bc61f72756d37509e768906733ba10b"></a><br/></td></tr>
<tr class="separator:a7bc61f72756d37509e768906733ba10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9688f0002be870b05d64b5f9fcdeb86b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a9688f0002be870b05d64b5f9fcdeb86b">setStartSegmentAddress</a> (unsigned short <a class="el" href="classintelhex.html#acf63100ba6ba58da893f29596560efbd">ipRegister</a>, unsigned short <a class="el" href="classintelhex.html#aabbf5689bc667734dca7f23a11d3df68">csRegister</a>)</td></tr>
<tr class="memdesc:a9688f0002be870b05d64b5f9fcdeb86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the segment start address for the IP and CS registers.  <a href="#a9688f0002be870b05d64b5f9fcdeb86b"></a><br/></td></tr>
<tr class="separator:a9688f0002be870b05d64b5f9fcdeb86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7629ca097b2de02dea37fcaa2dc2709c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a7629ca097b2de02dea37fcaa2dc2709c">setStartLinearAddress</a> (unsigned long <a class="el" href="classintelhex.html#abedd6ca388d3cad1d2525abc5939d27e">eipRegister</a>)</td></tr>
<tr class="memdesc:a7629ca097b2de02dea37fcaa2dc2709c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the segment start address for the EIP register.  <a href="#a7629ca097b2de02dea37fcaa2dc2709c"></a><br/></td></tr>
<tr class="separator:a7629ca097b2de02dea37fcaa2dc2709c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489fc3b9c34542def2a5167192b291da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a489fc3b9c34542def2a5167192b291da">segmentAddressingOn</a> ()</td></tr>
<tr class="memdesc:a489fc3b9c34542def2a5167192b291da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on segment addressing mode during encoding.  <a href="#a489fc3b9c34542def2a5167192b291da"></a><br/></td></tr>
<tr class="separator:a489fc3b9c34542def2a5167192b291da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5055edd337d19037ab254a27016267f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a5055edd337d19037ab254a27016267f8">linearAddressingOn</a> ()</td></tr>
<tr class="memdesc:a5055edd337d19037ab254a27016267f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on linear addressing mode during encoding.  <a href="#a5055edd337d19037ab254a27016267f8"></a><br/></td></tr>
<tr class="separator:a5055edd337d19037ab254a27016267f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a0119a04a2090af3ffe8c33a37cbc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#ac6a0119a04a2090af3ffe8c33a37cbc9">verboseOn</a> ()</td></tr>
<tr class="memdesc:ac6a0119a04a2090af3ffe8c33a37cbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on textual output to cout during decoding.  <a href="#ac6a0119a04a2090af3ffe8c33a37cbc9"></a><br/></td></tr>
<tr class="separator:ac6a0119a04a2090af3ffe8c33a37cbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3958f077a662291bbde3472ea2bcfb4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a3958f077a662291bbde3472ea2bcfb4d">verboseOff</a> ()</td></tr>
<tr class="memdesc:a3958f077a662291bbde3472ea2bcfb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns off textual output to cout during decoding.  <a href="#a3958f077a662291bbde3472ea2bcfb4d"></a><br/></td></tr>
<tr class="separator:a3958f077a662291bbde3472ea2bcfb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a320e23dab311a6c652aa7ddb9e2f9cc2"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a320e23dab311a6c652aa7ddb9e2f9cc2">operator&lt;&lt;</a> (ostream &amp;dataOut, <a class="el" href="classintelhex.html">intelhex</a> &amp;ihLocal)</td></tr>
<tr class="memdesc:a320e23dab311a6c652aa7ddb9e2f9cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream overload operator.  <a href="#a320e23dab311a6c652aa7ddb9e2f9cc2"></a><br/></td></tr>
<tr class="separator:a320e23dab311a6c652aa7ddb9e2f9cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fb9c5b9d6d069b5eb83340942fd54b"><td class="memItemLeft" align="right" valign="top">istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a73fb9c5b9d6d069b5eb83340942fd54b">operator&gt;&gt;</a> (istream &amp;dataIn, <a class="el" href="classintelhex.html">intelhex</a> &amp;ihLocal)</td></tr>
<tr class="memdesc:a73fb9c5b9d6d069b5eb83340942fd54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input stream overload operator.  <a href="#a73fb9c5b9d6d069b5eb83340942fd54b"></a><br/></td></tr>
<tr class="separator:a73fb9c5b9d6d069b5eb83340942fd54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to decode, encode and manipulate Intel HEX format files. </p>
<p>The Intel HEX class allows the user to stream in the content of an Intel HEX file so that its content can by analysed more easily than trying to decode the Intel HEX file in a text editor. In conjunction with a suitable application it is possible to create content, analyse content and even compare the content of files with one another. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae1efd0ed1f56546f8f5f5af87c6cbdd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">intelhex::intelhex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>intelhex Class Constructor. </p>
<p>Important initialisation steps performed here:</p>
<ul>
<li>clear segment base address to zero</li>
<li>clear all x86 start address registers to zero</li>
<li>note that there are, as yet, no errors or warnings</li>
<li>note that the EOF record has not yet been found</li>
<li>set verbode mode to 'false' (default)</li>
<li>initialise class ihIterator </li>
</ul>

</div>
</div>
<a class="anchor" id="a031ce4582899f5263fdcc2fa92cc3e45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">intelhex::~intelhex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>intelhex Class Deconstructor. </p>
<p>Currently the deconstructor is intentially empty. </p>

</div>
</div>
<a class="anchor" id="a41b4c3b7851461b9240fdef90bc62768"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">intelhex::intelhex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintelhex.html">intelhex</a> &amp;&#160;</td>
          <td class="paramname"><em>ihSource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>intelhex Class Copy Constructor. </p>
<p>Copy constructor copies all essential elements for the class. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab2b1119e14a960ea2b356967244aafb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the address pointer to the first available address. </p>
<pre class="fragment">     The address pointer will be moved to the first available address in 
     memory of the decoded file or of the data the user has inserted into
     memory for the purpose of encoding into the Intel HEX format.
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#a7759926596cfcffec94e391fff4298e9" title="Moves the address pointer to the last available address.">end()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function has no effect if no file has been as yet decoded and no data has been inserted into memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a5de5cf10103fc307127f9017f3e5cd76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::blankFill </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a84bbd449bb55e218b62ea73e2b399196"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::blankFill </td>
          <td>(</td>
          <td class="paramtype">unsigned char *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>sizeOfData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaf6f77af7a82623ef16471f105ac3fe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::blankFill </td>
          <td>(</td>
          <td class="paramtype">unsigned char *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>sizeOfData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>endAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2e5c67fccc34c78e6dbd28f4b795fb0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::blankFillAddressLowByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab7b16f457563da93569b9812fafb9e7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::blankFillAddressLowByte </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>endAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c26ba3dc9dd4f3021bb6c7f6983388f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::blankFillRandom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa1dbcbf3df1aaafd518882c882f43f76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::blankFillRandom </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>endAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a631d8930daeaf04bf0d9ad9c25679a0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long intelhex::currentAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current address being pointed to. </p>
<pre class="fragment">     Current address will be returned.
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#a83b54457c121b0f35b21b78fa2ecd712" title="Moves the address pointer to the desired address.">jumpTo()</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Current</td><td>address being pointed to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51f6d93f1ac2bdf5ddad8be4e1827ce9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::decrementAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements to next piece of data. </p>
<pre class="fragment">     Address pointer will take on the address of the previous location for 
     which there is data.
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#af9c6e296e5053fe8378e79445cf480cb" title="Increments to next piece of data.">incrementAddress()</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- pointer was decremented; a new data value was found </td></tr>
    <tr><td class="paramname">false</td><td>- start of available data reached; pointer is unchanged </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2bd5b567207303d4d9f4322e6262d6d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7759926596cfcffec94e391fff4298e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the address pointer to the last available address. </p>
<pre class="fragment">     The address pointer will be moved to the last available address in 
     memory of the decoded file or of the data the user has inserted into
     memory for the purpose of encoding into the Intel HEX format.
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#ab2b1119e14a960ea2b356967244aafb3" title="Moves the address pointer to the first available address.">begin()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function has no effect if no file has been as yet decoded and no data has been inserted into memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b159bea81eb832e37f6cf88a57ca659"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::endAddress </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the highest address currently available. </p>
<pre class="fragment">     Returns the last address that appears in the memory if there is data
     present. If not, no value will be returned.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>- variable to hold address requested</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- address existed and returned value is valid </td></tr>
    <tr><td class="paramname">false</td><td>- address did not exist and returned valid is not valid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#aa8833665b99f0b6ac64fcef7d2116c42" title="Returns the lowest address currently available.">startAddress()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aff915b320f5a4c2d84340fa57c99499c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::endOfData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if we have reached end of available data. </p>
<pre class="fragment">     The internal pointer is checked to see if we have reached the end of 
     the data held in memory
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#a044d6ab5b10a38ffa40a0b1f55b7e808" title="Overloaded prefix increment operator.">operator++()</a>, <a class="el" href="classintelhex.html#ab54337b9681fc0b50e3fdb18ed1714fa" title="Overloaded postfix increment operator.">operator++(int)</a>, operator&ndash;(), operator&ndash;(int), <a class="el" href="classintelhex.html#a2bd5b567207303d4d9f4322e6262d6d6">empty()</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- reached the end of the Intel HEX data in memory or no data in memory yet. </td></tr>
    <tr><td class="paramname">false</td><td>- end of Intel HEX data in memory not yet reached.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function has no effect if no file has been as yet decoded and no data has been inserted into memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a01f7799f7a86e45c28b713e9472a8a5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::getData </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data to which the iterator is currently pointing. </p>
<pre class="fragment">     Returns the data to which the internal iterator (pointer) is currently
     pointing. If no data is in memory, this function returns false.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- variable to hold data requested</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- data was available and returned value is valid </td></tr>
    <tr><td class="paramname">false</td><td>- data was not available and returned valid is not valid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>putData() </dd></dl>

</div>
</div>
<a class="anchor" id="a6596b518a9a832ed8e6ba21a0e07861c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::getData </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data for desired address. </p>
<pre class="fragment">     Returns the data for the desired address. If the address has no data
     assigned to it, the function returns false, the pointer to data is not
     written and the class's address pointer remains unchanged. If the 
     address has data assigned to it, the pointer to data will be written 
     with the data found and the class's address pointer will be moved to 
     this new location.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- variable to hold data requested </td></tr>
    <tr><td class="paramname">address</td><td>- address to be queried for valid data</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- data was available and returned value is valid </td></tr>
    <tr><td class="paramname">false</td><td>- data was not available and returned valid is not valid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>putData() </dd></dl>

</div>
</div>
<a class="anchor" id="a77cddd46c3f97692b4d89f138bdabb72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long intelhex::getNoErrors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of unread error messages. </p>
<pre class="fragment">     Number of unread error messages will be returned.
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#ab881b8cb0fe665395a29e4375db8f7c4" title="Pop next warning message from the list of warnings.">popNextWarning()</a>, <a class="el" href="classintelhex.html#a05a19e1e9f1eb493a8d0bc29db88683f" title="Returns number of unread warning messages.">getNoWarnings()</a>, <a class="el" href="classintelhex.html#a6609fd1c57a650c45a1961f6318d643e" title="Pop next error message from the list of errors.">popNextError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a05a19e1e9f1eb493a8d0bc29db88683f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long intelhex::getNoWarnings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of unread warning messages. </p>
<pre class="fragment">     Number of unread warning messages will be returned.
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#ab881b8cb0fe665395a29e4375db8f7c4" title="Pop next warning message from the list of warnings.">popNextWarning()</a>, <a class="el" href="classintelhex.html#a77cddd46c3f97692b4d89f138bdabb72" title="Returns number of unread error messages.">getNoErrors()</a>, <a class="el" href="classintelhex.html#a6609fd1c57a650c45a1961f6318d643e" title="Pop next error message from the list of errors.">popNextError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7bc61f72756d37509e768906733ba10b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::getStartLinearAddress </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>eipRegister</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns segment linear address for the EIP register. </p>
<pre class="fragment">     If this value exists, they will be returned. If not, the function
     returns false.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eipRegister</td><td>- variable to store EIP register's value</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- EIP register has defined value </td></tr>
    <tr><td class="paramname">false</td><td>- EIP register do not contain value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#a94d6d17ba22263a4775d80b2a0e6e95f" title="Returns segment start address for the IP and ES registers.">getStartSegmentAddress()</a>, <a class="el" href="classintelhex.html#a9688f0002be870b05d64b5f9fcdeb86b" title="Sets the segment start address for the IP and CS registers.">setStartSegmentAddress()</a>, <a class="el" href="classintelhex.html#a7629ca097b2de02dea37fcaa2dc2709c" title="Sets the segment start address for the EIP register.">setStartLinearAddress()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a94d6d17ba22263a4775d80b2a0e6e95f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::getStartSegmentAddress </td>
          <td>(</td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>ipRegister</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>csRegister</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns segment start address for the IP and ES registers. </p>
<pre class="fragment">     If these values exist, they will be returned. If not, the function
     returns false.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipRegister</td><td>- variable to store IP register's value </td></tr>
    <tr><td class="paramname">csRegister</td><td>- variable to store CS register's value</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- IP and CS registers have defined values </td></tr>
    <tr><td class="paramname">false</td><td>- IP and CS registers do not contain values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#a7bc61f72756d37509e768906733ba10b" title="Returns segment linear address for the EIP register.">getStartLinearAddress()</a>, <a class="el" href="classintelhex.html#a9688f0002be870b05d64b5f9fcdeb86b" title="Sets the segment start address for the IP and CS registers.">setStartSegmentAddress()</a>, <a class="el" href="classintelhex.html#a7629ca097b2de02dea37fcaa2dc2709c" title="Sets the segment start address for the EIP register.">setStartLinearAddress()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af9c6e296e5053fe8378e79445cf480cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::incrementAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments to next piece of data. </p>
<pre class="fragment">     Address pointer will take on the address of the next location for 
     which there is data.
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#a51f6d93f1ac2bdf5ddad8be4e1827ce9" title="Decrements to next piece of data.">decrementAddress()</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- pointer was incremented; a new data value was found </td></tr>
    <tr><td class="paramname">false</td><td>- end of available data reached; pointer is unchanged </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71096983db3c24a5ac9b95663937a4ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::insertData </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts desired byte at the current address pointer. </p>
<pre class="fragment">     Inserts byte of data at the current address pointer
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>- data byte to be inserted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#aa8833665b99f0b6ac64fcef7d2116c42" title="Returns the lowest address currently available.">startAddress()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a00ff4c491fabc5ef207071358e1b9298"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::insertData </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a83b54457c121b0f35b21b78fa2ecd712"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::jumpTo </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the address pointer to the desired address. </p>
<pre class="fragment">     Address pointer will take on the requested address if the address
     exists in the data stored in memory. If not, the address pointer does
     not change.
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#a631d8930daeaf04bf0d9ad9c25679a0b" title="Returns the current address being pointed to.">currentAddress()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>- Desired new address for the address pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- Address exists; pointer moved successfully </td></tr>
    <tr><td class="paramname">false</td><td>- Address did not exist; pointer not moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5055edd337d19037ab254a27016267f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::linearAddressingOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns on linear addressing mode during encoding. </p>
<p>Uses the Linear Address Record during encoding. </p>

</div>
</div>
<a class="anchor" id="a044d6ab5b10a38ffa40a0b1f55b7e808"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classintelhex.html">intelhex</a>&amp; intelhex::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded prefix increment operator. </p>
<p>Overloads the prefix increment operator to move interal iterator to next entry in the ihContent map </p>

</div>
</div>
<a class="anchor" id="ab54337b9681fc0b50e3fdb18ed1714fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classintelhex.html">intelhex</a> intelhex::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded postfix increment operator. </p>
<p>Overloads the postfix increment operator to move interal iterator to next entry in the ihContent map </p>

</div>
</div>
<a class="anchor" id="ab85cbeafe9cc6adcec79f1bc709addca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classintelhex.html">intelhex</a>&amp; intelhex::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded prefix decrement operator. </p>
<p>Overloads the prefix decrement operator to move interal iterator to previous entry in the ihContent map </p>

</div>
</div>
<a class="anchor" id="a90562846d95b5573923f129b82aeceec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classintelhex.html">intelhex</a> intelhex::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded postfix decrement operator. </p>
<p>Overloads the postfix decrement operator to move interal iterator to previous entry in the ihContent map </p>

</div>
</div>
<a class="anchor" id="a6408cc3141862454e846378abfad8ecc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classintelhex.html">intelhex</a>&amp; intelhex::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintelhex.html">intelhex</a> &amp;&#160;</td>
          <td class="paramname"><em>ihSource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>intelhex Class Assignment Operator. </p>
<pre class="fragment">     Implements the assignment operator so that the content of the Intel
     HEX file in memory can be copied to another 'intelhex' variable.
     You may want to keep a copy of the original data in memory and 
     only manipulate a copy.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ihSource</td><td>- intelhex variable to be assigned to new variable</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">pointer</td><td>to variable to which value is to be assigned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4fc2715f4c63d3f31e8d2b0533583e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::overwriteData </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a83edcd2329cb52a4bab6bb46463184d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::overwriteData </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6609fd1c57a650c45a1961f6318d643e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::popNextError </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop next error message from the list of errors. </p>
<pre class="fragment">     Next error message is returned from the list of errors. If there are
     no more errors in the list, no string will be returned unchanged.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>- variable to store error string to be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- more error messages are available </td></tr>
    <tr><td class="paramname">false</td><td>- no more error messages are available</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#a05a19e1e9f1eb493a8d0bc29db88683f" title="Returns number of unread warning messages.">getNoWarnings()</a>, <a class="el" href="classintelhex.html#a77cddd46c3f97692b4d89f138bdabb72" title="Returns number of unread error messages.">getNoErrors()</a>, <a class="el" href="classintelhex.html#a6609fd1c57a650c45a1961f6318d643e" title="Pop next error message from the list of errors.">popNextError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab881b8cb0fe665395a29e4375db8f7c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::popNextWarning </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>warning</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop next warning message from the list of warnings. </p>
<pre class="fragment">     Next warning message is returned from the list of warnings. If there 
     are no more warning in the list, the string will be unchanged.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">warning</td><td>- variable to store warning string to be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- more warning messages are available </td></tr>
    <tr><td class="paramname">false</td><td>- no more warning messages are available</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#a05a19e1e9f1eb493a8d0bc29db88683f" title="Returns number of unread warning messages.">getNoWarnings()</a>, <a class="el" href="classintelhex.html#a77cddd46c3f97692b4d89f138bdabb72" title="Returns number of unread error messages.">getNoErrors()</a>, <a class="el" href="classintelhex.html#a6609fd1c57a650c45a1961f6318d643e" title="Pop next error message from the list of errors.">popNextError()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a489fc3b9c34542def2a5167192b291da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::segmentAddressingOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns on segment addressing mode during encoding. </p>
<p>Uses the Segment Address Record during encoding. </p>

</div>
</div>
<a class="anchor" id="a7629ca097b2de02dea37fcaa2dc2709c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::setStartLinearAddress </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>eipRegister</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the segment start address for the EIP register. </p>
<pre class="fragment">     Allows user to define or redefine the contents of the EIP register
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eipRegister</td><td>- desired EIP register value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#a94d6d17ba22263a4775d80b2a0e6e95f" title="Returns segment start address for the IP and ES registers.">getStartSegmentAddress()</a>, <a class="el" href="classintelhex.html#a9688f0002be870b05d64b5f9fcdeb86b" title="Sets the segment start address for the IP and CS registers.">setStartSegmentAddress()</a>, <a class="el" href="classintelhex.html#a7bc61f72756d37509e768906733ba10b" title="Returns segment linear address for the EIP register.">getStartLinearAddress()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9688f0002be870b05d64b5f9fcdeb86b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::setStartSegmentAddress </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>ipRegister</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>csRegister</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the segment start address for the IP and CS registers. </p>
<pre class="fragment">     Allows user to define or redefine the contents of the IP and CS 
     registers
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipRegister</td><td>- desired IP register value </td></tr>
    <tr><td class="paramname">csRegister</td><td>- desired CS register value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#a7bc61f72756d37509e768906733ba10b" title="Returns segment linear address for the EIP register.">getStartLinearAddress()</a>, <a class="el" href="classintelhex.html#a94d6d17ba22263a4775d80b2a0e6e95f" title="Returns segment start address for the IP and ES registers.">getStartSegmentAddress()</a>, <a class="el" href="classintelhex.html#a7629ca097b2de02dea37fcaa2dc2709c" title="Sets the segment start address for the EIP register.">setStartLinearAddress()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afa757932ec420f977d33bb9a2d5a0a69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long intelhex::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if we have reached end of available data. </p>
<pre class="fragment">     The internal pointer is checked to see if we have reached the end of 
     the data held in memory
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#a044d6ab5b10a38ffa40a0b1f55b7e808" title="Overloaded prefix increment operator.">operator++()</a>, <a class="el" href="classintelhex.html#ab54337b9681fc0b50e3fdb18ed1714fa" title="Overloaded postfix increment operator.">operator++(int)</a>, operator&ndash;(), operator&ndash;(int), <a class="el" href="classintelhex.html#a2bd5b567207303d4d9f4322e6262d6d6">empty()</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- reached the end of the Intel HEX data in memory or no data in memory yet. </td></tr>
    <tr><td class="paramname">false</td><td>- end of Intel HEX data in memory not yet reached.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function has no effect if no file has been as yet decoded and no data has been inserted into memory. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8833665b99f0b6ac64fcef7d2116c42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::startAddress </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lowest address currently available. </p>
<pre class="fragment">     Returns the first address that appears in the memory if there is data
     present. If not, no value will be returned.
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#a9b159bea81eb832e37f6cf88a57ca659" title="Returns the highest address currently available.">endAddress()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>- variable to hold address requested</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- address existed and returned value is valid </td></tr>
    <tr><td class="paramname">false</td><td>- address did not exist and returned valid is not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3958f077a662291bbde3472ea2bcfb4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::verboseOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns off textual output to cout during decoding. </p>
<p>No output to cout during decoding of Intel HEX files. </p>

</div>
</div>
<a class="anchor" id="ac6a0119a04a2090af3ffe8c33a37cbc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void intelhex::verboseOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns on textual output to cout during decoding. </p>
<p>Per record single line output to cout during decoding of Intel HEX files. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a320e23dab311a6c652aa7ddb9e2f9cc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>dataOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classintelhex.html">intelhex</a> &amp;&#160;</td>
          <td class="paramname"><em>ihLocal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output stream overload operator. </p>
<pre class="fragment">     Operator overloaded to encode any data held in memory into the Intel
     HEX format for storage on disk                 
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#a73fb9c5b9d6d069b5eb83340942fd54b" title="Input stream overload operator.">operator&gt;&gt;()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataOut</td><td>- Output stream for to store the decoded file information </td></tr>
    <tr><td class="paramname">ihLocal</td><td>- Points to this class so that friend function has access to private class members</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-</td><td>pointer to output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73fb9c5b9d6d069b5eb83340942fd54b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>dataIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classintelhex.html">intelhex</a> &amp;&#160;</td>
          <td class="paramname"><em>ihLocal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input stream overload operator. </p>
<pre class="fragment">     Operator overloaded to decode data streamed in from a file in the 
     Intel HEX format into memory                 
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classintelhex.html#a320e23dab311a6c652aa7ddb9e2f9cc2" title="Output stream overload operator.">operator&lt;&lt;()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataIn</td><td>- Input stream for the encoded file information </td></tr>
    <tr><td class="paramname">ihLocal</td><td>- Points to this class so that friend function has access to private class members</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-</td><td>pointer to input stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aabbf5689bc667734dca7f23a11d3df68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short intelhex::csRegister</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abedd6ca388d3cad1d2525abc5939d27e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long intelhex::eipRegister</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab58b4357deef8e4f0af9817393fc0b6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool intelhex::exists</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a76fb4550b43dfbb08018cabf34298400"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list&lt;string&gt; intelhex::ihErrors</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ae0e9a75bdfaa50d6d0266bb3d56ed1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list&lt;string&gt; intelhex::ihWarnings</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acf63100ba6ba58da893f29596560efbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short intelhex::ipRegister</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a451b78972165b898e91a129670fce919"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long intelhex::noOfErrors</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ea3789cc9ea71c9b35322aabca05158"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long intelhex::noOfWarnings</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>library/<a class="el" href="intelhexclass_8h_source.html">intelhexclass.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 2 2013 15:28:47 for Wifly_Light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
